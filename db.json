{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/ZONE/os/test.html","path":"ZONE/os/test.html","modified":0,"renderable":0},{"_id":"source/ZONE/test/bg.jpg","path":"ZONE/test/bg.jpg","modified":0,"renderable":0},{"_id":"source/ZONE/test/find.jpg","path":"ZONE/test/find.jpg","modified":0,"renderable":0},{"_id":"source/ZONE/test/love.jpg","path":"ZONE/test/love.jpg","modified":0,"renderable":0},{"_id":"source/ZONE/test/test.html","path":"ZONE/test/test.html","modified":0,"renderable":0},{"_id":"source/ZONE/test/wechat.jpg","path":"ZONE/test/wechat.jpg","modified":0,"renderable":0},{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/algolia.svg","path":"img/algolia.svg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"89b86650a749b0a37945be60cf90d84df927c124","modified":1609217754000},{"_id":"source/_posts/2020年.md","hash":"e5d558605efc4ca7ff9d773da6a1b61f465bc6be","modified":1609415418000},{"_id":"source/_data/link.yml","hash":"74f729e79a657a4c0cbb591c892c4eef5176c896","modified":1609235384000},{"_id":"source/.DS_Store","hash":"0c39f0a54958092d1af368a5e6da42d4c03e068a","modified":1713955524497},{"_id":"source/_posts/JS-原型链.md","hash":"f81f6be9056a6c56480a44e8b8c7495086214ccc","modified":1648990112000},{"_id":"source/_posts/git基本操作整理.md","hash":"facdaed88be710156f9bc195230482253501c872","modified":1648988348000},{"_id":"source/_posts/ElementUI2-开发.md","hash":"94aa90b3e72f4fe7ff147e36c7723d6237d6269e","modified":1682395678004},{"_id":"source/_posts/五子棋联机游戏介绍.md","hash":"715020e62fed77e6ef988f3015b0a2bb77d9b8c9","modified":1610357066000},{"_id":"source/_posts/leetcode刷题.md","hash":"f2985703667b30c8cf41d92aae5e388afd39214b","modified":1647670480000},{"_id":"source/_posts/前端——节流与防抖.md","hash":"c54057d3a2958c6d7006f0ba73cf73e69dbd9e51","modified":1647672312000},{"_id":"source/_posts/单调栈的应用.md","hash":"8e0bb17a12607e46a0de9e95e36d177a11784d76","modified":1648792740000},{"_id":"source/_posts/数据结构复习.md","hash":"8d97dc4164218e94bdc8d36269fae27e889baaee","modified":1609836836000},{"_id":"source/_posts/数据结构论文.md","hash":"a709b36680abd38bb279c87f8661fb143009f3bc","modified":1609944002000},{"_id":"source/_posts/第一篇博客.md","hash":"b48c386cfaea1c670e393382f03d13e35a8f5da9","modified":1609343304000},{"_id":"source/_posts/高等讲堂.md","hash":"33e59c40128be86c34ba68a9764f947180dde838","modified":1705381411535},{"_id":"source/_posts/离散数学-复习.md","hash":"55527f28cbbb73c2b9197c3548e2bcbf94e8f7c8","modified":1610355680000},{"_id":"source/_posts/计算机组成原理实验.md","hash":"4a16712b9cd4068ad16831afe12f4194b00630bd","modified":1609343246000},{"_id":"source/_posts/Ubuntu系统中的常用操作.md","hash":"d33104ab2aea46c044e15d7df8f67d3e049bae1d","modified":1682341048175},{"_id":"source/_posts/本科四年个人酬金.md","hash":"e745c1ada15552b6046d930c2ffd0fac53a69789","modified":1692851084134},{"_id":"source/_posts/React-native开发.md","hash":"7cd4bced45b39b8bbc874657fbe866fd137ab0b0","modified":1682433828167},{"_id":"source/ZONE/os/test.html","hash":"7f6813ad83dd7db5a314112bd640e336e77b4c3e","modified":1614672182000},{"_id":"source/ZONE/test/find.jpg","hash":"b46c4fcdba70c808a916c7952176d318531d8adf","modified":1608727418000},{"_id":"source/ZONE/test/love.jpg","hash":"844a3fd668c1c1e23b7df07f8042a43b356a3862","modified":1608727558000},{"_id":"source/ZONE/test/test.html","hash":"7e386cf68e5e25793c44e7c264d5fd8e86433882","modified":1608790876000},{"_id":"source/_posts/Mac的常用操作.md","hash":"b5fcc9a66962682994cff00b6d9243c5dc815b22","modified":1682434302677},{"_id":"source/ZONE/test/wechat.jpg","hash":"8985aa7d57c212bcd1472c75f08be8294ea7be25","modified":1608788204000},{"_id":"source/_posts/image/React-native开发/1682428818056.png","hash":"a798486e695a17c1e9ae874848c9aa2b43fd7422","modified":1682428818097},{"_id":"source/ZONE/test/bg.jpg","hash":"13e563306df2c9bed893856fb234416dbf5475af","modified":1608726088000},{"_id":"themes/butterfly/LICENSE","hash":"c8bc7df08db9dd3b39c2c2259a163a36cf2f6808","modified":1609226080000},{"_id":"themes/butterfly/package.json","hash":"468687ba18a2179b720aff8fc82e88bd5cd83d32","modified":1727846613298},{"_id":"themes/butterfly/README_CN.md","hash":"37062b0e965b9070a42f06283d597d895c8aa9e3","modified":1609226080000},{"_id":"themes/butterfly/_config.yml","hash":"3fa6b9ff8e9d22d76e270504f4d97df68243e462","modified":1682582521910},{"_id":"themes/butterfly/README.md","hash":"4d0b23ad00caadaa717555cb8fd37d272eeaeca0","modified":1609226080000},{"_id":"themes/butterfly/languages/en.yml","hash":"948f4a29cd5fafdc46ad2008f60929acf76be2a3","modified":1609226080000},{"_id":"themes/butterfly/.github/stale.yml","hash":"7a131b8aa4936fbcedea3517299e1cdc1bcbcaab","modified":1609226080000},{"_id":"themes/butterfly/languages/default.yml","hash":"690fae93ee2e578e9085e988654ddb013d2fffd9","modified":1609226080000},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"600ac62a76344d012c2b776e570a5e21c66683a8","modified":1609226080000},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"3a02788767ed6a751e1c350ec620354b50ac86b9","modified":1609226080000},{"_id":"themes/butterfly/layout/404.pug","hash":"10ce9b0764d975460069bf116bfceaaeb9691d3a","modified":1609226080000},{"_id":"themes/butterfly/layout/archive.pug","hash":"2d5bf4b1755f89898c579c18d601be83d2bc8ebd","modified":1609226080000},{"_id":"themes/butterfly/layout/post.pug","hash":"0277577f7fce2b830259e29d3a2a82f35addbf78","modified":1609226080000},{"_id":"themes/butterfly/layout/page.pug","hash":"76536c903cabc8e4619759e3a8b6a384c0518716","modified":1609226080000},{"_id":"themes/butterfly/layout/index.pug","hash":"648dcbdb3d145a710de81c909e000e8664d2ac9c","modified":1609226080000},{"_id":"themes/butterfly/layout/category.pug","hash":"90e56274a7c853f6f30337011f9c9d6d035950dc","modified":1609226080000},{"_id":"themes/butterfly/layout/tag.pug","hash":"4bb5efc6dabdf1626685bf6771aaa1467155ae86","modified":1609226080000},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/custom.md","hash":"b41123ce5f0ccfa9e06a68b9f3cb59ba040a049a","modified":1609226080000},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.md","hash":"0b7979a908ebe8c350d73b6731f0be3e29d401c2","modified":1609226080000},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.md","hash":"205a69ba038cf76affcdc1f39d88a8cb8079fc12","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"8715948b93e7508b84d913be1969b28c6b067b9b","modified":1609226080000},{"_id":"themes/butterfly/scripts/events/404.js","hash":"5f6127ede7d139891208340b5cf5bf9314e4be7d","modified":1609226080000},{"_id":"themes/butterfly/scripts/events/init.js","hash":"f7ab55363d05c945569d9ac4afc889f9706308c6","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"924e1fefc81f33f165a5fa9856712a98e7c83ad5","modified":1609226080000},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"d9cdeecfb0098ad9bf4814ea2f95167b637e015d","modified":1609226080000},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"1e1da036fae593be7e2cc502f0a5cbeb2e7881d1","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"780566ea9155df8f503af4e80ec7eff10e00859a","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"6006ae4885ad82bd41ffd0f1734bde94d442c9ff","modified":1609226080000},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"f42b2358a44d91ef6c853ce75f23af6e8d3ff423","modified":1609226080000},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"0745597f4ffadde037e57e0f66f7d984dc576dc6","modified":1609226080000},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"ff3815e6923f248501ed76aebfa6e8e083edb9f7","modified":1609226080000},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"1e2ac4d26df7cd18a92f1404329f8eb1c388dc18","modified":1609226080000},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"dbce193ba170e004790550fe4694de8e29b299b9","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"66b14189a1913119ff5927c0b933b5c73fb37f48","modified":1609226080000},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"54c0c9c6d4d4ca754680cd24d7e204a745a6eec0","modified":1609226080000},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"7ffbe625f184116e442648c8416ea58614a1cef8","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"86b2a4d500542fe764fdc5ff71cf029604325930","modified":1609226080000},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"eb019da8c190923e759d2fd7cb846281eef8594e","modified":1609226080000},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"829229b0074b332ba779e159219eb2466612ff6e","modified":1609226080000},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"420ba8b11e7316b4c09eb301d39814bc9bae9f90","modified":1609226080000},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"08ea00791bd4738952234cb5d8360e119df6f875","modified":1609226080000},{"_id":"themes/butterfly/source/css/index.styl","hash":"c7924868adcb046b46498626a9223c7a7b3f2e30","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"012e46f5130a2ff312c28a4fcdc060195f92efde","modified":1609226080000},{"_id":"themes/butterfly/source/css/var.styl","hash":"ae8193bd0107c823b8d2a123f1c301084c9c227a","modified":1609226080000},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1609226080000},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1609226080000},{"_id":"themes/butterfly/source/img/algolia.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1609226080000},{"_id":"themes/butterfly/source/img/loading.gif","hash":"5f0287fb8fb98872fe1998c6f781111819e71806","modified":1609226080000},{"_id":"themes/butterfly/source/js/main.js","hash":"8f687a1b6d7c595c15b33df6a11a91d07c046f5d","modified":1609226080000},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1609226080000},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"4db1170be7a9360e2c5399d281b979da730df2a3","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"767b425f97e74a98002f4a435e36e8ec27e8a994","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"25fdae675275d2cefe427c6b5c3f73ed72c6bfbf","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"afe703c766b8717d119379ee27037481f1165af8","modified":1609226080000},{"_id":"themes/butterfly/source/js/utils.js","hash":"ba7e672a7bed2aefb9174e8122d92a643814272a","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"e33b993af0bfc521334dac8e3c8a227dfbf9fcaa","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/head/js.pug","hash":"473059d3a4a63fa95ea4d2ca71ae16c003502e0a","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"72efaa09ff60843567458bd54152e06f0cb2757e","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"c22d6e416c05cfa4153095a067e99716eabdcbd1","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"6dc2c9b85df9ab4f5b554305339fd80a90a6cf43","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"1ddbd09e1902da7fa4bf7824654f132e41622c42","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"9a6f8211cdcb4aa87ccb5fa4f62b89c245412c94","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"d22d4c98028272dfc6c2e721e469f572a6b62ed3","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"0060598ca1cf25619bdb110ea2c83c690e4d2939","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"343637e17415a92bd11ebdd2ef4cb340e2b4cf96","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"631ec7000fd4d6cfa2de118ee02ad8a42ffb34f5","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/loading/loading-js.pug","hash":"81a34e9d642a68e77650609601a8096c6445daef","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/loading/loading.pug","hash":"dd8e6813976be64e80eba6562b54e74527ab306d","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"2beb27e33e4492fa80e88c37dcb7a3ffd7da9e24","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"90b5c2600569f8cf769c5fb3a37c12536f71e375","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/page/artitalk.pug","hash":"f1476d8b05d81e572556f246ac2212085cbdf792","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"95924d28d71b28769963529f82b376a9dc731fad","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"f5ea1e10a169aeb98e42b19ac084c4eb27693b46","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"7e7832aafdf5ca50e71a039ad3fc98d8ef6e7d30","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"62dc2e683d56ddc9b588abc44dc1cfb778a2c68f","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"6ec54b77e3a90e148e66e317e5bb6c89624fddca","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"d9b96f24c2439f263a606fd38a5517bd4bb162b7","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"bee06b3f01fa1f0d8fa08c154234b452da425101","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/baidu_push.pug","hash":"d3490e78bd2569423dc1844b9db0fbb6cd855022","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"21a7f17ff457c0cf8747f0847dee6df675482574","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"38504aec959c050c082db1c5aeaf99345f97bbee","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"2448b243ded58aa1d5fc22fd115e6d06b636f9fd","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"e0e8bf00ef7a0a62ea2265bd5e4a33d0edab5946","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"851514d1200d1dbc99268b190c03d3bd83ba68d5","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"a72b8e82b99ba79903eaa53478bbd8f4ba4412e1","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"4c3da5a89b4e6fd3ab527f5c6d27790359d57f71","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"9066634f04443953e5c4e1b563e79ab6218983de","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"1c8eb5752cc6d42b384d7e363e66ece3f742f479","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"41790dac9780bebe95a2be2d7e327bd98be362d3","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"3a8e63d6c9f74578c55b96e3888adbf9928dad0a","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"966c31e7c57dbc543bb94e6f3802c4738c79ba47","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"1b48347561b6d068f3c720802dd9223a8d1971a5","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"e00568eb9a3c9ff005e1fbd505042081884a552a","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"8df2824b78b28d12da61a82a0da995b3116673a3","modified":1609226080000},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"18474102233847c9452c7eb1048df58dfd33c962","modified":1609226080000},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"56ce639b394ba195207ee00f5a2d6f22926b403f","modified":1609226080000},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"d67ecb6c950e802a9c73975b13cab44f899eb192","modified":1609226080000},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"3f0b8699f529f0842c3b101006f60cb7933c16ff","modified":1609226080000},{"_id":"themes/butterfly/source/css/_layout/404.styl","hash":"84c14368d3fab66d5fb7d03678766274e2e0d84f","modified":1609226080000},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"8a59aa7c185d89b437c0f529d57381dc21ff06ed","modified":1609226080000},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"f27ad7b5d781c98bcac5c12c2d70b69b830e0374","modified":1609226080000},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"8e6c9a2c1881985e4b2ae14ef1bdfdbb1bc83b37","modified":1609226080000},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"bfc4b9d8df66593c11c9ae78899f54e69785ca90","modified":1609226080000},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"9e66e9672eb6d60950024d5f73cb7b925b2549b2","modified":1609226080000},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"807f18717c29b5c41de6fc600a69a80ce8b7a19c","modified":1609226080000},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"c4ae9292d6b7e42943b1b11e109ed560dc3a7753","modified":1609226080000},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"6c74997b89984db3696572efc7cbafdf59ce7803","modified":1609226080000},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"ba391266cd967fa96109677455dd6701292afd52","modified":1609226080000},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"d6149c50ad33b3feb3da8a9d0b9e6557d1137210","modified":1609226080000},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"e00d34774a0d5644bae9989f0e89743b5f9e2ea5","modified":1609226080000},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"78ef182c0f6711c8491a8ee421b708c8f2a63c30","modified":1609226080000},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"0cb678f991af06015804eaebafa8e983b0dcc3de","modified":1609226080000},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"190b85de3e686393e45869d12464995f23b304dc","modified":1609226080000},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"ca1d3a885a85a91fcd6f7b55fca96cafb6a1b0a3","modified":1609226080000},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"4058ab759577efe280d5e38902be39054ed4b471","modified":1609226080000},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"3c7a7efbb14d8ce6538f612992aa1a62fd278991","modified":1609226080000},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"75c87cb69b2eb2a219eec9447cd79282ef612a68","modified":1609226080000},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"26e26797b3175498e20b2a8bf1679d3ed9fac5a6","modified":1609226080000},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"17f2d47f93cb91e1f5d5c046fcd649d4c54f0107","modified":1609226080000},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"573d3834d15768f9a6f70b86d28d9a9c44764e89","modified":1609226080000},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"a470029a157fbb8406ff72322a75ef63d6675431","modified":1609226080000},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"202b01db6ef3cca9e5a173e1a0dadfee8854a849","modified":1609226080000},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"92aa84cdec97729c86ba4674a355496eb37c986a","modified":1609226080000},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"5fe4235c038ed128819bd6918cd0781b372b598e","modified":1609226080000},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"6c12a03e26ca5d538537d472657d3d03a7fcbb87","modified":1609226080000},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"aa0728c556af75f5d66ecd44fa207722d474c26d","modified":1609226080000},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"56691537c7f06c2cf1ffa1509a328f506d938ee8","modified":1609226080000},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"75a5c15c7029197ec5cffd27f7c5455891c946c9","modified":1609226080000},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"8520674768dd0b1837f947892e8402b192a4f9c1","modified":1609226080000},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"8549829fb7d3c21cd9e119884962e8c463a4a267","modified":1609226080000},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"a19f12257b14f70806a0c3cb0e9df1090f36e919","modified":1609226080000},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"3234942decaa1fde5b872766d4943a2e8cb9ef72","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"f3f6eaecbcf9352342e259f4a5a3ad7160f31fc9","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"b741b5e942481d779a8a1fe94c45154a62a6b748","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"e5af55cdb87d1ffd3d8702bc77097159acf95b54","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/chat/gitter.pug","hash":"794ce3911f17d354b7196deb8c36d191afac63fb","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"bb467bb22f3d0775b33f9eacbfc086ecb7831e78","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"cd7ab4a776be93eea96a6f6fd0a547977fbe1ea3","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"663a298253eddb5126ca1a6139d69c7097ffb52e","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"47d5367d8308a5a134058f9f63c33c75890960f8","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"9b6b7b589ef7a8109d88ba439b2d8baf7286b961","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"a8d8be37236400508e97f75615f03cedccacddfb","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"91f269cdec593209950506b8b65e938ca3d0372a","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"6f4829a8e08c3bd36e96477efdbe552c85a7350b","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"589f8503f264d4fda971c8daf2028f45c4f2867b","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"776b71dd76a900b1bdf8e6e6fdf94e82bbe7e2b1","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"1c7e9fe86b7d7ef18cc876dfce19263fd4e73066","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"c8245cbb908c64430470b0ef2887d468ef77189c","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"407d88e4af099d5f1a3f44623ec276c999219ec3","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"0322d640fd6a91853dec3ad39cc24c9b1291322b","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"6f92311afe60ca5f44055016db9cecce8fb2dc62","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"faf1113de12d6db0486572d7e99b03cbd0c4a896","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"7ced4e62fc669b00c30bf5ffe814bd30d963a490","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"732f4ebf7a1be1c94917dec426acaa494348c0ef","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"6ba8915b0da215f306f0b055f0484d23eb26c84d","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/leancloud.pug","hash":"d78d0bd454f6bea611a55601807e63e107dfb60c","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"b187ee9721cfa864208af3e51a8b0d72fc5aa6ea","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"1c06e60b120c946c1856904848ceba6ab58d1f82","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"ff3727c3ec698ec61a28c55cbc8c8508f0efb0a0","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"8b4034e53ca5bf85097f681a6e76a53ce685c205","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"fbcf94ecdca30bed7cfc4f4ec08b200579c2614e","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"fbac21a6c5924fb2f8d1190fd634105fdbc603d4","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"0622e955f3d2efef457f61d0cec0408376bd180a","modified":1609226080000},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"7e9a7347dd8ca4c33c564fb62512743b6012bb2d","modified":1609226080000},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"ba3bdf02a6c78b15eada95638173a11445dac7ac","modified":1609226080000},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"1b2dc0ef768c9be9f18d1c1f93d88f916482c5df","modified":1609226080000},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"ebae44a37ac143f4e35523ebd6809371958fb930","modified":1609226080000},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"c1747b8641303a1d9472ec94f2bc654885feb270","modified":1609226080000},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"1309292f1c8c53d96cd7333507b106bcc24ca8fc","modified":1609226080000},{"_id":"public/2023/12/29/高等讲堂/index.html","hash":"6592556b5acfd75368d898e7c166ed25af65acfc","modified":1727846721573},{"_id":"public/2023/08/24/本科四年个人酬金/index.html","hash":"51d8db22d1100dae7b3ba7dfcac6350a7126555a","modified":1727846721573},{"_id":"public/2023/04/25/Mac的常用操作/index.html","hash":"8d435293dbac7bd25fd8de5640423fef193d7b44","modified":1727846721573},{"_id":"public/2023/04/25/React-native开发/index.html","hash":"f652b9c0cb2b60790e2a232d38270f29904444f9","modified":1727846721573},{"_id":"public/2023/04/25/ElementUI2-开发/index.html","hash":"af5d99ac87a5849a5b122ab995ca4246df4e7867","modified":1727846721573},{"_id":"public/2023/04/24/Ubuntu系统中的常用操作/index.html","hash":"0edbdb43d05c274fa87bf4b470fd25d98654f21b","modified":1727846721573},{"_id":"public/2022/03/29/git基本操作整理/index.html","hash":"1f87dd92da3c7c2b3af6e11f81b5c55673f606be","modified":1727846721573},{"_id":"public/2022/04/03/JS-原型链/index.html","hash":"fb81f4b3abca38fcd0bc6c3b572cc7b65ffd113c","modified":1727846721573},{"_id":"public/2022/03/19/前端——节流与防抖/index.html","hash":"d0414a628039551ccc8ecc7e1e38a56fc8651868","modified":1727846721573},{"_id":"public/2022/03/31/单调栈的应用/index.html","hash":"02cfc7c83fedea1c7720e7a4b14c2470db42e1ac","modified":1727846721573},{"_id":"public/2021/01/26/leetcode刷题/index.html","hash":"910b18acc0c7eafd9684380e4636a595355ae93d","modified":1727846721573},{"_id":"public/2021/01/11/五子棋联机游戏介绍/index.html","hash":"e108addd353391ed3c037ab09db9e70786e5dfec","modified":1727846721573},{"_id":"public/2021/01/11/离散数学-复习/index.html","hash":"642cbaedd52fa0b4cdabc31552a49aa4da8b0f21","modified":1727846721573},{"_id":"public/2021/01/06/数据结构论文/index.html","hash":"03f35ac4f461e3348bfe7d9359c988f7039b897e","modified":1727846721573},{"_id":"public/2021/01/05/数据结构复习/index.html","hash":"dedcb4114b786d0f2674e63768cbc6ad89629c90","modified":1727846721573},{"_id":"public/2020/12/31/2020年/index.html","hash":"9dd58affcb71dcb558a2e531c5068fedf79576f0","modified":1727846721573},{"_id":"public/2020/12/30/计算机组成原理实验/index.html","hash":"98a2279077e6a246d0c999e5fef296421cc7e1a6","modified":1727846721573},{"_id":"public/2020/12/29/第一篇博客/index.html","hash":"77be4b542a0cf6b1caae536d2a449eb18292b3a1","modified":1727846721573},{"_id":"public/archives/index.html","hash":"10d659f231da52934194bc97a4099b652567ad1b","modified":1729495261788},{"_id":"public/archives/page/2/index.html","hash":"144b6ec857722218e0cf10de923c8144d65c1f00","modified":1729495261788},{"_id":"public/archives/2020/index.html","hash":"496cded3e29a9e5171860a781622c65284e6fda3","modified":1729495261788},{"_id":"public/archives/2020/12/index.html","hash":"46db4cb080336aaf443922454af9dd342d8e7335","modified":1729495261788},{"_id":"public/archives/2021/index.html","hash":"be8fd7872b8fb18b90bf8ab9b4e2799fa8ee1300","modified":1729495261788},{"_id":"public/archives/2021/01/index.html","hash":"c87837e2c692c63625879e1f108dc9c2e82b6d31","modified":1729495261788},{"_id":"public/archives/2022/index.html","hash":"5c9932f34bad543c3231a4fc71ee273840b314ea","modified":1729495261788},{"_id":"public/archives/2022/03/index.html","hash":"efc111d6c6791cb9f934bdbe43186c728f717c27","modified":1729495261788},{"_id":"public/archives/2022/04/index.html","hash":"c2afdb907abd3e8c6d7c6f885d929405878a5707","modified":1729495261788},{"_id":"public/archives/2023/index.html","hash":"ef0cf01a1cf08129756f439e1788aaef11da46df","modified":1729495261788},{"_id":"public/archives/2023/04/index.html","hash":"b7e987e9a407633037bbec6fbacc09d60a68b9da","modified":1729495261788},{"_id":"public/archives/2023/08/index.html","hash":"a062ff5e54fa892650d89db033d130a8cd2bf5fe","modified":1729495261788},{"_id":"public/archives/2023/12/index.html","hash":"6af78eb67119079762235b7c5568169414a85fff","modified":1729495261788},{"_id":"public/index.html","hash":"bcbbfff3285b9d363b0e7fc2b39a22ad7b6b2987","modified":1729495261788},{"_id":"public/page/2/index.html","hash":"c23486458e055a5e940b72731b698e2e0e1c7c76","modified":1729495261788},{"_id":"public/CNAME","hash":"89b86650a749b0a37945be60cf90d84df927c124","modified":1705381425176},{"_id":"public/ZONE/os/test.html","hash":"7f6813ad83dd7db5a314112bd640e336e77b4c3e","modified":1705381425176},{"_id":"public/ZONE/test/find.jpg","hash":"b46c4fcdba70c808a916c7952176d318531d8adf","modified":1705381425176},{"_id":"public/ZONE/test/love.jpg","hash":"844a3fd668c1c1e23b7df07f8042a43b356a3862","modified":1705381425176},{"_id":"public/ZONE/test/test.html","hash":"7e386cf68e5e25793c44e7c264d5fd8e86433882","modified":1705381425176},{"_id":"public/ZONE/test/wechat.jpg","hash":"8985aa7d57c212bcd1472c75f08be8294ea7be25","modified":1705381425176},{"_id":"public/img/algolia.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1705381425176},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1705381425176},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1705381425176},{"_id":"public/img/loading.gif","hash":"5f0287fb8fb98872fe1998c6f781111819e71806","modified":1705381425176},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1705381425176},{"_id":"public/css/index.css","hash":"fc00457a77cf51ca873beec86305e9550f1d0906","modified":1705381425176},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1705381425176},{"_id":"public/js/utils.js","hash":"41481019ef510c74e744f4f7ec4d0a13b5ccc04c","modified":1705381425176},{"_id":"public/js/search/algolia.js","hash":"65b45e61586f7e66c3f338370bfd9daadd71a4b7","modified":1705381425176},{"_id":"public/js/search/local-search.js","hash":"459e2541afda483916d16fce4aaa56b41bcd42ba","modified":1705381425176},{"_id":"public/js/main.js","hash":"be5b2e99a836e4ba89dde647a501df86dd2be81c","modified":1705381425176},{"_id":"public/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1705381425176},{"_id":"public/ZONE/test/bg.jpg","hash":"13e563306df2c9bed893856fb234416dbf5475af","modified":1705381425176},{"_id":"source/_posts/数位DP解题思路.md","hash":"479f2887bec59c6fa6a24e4186d1bac6a50220d5","modified":1705828379135},{"_id":"public/2024/01/16/数位DP解题思路/index.html","hash":"3bf8bdf7b0f908348b314c60bc4e4d130598569d","modified":1727846721573},{"_id":"public/archives/2024/index.html","hash":"49ca3d1315d99d28667b378e1287959ec4dfd782","modified":1729495261788},{"_id":"public/archives/2024/01/index.html","hash":"60c4c5777c5796aea654afed909aa8295c70586a","modified":1729495261788},{"_id":"source/_posts/需要深入理解的一些算法.md","hash":"b5405ca6b38ee4cd5f2749edfa1ff39d5e131678","modified":1705828379132},{"_id":"public/2024/01/20/需要深入理解的一些算法/index.html","hash":"1b2dcf609625913b0c856fdd191dbe7166daafe7","modified":1727846721573},{"_id":"public/tags/算法/index.html","hash":"72ea081ae41a7dcf0e73d8dba2a12d425d4a1d80","modified":1729495261788},{"_id":"source/_posts/parse-from-mail-attachment.md","hash":"42c2df56b12518c7e8ca587fcd91c308fc9e558e","modified":1720111199155},{"_id":"public/2024/07/05/parse-from-mail-attachment/index.html","hash":"f9bd10d6fd28a003f5e9c60d8845bcc3108a67d7","modified":1727846721573},{"_id":"public/archives/page/3/index.html","hash":"61fd8506c20c28080bede236198a3a6301bf1377","modified":1729495261788},{"_id":"public/archives/2024/07/index.html","hash":"f59ae147f97124c1006fe781b8a9a6a10205340f","modified":1729495261788},{"_id":"public/page/3/index.html","hash":"f8f8a69dbd2208e0a79bb2373a5ca377a156f421","modified":1729495261788},{"_id":"source/_posts/贪心算法-加油站问题.md","hash":"cb35be01bcab192415126264450e68cd85ab00d2","modified":1727846718748},{"_id":"source/_posts/二分查找.md","hash":"76753ca5622006f646c328f095df0a45565059ab","modified":1727846693250},{"_id":"themes/butterfly/package-lock.json","hash":"7d9146e4f5d2aeb3e6dcea6502b863146e21a1f2","modified":1727846613331},{"_id":"public/2024/10/02/二分查找/index.html","hash":"b87525473e132403e67ee44ba538e64003eb7bed","modified":1727846721573},{"_id":"public/archives/2024/10/index.html","hash":"ed26cac89c35cc773bb9de1e0cd014be32ff1b76","modified":1729495261788},{"_id":"public/2024/09/08/贪心算法-加油站问题/index.html","hash":"53e89406efd34aefd16d6fbf92fe9489a7663b0f","modified":1727846721573},{"_id":"public/archives/2024/09/index.html","hash":"66ce8a32ed744febe65e52e36a10d0f43b868f42","modified":1729495261788},{"_id":"public/二分查找/index.html","hash":"7aa036b22ebd0b5f1e8baad255c2dfc67836ab82","modified":1729495261788},{"_id":"public/贪心算法-加油站问题/index.html","hash":"22f3154e05ac1ab1cde3c63bbf1b09a98a64f551","modified":1729495261788},{"_id":"public/parse-from-mail-attachment/index.html","hash":"dc5ead048060e757a8df20b692cc6108ac3ff9c2","modified":1729495261788},{"_id":"public/需要深入理解的一些算法/index.html","hash":"3897c6ea85525de42d23309d2bd4b944381a1ed9","modified":1729495261788},{"_id":"public/数位DP解题思路/index.html","hash":"6c4df0f3db5bbf75a5cd22cda882a58342ade32f","modified":1729495261788},{"_id":"public/高等讲堂/index.html","hash":"f57f7a01d2dcb326beb1c729ca5b9d2c0d906022","modified":1729495261788},{"_id":"public/本科四年个人酬金/index.html","hash":"2569e106a424bca57fa5cb077ec7199b2a684073","modified":1729495261788},{"_id":"public/Mac的常用操作/index.html","hash":"282f33dc10791f9a3b555bf61241d0f9034bcebb","modified":1729495261788},{"_id":"public/React-native开发/index.html","hash":"c66b0621de02d63ae4e49aefcbb78a9eadffd2c8","modified":1729495261788},{"_id":"public/ElementUI2-开发/index.html","hash":"c3d059431763e392041992c495d5d3546541c1c2","modified":1729495261788},{"_id":"public/Ubuntu系统中的常用操作/index.html","hash":"0ac0c61afc11bc949536b483a605da39b62bb661","modified":1729495261788},{"_id":"public/JS-原型链/index.html","hash":"ea7aa239dfe15f9e6342fbfcf2a09a37a17ac05b","modified":1729495261788},{"_id":"public/单调栈的应用/index.html","hash":"f354e159b2484a17347dbfe80669388f69c548c7","modified":1729495261788},{"_id":"public/leetcode刷题/index.html","hash":"62fb10d36bb1853abf4e6919095dd315b65ea1e4","modified":1729495261788},{"_id":"public/前端——节流与防抖/index.html","hash":"4930137fdc7ee2376fe3a7342adaf76125d5e8ba","modified":1729495261788},{"_id":"public/git基本操作整理/index.html","hash":"5747bda4a5a4dca3a045ef4e55e3cff5dacb0d31","modified":1729495261788},{"_id":"public/五子棋联机游戏介绍/index.html","hash":"a3688985dd65b347b6ad20c9aadc51f713d9a878","modified":1729495261788},{"_id":"public/离散数学-复习/index.html","hash":"5343ae5635a7fbf6ae273b040e2f10828830be3f","modified":1729495261788},{"_id":"public/数据结构复习/index.html","hash":"8d93f551a93019a3dcca72afe92e2a742ea8c030","modified":1729495261788},{"_id":"public/数据结构论文/index.html","hash":"04a18175f93f55680a596e172f3a237ca0cf5045","modified":1729495261788},{"_id":"public/2020年/index.html","hash":"bbd8122435d77d8a67ec2e35278f74e87a5af37d","modified":1729495261788},{"_id":"public/计算机组成原理实验/index.html","hash":"7f8ea3b91e63e144ee9f6d2cba7d316f7646992e","modified":1729495261788},{"_id":"public/第一篇博客/index.html","hash":"ab4d0e077f1db6e7080b246164e2e61d00c78de9","modified":1729495261788}],"Category":[],"Data":[{"_id":"link","data":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}],"Page":[],"Post":[{"title":"2020年结束了啦~","date":"2020-12-30T16:00:00.000Z","description":"2020年年度总结","cover":"https://s3.ax1x.com/2020/12/31/rvEA3T.jpg","_content":"\n> 2020年结束的好快，感觉这一年还没反应过来就已经要一晃而过了。\n>\n> 现在是2020年12月31日，在数据科学这堂课上，写下了这篇博客，就当做是对这一年的一个回顾。\n>\n> \n\n2020年开始于大一上学期的考试周，前一天是在图书馆复习着即将到来的大物考试\n\n[![rvAkOH.jpg](https://s3.ax1x.com/2020/12/31/rvAkOH.jpg)](https://imgchr.com/i/rvAkOH)\n\n在2020年开始的时候，发生了让自己心态发生了一些变化的事情。不过幸好，自己还是做到了每天去图书馆，复习着那几门科目。\n\n大物、线代、高程……一门一门的考试，每一门考前都是从焦虑到放松，以及考完后的解放。\n\n最后一门考的是线代，那天中午去北苑吃了叉烧饭（自己当时没有想到也是大一最后一顿叉烧饭\n\n[![rvAG0s.jpg](https://s3.ax1x.com/2020/12/31/rvAG0s.jpg)](https://imgchr.com/i/rvAG0s)\n\n在线代考完后，自己便立马带着手拉箱奔向高铁站，准备去坐即将发车的高铁了。\n\n1月9号便迎来了我的寒假的开始。寒假一开始我还试着好好学习Stl，但是学着学着感觉没意思就放弃了。感觉我可能还是需要做一些有意思的项目才能够坚持下去吧，求大佬带我做点有意思的东西QAQ\n\n同时，寒假里也迎来了认真复习的好结果，自己好多课都拿到了理想的成绩了啦~\n\n[![rvEpHs.jpg](https://s3.ax1x.com/2020/12/31/rvEpHs.jpg)](https://imgchr.com/i/rvEpHs)\n\n疫情到来之前，放寒假每天就很无聊，就是想着吃啥、玩啥，然后发一些乱七八糟的动态：\n\n> 以前走楼梯最喜欢数台阶数 \n>\n> 所以每次走的时候都害怕会多出来或者少掉一个台阶 \n>\n> 如果走完数量正确就算成功逃生\n\n很快，疫情来了。刚开始那段时间真的还是蛮焦虑的，特别担心这种“未知的病毒”到自己的身边。然后响应国家政策不出门，在家里就玩游戏：QQ飞车、植物大战僵尸、逆转裁判什么的。\n\n> 在原本的世界线里 \n>\n> 我于六小时前到达同济大学 \n>\n> 并将在明天开始电路理论课程 而现在的现实却是要放暑假了\n\n很快也迎来了延迟开学的消息，在推迟了一周开学后，便迎来了印象深刻的网课时期。\n\n网课时期每天干的事情就是好好上课，然后晚上会玩会儿游戏，点名表扬qjy同学。\n\n这个学期也玩到了两个我特别喜欢的游戏：\n\n一个是奇异人生（Life Is Strange）：\n\n[![rvEA3T.jpg](https://s3.ax1x.com/2020/12/31/rvEA3T.jpg)](https://imgchr.com/i/rvEA3T)\n\n还有一个则是消逝的光芒（Dying Light），画面相对比较血腥这里就不放图了。\n\n然后就迎来了软件工程的大项目——元气骑士（Vigor Knight），和另外三个小伙伴一起做了个实际上非常垃圾的游戏（我自己反正是玩不下去），也认识了wly,mjy和ljj\n\n[![rvENbd.md.jpg](https://s3.ax1x.com/2020/12/31/rvENbd.md.jpg)](https://imgchr.com/i/rvENbd)\n\n同时，网课这学期也发生了件比较让我高兴的事情。\n\n我和lyf（春雨支教社团老大姐）强行凑成了数学建模小组，报名参加了学校的建模校赛，并且在比赛前三个人都没有看过任何建模相关的知识。就是五一建模强行冲，最后一天熬夜到了凌晨四点，最后迎来了一个让我们大家都不敢相信的事情，收到了答辩邮件。大家都不敢相信我们能拿奖，毕竟所有人最开始的目标是成功参赛奖。贼兴奋\n\n[![rvEYKe.md.jpg](https://s3.ax1x.com/2020/12/31/rvEYKe.md.jpg)](https://imgchr.com/i/rvEYKe)\n[![rvEGvD.md.jpg](https://s3.ax1x.com/2020/12/31/rvEGvD.md.jpg)](https://imgchr.com/i/rvEGvD)\n[![rvE8gO.md.jpg](https://s3.ax1x.com/2020/12/31/rvE8gO.md.jpg)](https://imgchr.com/i/rvE8gO)\n[![rvEtDH.md.jpg](https://s3.ax1x.com/2020/12/31/rvEtDH.md.jpg)](https://imgchr.com/i/rvEtDH)\n\n然后这学期还和wly合作做了数据库的大作业，因为我和他害怕经管的同学会卷，所以我们就越做越复杂。结果最后发现：\n\n**内卷人竟是我自己**\n\n不过这个项目做的过程中真的效率超高，垃圾代码产出量也非常多，还是真的有挺多收获的。\n\n[![rvE6Kg.png](https://s3.ax1x.com/2020/12/31/rvE6Kg.png)](https://imgchr.com/i/rvE6Kg)\n\n最后再次分享大一下学期，这个非常可惜通过网课度过的一个学期，所做的事情：\n\n> 1.建模写了好看论文，并且结果不错 \n>\n> 2.做了精美扫雷游戏，玩起来不会崩\n>\n>  3.设计了厉害的数据库，得到了孙丽君的认可\n>\n>  4.做了比较菜的元气骑士，勉强能跑了 \n>\n> 5.网课都基本认真听了，没怎么划水 \n>\n> 6.期末认真复习了，四场考试都用一半时间就做完了 \n>\n> 7.学会了C#新语言，可以开搞unity了\n>\n> 8.认识了牛逼的新同学 \n>\n> 9.没和老同学失去联系 \n>\n> 10.飞车上荣耀钻石啦 \n>\n> 11.跑步坚持一个月了 \n>\n> 12.c++会用stl啦 \n>\n> 13.坚持上完了机器学习，期中没退课！ \n>\n> 14.电路理论做了精美笔记！可以卖钱了！ \n>\n> 15.还没忘记你们长啥样 \n>\n> 16.被软件开发基础老师夸了 \n>\n> 17.终于会用github了... \n>\n> 18.考试周坚持了一个半月没玩游戏 \n>\n> 19.芒果tv充了年费会员 \n>\n> 20.积极帮别人解决问题了\n\n是主要搞学习的一个学期，赞！\n\n然后就放暑假了，暑假里让我印象深刻的主要就三件事情：\n\n1.lyh（真·大一就认识的hxd）来金寨了，一起去天堂寨玩了，然后我发誓再也不要去天堂寨\n\n2.开始学车，每天顶着大太阳去科目二的地方练车，等一两个小时练一把车\n\n3.和wly打QQ飞车\n\n再然后就开学了，开学就是先军训。不过因为我暑假面试过了政治部，所以避免了太阳：\n\n[![rvEWan.jpg](https://s3.ax1x.com/2020/12/31/rvEWan.jpg)](https://imgchr.com/i/rvEWan)但是说实话，政治部那七天的生活绝对不轻松。甚至可以说，我的绝大多数宣传能力都是在期间学习到的\n\n我和其他宣传组的小伙伴共同每天艰难的生活着（下图拍于12月份）\n\n[![rvEHr4.jpg](https://s3.ax1x.com/2020/12/31/rvEHr4.jpg)](https://imgchr.com/i/rvEHr4)\n\n那段时间，说实话，我个人过得挺自闭的。\n\n因为感觉有非常多的事情没有做完（剪可视化、外拍、推送等），还感觉自己的成绩可能不是很理想。中间甚至一度想要退课明年再选军训，总而言之：很庆幸熬了过去。\n\n下图是在其他组还没起来，卑微宣传人已经开始工作的一天\n\n[![rvEzRK.jpg](https://s3.ax1x.com/2020/12/31/rvEzRK.jpg)](https://imgchr.com/i/rvEzRK)\n\n军训之后，这一学期就正式开始了。\n\n来嘉定的第一个学期，体验一般。\n\n每天的生活就是去上课，去自习，思考中午吃什么，思考晚上吃什么，睡觉。\n\n比较有意思的事情是评上了果酱和社奖、参加了软院晚会、支书达理活动、玩密室等。\n\n这里就不再总结了，不要问我为什么，因为我打字打累了。这段经历应该在这学期结束的时候还会复习一下吧。\n\n直接进入最终总结环节吧。\n\n\n\n## 2020年收获\n\n> 1.认识了wly、mjy、sbq、ckx、lxy、zlh、lmx、xhz、hzj、syk、dtw、wjh、wmb、znf、lrj、lrz、chs、yxb、zkf、dgg、jch、whz、xmx、hmz、sr等很多同学\n>\n> 2.之前朋友还在\n>\n> 3.会用服务器了，然后懂了一些Linux操作\n>\n> 4.会做简单网页了\n>\n> 5.拥有自己的博客了，也就是这个网站\n>\n> 6.Steam库++\n>\n> 7.真的学会数据结构了\n>\n> 8.拿了一次果酱\n>\n> 9.数学建模拿奖了\n>\n> 10.还是在愿意帮助别人","source":"_posts/2020年.md","raw":"---\ntitle: 2020年结束了啦~\ndate: 2020-12-31 00:00:00\ndescription: 2020年年度总结\ncover: https://s3.ax1x.com/2020/12/31/rvEA3T.jpg\n---\n\n> 2020年结束的好快，感觉这一年还没反应过来就已经要一晃而过了。\n>\n> 现在是2020年12月31日，在数据科学这堂课上，写下了这篇博客，就当做是对这一年的一个回顾。\n>\n> \n\n2020年开始于大一上学期的考试周，前一天是在图书馆复习着即将到来的大物考试\n\n[![rvAkOH.jpg](https://s3.ax1x.com/2020/12/31/rvAkOH.jpg)](https://imgchr.com/i/rvAkOH)\n\n在2020年开始的时候，发生了让自己心态发生了一些变化的事情。不过幸好，自己还是做到了每天去图书馆，复习着那几门科目。\n\n大物、线代、高程……一门一门的考试，每一门考前都是从焦虑到放松，以及考完后的解放。\n\n最后一门考的是线代，那天中午去北苑吃了叉烧饭（自己当时没有想到也是大一最后一顿叉烧饭\n\n[![rvAG0s.jpg](https://s3.ax1x.com/2020/12/31/rvAG0s.jpg)](https://imgchr.com/i/rvAG0s)\n\n在线代考完后，自己便立马带着手拉箱奔向高铁站，准备去坐即将发车的高铁了。\n\n1月9号便迎来了我的寒假的开始。寒假一开始我还试着好好学习Stl，但是学着学着感觉没意思就放弃了。感觉我可能还是需要做一些有意思的项目才能够坚持下去吧，求大佬带我做点有意思的东西QAQ\n\n同时，寒假里也迎来了认真复习的好结果，自己好多课都拿到了理想的成绩了啦~\n\n[![rvEpHs.jpg](https://s3.ax1x.com/2020/12/31/rvEpHs.jpg)](https://imgchr.com/i/rvEpHs)\n\n疫情到来之前，放寒假每天就很无聊，就是想着吃啥、玩啥，然后发一些乱七八糟的动态：\n\n> 以前走楼梯最喜欢数台阶数 \n>\n> 所以每次走的时候都害怕会多出来或者少掉一个台阶 \n>\n> 如果走完数量正确就算成功逃生\n\n很快，疫情来了。刚开始那段时间真的还是蛮焦虑的，特别担心这种“未知的病毒”到自己的身边。然后响应国家政策不出门，在家里就玩游戏：QQ飞车、植物大战僵尸、逆转裁判什么的。\n\n> 在原本的世界线里 \n>\n> 我于六小时前到达同济大学 \n>\n> 并将在明天开始电路理论课程 而现在的现实却是要放暑假了\n\n很快也迎来了延迟开学的消息，在推迟了一周开学后，便迎来了印象深刻的网课时期。\n\n网课时期每天干的事情就是好好上课，然后晚上会玩会儿游戏，点名表扬qjy同学。\n\n这个学期也玩到了两个我特别喜欢的游戏：\n\n一个是奇异人生（Life Is Strange）：\n\n[![rvEA3T.jpg](https://s3.ax1x.com/2020/12/31/rvEA3T.jpg)](https://imgchr.com/i/rvEA3T)\n\n还有一个则是消逝的光芒（Dying Light），画面相对比较血腥这里就不放图了。\n\n然后就迎来了软件工程的大项目——元气骑士（Vigor Knight），和另外三个小伙伴一起做了个实际上非常垃圾的游戏（我自己反正是玩不下去），也认识了wly,mjy和ljj\n\n[![rvENbd.md.jpg](https://s3.ax1x.com/2020/12/31/rvENbd.md.jpg)](https://imgchr.com/i/rvENbd)\n\n同时，网课这学期也发生了件比较让我高兴的事情。\n\n我和lyf（春雨支教社团老大姐）强行凑成了数学建模小组，报名参加了学校的建模校赛，并且在比赛前三个人都没有看过任何建模相关的知识。就是五一建模强行冲，最后一天熬夜到了凌晨四点，最后迎来了一个让我们大家都不敢相信的事情，收到了答辩邮件。大家都不敢相信我们能拿奖，毕竟所有人最开始的目标是成功参赛奖。贼兴奋\n\n[![rvEYKe.md.jpg](https://s3.ax1x.com/2020/12/31/rvEYKe.md.jpg)](https://imgchr.com/i/rvEYKe)\n[![rvEGvD.md.jpg](https://s3.ax1x.com/2020/12/31/rvEGvD.md.jpg)](https://imgchr.com/i/rvEGvD)\n[![rvE8gO.md.jpg](https://s3.ax1x.com/2020/12/31/rvE8gO.md.jpg)](https://imgchr.com/i/rvE8gO)\n[![rvEtDH.md.jpg](https://s3.ax1x.com/2020/12/31/rvEtDH.md.jpg)](https://imgchr.com/i/rvEtDH)\n\n然后这学期还和wly合作做了数据库的大作业，因为我和他害怕经管的同学会卷，所以我们就越做越复杂。结果最后发现：\n\n**内卷人竟是我自己**\n\n不过这个项目做的过程中真的效率超高，垃圾代码产出量也非常多，还是真的有挺多收获的。\n\n[![rvE6Kg.png](https://s3.ax1x.com/2020/12/31/rvE6Kg.png)](https://imgchr.com/i/rvE6Kg)\n\n最后再次分享大一下学期，这个非常可惜通过网课度过的一个学期，所做的事情：\n\n> 1.建模写了好看论文，并且结果不错 \n>\n> 2.做了精美扫雷游戏，玩起来不会崩\n>\n>  3.设计了厉害的数据库，得到了孙丽君的认可\n>\n>  4.做了比较菜的元气骑士，勉强能跑了 \n>\n> 5.网课都基本认真听了，没怎么划水 \n>\n> 6.期末认真复习了，四场考试都用一半时间就做完了 \n>\n> 7.学会了C#新语言，可以开搞unity了\n>\n> 8.认识了牛逼的新同学 \n>\n> 9.没和老同学失去联系 \n>\n> 10.飞车上荣耀钻石啦 \n>\n> 11.跑步坚持一个月了 \n>\n> 12.c++会用stl啦 \n>\n> 13.坚持上完了机器学习，期中没退课！ \n>\n> 14.电路理论做了精美笔记！可以卖钱了！ \n>\n> 15.还没忘记你们长啥样 \n>\n> 16.被软件开发基础老师夸了 \n>\n> 17.终于会用github了... \n>\n> 18.考试周坚持了一个半月没玩游戏 \n>\n> 19.芒果tv充了年费会员 \n>\n> 20.积极帮别人解决问题了\n\n是主要搞学习的一个学期，赞！\n\n然后就放暑假了，暑假里让我印象深刻的主要就三件事情：\n\n1.lyh（真·大一就认识的hxd）来金寨了，一起去天堂寨玩了，然后我发誓再也不要去天堂寨\n\n2.开始学车，每天顶着大太阳去科目二的地方练车，等一两个小时练一把车\n\n3.和wly打QQ飞车\n\n再然后就开学了，开学就是先军训。不过因为我暑假面试过了政治部，所以避免了太阳：\n\n[![rvEWan.jpg](https://s3.ax1x.com/2020/12/31/rvEWan.jpg)](https://imgchr.com/i/rvEWan)但是说实话，政治部那七天的生活绝对不轻松。甚至可以说，我的绝大多数宣传能力都是在期间学习到的\n\n我和其他宣传组的小伙伴共同每天艰难的生活着（下图拍于12月份）\n\n[![rvEHr4.jpg](https://s3.ax1x.com/2020/12/31/rvEHr4.jpg)](https://imgchr.com/i/rvEHr4)\n\n那段时间，说实话，我个人过得挺自闭的。\n\n因为感觉有非常多的事情没有做完（剪可视化、外拍、推送等），还感觉自己的成绩可能不是很理想。中间甚至一度想要退课明年再选军训，总而言之：很庆幸熬了过去。\n\n下图是在其他组还没起来，卑微宣传人已经开始工作的一天\n\n[![rvEzRK.jpg](https://s3.ax1x.com/2020/12/31/rvEzRK.jpg)](https://imgchr.com/i/rvEzRK)\n\n军训之后，这一学期就正式开始了。\n\n来嘉定的第一个学期，体验一般。\n\n每天的生活就是去上课，去自习，思考中午吃什么，思考晚上吃什么，睡觉。\n\n比较有意思的事情是评上了果酱和社奖、参加了软院晚会、支书达理活动、玩密室等。\n\n这里就不再总结了，不要问我为什么，因为我打字打累了。这段经历应该在这学期结束的时候还会复习一下吧。\n\n直接进入最终总结环节吧。\n\n\n\n## 2020年收获\n\n> 1.认识了wly、mjy、sbq、ckx、lxy、zlh、lmx、xhz、hzj、syk、dtw、wjh、wmb、znf、lrj、lrz、chs、yxb、zkf、dgg、jch、whz、xmx、hmz、sr等很多同学\n>\n> 2.之前朋友还在\n>\n> 3.会用服务器了，然后懂了一些Linux操作\n>\n> 4.会做简单网页了\n>\n> 5.拥有自己的博客了，也就是这个网站\n>\n> 6.Steam库++\n>\n> 7.真的学会数据结构了\n>\n> 8.拿了一次果酱\n>\n> 9.数学建模拿奖了\n>\n> 10.还是在愿意帮助别人","slug":"2020年","published":1,"updated":"2020-12-31T11:50:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clrfw2jf40000stfa4sc28bq7","content":"<blockquote>\n<p>2020年结束的好快，感觉这一年还没反应过来就已经要一晃而过了。</p>\n<p>现在是2020年12月31日，在数据科学这堂课上，写下了这篇博客，就当做是对这一年的一个回顾。</p>\n</blockquote>\n<p>2020年开始于大一上学期的考试周，前一天是在图书馆复习着即将到来的大物考试</p>\n<p><a href=\"https://imgchr.com/i/rvAkOH\"><img src=\"https://s3.ax1x.com/2020/12/31/rvAkOH.jpg\" alt=\"rvAkOH.jpg\"></a></p>\n<p>在2020年开始的时候，发生了让自己心态发生了一些变化的事情。不过幸好，自己还是做到了每天去图书馆，复习着那几门科目。</p>\n<p>大物、线代、高程……一门一门的考试，每一门考前都是从焦虑到放松，以及考完后的解放。</p>\n<p>最后一门考的是线代，那天中午去北苑吃了叉烧饭（自己当时没有想到也是大一最后一顿叉烧饭</p>\n<p><a href=\"https://imgchr.com/i/rvAG0s\"><img src=\"https://s3.ax1x.com/2020/12/31/rvAG0s.jpg\" alt=\"rvAG0s.jpg\"></a></p>\n<p>在线代考完后，自己便立马带着手拉箱奔向高铁站，准备去坐即将发车的高铁了。</p>\n<p>1月9号便迎来了我的寒假的开始。寒假一开始我还试着好好学习Stl，但是学着学着感觉没意思就放弃了。感觉我可能还是需要做一些有意思的项目才能够坚持下去吧，求大佬带我做点有意思的东西QAQ</p>\n<p>同时，寒假里也迎来了认真复习的好结果，自己好多课都拿到了理想的成绩了啦~</p>\n<p><a href=\"https://imgchr.com/i/rvEpHs\"><img src=\"https://s3.ax1x.com/2020/12/31/rvEpHs.jpg\" alt=\"rvEpHs.jpg\"></a></p>\n<p>疫情到来之前，放寒假每天就很无聊，就是想着吃啥、玩啥，然后发一些乱七八糟的动态：</p>\n<blockquote>\n<p>以前走楼梯最喜欢数台阶数 </p>\n<p>所以每次走的时候都害怕会多出来或者少掉一个台阶 </p>\n<p>如果走完数量正确就算成功逃生</p>\n</blockquote>\n<p>很快，疫情来了。刚开始那段时间真的还是蛮焦虑的，特别担心这种“未知的病毒”到自己的身边。然后响应国家政策不出门，在家里就玩游戏：QQ飞车、植物大战僵尸、逆转裁判什么的。</p>\n<blockquote>\n<p>在原本的世界线里 </p>\n<p>我于六小时前到达同济大学 </p>\n<p>并将在明天开始电路理论课程 而现在的现实却是要放暑假了</p>\n</blockquote>\n<p>很快也迎来了延迟开学的消息，在推迟了一周开学后，便迎来了印象深刻的网课时期。</p>\n<p>网课时期每天干的事情就是好好上课，然后晚上会玩会儿游戏，点名表扬qjy同学。</p>\n<p>这个学期也玩到了两个我特别喜欢的游戏：</p>\n<p>一个是奇异人生（Life Is Strange）：</p>\n<p><a href=\"https://imgchr.com/i/rvEA3T\"><img src=\"https://s3.ax1x.com/2020/12/31/rvEA3T.jpg\" alt=\"rvEA3T.jpg\"></a></p>\n<p>还有一个则是消逝的光芒（Dying Light），画面相对比较血腥这里就不放图了。</p>\n<p>然后就迎来了软件工程的大项目——元气骑士（Vigor Knight），和另外三个小伙伴一起做了个实际上非常垃圾的游戏（我自己反正是玩不下去），也认识了wly,mjy和ljj</p>\n<p><a href=\"https://imgchr.com/i/rvENbd\"><img src=\"https://s3.ax1x.com/2020/12/31/rvENbd.md.jpg\" alt=\"rvENbd.md.jpg\"></a></p>\n<p>同时，网课这学期也发生了件比较让我高兴的事情。</p>\n<p>我和lyf（春雨支教社团老大姐）强行凑成了数学建模小组，报名参加了学校的建模校赛，并且在比赛前三个人都没有看过任何建模相关的知识。就是五一建模强行冲，最后一天熬夜到了凌晨四点，最后迎来了一个让我们大家都不敢相信的事情，收到了答辩邮件。大家都不敢相信我们能拿奖，毕竟所有人最开始的目标是成功参赛奖。贼兴奋</p>\n<p><a href=\"https://imgchr.com/i/rvEYKe\"><img src=\"https://s3.ax1x.com/2020/12/31/rvEYKe.md.jpg\" alt=\"rvEYKe.md.jpg\"></a><br><a href=\"https://imgchr.com/i/rvEGvD\"><img src=\"https://s3.ax1x.com/2020/12/31/rvEGvD.md.jpg\" alt=\"rvEGvD.md.jpg\"></a><br><a href=\"https://imgchr.com/i/rvE8gO\"><img src=\"https://s3.ax1x.com/2020/12/31/rvE8gO.md.jpg\" alt=\"rvE8gO.md.jpg\"></a><br><a href=\"https://imgchr.com/i/rvEtDH\"><img src=\"https://s3.ax1x.com/2020/12/31/rvEtDH.md.jpg\" alt=\"rvEtDH.md.jpg\"></a></p>\n<p>然后这学期还和wly合作做了数据库的大作业，因为我和他害怕经管的同学会卷，所以我们就越做越复杂。结果最后发现：</p>\n<p><strong>内卷人竟是我自己</strong></p>\n<p>不过这个项目做的过程中真的效率超高，垃圾代码产出量也非常多，还是真的有挺多收获的。</p>\n<p><a href=\"https://imgchr.com/i/rvE6Kg\"><img src=\"https://s3.ax1x.com/2020/12/31/rvE6Kg.png\" alt=\"rvE6Kg.png\"></a></p>\n<p>最后再次分享大一下学期，这个非常可惜通过网课度过的一个学期，所做的事情：</p>\n<blockquote>\n<p>1.建模写了好看论文，并且结果不错 </p>\n<p>2.做了精美扫雷游戏，玩起来不会崩</p>\n<p> 3.设计了厉害的数据库，得到了孙丽君的认可</p>\n<p> 4.做了比较菜的元气骑士，勉强能跑了 </p>\n<p>5.网课都基本认真听了，没怎么划水 </p>\n<p>6.期末认真复习了，四场考试都用一半时间就做完了 </p>\n<p>7.学会了C#新语言，可以开搞unity了</p>\n<p>8.认识了牛逼的新同学 </p>\n<p>9.没和老同学失去联系 </p>\n<p>10.飞车上荣耀钻石啦 </p>\n<p>11.跑步坚持一个月了 </p>\n<p>12.c++会用stl啦 </p>\n<p>13.坚持上完了机器学习，期中没退课！ </p>\n<p>14.电路理论做了精美笔记！可以卖钱了！ </p>\n<p>15.还没忘记你们长啥样 </p>\n<p>16.被软件开发基础老师夸了 </p>\n<p>17.终于会用github了… </p>\n<p>18.考试周坚持了一个半月没玩游戏 </p>\n<p>19.芒果tv充了年费会员 </p>\n<p>20.积极帮别人解决问题了</p>\n</blockquote>\n<p>是主要搞学习的一个学期，赞！</p>\n<p>然后就放暑假了，暑假里让我印象深刻的主要就三件事情：</p>\n<p>1.lyh（真·大一就认识的hxd）来金寨了，一起去天堂寨玩了，然后我发誓再也不要去天堂寨</p>\n<p>2.开始学车，每天顶着大太阳去科目二的地方练车，等一两个小时练一把车</p>\n<p>3.和wly打QQ飞车</p>\n<p>再然后就开学了，开学就是先军训。不过因为我暑假面试过了政治部，所以避免了太阳：</p>\n<p><a href=\"https://imgchr.com/i/rvEWan\"><img src=\"https://s3.ax1x.com/2020/12/31/rvEWan.jpg\" alt=\"rvEWan.jpg\"></a>但是说实话，政治部那七天的生活绝对不轻松。甚至可以说，我的绝大多数宣传能力都是在期间学习到的</p>\n<p>我和其他宣传组的小伙伴共同每天艰难的生活着（下图拍于12月份）</p>\n<p><a href=\"https://imgchr.com/i/rvEHr4\"><img src=\"https://s3.ax1x.com/2020/12/31/rvEHr4.jpg\" alt=\"rvEHr4.jpg\"></a></p>\n<p>那段时间，说实话，我个人过得挺自闭的。</p>\n<p>因为感觉有非常多的事情没有做完（剪可视化、外拍、推送等），还感觉自己的成绩可能不是很理想。中间甚至一度想要退课明年再选军训，总而言之：很庆幸熬了过去。</p>\n<p>下图是在其他组还没起来，卑微宣传人已经开始工作的一天</p>\n<p><a href=\"https://imgchr.com/i/rvEzRK\"><img src=\"https://s3.ax1x.com/2020/12/31/rvEzRK.jpg\" alt=\"rvEzRK.jpg\"></a></p>\n<p>军训之后，这一学期就正式开始了。</p>\n<p>来嘉定的第一个学期，体验一般。</p>\n<p>每天的生活就是去上课，去自习，思考中午吃什么，思考晚上吃什么，睡觉。</p>\n<p>比较有意思的事情是评上了果酱和社奖、参加了软院晚会、支书达理活动、玩密室等。</p>\n<p>这里就不再总结了，不要问我为什么，因为我打字打累了。这段经历应该在这学期结束的时候还会复习一下吧。</p>\n<p>直接进入最终总结环节吧。</p>\n<h2 id=\"2020年收获\"><a href=\"#2020年收获\" class=\"headerlink\" title=\"2020年收获\"></a>2020年收获</h2><blockquote>\n<p>1.认识了wly、mjy、sbq、ckx、lxy、zlh、lmx、xhz、hzj、syk、dtw、wjh、wmb、znf、lrj、lrz、chs、yxb、zkf、dgg、jch、whz、xmx、hmz、sr等很多同学</p>\n<p>2.之前朋友还在</p>\n<p>3.会用服务器了，然后懂了一些Linux操作</p>\n<p>4.会做简单网页了</p>\n<p>5.拥有自己的博客了，也就是这个网站</p>\n<p>6.Steam库++</p>\n<p>7.真的学会数据结构了</p>\n<p>8.拿了一次果酱</p>\n<p>9.数学建模拿奖了</p>\n<p>10.还是在愿意帮助别人</p>\n</blockquote>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<blockquote>\n<p>2020年结束的好快，感觉这一年还没反应过来就已经要一晃而过了。</p>\n<p>现在是2020年12月31日，在数据科学这堂课上，写下了这篇博客，就当做是对这一年的一个回顾。</p>\n</blockquote>\n<p>2020年开始于大一上学期的考试周，前一天是在图书馆复习着即将到来的大物考试</p>\n<p><a href=\"https://imgchr.com/i/rvAkOH\"><img src=\"https://s3.ax1x.com/2020/12/31/rvAkOH.jpg\" alt=\"rvAkOH.jpg\"></a></p>\n<p>在2020年开始的时候，发生了让自己心态发生了一些变化的事情。不过幸好，自己还是做到了每天去图书馆，复习着那几门科目。</p>\n<p>大物、线代、高程……一门一门的考试，每一门考前都是从焦虑到放松，以及考完后的解放。</p>\n<p>最后一门考的是线代，那天中午去北苑吃了叉烧饭（自己当时没有想到也是大一最后一顿叉烧饭</p>\n<p><a href=\"https://imgchr.com/i/rvAG0s\"><img src=\"https://s3.ax1x.com/2020/12/31/rvAG0s.jpg\" alt=\"rvAG0s.jpg\"></a></p>\n<p>在线代考完后，自己便立马带着手拉箱奔向高铁站，准备去坐即将发车的高铁了。</p>\n<p>1月9号便迎来了我的寒假的开始。寒假一开始我还试着好好学习Stl，但是学着学着感觉没意思就放弃了。感觉我可能还是需要做一些有意思的项目才能够坚持下去吧，求大佬带我做点有意思的东西QAQ</p>\n<p>同时，寒假里也迎来了认真复习的好结果，自己好多课都拿到了理想的成绩了啦~</p>\n<p><a href=\"https://imgchr.com/i/rvEpHs\"><img src=\"https://s3.ax1x.com/2020/12/31/rvEpHs.jpg\" alt=\"rvEpHs.jpg\"></a></p>\n<p>疫情到来之前，放寒假每天就很无聊，就是想着吃啥、玩啥，然后发一些乱七八糟的动态：</p>\n<blockquote>\n<p>以前走楼梯最喜欢数台阶数 </p>\n<p>所以每次走的时候都害怕会多出来或者少掉一个台阶 </p>\n<p>如果走完数量正确就算成功逃生</p>\n</blockquote>\n<p>很快，疫情来了。刚开始那段时间真的还是蛮焦虑的，特别担心这种“未知的病毒”到自己的身边。然后响应国家政策不出门，在家里就玩游戏：QQ飞车、植物大战僵尸、逆转裁判什么的。</p>\n<blockquote>\n<p>在原本的世界线里 </p>\n<p>我于六小时前到达同济大学 </p>\n<p>并将在明天开始电路理论课程 而现在的现实却是要放暑假了</p>\n</blockquote>\n<p>很快也迎来了延迟开学的消息，在推迟了一周开学后，便迎来了印象深刻的网课时期。</p>\n<p>网课时期每天干的事情就是好好上课，然后晚上会玩会儿游戏，点名表扬qjy同学。</p>\n<p>这个学期也玩到了两个我特别喜欢的游戏：</p>\n<p>一个是奇异人生（Life Is Strange）：</p>\n<p><a href=\"https://imgchr.com/i/rvEA3T\"><img src=\"https://s3.ax1x.com/2020/12/31/rvEA3T.jpg\" alt=\"rvEA3T.jpg\"></a></p>\n<p>还有一个则是消逝的光芒（Dying Light），画面相对比较血腥这里就不放图了。</p>\n<p>然后就迎来了软件工程的大项目——元气骑士（Vigor Knight），和另外三个小伙伴一起做了个实际上非常垃圾的游戏（我自己反正是玩不下去），也认识了wly,mjy和ljj</p>\n<p><a href=\"https://imgchr.com/i/rvENbd\"><img src=\"https://s3.ax1x.com/2020/12/31/rvENbd.md.jpg\" alt=\"rvENbd.md.jpg\"></a></p>\n<p>同时，网课这学期也发生了件比较让我高兴的事情。</p>\n<p>我和lyf（春雨支教社团老大姐）强行凑成了数学建模小组，报名参加了学校的建模校赛，并且在比赛前三个人都没有看过任何建模相关的知识。就是五一建模强行冲，最后一天熬夜到了凌晨四点，最后迎来了一个让我们大家都不敢相信的事情，收到了答辩邮件。大家都不敢相信我们能拿奖，毕竟所有人最开始的目标是成功参赛奖。贼兴奋</p>\n<p><a href=\"https://imgchr.com/i/rvEYKe\"><img src=\"https://s3.ax1x.com/2020/12/31/rvEYKe.md.jpg\" alt=\"rvEYKe.md.jpg\"></a><br><a href=\"https://imgchr.com/i/rvEGvD\"><img src=\"https://s3.ax1x.com/2020/12/31/rvEGvD.md.jpg\" alt=\"rvEGvD.md.jpg\"></a><br><a href=\"https://imgchr.com/i/rvE8gO\"><img src=\"https://s3.ax1x.com/2020/12/31/rvE8gO.md.jpg\" alt=\"rvE8gO.md.jpg\"></a><br><a href=\"https://imgchr.com/i/rvEtDH\"><img src=\"https://s3.ax1x.com/2020/12/31/rvEtDH.md.jpg\" alt=\"rvEtDH.md.jpg\"></a></p>\n<p>然后这学期还和wly合作做了数据库的大作业，因为我和他害怕经管的同学会卷，所以我们就越做越复杂。结果最后发现：</p>\n<p><strong>内卷人竟是我自己</strong></p>\n<p>不过这个项目做的过程中真的效率超高，垃圾代码产出量也非常多，还是真的有挺多收获的。</p>\n<p><a href=\"https://imgchr.com/i/rvE6Kg\"><img src=\"https://s3.ax1x.com/2020/12/31/rvE6Kg.png\" alt=\"rvE6Kg.png\"></a></p>\n<p>最后再次分享大一下学期，这个非常可惜通过网课度过的一个学期，所做的事情：</p>\n<blockquote>\n<p>1.建模写了好看论文，并且结果不错 </p>\n<p>2.做了精美扫雷游戏，玩起来不会崩</p>\n<p> 3.设计了厉害的数据库，得到了孙丽君的认可</p>\n<p> 4.做了比较菜的元气骑士，勉强能跑了 </p>\n<p>5.网课都基本认真听了，没怎么划水 </p>\n<p>6.期末认真复习了，四场考试都用一半时间就做完了 </p>\n<p>7.学会了C#新语言，可以开搞unity了</p>\n<p>8.认识了牛逼的新同学 </p>\n<p>9.没和老同学失去联系 </p>\n<p>10.飞车上荣耀钻石啦 </p>\n<p>11.跑步坚持一个月了 </p>\n<p>12.c++会用stl啦 </p>\n<p>13.坚持上完了机器学习，期中没退课！ </p>\n<p>14.电路理论做了精美笔记！可以卖钱了！ </p>\n<p>15.还没忘记你们长啥样 </p>\n<p>16.被软件开发基础老师夸了 </p>\n<p>17.终于会用github了… </p>\n<p>18.考试周坚持了一个半月没玩游戏 </p>\n<p>19.芒果tv充了年费会员 </p>\n<p>20.积极帮别人解决问题了</p>\n</blockquote>\n<p>是主要搞学习的一个学期，赞！</p>\n<p>然后就放暑假了，暑假里让我印象深刻的主要就三件事情：</p>\n<p>1.lyh（真·大一就认识的hxd）来金寨了，一起去天堂寨玩了，然后我发誓再也不要去天堂寨</p>\n<p>2.开始学车，每天顶着大太阳去科目二的地方练车，等一两个小时练一把车</p>\n<p>3.和wly打QQ飞车</p>\n<p>再然后就开学了，开学就是先军训。不过因为我暑假面试过了政治部，所以避免了太阳：</p>\n<p><a href=\"https://imgchr.com/i/rvEWan\"><img src=\"https://s3.ax1x.com/2020/12/31/rvEWan.jpg\" alt=\"rvEWan.jpg\"></a>但是说实话，政治部那七天的生活绝对不轻松。甚至可以说，我的绝大多数宣传能力都是在期间学习到的</p>\n<p>我和其他宣传组的小伙伴共同每天艰难的生活着（下图拍于12月份）</p>\n<p><a href=\"https://imgchr.com/i/rvEHr4\"><img src=\"https://s3.ax1x.com/2020/12/31/rvEHr4.jpg\" alt=\"rvEHr4.jpg\"></a></p>\n<p>那段时间，说实话，我个人过得挺自闭的。</p>\n<p>因为感觉有非常多的事情没有做完（剪可视化、外拍、推送等），还感觉自己的成绩可能不是很理想。中间甚至一度想要退课明年再选军训，总而言之：很庆幸熬了过去。</p>\n<p>下图是在其他组还没起来，卑微宣传人已经开始工作的一天</p>\n<p><a href=\"https://imgchr.com/i/rvEzRK\"><img src=\"https://s3.ax1x.com/2020/12/31/rvEzRK.jpg\" alt=\"rvEzRK.jpg\"></a></p>\n<p>军训之后，这一学期就正式开始了。</p>\n<p>来嘉定的第一个学期，体验一般。</p>\n<p>每天的生活就是去上课，去自习，思考中午吃什么，思考晚上吃什么，睡觉。</p>\n<p>比较有意思的事情是评上了果酱和社奖、参加了软院晚会、支书达理活动、玩密室等。</p>\n<p>这里就不再总结了，不要问我为什么，因为我打字打累了。这段经历应该在这学期结束的时候还会复习一下吧。</p>\n<p>直接进入最终总结环节吧。</p>\n<h2 id=\"2020年收获\"><a href=\"#2020年收获\" class=\"headerlink\" title=\"2020年收获\"></a>2020年收获</h2><blockquote>\n<p>1.认识了wly、mjy、sbq、ckx、lxy、zlh、lmx、xhz、hzj、syk、dtw、wjh、wmb、znf、lrj、lrz、chs、yxb、zkf、dgg、jch、whz、xmx、hmz、sr等很多同学</p>\n<p>2.之前朋友还在</p>\n<p>3.会用服务器了，然后懂了一些Linux操作</p>\n<p>4.会做简单网页了</p>\n<p>5.拥有自己的博客了，也就是这个网站</p>\n<p>6.Steam库++</p>\n<p>7.真的学会数据结构了</p>\n<p>8.拿了一次果酱</p>\n<p>9.数学建模拿奖了</p>\n<p>10.还是在愿意帮助别人</p>\n</blockquote>\n"},{"title":"JS——原型链","date":"2022-04-03T10:00:00.000Z","description":"有关Js原型链的一些知识。","cover":"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403162850136.png","_content":"\n\n\n## 前言\n\n在学习JS中的原型，原型链，继承这些知识之前，我们先学习下基础知识：**函数和对象的关系**。\n\n我们一直都知道，函数也是对象的一种，因为通过` instanceof `就可以判断出来。但是函数和对象的关系并不是简单的包含和被包含的关系，这两者之间的关系还是有点复杂的。接下来我们就来捋一捋。\n\n首先，阐述一点，**对象都是通过函数创建的**。\n对于下面这种类型的代码，一般叫做“语法糖”：\n\n```javascript\nvar obj = {a:10,b:20};\nvar arr = [5, 'x', true];\n```\n\n但是，其实上面这段代码的实质是下面这样的：\n\n```javascript\nvar obj = new Object();\nobj.a = 10;\nobj.b = 20;\n\nvar arr = new Array();\narr[0] = 5;\narr[1] = 'x';\narr[2] = true;\n```\n\n而`Object`和`Array`都是函数，可以自己用`typeof`函数进行验证。\n\n所以，可以得出：**对象都是通过函数创建的**。\n\n那么下面就进入正题。\n\n## 原型prototype\n\n在前言中，我们说了函数也是一种对象，所以函数也是属性的集合，同时，也可以对函数进行自定义属性。\n**每个函数都有一个属性——prototype。这个prototype的属性值是一个对象（属性的集合），默认只有一个叫做constructor的属性，指向这个函数本身。** 如下图所示：\n\n![image-20220403154221307](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403154221307.png)\n\n上图中，`SuperType`是一个函数，右侧的方框就是**它的原型**。\n\n原型既然作为对象（属性的集合），除了`constructor`外，还可以自定义许多属性，比如下面这样的：\n\n![image-20220403154324885](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403154324885.png)\n\n当然了，我们也可以在自己定义的方法的`prototype`中增加我们自己的属性，比如像下面这样的：\n\n```javascript\nfunction Fn() { }\nFn.prototype.name = '张三';\nFn.prototype.getAge = function () {\n    return 12;\n};\nvar a = new Fn();\n```\n\n![image-20220403154612542](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403154612542.png)\n\nFn就是下面这样：\n\n![image-20220403154633724](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403154633724.png)\n\n那么问题来了：函数的`prototype`到底有何用呢？\n\n在解决这个问题之前，我们还是先来看下另一个让人迷糊的属性：`__proto__`\n\n## 隐式原型  _ proto_\n\n先看一段非常常见的代码：\n\n```javascript\nfunction Fn() { }\nFn.prototype.name = '张三';\nFn.prototype.getAge = function () {\n    return 12;\n};\nvar fn = new Fn();\nconsole.log(fn.name);\nconsole.log(fn.getAge());\n```\n\n即，Fn是一个函数，fn对象是从Fn函数new出来的，这样fn对象就可以调用Fn.prototype中的属性。\n\n但是，因为每个对象都有一个隐藏的属性——` __proto__`，这个属性引用了**创建这个对象的函数的prototype**。即：` fn._proto_ === Fn.prototype `\n那么，这里的`__proto__`到底是什么呢？\n\n其实，这个`__proto__`是一个隐藏的属性，javascript不希望开发者用到这个属性值，有的低版本浏览器甚至不支持这个属性值。\n\n```javascript\nvar obj = {};\nconsole.log(obj.__proto__);\n```\n\n![image-20220403160024050](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403160024050.png)\n\n\n\n\n```javascript\nconsole.log(Object.prototype);\n```\n\n![image-20220403160148483](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403160148483.png)\n\n\n\n从上面来看，`obj.__proto__`和`Object.prototype`的属性一样！为什么呢？\n\n原因是：obj这个对象本质上是被Object函数创建的，因此obj.**\\_\\_proto__**=== Object.prototype。我们可以用一个图来表示。\n\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403160408070.png' width=\"50%\">\n\n即，**每个对象都有一个\\_\\_proto__属性，指向创建该对象的函数的prototype。**\n\n> **说一下自定义函数的prototype：**\n> 自定义函数的`prototype`本质上就是和 `var obj = {}` 是一样的，都是被`Object`创建，所以它的`__proto__`指向的就是`Object.prototype`。\n\n但是，**`Object.prototype`确实一个特例——它的`__proto__`指向的是`null`**。\n\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403161118789.png' width=\"50%\">\n\n另外一个问题：函数也是一种对象，函数也有`__proto__`吗？\n答：当然也不例外啦！\n下面用一段代码和一张图来说明这个问题，看完相信就有个比较直观的理解啦！\n\n```javascript\nfunction fn(x, y) {\n    return x+y;\n}\nconsole.log(fn(10,20));\n\n// 以下只是为了演示函数被Function创建的\nvar fn1 = new Function(\"x\",\"y\",\"return x+y;\");\nconsole.log(fn1(5,6));\n```\n\n用图表示就是：\n\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403161731562.png' width=\"60%\">\n\n从上图可以看出：自定义函数`Foo.__proto__`指向`Function.prototype`，`Object.__proto__`指向`Function.prototype`。\n\n但是，为什么有`Function.__proto__`指向`Function.prototype`呢？\n\n其实原因很简单：**`Function`也是一个函数，函数是一种对象，也有`__proto__`属性。既然是函数，那么它一定是被`Function`创建。所以`Function`是被自身创建的。所以它的`__proto__`指向了自身的`Prototype`**\n\n最后一个问题：`Function.prototype`指向的对象，它的`__proto__`是不是也指向`Object.prototype`？\n\n答案是肯定的。因为`Function.prototype`指向的对象也是一个普通的被`Object`创建的对象，所以也遵循基本的规则。如下图：\n\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403162506341.png' width=\"50%\">\n\n说了这么多，我们将上面这些图片整合到一整个图片，便于整体理解，图片如下：\n\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403162639383.png' width=\"50%\">\n\n## instanceof\n\n主要是说明下`instanceof`的判断规则是如何进行的。先看如下代码和图片：\n\n```javascript\nfunction Foo() {\n}\nvar f1 = new Foo();\n\nconsole.log(f1 instanceof Foo);//true\nconsole.log(f1 instanceof Object);// true\n```\n\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403162850136.png' width=\"50%\">\n\n`instanceof`的判断规则为：\n假设`instanceof`运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为B。\n\n`instanceof`的判断规则是：沿着A的`__proto__`这条线来找，同时沿着B的`prototype`这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回`true`。如果找到终点还未重合，则返回`false`。\n\n结合这个判断规则，上面的代码和图示相信很容易看懂了。\n\n## 原型继承\n\n首先说一下什么是原型链：\n**访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着\\_proto_这条链向上找，这就是原型链**。\n\n举一个例子说明下吧：\n在实际应用中如何区分一个属性到底是基本的还是从原型中找到的呢？\n答案就是：`hasOwnProperty`这个函数，特别是在for…in…循环中，一定要注意。\n\n![image-20220403174502374](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403174502374.png)\n\n但是，`f1`本身并没有`hasOwnProperty`这个方法，那是从哪里来的呢？答案很简单，是从`Object.prototype`中来的。看下图：\n\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403174630283.png' width='70%'>\n\n对象的原型链是沿着`__proto__`这条线走的，因此在查找`f1.hasOwnProperty`属性时，就会顺着原型链一直查找到`Object.prototype`。\n\n由于所有对象的原型链都会找到`Object.prototype`，因此所有对象都会有`Object.prototype`的方法。这就是所谓的“继承”。\n\n## 示例\n\n> 下面这段代码的输出：\n>\n> ```javascript\n> function Setcount(count){\n> \tthis.count=count\n> }\n> \n> Setcount.prototype.printCount=function(){\n> \tconsole.log(this.count)\n> }\n> \n> let a = new Setcount(100)\n> a.count =200\n> a.__proto__.count=300\n> a.__proto__.printCount()\n> a.printCount()\n> ```\n>\n> 结果为300和200。\n\n\n\n> 下面这段代码的输出：\n>\n> ```javascript\n> Object.prototype.foo = 'Object';\n> Function.prototype.foo = 'Function';\n> function Animal () {};\n> var cat = new Animal();\n> console.log(cat.foo);\n> console.log(Animal.foo);\n> ```\n>\n> 输出为Object 和 Function\n","source":"_posts/JS-原型链.md","raw":"---\ntitle: JS——原型链\ndate: 2022-4-03 18:00:00\ndescription: 有关Js原型链的一些知识。\ncover: https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403162850136.png\n---\n\n\n\n## 前言\n\n在学习JS中的原型，原型链，继承这些知识之前，我们先学习下基础知识：**函数和对象的关系**。\n\n我们一直都知道，函数也是对象的一种，因为通过` instanceof `就可以判断出来。但是函数和对象的关系并不是简单的包含和被包含的关系，这两者之间的关系还是有点复杂的。接下来我们就来捋一捋。\n\n首先，阐述一点，**对象都是通过函数创建的**。\n对于下面这种类型的代码，一般叫做“语法糖”：\n\n```javascript\nvar obj = {a:10,b:20};\nvar arr = [5, 'x', true];\n```\n\n但是，其实上面这段代码的实质是下面这样的：\n\n```javascript\nvar obj = new Object();\nobj.a = 10;\nobj.b = 20;\n\nvar arr = new Array();\narr[0] = 5;\narr[1] = 'x';\narr[2] = true;\n```\n\n而`Object`和`Array`都是函数，可以自己用`typeof`函数进行验证。\n\n所以，可以得出：**对象都是通过函数创建的**。\n\n那么下面就进入正题。\n\n## 原型prototype\n\n在前言中，我们说了函数也是一种对象，所以函数也是属性的集合，同时，也可以对函数进行自定义属性。\n**每个函数都有一个属性——prototype。这个prototype的属性值是一个对象（属性的集合），默认只有一个叫做constructor的属性，指向这个函数本身。** 如下图所示：\n\n![image-20220403154221307](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403154221307.png)\n\n上图中，`SuperType`是一个函数，右侧的方框就是**它的原型**。\n\n原型既然作为对象（属性的集合），除了`constructor`外，还可以自定义许多属性，比如下面这样的：\n\n![image-20220403154324885](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403154324885.png)\n\n当然了，我们也可以在自己定义的方法的`prototype`中增加我们自己的属性，比如像下面这样的：\n\n```javascript\nfunction Fn() { }\nFn.prototype.name = '张三';\nFn.prototype.getAge = function () {\n    return 12;\n};\nvar a = new Fn();\n```\n\n![image-20220403154612542](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403154612542.png)\n\nFn就是下面这样：\n\n![image-20220403154633724](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403154633724.png)\n\n那么问题来了：函数的`prototype`到底有何用呢？\n\n在解决这个问题之前，我们还是先来看下另一个让人迷糊的属性：`__proto__`\n\n## 隐式原型  _ proto_\n\n先看一段非常常见的代码：\n\n```javascript\nfunction Fn() { }\nFn.prototype.name = '张三';\nFn.prototype.getAge = function () {\n    return 12;\n};\nvar fn = new Fn();\nconsole.log(fn.name);\nconsole.log(fn.getAge());\n```\n\n即，Fn是一个函数，fn对象是从Fn函数new出来的，这样fn对象就可以调用Fn.prototype中的属性。\n\n但是，因为每个对象都有一个隐藏的属性——` __proto__`，这个属性引用了**创建这个对象的函数的prototype**。即：` fn._proto_ === Fn.prototype `\n那么，这里的`__proto__`到底是什么呢？\n\n其实，这个`__proto__`是一个隐藏的属性，javascript不希望开发者用到这个属性值，有的低版本浏览器甚至不支持这个属性值。\n\n```javascript\nvar obj = {};\nconsole.log(obj.__proto__);\n```\n\n![image-20220403160024050](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403160024050.png)\n\n\n\n\n```javascript\nconsole.log(Object.prototype);\n```\n\n![image-20220403160148483](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403160148483.png)\n\n\n\n从上面来看，`obj.__proto__`和`Object.prototype`的属性一样！为什么呢？\n\n原因是：obj这个对象本质上是被Object函数创建的，因此obj.**\\_\\_proto__**=== Object.prototype。我们可以用一个图来表示。\n\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403160408070.png' width=\"50%\">\n\n即，**每个对象都有一个\\_\\_proto__属性，指向创建该对象的函数的prototype。**\n\n> **说一下自定义函数的prototype：**\n> 自定义函数的`prototype`本质上就是和 `var obj = {}` 是一样的，都是被`Object`创建，所以它的`__proto__`指向的就是`Object.prototype`。\n\n但是，**`Object.prototype`确实一个特例——它的`__proto__`指向的是`null`**。\n\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403161118789.png' width=\"50%\">\n\n另外一个问题：函数也是一种对象，函数也有`__proto__`吗？\n答：当然也不例外啦！\n下面用一段代码和一张图来说明这个问题，看完相信就有个比较直观的理解啦！\n\n```javascript\nfunction fn(x, y) {\n    return x+y;\n}\nconsole.log(fn(10,20));\n\n// 以下只是为了演示函数被Function创建的\nvar fn1 = new Function(\"x\",\"y\",\"return x+y;\");\nconsole.log(fn1(5,6));\n```\n\n用图表示就是：\n\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403161731562.png' width=\"60%\">\n\n从上图可以看出：自定义函数`Foo.__proto__`指向`Function.prototype`，`Object.__proto__`指向`Function.prototype`。\n\n但是，为什么有`Function.__proto__`指向`Function.prototype`呢？\n\n其实原因很简单：**`Function`也是一个函数，函数是一种对象，也有`__proto__`属性。既然是函数，那么它一定是被`Function`创建。所以`Function`是被自身创建的。所以它的`__proto__`指向了自身的`Prototype`**\n\n最后一个问题：`Function.prototype`指向的对象，它的`__proto__`是不是也指向`Object.prototype`？\n\n答案是肯定的。因为`Function.prototype`指向的对象也是一个普通的被`Object`创建的对象，所以也遵循基本的规则。如下图：\n\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403162506341.png' width=\"50%\">\n\n说了这么多，我们将上面这些图片整合到一整个图片，便于整体理解，图片如下：\n\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403162639383.png' width=\"50%\">\n\n## instanceof\n\n主要是说明下`instanceof`的判断规则是如何进行的。先看如下代码和图片：\n\n```javascript\nfunction Foo() {\n}\nvar f1 = new Foo();\n\nconsole.log(f1 instanceof Foo);//true\nconsole.log(f1 instanceof Object);// true\n```\n\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403162850136.png' width=\"50%\">\n\n`instanceof`的判断规则为：\n假设`instanceof`运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为B。\n\n`instanceof`的判断规则是：沿着A的`__proto__`这条线来找，同时沿着B的`prototype`这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回`true`。如果找到终点还未重合，则返回`false`。\n\n结合这个判断规则，上面的代码和图示相信很容易看懂了。\n\n## 原型继承\n\n首先说一下什么是原型链：\n**访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着\\_proto_这条链向上找，这就是原型链**。\n\n举一个例子说明下吧：\n在实际应用中如何区分一个属性到底是基本的还是从原型中找到的呢？\n答案就是：`hasOwnProperty`这个函数，特别是在for…in…循环中，一定要注意。\n\n![image-20220403174502374](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403174502374.png)\n\n但是，`f1`本身并没有`hasOwnProperty`这个方法，那是从哪里来的呢？答案很简单，是从`Object.prototype`中来的。看下图：\n\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403174630283.png' width='70%'>\n\n对象的原型链是沿着`__proto__`这条线走的，因此在查找`f1.hasOwnProperty`属性时，就会顺着原型链一直查找到`Object.prototype`。\n\n由于所有对象的原型链都会找到`Object.prototype`，因此所有对象都会有`Object.prototype`的方法。这就是所谓的“继承”。\n\n## 示例\n\n> 下面这段代码的输出：\n>\n> ```javascript\n> function Setcount(count){\n> \tthis.count=count\n> }\n> \n> Setcount.prototype.printCount=function(){\n> \tconsole.log(this.count)\n> }\n> \n> let a = new Setcount(100)\n> a.count =200\n> a.__proto__.count=300\n> a.__proto__.printCount()\n> a.printCount()\n> ```\n>\n> 结果为300和200。\n\n\n\n> 下面这段代码的输出：\n>\n> ```javascript\n> Object.prototype.foo = 'Object';\n> Function.prototype.foo = 'Function';\n> function Animal () {};\n> var cat = new Animal();\n> console.log(cat.foo);\n> console.log(Animal.foo);\n> ```\n>\n> 输出为Object 和 Function\n","slug":"JS-原型链","published":1,"updated":"2022-04-03T12:48:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clrfw2jfb0001stfa3pvc9i5z","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在学习JS中的原型，原型链，继承这些知识之前，我们先学习下基础知识：<strong>函数和对象的关系</strong>。</p>\n<p>我们一直都知道，函数也是对象的一种，因为通过<code>instanceof</code>就可以判断出来。但是函数和对象的关系并不是简单的包含和被包含的关系，这两者之间的关系还是有点复杂的。接下来我们就来捋一捋。</p>\n<p>首先，阐述一点，<strong>对象都是通过函数创建的</strong>。<br>对于下面这种类型的代码，一般叫做“语法糖”：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;<span class=\"attr\">a</span>:<span class=\"number\">10</span>,<span class=\"attr\">b</span>:<span class=\"number\">20</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">5</span>, <span class=\"string\">&#x27;x&#x27;</span>, <span class=\"literal\">true</span>];</span><br></pre></td></tr></table></figure>\n<p>但是，其实上面这段代码的实质是下面这样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">obj.a = <span class=\"number\">10</span>;</span><br><span class=\"line\">obj.b = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\">arr[<span class=\"number\">0</span>] = <span class=\"number\">5</span>;</span><br><span class=\"line\">arr[<span class=\"number\">1</span>] = <span class=\"string\">&#x27;x&#x27;</span>;</span><br><span class=\"line\">arr[<span class=\"number\">2</span>] = <span class=\"literal\">true</span>;</span><br></pre></td></tr></table></figure>\n<p>而<code>Object</code>和<code>Array</code>都是函数，可以自己用<code>typeof</code>函数进行验证。</p>\n<p>所以，可以得出：<strong>对象都是通过函数创建的</strong>。</p>\n<p>那么下面就进入正题。</p>\n<h2 id=\"原型prototype\"><a href=\"#原型prototype\" class=\"headerlink\" title=\"原型prototype\"></a>原型prototype</h2><p>在前言中，我们说了函数也是一种对象，所以函数也是属性的集合，同时，也可以对函数进行自定义属性。<br><strong>每个函数都有一个属性——prototype。这个prototype的属性值是一个对象（属性的集合），默认只有一个叫做constructor的属性，指向这个函数本身。</strong> 如下图所示：</p>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403154221307.png\" alt=\"image-20220403154221307\"></p>\n<p>上图中，<code>SuperType</code>是一个函数，右侧的方框就是<strong>它的原型</strong>。</p>\n<p>原型既然作为对象（属性的集合），除了<code>constructor</code>外，还可以自定义许多属性，比如下面这样的：</p>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403154324885.png\" alt=\"image-20220403154324885\"></p>\n<p>当然了，我们也可以在自己定义的方法的<code>prototype</code>中增加我们自己的属性，比如像下面这样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Fn</span>(<span class=\"params\"></span>) </span>&#123; &#125;</span><br><span class=\"line\">Fn.prototype.name = <span class=\"string\">&#x27;张三&#x27;</span>;</span><br><span class=\"line\">Fn.prototype.getAge = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">12</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> Fn();</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403154612542.png\" alt=\"image-20220403154612542\"></p>\n<p>Fn就是下面这样：</p>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403154633724.png\" alt=\"image-20220403154633724\"></p>\n<p>那么问题来了：函数的<code>prototype</code>到底有何用呢？</p>\n<p>在解决这个问题之前，我们还是先来看下另一个让人迷糊的属性：<code>__proto__</code></p>\n<h2 id=\"隐式原型-proto\"><a href=\"#隐式原型-proto\" class=\"headerlink\" title=\"隐式原型  _ proto_\"></a>隐式原型  _ proto_</h2><p>先看一段非常常见的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Fn</span>(<span class=\"params\"></span>) </span>&#123; &#125;</span><br><span class=\"line\">Fn.prototype.name = <span class=\"string\">&#x27;张三&#x27;</span>;</span><br><span class=\"line\">Fn.prototype.getAge = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">12</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"keyword\">new</span> Fn();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(fn.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(fn.getAge());</span><br></pre></td></tr></table></figure>\n<p>即，Fn是一个函数，fn对象是从Fn函数new出来的，这样fn对象就可以调用Fn.prototype中的属性。</p>\n<p>但是，因为每个对象都有一个隐藏的属性——<code> __proto__</code>，这个属性引用了<strong>创建这个对象的函数的prototype</strong>。即：<code>fn._proto_ === Fn.prototype</code><br>那么，这里的<code>__proto__</code>到底是什么呢？</p>\n<p>其实，这个<code>__proto__</code>是一个隐藏的属性，javascript不希望开发者用到这个属性值，有的低版本浏览器甚至不支持这个属性值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.__proto__);</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403160024050.png\" alt=\"image-20220403160024050\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.prototype);</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403160148483.png\" alt=\"image-20220403160148483\"></p>\n<p>从上面来看，<code>obj.__proto__</code>和<code>Object.prototype</code>的属性一样！为什么呢？</p>\n<p>原因是：obj这个对象本质上是被Object函数创建的，因此obj.<strong>__proto__</strong>=== Object.prototype。我们可以用一个图来表示。</p>\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403160408070.png' width=\"50%\">\n\n<p>即，<strong>每个对象都有一个__proto__属性，指向创建该对象的函数的prototype。</strong></p>\n<blockquote>\n<p><strong>说一下自定义函数的prototype：</strong><br>自定义函数的<code>prototype</code>本质上就是和 <code>var obj = &#123;&#125;</code> 是一样的，都是被<code>Object</code>创建，所以它的<code>__proto__</code>指向的就是<code>Object.prototype</code>。</p>\n</blockquote>\n<p>但是，**<code>Object.prototype</code>确实一个特例——它的<code>__proto__</code>指向的是<code>null</code>**。</p>\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403161118789.png' width=\"50%\">\n\n<p>另外一个问题：函数也是一种对象，函数也有<code>__proto__</code>吗？<br>答：当然也不例外啦！<br>下面用一段代码和一张图来说明这个问题，看完相信就有个比较直观的理解啦！</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x+y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(fn(<span class=\"number\">10</span>,<span class=\"number\">20</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以下只是为了演示函数被Function创建的</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>(<span class=\"string\">&quot;x&quot;</span>,<span class=\"string\">&quot;y&quot;</span>,<span class=\"string\">&quot;return x+y;&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(fn1(<span class=\"number\">5</span>,<span class=\"number\">6</span>));</span><br></pre></td></tr></table></figure>\n<p>用图表示就是：</p>\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403161731562.png' width=\"60%\">\n\n<p>从上图可以看出：自定义函数<code>Foo.__proto__</code>指向<code>Function.prototype</code>，<code>Object.__proto__</code>指向<code>Function.prototype</code>。</p>\n<p>但是，为什么有<code>Function.__proto__</code>指向<code>Function.prototype</code>呢？</p>\n<p>其实原因很简单：**<code>Function</code>也是一个函数，函数是一种对象，也有<code>__proto__</code>属性。既然是函数，那么它一定是被<code>Function</code>创建。所以<code>Function</code>是被自身创建的。所以它的<code>__proto__</code>指向了自身的<code>Prototype</code>**</p>\n<p>最后一个问题：<code>Function.prototype</code>指向的对象，它的<code>__proto__</code>是不是也指向<code>Object.prototype</code>？</p>\n<p>答案是肯定的。因为<code>Function.prototype</code>指向的对象也是一个普通的被<code>Object</code>创建的对象，所以也遵循基本的规则。如下图：</p>\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403162506341.png' width=\"50%\">\n\n<p>说了这么多，我们将上面这些图片整合到一整个图片，便于整体理解，图片如下：</p>\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403162639383.png' width=\"50%\">\n\n<h2 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h2><p>主要是说明下<code>instanceof</code>的判断规则是如何进行的。先看如下代码和图片：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> f1 = <span class=\"keyword\">new</span> Foo();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(f1 <span class=\"keyword\">instanceof</span> Foo);<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(f1 <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>);<span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403162850136.png' width=\"50%\">\n\n<p><code>instanceof</code>的判断规则为：<br>假设<code>instanceof</code>运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为B。</p>\n<p><code>instanceof</code>的判断规则是：沿着A的<code>__proto__</code>这条线来找，同时沿着B的<code>prototype</code>这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回<code>true</code>。如果找到终点还未重合，则返回<code>false</code>。</p>\n<p>结合这个判断规则，上面的代码和图示相信很容易看懂了。</p>\n<h2 id=\"原型继承\"><a href=\"#原型继承\" class=\"headerlink\" title=\"原型继承\"></a>原型继承</h2><p>首先说一下什么是原型链：<br><strong>访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着_proto_这条链向上找，这就是原型链</strong>。</p>\n<p>举一个例子说明下吧：<br>在实际应用中如何区分一个属性到底是基本的还是从原型中找到的呢？<br>答案就是：<code>hasOwnProperty</code>这个函数，特别是在for…in…循环中，一定要注意。</p>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403174502374.png\" alt=\"image-20220403174502374\"></p>\n<p>但是，<code>f1</code>本身并没有<code>hasOwnProperty</code>这个方法，那是从哪里来的呢？答案很简单，是从<code>Object.prototype</code>中来的。看下图：</p>\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403174630283.png' width='70%'>\n\n<p>对象的原型链是沿着<code>__proto__</code>这条线走的，因此在查找<code>f1.hasOwnProperty</code>属性时，就会顺着原型链一直查找到<code>Object.prototype</code>。</p>\n<p>由于所有对象的原型链都会找到<code>Object.prototype</code>，因此所有对象都会有<code>Object.prototype</code>的方法。这就是所谓的“继承”。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><blockquote>\n<p>下面这段代码的输出：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Setcount</span>(<span class=\"params\">count</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.count=count</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Setcount.prototype.printCount=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.count)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"keyword\">new</span> Setcount(<span class=\"number\">100</span>)</span><br><span class=\"line\">a.count =<span class=\"number\">200</span></span><br><span class=\"line\">a.__proto__.count=<span class=\"number\">300</span></span><br><span class=\"line\">a.__proto__.printCount()</span><br><span class=\"line\">a.printCount()</span><br></pre></td></tr></table></figure>\n\n<p>结果为300和200。</p>\n</blockquote>\n<blockquote>\n<p>下面这段代码的输出：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.foo = <span class=\"string\">&#x27;Object&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.foo = <span class=\"string\">&#x27;Function&#x27;</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.foo);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Animal.foo);</span><br></pre></td></tr></table></figure>\n\n<p>输出为Object 和 Function</p>\n</blockquote>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在学习JS中的原型，原型链，继承这些知识之前，我们先学习下基础知识：<strong>函数和对象的关系</strong>。</p>\n<p>我们一直都知道，函数也是对象的一种，因为通过<code>instanceof</code>就可以判断出来。但是函数和对象的关系并不是简单的包含和被包含的关系，这两者之间的关系还是有点复杂的。接下来我们就来捋一捋。</p>\n<p>首先，阐述一点，<strong>对象都是通过函数创建的</strong>。<br>对于下面这种类型的代码，一般叫做“语法糖”：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;<span class=\"attr\">a</span>:<span class=\"number\">10</span>,<span class=\"attr\">b</span>:<span class=\"number\">20</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">5</span>, <span class=\"string\">&#x27;x&#x27;</span>, <span class=\"literal\">true</span>];</span><br></pre></td></tr></table></figure>\n<p>但是，其实上面这段代码的实质是下面这样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">obj.a = <span class=\"number\">10</span>;</span><br><span class=\"line\">obj.b = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\">arr[<span class=\"number\">0</span>] = <span class=\"number\">5</span>;</span><br><span class=\"line\">arr[<span class=\"number\">1</span>] = <span class=\"string\">&#x27;x&#x27;</span>;</span><br><span class=\"line\">arr[<span class=\"number\">2</span>] = <span class=\"literal\">true</span>;</span><br></pre></td></tr></table></figure>\n<p>而<code>Object</code>和<code>Array</code>都是函数，可以自己用<code>typeof</code>函数进行验证。</p>\n<p>所以，可以得出：<strong>对象都是通过函数创建的</strong>。</p>\n<p>那么下面就进入正题。</p>\n<h2 id=\"原型prototype\"><a href=\"#原型prototype\" class=\"headerlink\" title=\"原型prototype\"></a>原型prototype</h2><p>在前言中，我们说了函数也是一种对象，所以函数也是属性的集合，同时，也可以对函数进行自定义属性。<br><strong>每个函数都有一个属性——prototype。这个prototype的属性值是一个对象（属性的集合），默认只有一个叫做constructor的属性，指向这个函数本身。</strong> 如下图所示：</p>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403154221307.png\" alt=\"image-20220403154221307\"></p>\n<p>上图中，<code>SuperType</code>是一个函数，右侧的方框就是<strong>它的原型</strong>。</p>\n<p>原型既然作为对象（属性的集合），除了<code>constructor</code>外，还可以自定义许多属性，比如下面这样的：</p>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403154324885.png\" alt=\"image-20220403154324885\"></p>\n<p>当然了，我们也可以在自己定义的方法的<code>prototype</code>中增加我们自己的属性，比如像下面这样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Fn</span>(<span class=\"params\"></span>) </span>&#123; &#125;</span><br><span class=\"line\">Fn.prototype.name = <span class=\"string\">&#x27;张三&#x27;</span>;</span><br><span class=\"line\">Fn.prototype.getAge = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">12</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> Fn();</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403154612542.png\" alt=\"image-20220403154612542\"></p>\n<p>Fn就是下面这样：</p>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403154633724.png\" alt=\"image-20220403154633724\"></p>\n<p>那么问题来了：函数的<code>prototype</code>到底有何用呢？</p>\n<p>在解决这个问题之前，我们还是先来看下另一个让人迷糊的属性：<code>__proto__</code></p>\n<h2 id=\"隐式原型-proto\"><a href=\"#隐式原型-proto\" class=\"headerlink\" title=\"隐式原型  _ proto_\"></a>隐式原型  _ proto_</h2><p>先看一段非常常见的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Fn</span>(<span class=\"params\"></span>) </span>&#123; &#125;</span><br><span class=\"line\">Fn.prototype.name = <span class=\"string\">&#x27;张三&#x27;</span>;</span><br><span class=\"line\">Fn.prototype.getAge = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">12</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"keyword\">new</span> Fn();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(fn.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(fn.getAge());</span><br></pre></td></tr></table></figure>\n<p>即，Fn是一个函数，fn对象是从Fn函数new出来的，这样fn对象就可以调用Fn.prototype中的属性。</p>\n<p>但是，因为每个对象都有一个隐藏的属性——<code> __proto__</code>，这个属性引用了<strong>创建这个对象的函数的prototype</strong>。即：<code>fn._proto_ === Fn.prototype</code><br>那么，这里的<code>__proto__</code>到底是什么呢？</p>\n<p>其实，这个<code>__proto__</code>是一个隐藏的属性，javascript不希望开发者用到这个属性值，有的低版本浏览器甚至不支持这个属性值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.__proto__);</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403160024050.png\" alt=\"image-20220403160024050\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.prototype);</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403160148483.png\" alt=\"image-20220403160148483\"></p>\n<p>从上面来看，<code>obj.__proto__</code>和<code>Object.prototype</code>的属性一样！为什么呢？</p>\n<p>原因是：obj这个对象本质上是被Object函数创建的，因此obj.<strong>__proto__</strong>=== Object.prototype。我们可以用一个图来表示。</p>\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403160408070.png' width=\"50%\">\n\n<p>即，<strong>每个对象都有一个__proto__属性，指向创建该对象的函数的prototype。</strong></p>\n<blockquote>\n<p><strong>说一下自定义函数的prototype：</strong><br>自定义函数的<code>prototype</code>本质上就是和 <code>var obj = &#123;&#125;</code> 是一样的，都是被<code>Object</code>创建，所以它的<code>__proto__</code>指向的就是<code>Object.prototype</code>。</p>\n</blockquote>\n<p>但是，**<code>Object.prototype</code>确实一个特例——它的<code>__proto__</code>指向的是<code>null</code>**。</p>\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403161118789.png' width=\"50%\">\n\n<p>另外一个问题：函数也是一种对象，函数也有<code>__proto__</code>吗？<br>答：当然也不例外啦！<br>下面用一段代码和一张图来说明这个问题，看完相信就有个比较直观的理解啦！</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x+y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(fn(<span class=\"number\">10</span>,<span class=\"number\">20</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以下只是为了演示函数被Function创建的</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>(<span class=\"string\">&quot;x&quot;</span>,<span class=\"string\">&quot;y&quot;</span>,<span class=\"string\">&quot;return x+y;&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(fn1(<span class=\"number\">5</span>,<span class=\"number\">6</span>));</span><br></pre></td></tr></table></figure>\n<p>用图表示就是：</p>\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403161731562.png' width=\"60%\">\n\n<p>从上图可以看出：自定义函数<code>Foo.__proto__</code>指向<code>Function.prototype</code>，<code>Object.__proto__</code>指向<code>Function.prototype</code>。</p>\n<p>但是，为什么有<code>Function.__proto__</code>指向<code>Function.prototype</code>呢？</p>\n<p>其实原因很简单：**<code>Function</code>也是一个函数，函数是一种对象，也有<code>__proto__</code>属性。既然是函数，那么它一定是被<code>Function</code>创建。所以<code>Function</code>是被自身创建的。所以它的<code>__proto__</code>指向了自身的<code>Prototype</code>**</p>\n<p>最后一个问题：<code>Function.prototype</code>指向的对象，它的<code>__proto__</code>是不是也指向<code>Object.prototype</code>？</p>\n<p>答案是肯定的。因为<code>Function.prototype</code>指向的对象也是一个普通的被<code>Object</code>创建的对象，所以也遵循基本的规则。如下图：</p>\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403162506341.png' width=\"50%\">\n\n<p>说了这么多，我们将上面这些图片整合到一整个图片，便于整体理解，图片如下：</p>\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403162639383.png' width=\"50%\">\n\n<h2 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h2><p>主要是说明下<code>instanceof</code>的判断规则是如何进行的。先看如下代码和图片：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> f1 = <span class=\"keyword\">new</span> Foo();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(f1 <span class=\"keyword\">instanceof</span> Foo);<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(f1 <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>);<span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403162850136.png' width=\"50%\">\n\n<p><code>instanceof</code>的判断规则为：<br>假设<code>instanceof</code>运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为B。</p>\n<p><code>instanceof</code>的判断规则是：沿着A的<code>__proto__</code>这条线来找，同时沿着B的<code>prototype</code>这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回<code>true</code>。如果找到终点还未重合，则返回<code>false</code>。</p>\n<p>结合这个判断规则，上面的代码和图示相信很容易看懂了。</p>\n<h2 id=\"原型继承\"><a href=\"#原型继承\" class=\"headerlink\" title=\"原型继承\"></a>原型继承</h2><p>首先说一下什么是原型链：<br><strong>访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着_proto_这条链向上找，这就是原型链</strong>。</p>\n<p>举一个例子说明下吧：<br>在实际应用中如何区分一个属性到底是基本的还是从原型中找到的呢？<br>答案就是：<code>hasOwnProperty</code>这个函数，特别是在for…in…循环中，一定要注意。</p>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403174502374.png\" alt=\"image-20220403174502374\"></p>\n<p>但是，<code>f1</code>本身并没有<code>hasOwnProperty</code>这个方法，那是从哪里来的呢？答案很简单，是从<code>Object.prototype</code>中来的。看下图：</p>\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403174630283.png' width='70%'>\n\n<p>对象的原型链是沿着<code>__proto__</code>这条线走的，因此在查找<code>f1.hasOwnProperty</code>属性时，就会顺着原型链一直查找到<code>Object.prototype</code>。</p>\n<p>由于所有对象的原型链都会找到<code>Object.prototype</code>，因此所有对象都会有<code>Object.prototype</code>的方法。这就是所谓的“继承”。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><blockquote>\n<p>下面这段代码的输出：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Setcount</span>(<span class=\"params\">count</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.count=count</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Setcount.prototype.printCount=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.count)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"keyword\">new</span> Setcount(<span class=\"number\">100</span>)</span><br><span class=\"line\">a.count =<span class=\"number\">200</span></span><br><span class=\"line\">a.__proto__.count=<span class=\"number\">300</span></span><br><span class=\"line\">a.__proto__.printCount()</span><br><span class=\"line\">a.printCount()</span><br></pre></td></tr></table></figure>\n\n<p>结果为300和200。</p>\n</blockquote>\n<blockquote>\n<p>下面这段代码的输出：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.foo = <span class=\"string\">&#x27;Object&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.foo = <span class=\"string\">&#x27;Function&#x27;</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.foo);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Animal.foo);</span><br></pre></td></tr></table></figure>\n\n<p>输出为Object 和 Function</p>\n</blockquote>\n"},{"title":"ElementUI2 开发","date":"2023-04-25T04:06:16.000Z","_content":"需要python2环境\n\nhttps://www.wyr.me/post/658\n\n```she\nbrew install pyenv\npyenv install 2.7.18\nexport PATH=\"$(pyenv root)/shims:${PATH}\"\npyenv global 2.7.18\npython --version\n```\n\n\n\n需要注意node-sass版本的对应关系\n\n如，默认的node-sass是4.11.0，而这个版本对node有要求：\n\n| OS           | Architecture | Node                                                   |\n| ------------ | ------------ | ------------------------------------------------------ |\n| Windows      | x86 & x64    | 0.10, 0.12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11          |\n| OSX          | x64          | 0.10, 0.12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11          |\n| Linux*       | x86 & x64    | 0.10, 0.12, 1, 2, 3, 4, 5, 6, 7, 8**, 9**, 10**^, 11** |\n| Alpine Linux | x64          | 6, 8, 10, 11                                           |\n\n所以使用nvm install 11，先下载11版本的node\n","source":"_posts/ElementUI2-开发.md","raw":"---\ntitle: ElementUI2 开发\ndate: 2023-04-25 12:06:16\ntags:\n---\n需要python2环境\n\nhttps://www.wyr.me/post/658\n\n```she\nbrew install pyenv\npyenv install 2.7.18\nexport PATH=\"$(pyenv root)/shims:${PATH}\"\npyenv global 2.7.18\npython --version\n```\n\n\n\n需要注意node-sass版本的对应关系\n\n如，默认的node-sass是4.11.0，而这个版本对node有要求：\n\n| OS           | Architecture | Node                                                   |\n| ------------ | ------------ | ------------------------------------------------------ |\n| Windows      | x86 & x64    | 0.10, 0.12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11          |\n| OSX          | x64          | 0.10, 0.12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11          |\n| Linux*       | x86 & x64    | 0.10, 0.12, 1, 2, 3, 4, 5, 6, 7, 8**, 9**, 10**^, 11** |\n| Alpine Linux | x64          | 6, 8, 10, 11                                           |\n\n所以使用nvm install 11，先下载11版本的node\n","slug":"ElementUI2-开发","published":1,"updated":"2023-04-25T04:07:58.004Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clrfw2jfe0002stfa7qwg96im","content":"<p>需要python2环境</p>\n<p><a href=\"https://www.wyr.me/post/658\">https://www.wyr.me/post/658</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install pyenv</span><br><span class=\"line\">pyenv install 2.7.18</span><br><span class=\"line\">export PATH&#x3D;&quot;$(pyenv root)&#x2F;shims:$&#123;PATH&#125;&quot;</span><br><span class=\"line\">pyenv global 2.7.18</span><br><span class=\"line\">python --version</span><br></pre></td></tr></table></figure>\n\n\n<p>需要注意node-sass版本的对应关系</p>\n<p>如，默认的node-sass是4.11.0，而这个版本对node有要求：</p>\n<table>\n<thead>\n<tr>\n<th>OS</th>\n<th>Architecture</th>\n<th>Node</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Windows</td>\n<td>x86 &amp; x64</td>\n<td>0.10, 0.12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11</td>\n</tr>\n<tr>\n<td>OSX</td>\n<td>x64</td>\n<td>0.10, 0.12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11</td>\n</tr>\n<tr>\n<td>Linux*</td>\n<td>x86 &amp; x64</td>\n<td>0.10, 0.12, 1, 2, 3, 4, 5, 6, 7, 8**, 9**, 10<strong>^, 11</strong></td>\n</tr>\n<tr>\n<td>Alpine Linux</td>\n<td>x64</td>\n<td>6, 8, 10, 11</td>\n</tr>\n</tbody></table>\n<p>所以使用nvm install 11，先下载11版本的node</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p>需要python2环境</p>\n<p><a href=\"https://www.wyr.me/post/658\">https://www.wyr.me/post/658</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install pyenv</span><br><span class=\"line\">pyenv install 2.7.18</span><br><span class=\"line\">export PATH&#x3D;&quot;$(pyenv root)&#x2F;shims:$&#123;PATH&#125;&quot;</span><br><span class=\"line\">pyenv global 2.7.18</span><br><span class=\"line\">python --version</span><br></pre></td></tr></table></figure>\n\n\n<p>需要注意node-sass版本的对应关系</p>\n<p>如，默认的node-sass是4.11.0，而这个版本对node有要求：</p>\n<table>\n<thead>\n<tr>\n<th>OS</th>\n<th>Architecture</th>\n<th>Node</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Windows</td>\n<td>x86 &amp; x64</td>\n<td>0.10, 0.12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11</td>\n</tr>\n<tr>\n<td>OSX</td>\n<td>x64</td>\n<td>0.10, 0.12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11</td>\n</tr>\n<tr>\n<td>Linux*</td>\n<td>x86 &amp; x64</td>\n<td>0.10, 0.12, 1, 2, 3, 4, 5, 6, 7, 8**, 9**, 10<strong>^, 11</strong></td>\n</tr>\n<tr>\n<td>Alpine Linux</td>\n<td>x64</td>\n<td>6, 8, 10, 11</td>\n</tr>\n</tbody></table>\n<p>所以使用nvm install 11，先下载11版本的node</p>\n"},{"title":"React native开发","date":"2023-04-25T13:19:03.000Z","_content":"\n配置android环境\n\n```shell\nexport ANDROID_HOME=$HOME/Library/Android/sdk\nexport PATH=$PATH:$ANDROID_HOME/emulator\nexport PATH=$PATH:$ANDROID_HOME/tools\nexport PATH=$PATH:$ANDROID_HOME/tools/bin\nexport PATH=$PATH:$ANDROID_HOME/platform-tools\n```\n\n![1682428818056](image/React-native开发/1682428818056.png)\n","source":"_posts/React-native开发.md","raw":"---\ntitle: React native开发\ndate: 2023-04-25 21:19:03\ntags:\n---\n\n配置android环境\n\n```shell\nexport ANDROID_HOME=$HOME/Library/Android/sdk\nexport PATH=$PATH:$ANDROID_HOME/emulator\nexport PATH=$PATH:$ANDROID_HOME/tools\nexport PATH=$PATH:$ANDROID_HOME/tools/bin\nexport PATH=$PATH:$ANDROID_HOME/platform-tools\n```\n\n![1682428818056](image/React-native开发/1682428818056.png)\n","slug":"React-native开发","published":1,"updated":"2023-04-25T14:43:48.167Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clrfw2jff0003stfa879phbta","content":"<p>配置android环境</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export ANDROID_HOME=$HOME/Library/Android/sdk</span><br><span class=\"line\">export PATH=$PATH:$ANDROID_HOME/emulator</span><br><span class=\"line\">export PATH=$PATH:$ANDROID_HOME/tools</span><br><span class=\"line\">export PATH=$PATH:$ANDROID_HOME/tools/bin</span><br><span class=\"line\">export PATH=$PATH:$ANDROID_HOME/platform-tools</span><br></pre></td></tr></table></figure>\n<p><img src=\"image/React-native%E5%BC%80%E5%8F%91/1682428818056.png\" alt=\"1682428818056\"></p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p>配置android环境</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export ANDROID_HOME=$HOME/Library/Android/sdk</span><br><span class=\"line\">export PATH=$PATH:$ANDROID_HOME/emulator</span><br><span class=\"line\">export PATH=$PATH:$ANDROID_HOME/tools</span><br><span class=\"line\">export PATH=$PATH:$ANDROID_HOME/tools/bin</span><br><span class=\"line\">export PATH=$PATH:$ANDROID_HOME/platform-tools</span><br></pre></td></tr></table></figure>\n<p><img src=\"image/React-native%E5%BC%80%E5%8F%91/1682428818056.png\" alt=\"1682428818056\"></p>\n"},{"title":"Ubuntu系统中的常用操作","date":"2023-04-24T12:37:11.000Z","_content":"\n## jenkins的配置\n\n安装jenkins：\n\nhttps://blog.csdn.net/wf908164152/article/details/125716221\n\n```shell\nsudo apt-get install maven\n```\n\n设置权限：\n\n```shell\nvim /etc/default/jenkins\n```\n\n![image-20230409210155014](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230409210155014.png)\n\n```shell\n# 把jenkins目录文件交给ubuntu用户\nchown -R ubuntu:ubuntu /var/lib/jenkins\n```\n\n安装gitee、maven、nodejs插件\n\n```shell\ncurl -sL https://deb.nodesource.com/setup_14.x | sudo bash -\nsudo apt -y install nodejs\n```\n\n![image-20230409201414802](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230409201414802.png)\n\n设置jenkins令牌（https://blog.csdn.net/weixin_44931933/article/details/127704724）\n\n新建项目：web hooks配置\n\n配置maven\n\n![image-20230409202701088](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230409202701088.png)\n\n## screen的使用\n\n参考文章：https://blog.csdn.net/qq_34131701/article/details/124353270\n\n\n## 防火墙的使用\n\nhttps://blog.csdn.net/yt_php/article/details/104233920/\n","source":"_posts/Ubuntu系统中的常用操作.md","raw":"---\ntitle: Ubuntu系统中的常用操作\ndate: 2023-04-24 20:37:11\ntags:\n---\n\n## jenkins的配置\n\n安装jenkins：\n\nhttps://blog.csdn.net/wf908164152/article/details/125716221\n\n```shell\nsudo apt-get install maven\n```\n\n设置权限：\n\n```shell\nvim /etc/default/jenkins\n```\n\n![image-20230409210155014](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230409210155014.png)\n\n```shell\n# 把jenkins目录文件交给ubuntu用户\nchown -R ubuntu:ubuntu /var/lib/jenkins\n```\n\n安装gitee、maven、nodejs插件\n\n```shell\ncurl -sL https://deb.nodesource.com/setup_14.x | sudo bash -\nsudo apt -y install nodejs\n```\n\n![image-20230409201414802](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230409201414802.png)\n\n设置jenkins令牌（https://blog.csdn.net/weixin_44931933/article/details/127704724）\n\n新建项目：web hooks配置\n\n配置maven\n\n![image-20230409202701088](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230409202701088.png)\n\n## screen的使用\n\n参考文章：https://blog.csdn.net/qq_34131701/article/details/124353270\n\n\n## 防火墙的使用\n\nhttps://blog.csdn.net/yt_php/article/details/104233920/\n","slug":"Ubuntu系统中的常用操作","published":1,"updated":"2023-04-24T12:57:28.175Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clrfw2jff0004stfa77lsdjzw","content":"<h2 id=\"jenkins的配置\"><a href=\"#jenkins的配置\" class=\"headerlink\" title=\"jenkins的配置\"></a>jenkins的配置</h2><p>安装jenkins：</p>\n<p><a href=\"https://blog.csdn.net/wf908164152/article/details/125716221\">https://blog.csdn.net/wf908164152/article/details/125716221</a></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install maven</span><br></pre></td></tr></table></figure>\n<p>设置权限：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /etc/default/jenkins</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230409210155014.png\" alt=\"image-20230409210155014\"></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 把jenkins目录文件交给ubuntu用户</span></span><br><span class=\"line\">chown -R ubuntu:ubuntu /var/lib/jenkins</span><br></pre></td></tr></table></figure>\n<p>安装gitee、maven、nodejs插件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -sL https://deb.nodesource.com/setup_14.x | sudo bash -</span><br><span class=\"line\">sudo apt -y install nodejs</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230409201414802.png\" alt=\"image-20230409201414802\"></p>\n<p>设置jenkins令牌（<a href=\"https://blog.csdn.net/weixin_44931933/article/details/127704724%EF%BC%89\">https://blog.csdn.net/weixin_44931933/article/details/127704724）</a></p>\n<p>新建项目：web hooks配置</p>\n<p>配置maven</p>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230409202701088.png\" alt=\"image-20230409202701088\"></p>\n<h2 id=\"screen的使用\"><a href=\"#screen的使用\" class=\"headerlink\" title=\"screen的使用\"></a>screen的使用</h2><p>参考文章：<a href=\"https://blog.csdn.net/qq_34131701/article/details/124353270\">https://blog.csdn.net/qq_34131701/article/details/124353270</a></p>\n<h2 id=\"防火墙的使用\"><a href=\"#防火墙的使用\" class=\"headerlink\" title=\"防火墙的使用\"></a>防火墙的使用</h2><p><a href=\"https://blog.csdn.net/yt_php/article/details/104233920/\">https://blog.csdn.net/yt_php/article/details/104233920/</a></p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h2 id=\"jenkins的配置\"><a href=\"#jenkins的配置\" class=\"headerlink\" title=\"jenkins的配置\"></a>jenkins的配置</h2><p>安装jenkins：</p>\n<p><a href=\"https://blog.csdn.net/wf908164152/article/details/125716221\">https://blog.csdn.net/wf908164152/article/details/125716221</a></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install maven</span><br></pre></td></tr></table></figure>\n<p>设置权限：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /etc/default/jenkins</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230409210155014.png\" alt=\"image-20230409210155014\"></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 把jenkins目录文件交给ubuntu用户</span></span><br><span class=\"line\">chown -R ubuntu:ubuntu /var/lib/jenkins</span><br></pre></td></tr></table></figure>\n<p>安装gitee、maven、nodejs插件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -sL https://deb.nodesource.com/setup_14.x | sudo bash -</span><br><span class=\"line\">sudo apt -y install nodejs</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230409201414802.png\" alt=\"image-20230409201414802\"></p>\n<p>设置jenkins令牌（<a href=\"https://blog.csdn.net/weixin_44931933/article/details/127704724%EF%BC%89\">https://blog.csdn.net/weixin_44931933/article/details/127704724）</a></p>\n<p>新建项目：web hooks配置</p>\n<p>配置maven</p>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230409202701088.png\" alt=\"image-20230409202701088\"></p>\n<h2 id=\"screen的使用\"><a href=\"#screen的使用\" class=\"headerlink\" title=\"screen的使用\"></a>screen的使用</h2><p>参考文章：<a href=\"https://blog.csdn.net/qq_34131701/article/details/124353270\">https://blog.csdn.net/qq_34131701/article/details/124353270</a></p>\n<h2 id=\"防火墙的使用\"><a href=\"#防火墙的使用\" class=\"headerlink\" title=\"防火墙的使用\"></a>防火墙的使用</h2><p><a href=\"https://blog.csdn.net/yt_php/article/details/104233920/\">https://blog.csdn.net/yt_php/article/details/104233920/</a></p>\n"},{"title":"leetcode-数组题","date":"2021-01-25T16:00:00.000Z","description":"leetcode上有关数组的题目","cover":"https://s3.ax1x.com/2020/12/31/rvEA3T.jpg","_content":"\n\n\n### 4 寻找两个正序数组的中位数\n\n1.遍历数组，使用类似于归并排序的两个指针一一比较大小\n\n时间复杂度：O(N)\n\n空间复杂度：O(1)\n\n执行用时：48 ms, 在所有 C++ 提交中击败了83.73%的用户\n\n内存消耗：86.9 MB, 在所有 C++ 提交中击败了95.52%的用户\n\n```c++\ndouble findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n\t//O(N)\n\tint i = -1, j = -1;\n\tint size1 = nums1.size(), size2 = nums2.size();\n\tif ((size1 + size2) % 2 == 0)\n\t{\n\t\t//even\n\t\tint a;\n\t\tfor (int k = 0; k < (size1 + size2) / 2 - 1; ++k)\n\t\t{\n\t\t\tif (i == size1 - 1)\n\t\t\t\t++j;\n\t\t\telse if (j == size2 - 1)\n\t\t\t\t++i;\n\t\t\telse if (nums1[i + 1] > nums2[j + 1])\n\t\t\t{\n\t\t\t\t++j;\n\t\t\t}\n\t\t\telse\n\t\t\t\t++i;\n\t\t}\n\t\t//choose two num;\n\t\tif (i == size1 - 1)\n\t\t\ta = nums2[++j];\n\t\telse if (j == size2 - 1)\n\t\t\ta = nums1[++i];\n\t\telse if (nums1[i + 1] > nums2[j + 1])\n\t\t{\n\t\t\ta = nums2[++j];\n\t\t}\n\t\telse\n\t\t\ta = nums1[++i];\n\t\tif (i == size1 - 1)\n\t\t\ta += nums2[++j];\n\t\telse if (j == size2 - 1)\n\t\t\ta += nums1[++i];\n\t\telse if (nums1[i + 1] > nums2[j + 1])\n\t\t{\n\t\t\ta += nums2[++j];\n\t\t}\n\t\telse\n\t\t\ta += nums1[++i];\n\t\treturn a / 2.0;\n\t}\n\telse\n\t{\n\t\tfor (int k = 0; k < (size1 + size2) / 2 ; ++k)\n\t\t{\n\t\t\tif (i == size1 - 1)\n\t\t\t\t++j;\n\t\t\telse if (j == size2 - 1)\n\t\t\t\t++i;\n\t\t\telse if (nums1[i + 1] > nums2[j + 1])\n\t\t\t{\n\t\t\t\t++j;\n\t\t\t}\n\t\t\telse\n\t\t\t\t++i;\n\t\t}\n\t\tif (i == size1 - 1)\n\t\t\treturn nums2[++j];\n\t\telse if (j == size2 - 1)\n\t\t\treturn nums1[++i];\n\t\telse if (nums1[i + 1] > nums2[j + 1])\n\t\t{\n\t\t\treturn nums2[++j];\n\t\t}\n\t\telse\n\t\t\treturn nums1[++i];\n\t}\n}\n```\n\n\n\n### 5 最长回文子串\n\n1.递推，利用状态转移方程dp[i] [j]表示字符串的i到j是否为回文串\n\n初始条件：\n\n- dp[i] [i]=true\n- dp[i] [i+1]= s[i]==s[i+1]\n\n转移条件：\n\n- dp[i] [j]= true if dp[i+1] [j-1] and s[i]==s[j]\n\n时间复杂度:O(N)\n\n空间复杂度:O(N)\n\n执行用时：456 ms, 在所有 C++ 提交中击败了41.14%的用户\n\n内存消耗：7.9 MB, 在所有 C++ 提交中击败了77.31%的用户\n\n```c++\nstring longestPalindrome(string s) {\n\tbool dp[1000][1000];\n\tint strLength = s.length();\n\tint maxS = -1, maxE = -1;\n\tfor (int i = 0; i < strLength; ++i)\n\t\tfor (int j = 0; j < strLength; ++j)\n\t\t\tdp[i][j] = false;\n\t//边界条件\n\tfor (int i = 0; i < strLength; ++i)\n\t{\n\t\tdp[i][i] = true;\n\t\tmaxS = i;\n\t\tmaxE = i;\n\t}\n\tfor (int i = 0; i < strLength - 1; ++i)\n\t\tif (s[i] == s[i + 1])\n\t\t{\n\t\t\tdp[i][i + 1] = true;\n\t\t\tmaxS = i;\n\t\t\tmaxE = i + 1;\n\t\t}\n\t//奇数转移方程\n\tfor (int i = 0; i < strLength; ++i)\n\t{\n\t\tfor (int j = 1; j <= i && j <= strLength - i - 1; ++j)\n\t\t{\n\t\t\tif (dp[i - j + 1][i + j - 1] && s[i - j] == s[i + j])\n\t\t\t{\n\t\t\t\tdp[i - j][i + j] = true;\n\t\t\t}\n\t\t\tif (dp[i - j][i + j] && 2 * j + 1 > maxE - maxS + 1)\n\t\t\t{\n\t\t\t\tmaxS = i - j;\n\t\t\t\tmaxE = i + j;\n\t\t\t}\n\t\t}\n\t}\n\t//偶数转移方程\n\tfor (int i = 0; i < strLength - 1; ++i)\n\t{\n\t\tfor (int j = 1; j <= i && j <= strLength - i - 2; ++j)\n\t\t{\n\t\t\tif (dp[i - j + 1][i + j ] && s[i - j] == s[i + j+1])\n\t\t\t{\n\t\t\t\tdp[i - j][i + j+1] = true;\n\t\t\t}\n\t\t\tif (dp[i - j][i + j+1] && 2 * j + 2 > maxE - maxS + 1)\n\t\t\t{\n\t\t\t\tmaxS = i - j;\n\t\t\t\tmaxE = i + j+1;\n\t\t\t}\n\t\t}\n\t}\n\tif (maxS == -1)\n\t\treturn \"\";\n\telse\n\t\treturn s.substr(maxS, maxE - maxS + 1);\n}\n```\n\n\n\n\n\n### 6.Z字形变换\n\n1.利用一个二维数组存储绘制出的Z字形，完成绘制后遍历二维数组每一个顺序输出\n\n时间复杂度：O(N²)\n\n空间复杂度：O(N²)\n\n执行用时：1288 ms, 在所有 C++ 提交中击败了5.08%的用户\n\n内存消耗：9.1 MB, 在所有 C++ 提交中击败了62.58%的用户\n\n```c++\nstring convert(string s, int numRows) {\n\tchar word[1000][1000] = { 0 };\n\tint row = 0, col = 0;\n\tbool shu = true;\n\tif (numRows == 1)\n\t\treturn s;\n\tfor (int i = 0; i < s.length(); ++i)\n\t{\n\t\tword[row][col] = s[i];\n\t\tif (shu)\n\t\t{\n\t\t\tif (row == numRows - 1)\n\t\t\t{\n\t\t\t\tshu = false;\n\t\t\t\t--row;\n\t\t\t\t++col;\n\t\t\t}\n\t\t\telse\n\t\t\t\t++row;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (row == 0)\n\t\t\t{\n\t\t\t\tshu = true;\n\t\t\t\t++row;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t--row;\n\t\t\t\t++col;\n\t\t\t}\n\t\t}\n\t}\n\t//顺序读取\n\tstring ans;\n\tfor (int i = 0; i < 1000; ++i)\n\t\tfor (int j = 0; j < 1000; ++j)\n\t\t\tif (word[i][j] != 0)\n\t\t\t\tans.push_back(word[i][j]);\n\treturn ans;\n}\n```\n\n2.思路类似于1，不过不再采用1中二维数组的方式存取数据\n\n而是借鉴稀疏矩阵的方法，定义一个Node，将其存储在vector< Node >中。在绘制完毕后，重载比较运算符来进行排序。\n\n时间复杂度：O(NlogN)\n\n空间复杂度：O(N)\n\n执行用时：36 ms, 在所有 C++ 提交中击败了20.65%的用户\n\n内存消耗：12.6 MB, 在所有 C++ 提交中击败了17.63%的用户\n\n```c++\nstruct Node\n{\n\tint row;\n\tint col;\n\tchar data;\n\tNode(int r, int c, char d)\n\t{\n\t\trow = r;\n\t\tcol = c;\n\t\tdata = d;\n\t}\n\tbool operator<(const Node& p2)\n\t{\n\t\tif (this->row < p2.row)\n\t\t\treturn true;\n\t\telse return (this->row == p2.row&&this->col < p2.col);\n\t\t\t\n\t}\n};\n\n\n\nstring convert(string s, int numRows) {\n\tvector<Node> result;//类似于稀疏矩阵\n\tint row = 0, col = 0;\n\tbool shu = true;\n\tif (numRows == 1)\n\t\treturn s;\n\tfor (int i = 0; i < s.length(); ++i)\n\t{\n\t\tresult.push_back(Node(row, col, s[i]));\n\t\tif (shu)\n\t\t{\n\t\t\tif (row == numRows - 1)\n\t\t\t{\n\t\t\t\tshu = false;\n\t\t\t\t--row;\n\t\t\t\t++col;\n\t\t\t}\n\t\t\telse\n\t\t\t\t++row;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (row == 0)\n\t\t\t{\n\t\t\t\tshu = true;\n\t\t\t\t++row;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t--row;\n\t\t\t\t++col;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//对内部进行排序，先比较行，行小的在前，紧接着比较列\n\t//时间复杂度为O(NlogN)\n\tsort(result.begin(), result.end());\n\tstring ans;\n\n\tfor (auto i = result.begin(); i != result.end(); ++i)\n\t{\n\t\tans.push_back(i->data);\n\t}\n\treturn ans;\n}\n```\n\n\n\n3.利用1的方法，不过不再采用二维数组存储，而是使用一个vector存储每一行的字符串。到每一行直接加入尾端即可。这样字符串总长度实际上只有N。\n\n时间复杂度：O（N）\n\n空间复杂度：O（N）\n\n执行用时：8 ms, 在所有 C++ 提交中击败了93.23%的用户\n\n内存消耗：10.5 MB, 在所有 C++ 提交中击败了57.73%的用户\n\n```c++\nstring convert(string s, int numRows) {\n\tvector<string> result(numRows);\n\tint row = 0, col = 0;\n\tbool shu = true;\n\tif (numRows == 1)\n\t\treturn s;\n\tfor (int i = 0; i < s.length(); ++i)\n\t{\n\t\tresult[row].push_back(s[i]);\n\t\tif (shu)\n\t\t{\n\t\t\tif (row == numRows - 1)\n\t\t\t{\n\t\t\t\tshu = false;\n\t\t\t\t--row;\n\t\t\t\t++col;\n\t\t\t}\n\t\t\telse\n\t\t\t\t++row;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (row == 0)\n\t\t\t{\n\t\t\t\tshu = true;\n\t\t\t\t++row;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t--row;\n\t\t\t\t++col;\n\t\t\t}\n\t\t}\n\t}\n\t//顺序读取\n\tstring ans;\n\tfor (int i = 0; i < numRows; ++i)\n\t\tans += result[i];\n\treturn ans;\n}\n```\n\n\n\n### 23 合并K组升序链表\n\n1.采用K路归并的思路\n\n时间复杂度：O（nk)\n\n执行用时：756 ms, 在所有 C++ 提交中击败了7.77%的用户\n\n内存消耗：12.6 MB, 在所有 C++ 提交中击败了98.43%的用户\n\n```c++\nListNode* mergeKLists(vector<ListNode*>& lists) {\n        int n = lists.size();\n        bool allZero = false;\n        //N路归并\n        ListNode* head = new ListNode();\n        ListNode* ptr = head;\n        while (!allZero)\n        {\n            int minNum = 99999;\n            int index = -1;\n            for (int i = 0; i < n; ++i)\n            {\n                if (lists[i] != nullptr&&lists[i]->val < minNum)\n                {\n                    index = i;\n                    minNum = lists[i]->val;\n                }\n            }\n            //找到最小的了\n            if (index == -1)\n                allZero = true;\n            else\n            {\n                ptr->next = lists[index];\n                ptr = ptr->next;\n                lists[index] = lists[index]->next;\n            }\n        }\n        return head->next;\n    }\n```\n\n\n\n2.采用二路归并的思路\n\n时间复杂度：O（NlogK)\n\n执行用时：20 ms, 在所有 C++ 提交中击败了99.49%的用户\n\n内存消耗：22.2 MB, 在所有 C++ 提交中击败了13.34%的用户\n\n```c++\n//归并从下标start开始的n个链表\nListNode* merge2Lists(vector<ListNode*>& lists, int start,int n) {\n\tif (n == 0)\n\t\treturn nullptr;\n\tif (n == 1)\n\t\treturn lists[start];\n\tListNode* p1 = merge2Lists(lists, start, n / 2);\n\tListNode* p2 = merge2Lists(lists, start + n / 2, n - (n / 2));\n\t//对p1和p2进行归并\n\tListNode* head = new ListNode();\n\tListNode* ptr = head;\n\twhile (p1 != nullptr&&p2 != nullptr) {\n\t\tif (p1->val < p2->val) {\n\t\t\tptr->next = p1;\n\t\t\tp1 = p1->next;\n\t\t\tptr = ptr->next;\n\t\t}\n\t\telse {\n\t\t\tptr->next = p2;\n\t\t\tp2 = p2->next;\n\t\t\tptr = ptr->next;\n\t\t}\n\t}\n\twhile (p1 != nullptr) {\n\t\tptr->next = p1;\n\t\tp1 = p1->next;\n\t\tptr = ptr->next;\n\t}\n\twhile (p2 != nullptr) {\n\t\tptr->next = p2;\n\t\tp2 = p2->next;\n\t\tptr = ptr->next;\n\t}\n\treturn head->next;\n}\n\nListNode* mergeKLists(vector<ListNode*>& lists) {\n\treturn merge2Lists(lists, 0, lists.size());\n}\n```\n\n\n\n### 最小水位\n\n类似于最小生成树，使用优先级队列存储\n\n时间复杂度：O（N²logK)\n\n```c++\nstruct GridNode {\n\tint row;\n\tint col;\n\tint index;\n\t//const很重要!\n\tbool operator<(const GridNode& node)const {\n\t\treturn this->index < node.index;\n\t}\n\tbool operator>(const GridNode& node)const {\n\t\treturn this->index > node.index;\n\t}\n\n\tGridNode(int r, int c, int i) :row(r), col(c), index(i) {};\n\tGridNode() {};\n};\n\nint swimInWater(vector<vector<int>>& grid) {\n\tpriority_queue<GridNode,vector<GridNode>,greater<GridNode>> q;\n\tint n = grid.size();\n\n\t//初始化\n\tint minshuiwei = grid[0][0];\n\tgrid[0][0] = -1;\n\tq.push(GridNode(0, 1, grid[0][1]));\n\tq.push(GridNode(1, 0, grid[1][0]));\n\twhile (grid[n - 1][n - 1] != -1) {\n\t\t//找出当前最小的水位\n\t\tGridNode temp = q.top();\n\t\tq.pop();\n\t\tgrid[temp.row][temp.col] = -1;\n\t\tif (temp.index > minshuiwei) {\n\t\t\tminshuiwei = temp.index;\n\t\t}\n\t\t//加入其上下左右\n\t\tif (temp.row != 0 && grid[temp.row - 1][temp.col] != -1) {\n\t\t\tq.push(GridNode(temp.row - 1, temp.col, grid[temp.row - 1][temp.col]));\n\t\t}\n\t\tif (temp.col != 0 && grid[temp.row][temp.col - 1] != -1) {\n\t\t\tq.push(GridNode(temp.row, temp.col - 1, grid[temp.row][temp.col - 1]));\n\t\t}\n\t\tif (temp.row != n - 1 && grid[temp.row + 1][temp.col] != -1) {\n\t\t\tq.push(GridNode(temp.row + 1, temp.col, grid[temp.row + 1][temp.col]));\n\t\t}\n\t\tif (temp.col != n - 1 && grid[temp.row][temp.col + 1] != -1) {\n\t\t\tq.push(GridNode(temp.row, temp.col + 1, grid[temp.row][temp.col + 1]));\n\t\t}\n\n\t}\n\treturn minshuiwei;\n}\n```\n\n","source":"_posts/leetcode刷题.md","raw":"---\ntitle: leetcode-数组题\ndate: 2021-1-26 00:00:00\ndescription: leetcode上有关数组的题目\ncover: https://s3.ax1x.com/2020/12/31/rvEA3T.jpg\n---\n\n\n\n### 4 寻找两个正序数组的中位数\n\n1.遍历数组，使用类似于归并排序的两个指针一一比较大小\n\n时间复杂度：O(N)\n\n空间复杂度：O(1)\n\n执行用时：48 ms, 在所有 C++ 提交中击败了83.73%的用户\n\n内存消耗：86.9 MB, 在所有 C++ 提交中击败了95.52%的用户\n\n```c++\ndouble findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n\t//O(N)\n\tint i = -1, j = -1;\n\tint size1 = nums1.size(), size2 = nums2.size();\n\tif ((size1 + size2) % 2 == 0)\n\t{\n\t\t//even\n\t\tint a;\n\t\tfor (int k = 0; k < (size1 + size2) / 2 - 1; ++k)\n\t\t{\n\t\t\tif (i == size1 - 1)\n\t\t\t\t++j;\n\t\t\telse if (j == size2 - 1)\n\t\t\t\t++i;\n\t\t\telse if (nums1[i + 1] > nums2[j + 1])\n\t\t\t{\n\t\t\t\t++j;\n\t\t\t}\n\t\t\telse\n\t\t\t\t++i;\n\t\t}\n\t\t//choose two num;\n\t\tif (i == size1 - 1)\n\t\t\ta = nums2[++j];\n\t\telse if (j == size2 - 1)\n\t\t\ta = nums1[++i];\n\t\telse if (nums1[i + 1] > nums2[j + 1])\n\t\t{\n\t\t\ta = nums2[++j];\n\t\t}\n\t\telse\n\t\t\ta = nums1[++i];\n\t\tif (i == size1 - 1)\n\t\t\ta += nums2[++j];\n\t\telse if (j == size2 - 1)\n\t\t\ta += nums1[++i];\n\t\telse if (nums1[i + 1] > nums2[j + 1])\n\t\t{\n\t\t\ta += nums2[++j];\n\t\t}\n\t\telse\n\t\t\ta += nums1[++i];\n\t\treturn a / 2.0;\n\t}\n\telse\n\t{\n\t\tfor (int k = 0; k < (size1 + size2) / 2 ; ++k)\n\t\t{\n\t\t\tif (i == size1 - 1)\n\t\t\t\t++j;\n\t\t\telse if (j == size2 - 1)\n\t\t\t\t++i;\n\t\t\telse if (nums1[i + 1] > nums2[j + 1])\n\t\t\t{\n\t\t\t\t++j;\n\t\t\t}\n\t\t\telse\n\t\t\t\t++i;\n\t\t}\n\t\tif (i == size1 - 1)\n\t\t\treturn nums2[++j];\n\t\telse if (j == size2 - 1)\n\t\t\treturn nums1[++i];\n\t\telse if (nums1[i + 1] > nums2[j + 1])\n\t\t{\n\t\t\treturn nums2[++j];\n\t\t}\n\t\telse\n\t\t\treturn nums1[++i];\n\t}\n}\n```\n\n\n\n### 5 最长回文子串\n\n1.递推，利用状态转移方程dp[i] [j]表示字符串的i到j是否为回文串\n\n初始条件：\n\n- dp[i] [i]=true\n- dp[i] [i+1]= s[i]==s[i+1]\n\n转移条件：\n\n- dp[i] [j]= true if dp[i+1] [j-1] and s[i]==s[j]\n\n时间复杂度:O(N)\n\n空间复杂度:O(N)\n\n执行用时：456 ms, 在所有 C++ 提交中击败了41.14%的用户\n\n内存消耗：7.9 MB, 在所有 C++ 提交中击败了77.31%的用户\n\n```c++\nstring longestPalindrome(string s) {\n\tbool dp[1000][1000];\n\tint strLength = s.length();\n\tint maxS = -1, maxE = -1;\n\tfor (int i = 0; i < strLength; ++i)\n\t\tfor (int j = 0; j < strLength; ++j)\n\t\t\tdp[i][j] = false;\n\t//边界条件\n\tfor (int i = 0; i < strLength; ++i)\n\t{\n\t\tdp[i][i] = true;\n\t\tmaxS = i;\n\t\tmaxE = i;\n\t}\n\tfor (int i = 0; i < strLength - 1; ++i)\n\t\tif (s[i] == s[i + 1])\n\t\t{\n\t\t\tdp[i][i + 1] = true;\n\t\t\tmaxS = i;\n\t\t\tmaxE = i + 1;\n\t\t}\n\t//奇数转移方程\n\tfor (int i = 0; i < strLength; ++i)\n\t{\n\t\tfor (int j = 1; j <= i && j <= strLength - i - 1; ++j)\n\t\t{\n\t\t\tif (dp[i - j + 1][i + j - 1] && s[i - j] == s[i + j])\n\t\t\t{\n\t\t\t\tdp[i - j][i + j] = true;\n\t\t\t}\n\t\t\tif (dp[i - j][i + j] && 2 * j + 1 > maxE - maxS + 1)\n\t\t\t{\n\t\t\t\tmaxS = i - j;\n\t\t\t\tmaxE = i + j;\n\t\t\t}\n\t\t}\n\t}\n\t//偶数转移方程\n\tfor (int i = 0; i < strLength - 1; ++i)\n\t{\n\t\tfor (int j = 1; j <= i && j <= strLength - i - 2; ++j)\n\t\t{\n\t\t\tif (dp[i - j + 1][i + j ] && s[i - j] == s[i + j+1])\n\t\t\t{\n\t\t\t\tdp[i - j][i + j+1] = true;\n\t\t\t}\n\t\t\tif (dp[i - j][i + j+1] && 2 * j + 2 > maxE - maxS + 1)\n\t\t\t{\n\t\t\t\tmaxS = i - j;\n\t\t\t\tmaxE = i + j+1;\n\t\t\t}\n\t\t}\n\t}\n\tif (maxS == -1)\n\t\treturn \"\";\n\telse\n\t\treturn s.substr(maxS, maxE - maxS + 1);\n}\n```\n\n\n\n\n\n### 6.Z字形变换\n\n1.利用一个二维数组存储绘制出的Z字形，完成绘制后遍历二维数组每一个顺序输出\n\n时间复杂度：O(N²)\n\n空间复杂度：O(N²)\n\n执行用时：1288 ms, 在所有 C++ 提交中击败了5.08%的用户\n\n内存消耗：9.1 MB, 在所有 C++ 提交中击败了62.58%的用户\n\n```c++\nstring convert(string s, int numRows) {\n\tchar word[1000][1000] = { 0 };\n\tint row = 0, col = 0;\n\tbool shu = true;\n\tif (numRows == 1)\n\t\treturn s;\n\tfor (int i = 0; i < s.length(); ++i)\n\t{\n\t\tword[row][col] = s[i];\n\t\tif (shu)\n\t\t{\n\t\t\tif (row == numRows - 1)\n\t\t\t{\n\t\t\t\tshu = false;\n\t\t\t\t--row;\n\t\t\t\t++col;\n\t\t\t}\n\t\t\telse\n\t\t\t\t++row;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (row == 0)\n\t\t\t{\n\t\t\t\tshu = true;\n\t\t\t\t++row;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t--row;\n\t\t\t\t++col;\n\t\t\t}\n\t\t}\n\t}\n\t//顺序读取\n\tstring ans;\n\tfor (int i = 0; i < 1000; ++i)\n\t\tfor (int j = 0; j < 1000; ++j)\n\t\t\tif (word[i][j] != 0)\n\t\t\t\tans.push_back(word[i][j]);\n\treturn ans;\n}\n```\n\n2.思路类似于1，不过不再采用1中二维数组的方式存取数据\n\n而是借鉴稀疏矩阵的方法，定义一个Node，将其存储在vector< Node >中。在绘制完毕后，重载比较运算符来进行排序。\n\n时间复杂度：O(NlogN)\n\n空间复杂度：O(N)\n\n执行用时：36 ms, 在所有 C++ 提交中击败了20.65%的用户\n\n内存消耗：12.6 MB, 在所有 C++ 提交中击败了17.63%的用户\n\n```c++\nstruct Node\n{\n\tint row;\n\tint col;\n\tchar data;\n\tNode(int r, int c, char d)\n\t{\n\t\trow = r;\n\t\tcol = c;\n\t\tdata = d;\n\t}\n\tbool operator<(const Node& p2)\n\t{\n\t\tif (this->row < p2.row)\n\t\t\treturn true;\n\t\telse return (this->row == p2.row&&this->col < p2.col);\n\t\t\t\n\t}\n};\n\n\n\nstring convert(string s, int numRows) {\n\tvector<Node> result;//类似于稀疏矩阵\n\tint row = 0, col = 0;\n\tbool shu = true;\n\tif (numRows == 1)\n\t\treturn s;\n\tfor (int i = 0; i < s.length(); ++i)\n\t{\n\t\tresult.push_back(Node(row, col, s[i]));\n\t\tif (shu)\n\t\t{\n\t\t\tif (row == numRows - 1)\n\t\t\t{\n\t\t\t\tshu = false;\n\t\t\t\t--row;\n\t\t\t\t++col;\n\t\t\t}\n\t\t\telse\n\t\t\t\t++row;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (row == 0)\n\t\t\t{\n\t\t\t\tshu = true;\n\t\t\t\t++row;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t--row;\n\t\t\t\t++col;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//对内部进行排序，先比较行，行小的在前，紧接着比较列\n\t//时间复杂度为O(NlogN)\n\tsort(result.begin(), result.end());\n\tstring ans;\n\n\tfor (auto i = result.begin(); i != result.end(); ++i)\n\t{\n\t\tans.push_back(i->data);\n\t}\n\treturn ans;\n}\n```\n\n\n\n3.利用1的方法，不过不再采用二维数组存储，而是使用一个vector存储每一行的字符串。到每一行直接加入尾端即可。这样字符串总长度实际上只有N。\n\n时间复杂度：O（N）\n\n空间复杂度：O（N）\n\n执行用时：8 ms, 在所有 C++ 提交中击败了93.23%的用户\n\n内存消耗：10.5 MB, 在所有 C++ 提交中击败了57.73%的用户\n\n```c++\nstring convert(string s, int numRows) {\n\tvector<string> result(numRows);\n\tint row = 0, col = 0;\n\tbool shu = true;\n\tif (numRows == 1)\n\t\treturn s;\n\tfor (int i = 0; i < s.length(); ++i)\n\t{\n\t\tresult[row].push_back(s[i]);\n\t\tif (shu)\n\t\t{\n\t\t\tif (row == numRows - 1)\n\t\t\t{\n\t\t\t\tshu = false;\n\t\t\t\t--row;\n\t\t\t\t++col;\n\t\t\t}\n\t\t\telse\n\t\t\t\t++row;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (row == 0)\n\t\t\t{\n\t\t\t\tshu = true;\n\t\t\t\t++row;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t--row;\n\t\t\t\t++col;\n\t\t\t}\n\t\t}\n\t}\n\t//顺序读取\n\tstring ans;\n\tfor (int i = 0; i < numRows; ++i)\n\t\tans += result[i];\n\treturn ans;\n}\n```\n\n\n\n### 23 合并K组升序链表\n\n1.采用K路归并的思路\n\n时间复杂度：O（nk)\n\n执行用时：756 ms, 在所有 C++ 提交中击败了7.77%的用户\n\n内存消耗：12.6 MB, 在所有 C++ 提交中击败了98.43%的用户\n\n```c++\nListNode* mergeKLists(vector<ListNode*>& lists) {\n        int n = lists.size();\n        bool allZero = false;\n        //N路归并\n        ListNode* head = new ListNode();\n        ListNode* ptr = head;\n        while (!allZero)\n        {\n            int minNum = 99999;\n            int index = -1;\n            for (int i = 0; i < n; ++i)\n            {\n                if (lists[i] != nullptr&&lists[i]->val < minNum)\n                {\n                    index = i;\n                    minNum = lists[i]->val;\n                }\n            }\n            //找到最小的了\n            if (index == -1)\n                allZero = true;\n            else\n            {\n                ptr->next = lists[index];\n                ptr = ptr->next;\n                lists[index] = lists[index]->next;\n            }\n        }\n        return head->next;\n    }\n```\n\n\n\n2.采用二路归并的思路\n\n时间复杂度：O（NlogK)\n\n执行用时：20 ms, 在所有 C++ 提交中击败了99.49%的用户\n\n内存消耗：22.2 MB, 在所有 C++ 提交中击败了13.34%的用户\n\n```c++\n//归并从下标start开始的n个链表\nListNode* merge2Lists(vector<ListNode*>& lists, int start,int n) {\n\tif (n == 0)\n\t\treturn nullptr;\n\tif (n == 1)\n\t\treturn lists[start];\n\tListNode* p1 = merge2Lists(lists, start, n / 2);\n\tListNode* p2 = merge2Lists(lists, start + n / 2, n - (n / 2));\n\t//对p1和p2进行归并\n\tListNode* head = new ListNode();\n\tListNode* ptr = head;\n\twhile (p1 != nullptr&&p2 != nullptr) {\n\t\tif (p1->val < p2->val) {\n\t\t\tptr->next = p1;\n\t\t\tp1 = p1->next;\n\t\t\tptr = ptr->next;\n\t\t}\n\t\telse {\n\t\t\tptr->next = p2;\n\t\t\tp2 = p2->next;\n\t\t\tptr = ptr->next;\n\t\t}\n\t}\n\twhile (p1 != nullptr) {\n\t\tptr->next = p1;\n\t\tp1 = p1->next;\n\t\tptr = ptr->next;\n\t}\n\twhile (p2 != nullptr) {\n\t\tptr->next = p2;\n\t\tp2 = p2->next;\n\t\tptr = ptr->next;\n\t}\n\treturn head->next;\n}\n\nListNode* mergeKLists(vector<ListNode*>& lists) {\n\treturn merge2Lists(lists, 0, lists.size());\n}\n```\n\n\n\n### 最小水位\n\n类似于最小生成树，使用优先级队列存储\n\n时间复杂度：O（N²logK)\n\n```c++\nstruct GridNode {\n\tint row;\n\tint col;\n\tint index;\n\t//const很重要!\n\tbool operator<(const GridNode& node)const {\n\t\treturn this->index < node.index;\n\t}\n\tbool operator>(const GridNode& node)const {\n\t\treturn this->index > node.index;\n\t}\n\n\tGridNode(int r, int c, int i) :row(r), col(c), index(i) {};\n\tGridNode() {};\n};\n\nint swimInWater(vector<vector<int>>& grid) {\n\tpriority_queue<GridNode,vector<GridNode>,greater<GridNode>> q;\n\tint n = grid.size();\n\n\t//初始化\n\tint minshuiwei = grid[0][0];\n\tgrid[0][0] = -1;\n\tq.push(GridNode(0, 1, grid[0][1]));\n\tq.push(GridNode(1, 0, grid[1][0]));\n\twhile (grid[n - 1][n - 1] != -1) {\n\t\t//找出当前最小的水位\n\t\tGridNode temp = q.top();\n\t\tq.pop();\n\t\tgrid[temp.row][temp.col] = -1;\n\t\tif (temp.index > minshuiwei) {\n\t\t\tminshuiwei = temp.index;\n\t\t}\n\t\t//加入其上下左右\n\t\tif (temp.row != 0 && grid[temp.row - 1][temp.col] != -1) {\n\t\t\tq.push(GridNode(temp.row - 1, temp.col, grid[temp.row - 1][temp.col]));\n\t\t}\n\t\tif (temp.col != 0 && grid[temp.row][temp.col - 1] != -1) {\n\t\t\tq.push(GridNode(temp.row, temp.col - 1, grid[temp.row][temp.col - 1]));\n\t\t}\n\t\tif (temp.row != n - 1 && grid[temp.row + 1][temp.col] != -1) {\n\t\t\tq.push(GridNode(temp.row + 1, temp.col, grid[temp.row + 1][temp.col]));\n\t\t}\n\t\tif (temp.col != n - 1 && grid[temp.row][temp.col + 1] != -1) {\n\t\t\tq.push(GridNode(temp.row, temp.col + 1, grid[temp.row][temp.col + 1]));\n\t\t}\n\n\t}\n\treturn minshuiwei;\n}\n```\n\n","slug":"leetcode刷题","published":1,"updated":"2022-03-19T06:14:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clrfw2jfg0005stfa515ud6d3","content":"<h3 id=\"4-寻找两个正序数组的中位数\"><a href=\"#4-寻找两个正序数组的中位数\" class=\"headerlink\" title=\"4 寻找两个正序数组的中位数\"></a>4 寻找两个正序数组的中位数</h3><p>1.遍历数组，使用类似于归并排序的两个指针一一比较大小</p>\n<p>时间复杂度：O(N)</p>\n<p>空间复杂度：O(1)</p>\n<p>执行用时：48 ms, 在所有 C++ 提交中击败了83.73%的用户</p>\n<p>内存消耗：86.9 MB, 在所有 C++ 提交中击败了95.52%的用户</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">findMedianSortedArrays</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums1, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//O(N)</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = <span class=\"number\">-1</span>, j = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> size1 = nums1.size(), size2 = nums2.size();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((size1 + size2) % <span class=\"number\">2</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//even</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> a;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; (size1 + size2) / <span class=\"number\">2</span> - <span class=\"number\">1</span>; ++k)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i == size1 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t\t++j;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j == size2 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t\t++i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums1[i + <span class=\"number\">1</span>] &gt; nums2[j + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t++j;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t++i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//choose two num;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i == size1 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\ta = nums2[++j];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j == size2 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\ta = nums1[++i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums1[i + <span class=\"number\">1</span>] &gt; nums2[j + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ta = nums2[++j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\ta = nums1[++i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i == size1 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\ta += nums2[++j];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j == size2 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\ta += nums1[++i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums1[i + <span class=\"number\">1</span>] &gt; nums2[j + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ta += nums2[++j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\ta += nums1[++i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a / <span class=\"number\">2.0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; (size1 + size2) / <span class=\"number\">2</span> ; ++k)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i == size1 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t\t++j;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j == size2 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t\t++i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums1[i + <span class=\"number\">1</span>] &gt; nums2[j + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t++j;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t++i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i == size1 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> nums2[++j];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j == size2 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> nums1[++i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums1[i + <span class=\"number\">1</span>] &gt; nums2[j + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> nums2[++j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> nums1[++i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"5-最长回文子串\"><a href=\"#5-最长回文子串\" class=\"headerlink\" title=\"5 最长回文子串\"></a>5 最长回文子串</h3><p>1.递推，利用状态转移方程dp[i] [j]表示字符串的i到j是否为回文串</p>\n<p>初始条件：</p>\n<ul>\n<li>dp[i] [i]=true</li>\n<li>dp[i] [i+1]= s[i]==s[i+1]</li>\n</ul>\n<p>转移条件：</p>\n<ul>\n<li>dp[i] [j]= true if dp[i+1] [j-1] and s[i]==s[j]</li>\n</ul>\n<p>时间复杂度:O(N)</p>\n<p>空间复杂度:O(N)</p>\n<p>执行用时：456 ms, 在所有 C++ 提交中击败了41.14%的用户</p>\n<p>内存消耗：7.9 MB, 在所有 C++ 提交中击败了77.31%的用户</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> dp[<span class=\"number\">1000</span>][<span class=\"number\">1000</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> strLength = s.length();</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> maxS = <span class=\"number\">-1</span>, maxE = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; strLength; ++i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; strLength; ++j)</span><br><span class=\"line\">\t\t\tdp[i][j] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//边界条件</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; strLength; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tdp[i][i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\tmaxS = i;</span><br><span class=\"line\">\t\tmaxE = i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; strLength - <span class=\"number\">1</span>; ++i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (s[i] == s[i + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tdp[i][i + <span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\tmaxS = i;</span><br><span class=\"line\">\t\t\tmaxE = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//奇数转移方程</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; strLength; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= i &amp;&amp; j &lt;= strLength - i - <span class=\"number\">1</span>; ++j)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (dp[i - j + <span class=\"number\">1</span>][i + j - <span class=\"number\">1</span>] &amp;&amp; s[i - j] == s[i + j])</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tdp[i - j][i + j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (dp[i - j][i + j] &amp;&amp; <span class=\"number\">2</span> * j + <span class=\"number\">1</span> &gt; maxE - maxS + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tmaxS = i - j;</span><br><span class=\"line\">\t\t\t\tmaxE = i + j;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//偶数转移方程</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; strLength - <span class=\"number\">1</span>; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= i &amp;&amp; j &lt;= strLength - i - <span class=\"number\">2</span>; ++j)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (dp[i - j + <span class=\"number\">1</span>][i + j ] &amp;&amp; s[i - j] == s[i + j+<span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tdp[i - j][i + j+<span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (dp[i - j][i + j+<span class=\"number\">1</span>] &amp;&amp; <span class=\"number\">2</span> * j + <span class=\"number\">2</span> &gt; maxE - maxS + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tmaxS = i - j;</span><br><span class=\"line\">\t\t\t\tmaxE = i + j+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (maxS == <span class=\"number\">-1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> s.substr(maxS, maxE - maxS + <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h3 id=\"6-Z字形变换\"><a href=\"#6-Z字形变换\" class=\"headerlink\" title=\"6.Z字形变换\"></a>6.Z字形变换</h3><p>1.利用一个二维数组存储绘制出的Z字形，完成绘制后遍历二维数组每一个顺序输出</p>\n<p>时间复杂度：O(N²)</p>\n<p>空间复杂度：O(N²)</p>\n<p>执行用时：1288 ms, 在所有 C++ 提交中击败了5.08%的用户</p>\n<p>内存消耗：9.1 MB, 在所有 C++ 提交中击败了62.58%的用户</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">convert</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> numRows)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> word[<span class=\"number\">1000</span>][<span class=\"number\">1000</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> row = <span class=\"number\">0</span>, col = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> shu = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (numRows == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> s;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tword[row][col] = s[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (shu)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (row == numRows - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tshu = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t\t--row;</span><br><span class=\"line\">\t\t\t\t++col;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t++row;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (row == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tshu = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t\t++row;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t--row;</span><br><span class=\"line\">\t\t\t\t++col;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//顺序读取</span></span><br><span class=\"line\">\t<span class=\"built_in\">string</span> ans;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; ++i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">1000</span>; ++j)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (word[i][j] != <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\tans.push_back(word[i][j]);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2.思路类似于1，不过不再采用1中二维数组的方式存取数据</p>\n<p>而是借鉴稀疏矩阵的方法，定义一个Node，将其存储在vector&lt; Node &gt;中。在绘制完毕后，重载比较运算符来进行排序。</p>\n<p>时间复杂度：O(NlogN)</p>\n<p>空间复杂度：O(N)</p>\n<p>执行用时：36 ms, 在所有 C++ 提交中击败了20.65%的用户</p>\n<p>内存消耗：12.6 MB, 在所有 C++ 提交中击败了17.63%的用户</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> row;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> col;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> data;</span><br><span class=\"line\">\tNode(<span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> c, <span class=\"keyword\">char</span> d)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\trow = r;</span><br><span class=\"line\">\t\tcol = c;</span><br><span class=\"line\">\t\tdata = d;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"keyword\">const</span> Node&amp; p2)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;row &lt; p2.row)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span>-&gt;row == p2.row&amp;&amp;<span class=\"keyword\">this</span>-&gt;col &lt; p2.col);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">convert</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> numRows)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;Node&gt; result;<span class=\"comment\">//类似于稀疏矩阵</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> row = <span class=\"number\">0</span>, col = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> shu = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (numRows == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> s;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tresult.push_back(Node(row, col, s[i]));</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (shu)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (row == numRows - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tshu = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t\t--row;</span><br><span class=\"line\">\t\t\t\t++col;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t++row;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (row == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tshu = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t\t++row;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t--row;</span><br><span class=\"line\">\t\t\t\t++col;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//对内部进行排序，先比较行，行小的在前，紧接着比较列</span></span><br><span class=\"line\">\t<span class=\"comment\">//时间复杂度为O(NlogN)</span></span><br><span class=\"line\">\tsort(result.begin(), result.end());</span><br><span class=\"line\">\t<span class=\"built_in\">string</span> ans;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i = result.begin(); i != result.end(); ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tans.push_back(i-&gt;data);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>3.利用1的方法，不过不再采用二维数组存储，而是使用一个vector存储每一行的字符串。到每一行直接加入尾端即可。这样字符串总长度实际上只有N。</p>\n<p>时间复杂度：O（N）</p>\n<p>空间复杂度：O（N）</p>\n<p>执行用时：8 ms, 在所有 C++ 提交中击败了93.23%的用户</p>\n<p>内存消耗：10.5 MB, 在所有 C++ 提交中击败了57.73%的用户</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">convert</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> numRows)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">result</span><span class=\"params\">(numRows)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> row = <span class=\"number\">0</span>, col = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> shu = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (numRows == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> s;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tresult[row].push_back(s[i]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (shu)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (row == numRows - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tshu = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t\t--row;</span><br><span class=\"line\">\t\t\t\t++col;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t++row;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (row == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tshu = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t\t++row;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t--row;</span><br><span class=\"line\">\t\t\t\t++col;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//顺序读取</span></span><br><span class=\"line\">\t<span class=\"built_in\">string</span> ans;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numRows; ++i)</span><br><span class=\"line\">\t\tans += result[i];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"23-合并K组升序链表\"><a href=\"#23-合并K组升序链表\" class=\"headerlink\" title=\"23 合并K组升序链表\"></a>23 合并K组升序链表</h3><p>1.采用K路归并的思路</p>\n<p>时间复杂度：O（nk)</p>\n<p>执行用时：756 ms, 在所有 C++ 提交中击败了7.77%的用户</p>\n<p>内存消耗：12.6 MB, 在所有 C++ 提交中击败了98.43%的用户</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">mergeKLists</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = lists.size();</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> allZero = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">//N路归并</span></span><br><span class=\"line\">        ListNode* head = <span class=\"keyword\">new</span> ListNode();</span><br><span class=\"line\">        ListNode* ptr = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!allZero)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> minNum = <span class=\"number\">99999</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> index = <span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (lists[i] != <span class=\"literal\">nullptr</span>&amp;&amp;lists[i]-&gt;val &lt; minNum)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    index = i;</span><br><span class=\"line\">                    minNum = lists[i]-&gt;val;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//找到最小的了</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (index == <span class=\"number\">-1</span>)</span><br><span class=\"line\">                allZero = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ptr-&gt;next = lists[index];</span><br><span class=\"line\">                ptr = ptr-&gt;next;</span><br><span class=\"line\">                lists[index] = lists[index]-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head-&gt;next;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>2.采用二路归并的思路</p>\n<p>时间复杂度：O（NlogK)</p>\n<p>执行用时：20 ms, 在所有 C++ 提交中击败了99.49%的用户</p>\n<p>内存消耗：22.2 MB, 在所有 C++ 提交中击败了13.34%的用户</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//归并从下标start开始的n个链表</span></span><br><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">merge2Lists</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ListNode*&gt;&amp; lists, <span class=\"keyword\">int</span> start,<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> lists[start];</span><br><span class=\"line\">\tListNode* p1 = merge2Lists(lists, start, n / <span class=\"number\">2</span>);</span><br><span class=\"line\">\tListNode* p2 = merge2Lists(lists, start + n / <span class=\"number\">2</span>, n - (n / <span class=\"number\">2</span>));</span><br><span class=\"line\">\t<span class=\"comment\">//对p1和p2进行归并</span></span><br><span class=\"line\">\tListNode* head = <span class=\"keyword\">new</span> ListNode();</span><br><span class=\"line\">\tListNode* ptr = head;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (p1 != <span class=\"literal\">nullptr</span>&amp;&amp;p2 != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (p1-&gt;val &lt; p2-&gt;val) &#123;</span><br><span class=\"line\">\t\t\tptr-&gt;next = p1;</span><br><span class=\"line\">\t\t\tp1 = p1-&gt;next;</span><br><span class=\"line\">\t\t\tptr = ptr-&gt;next;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tptr-&gt;next = p2;</span><br><span class=\"line\">\t\t\tp2 = p2-&gt;next;</span><br><span class=\"line\">\t\t\tptr = ptr-&gt;next;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (p1 != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\tptr-&gt;next = p1;</span><br><span class=\"line\">\t\tp1 = p1-&gt;next;</span><br><span class=\"line\">\t\tptr = ptr-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (p2 != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\tptr-&gt;next = p2;</span><br><span class=\"line\">\t\tp2 = p2-&gt;next;</span><br><span class=\"line\">\t\tptr = ptr-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> head-&gt;next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">mergeKLists</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> merge2Lists(lists, <span class=\"number\">0</span>, lists.size());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"最小水位\"><a href=\"#最小水位\" class=\"headerlink\" title=\"最小水位\"></a>最小水位</h3><p>类似于最小生成树，使用优先级队列存储</p>\n<p>时间复杂度：O（N²logK)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GridNode</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> row;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> col;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index;</span><br><span class=\"line\">\t<span class=\"comment\">//const很重要!</span></span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"keyword\">const</span> GridNode&amp; node)<span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;index &lt; node.index;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&gt;(<span class=\"keyword\">const</span> GridNode&amp; node)<span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;index &gt; node.index;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tGridNode(<span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> c, <span class=\"keyword\">int</span> i) :row(r), col(c), index(i) &#123;&#125;;</span><br><span class=\"line\">\tGridNode() &#123;&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">swimInWater</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">priority_queue</span>&lt;GridNode,<span class=\"built_in\">vector</span>&lt;GridNode&gt;,greater&lt;GridNode&gt;&gt; q;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n = grid.size();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//初始化</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> minshuiwei = grid[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">\tgrid[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\tq.push(GridNode(<span class=\"number\">0</span>, <span class=\"number\">1</span>, grid[<span class=\"number\">0</span>][<span class=\"number\">1</span>]));</span><br><span class=\"line\">\tq.push(GridNode(<span class=\"number\">1</span>, <span class=\"number\">0</span>, grid[<span class=\"number\">1</span>][<span class=\"number\">0</span>]));</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (grid[n - <span class=\"number\">1</span>][n - <span class=\"number\">1</span>] != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//找出当前最小的水位</span></span><br><span class=\"line\">\t\tGridNode temp = q.top();</span><br><span class=\"line\">\t\tq.pop();</span><br><span class=\"line\">\t\tgrid[temp.row][temp.col] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (temp.index &gt; minshuiwei) &#123;</span><br><span class=\"line\">\t\t\tminshuiwei = temp.index;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//加入其上下左右</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (temp.row != <span class=\"number\">0</span> &amp;&amp; grid[temp.row - <span class=\"number\">1</span>][temp.col] != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">\t\t\tq.push(GridNode(temp.row - <span class=\"number\">1</span>, temp.col, grid[temp.row - <span class=\"number\">1</span>][temp.col]));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (temp.col != <span class=\"number\">0</span> &amp;&amp; grid[temp.row][temp.col - <span class=\"number\">1</span>] != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">\t\t\tq.push(GridNode(temp.row, temp.col - <span class=\"number\">1</span>, grid[temp.row][temp.col - <span class=\"number\">1</span>]));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (temp.row != n - <span class=\"number\">1</span> &amp;&amp; grid[temp.row + <span class=\"number\">1</span>][temp.col] != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">\t\t\tq.push(GridNode(temp.row + <span class=\"number\">1</span>, temp.col, grid[temp.row + <span class=\"number\">1</span>][temp.col]));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (temp.col != n - <span class=\"number\">1</span> &amp;&amp; grid[temp.row][temp.col + <span class=\"number\">1</span>] != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">\t\t\tq.push(GridNode(temp.row, temp.col + <span class=\"number\">1</span>, grid[temp.row][temp.col + <span class=\"number\">1</span>]));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> minshuiwei;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<h3 id=\"4-寻找两个正序数组的中位数\"><a href=\"#4-寻找两个正序数组的中位数\" class=\"headerlink\" title=\"4 寻找两个正序数组的中位数\"></a>4 寻找两个正序数组的中位数</h3><p>1.遍历数组，使用类似于归并排序的两个指针一一比较大小</p>\n<p>时间复杂度：O(N)</p>\n<p>空间复杂度：O(1)</p>\n<p>执行用时：48 ms, 在所有 C++ 提交中击败了83.73%的用户</p>\n<p>内存消耗：86.9 MB, 在所有 C++ 提交中击败了95.52%的用户</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">findMedianSortedArrays</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums1, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//O(N)</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = <span class=\"number\">-1</span>, j = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> size1 = nums1.size(), size2 = nums2.size();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((size1 + size2) % <span class=\"number\">2</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//even</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> a;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; (size1 + size2) / <span class=\"number\">2</span> - <span class=\"number\">1</span>; ++k)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i == size1 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t\t++j;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j == size2 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t\t++i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums1[i + <span class=\"number\">1</span>] &gt; nums2[j + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t++j;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t++i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//choose two num;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i == size1 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\ta = nums2[++j];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j == size2 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\ta = nums1[++i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums1[i + <span class=\"number\">1</span>] &gt; nums2[j + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ta = nums2[++j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\ta = nums1[++i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i == size1 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\ta += nums2[++j];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j == size2 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\ta += nums1[++i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums1[i + <span class=\"number\">1</span>] &gt; nums2[j + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ta += nums2[++j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\ta += nums1[++i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a / <span class=\"number\">2.0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; (size1 + size2) / <span class=\"number\">2</span> ; ++k)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i == size1 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t\t++j;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j == size2 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t\t++i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums1[i + <span class=\"number\">1</span>] &gt; nums2[j + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t++j;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t++i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i == size1 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> nums2[++j];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j == size2 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> nums1[++i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums1[i + <span class=\"number\">1</span>] &gt; nums2[j + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> nums2[++j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> nums1[++i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"5-最长回文子串\"><a href=\"#5-最长回文子串\" class=\"headerlink\" title=\"5 最长回文子串\"></a>5 最长回文子串</h3><p>1.递推，利用状态转移方程dp[i] [j]表示字符串的i到j是否为回文串</p>\n<p>初始条件：</p>\n<ul>\n<li>dp[i] [i]=true</li>\n<li>dp[i] [i+1]= s[i]==s[i+1]</li>\n</ul>\n<p>转移条件：</p>\n<ul>\n<li>dp[i] [j]= true if dp[i+1] [j-1] and s[i]==s[j]</li>\n</ul>\n<p>时间复杂度:O(N)</p>\n<p>空间复杂度:O(N)</p>\n<p>执行用时：456 ms, 在所有 C++ 提交中击败了41.14%的用户</p>\n<p>内存消耗：7.9 MB, 在所有 C++ 提交中击败了77.31%的用户</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> dp[<span class=\"number\">1000</span>][<span class=\"number\">1000</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> strLength = s.length();</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> maxS = <span class=\"number\">-1</span>, maxE = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; strLength; ++i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; strLength; ++j)</span><br><span class=\"line\">\t\t\tdp[i][j] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//边界条件</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; strLength; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tdp[i][i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\tmaxS = i;</span><br><span class=\"line\">\t\tmaxE = i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; strLength - <span class=\"number\">1</span>; ++i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (s[i] == s[i + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tdp[i][i + <span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\tmaxS = i;</span><br><span class=\"line\">\t\t\tmaxE = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//奇数转移方程</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; strLength; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= i &amp;&amp; j &lt;= strLength - i - <span class=\"number\">1</span>; ++j)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (dp[i - j + <span class=\"number\">1</span>][i + j - <span class=\"number\">1</span>] &amp;&amp; s[i - j] == s[i + j])</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tdp[i - j][i + j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (dp[i - j][i + j] &amp;&amp; <span class=\"number\">2</span> * j + <span class=\"number\">1</span> &gt; maxE - maxS + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tmaxS = i - j;</span><br><span class=\"line\">\t\t\t\tmaxE = i + j;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//偶数转移方程</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; strLength - <span class=\"number\">1</span>; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= i &amp;&amp; j &lt;= strLength - i - <span class=\"number\">2</span>; ++j)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (dp[i - j + <span class=\"number\">1</span>][i + j ] &amp;&amp; s[i - j] == s[i + j+<span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tdp[i - j][i + j+<span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (dp[i - j][i + j+<span class=\"number\">1</span>] &amp;&amp; <span class=\"number\">2</span> * j + <span class=\"number\">2</span> &gt; maxE - maxS + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tmaxS = i - j;</span><br><span class=\"line\">\t\t\t\tmaxE = i + j+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (maxS == <span class=\"number\">-1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> s.substr(maxS, maxE - maxS + <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h3 id=\"6-Z字形变换\"><a href=\"#6-Z字形变换\" class=\"headerlink\" title=\"6.Z字形变换\"></a>6.Z字形变换</h3><p>1.利用一个二维数组存储绘制出的Z字形，完成绘制后遍历二维数组每一个顺序输出</p>\n<p>时间复杂度：O(N²)</p>\n<p>空间复杂度：O(N²)</p>\n<p>执行用时：1288 ms, 在所有 C++ 提交中击败了5.08%的用户</p>\n<p>内存消耗：9.1 MB, 在所有 C++ 提交中击败了62.58%的用户</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">convert</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> numRows)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> word[<span class=\"number\">1000</span>][<span class=\"number\">1000</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> row = <span class=\"number\">0</span>, col = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> shu = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (numRows == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> s;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tword[row][col] = s[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (shu)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (row == numRows - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tshu = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t\t--row;</span><br><span class=\"line\">\t\t\t\t++col;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t++row;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (row == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tshu = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t\t++row;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t--row;</span><br><span class=\"line\">\t\t\t\t++col;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//顺序读取</span></span><br><span class=\"line\">\t<span class=\"built_in\">string</span> ans;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; ++i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">1000</span>; ++j)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (word[i][j] != <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\tans.push_back(word[i][j]);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2.思路类似于1，不过不再采用1中二维数组的方式存取数据</p>\n<p>而是借鉴稀疏矩阵的方法，定义一个Node，将其存储在vector&lt; Node &gt;中。在绘制完毕后，重载比较运算符来进行排序。</p>\n<p>时间复杂度：O(NlogN)</p>\n<p>空间复杂度：O(N)</p>\n<p>执行用时：36 ms, 在所有 C++ 提交中击败了20.65%的用户</p>\n<p>内存消耗：12.6 MB, 在所有 C++ 提交中击败了17.63%的用户</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> row;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> col;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> data;</span><br><span class=\"line\">\tNode(<span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> c, <span class=\"keyword\">char</span> d)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\trow = r;</span><br><span class=\"line\">\t\tcol = c;</span><br><span class=\"line\">\t\tdata = d;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"keyword\">const</span> Node&amp; p2)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;row &lt; p2.row)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span>-&gt;row == p2.row&amp;&amp;<span class=\"keyword\">this</span>-&gt;col &lt; p2.col);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">convert</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> numRows)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;Node&gt; result;<span class=\"comment\">//类似于稀疏矩阵</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> row = <span class=\"number\">0</span>, col = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> shu = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (numRows == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> s;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tresult.push_back(Node(row, col, s[i]));</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (shu)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (row == numRows - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tshu = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t\t--row;</span><br><span class=\"line\">\t\t\t\t++col;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t++row;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (row == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tshu = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t\t++row;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t--row;</span><br><span class=\"line\">\t\t\t\t++col;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//对内部进行排序，先比较行，行小的在前，紧接着比较列</span></span><br><span class=\"line\">\t<span class=\"comment\">//时间复杂度为O(NlogN)</span></span><br><span class=\"line\">\tsort(result.begin(), result.end());</span><br><span class=\"line\">\t<span class=\"built_in\">string</span> ans;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i = result.begin(); i != result.end(); ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tans.push_back(i-&gt;data);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>3.利用1的方法，不过不再采用二维数组存储，而是使用一个vector存储每一行的字符串。到每一行直接加入尾端即可。这样字符串总长度实际上只有N。</p>\n<p>时间复杂度：O（N）</p>\n<p>空间复杂度：O（N）</p>\n<p>执行用时：8 ms, 在所有 C++ 提交中击败了93.23%的用户</p>\n<p>内存消耗：10.5 MB, 在所有 C++ 提交中击败了57.73%的用户</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">convert</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> numRows)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">result</span><span class=\"params\">(numRows)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> row = <span class=\"number\">0</span>, col = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> shu = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (numRows == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> s;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tresult[row].push_back(s[i]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (shu)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (row == numRows - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tshu = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t\t--row;</span><br><span class=\"line\">\t\t\t\t++col;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t++row;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (row == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tshu = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t\t++row;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t--row;</span><br><span class=\"line\">\t\t\t\t++col;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//顺序读取</span></span><br><span class=\"line\">\t<span class=\"built_in\">string</span> ans;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numRows; ++i)</span><br><span class=\"line\">\t\tans += result[i];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"23-合并K组升序链表\"><a href=\"#23-合并K组升序链表\" class=\"headerlink\" title=\"23 合并K组升序链表\"></a>23 合并K组升序链表</h3><p>1.采用K路归并的思路</p>\n<p>时间复杂度：O（nk)</p>\n<p>执行用时：756 ms, 在所有 C++ 提交中击败了7.77%的用户</p>\n<p>内存消耗：12.6 MB, 在所有 C++ 提交中击败了98.43%的用户</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">mergeKLists</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = lists.size();</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> allZero = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">//N路归并</span></span><br><span class=\"line\">        ListNode* head = <span class=\"keyword\">new</span> ListNode();</span><br><span class=\"line\">        ListNode* ptr = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!allZero)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> minNum = <span class=\"number\">99999</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> index = <span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (lists[i] != <span class=\"literal\">nullptr</span>&amp;&amp;lists[i]-&gt;val &lt; minNum)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    index = i;</span><br><span class=\"line\">                    minNum = lists[i]-&gt;val;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//找到最小的了</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (index == <span class=\"number\">-1</span>)</span><br><span class=\"line\">                allZero = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ptr-&gt;next = lists[index];</span><br><span class=\"line\">                ptr = ptr-&gt;next;</span><br><span class=\"line\">                lists[index] = lists[index]-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head-&gt;next;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>2.采用二路归并的思路</p>\n<p>时间复杂度：O（NlogK)</p>\n<p>执行用时：20 ms, 在所有 C++ 提交中击败了99.49%的用户</p>\n<p>内存消耗：22.2 MB, 在所有 C++ 提交中击败了13.34%的用户</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//归并从下标start开始的n个链表</span></span><br><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">merge2Lists</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ListNode*&gt;&amp; lists, <span class=\"keyword\">int</span> start,<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> lists[start];</span><br><span class=\"line\">\tListNode* p1 = merge2Lists(lists, start, n / <span class=\"number\">2</span>);</span><br><span class=\"line\">\tListNode* p2 = merge2Lists(lists, start + n / <span class=\"number\">2</span>, n - (n / <span class=\"number\">2</span>));</span><br><span class=\"line\">\t<span class=\"comment\">//对p1和p2进行归并</span></span><br><span class=\"line\">\tListNode* head = <span class=\"keyword\">new</span> ListNode();</span><br><span class=\"line\">\tListNode* ptr = head;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (p1 != <span class=\"literal\">nullptr</span>&amp;&amp;p2 != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (p1-&gt;val &lt; p2-&gt;val) &#123;</span><br><span class=\"line\">\t\t\tptr-&gt;next = p1;</span><br><span class=\"line\">\t\t\tp1 = p1-&gt;next;</span><br><span class=\"line\">\t\t\tptr = ptr-&gt;next;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tptr-&gt;next = p2;</span><br><span class=\"line\">\t\t\tp2 = p2-&gt;next;</span><br><span class=\"line\">\t\t\tptr = ptr-&gt;next;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (p1 != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\tptr-&gt;next = p1;</span><br><span class=\"line\">\t\tp1 = p1-&gt;next;</span><br><span class=\"line\">\t\tptr = ptr-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (p2 != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\tptr-&gt;next = p2;</span><br><span class=\"line\">\t\tp2 = p2-&gt;next;</span><br><span class=\"line\">\t\tptr = ptr-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> head-&gt;next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">mergeKLists</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> merge2Lists(lists, <span class=\"number\">0</span>, lists.size());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"最小水位\"><a href=\"#最小水位\" class=\"headerlink\" title=\"最小水位\"></a>最小水位</h3><p>类似于最小生成树，使用优先级队列存储</p>\n<p>时间复杂度：O（N²logK)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GridNode</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> row;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> col;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index;</span><br><span class=\"line\">\t<span class=\"comment\">//const很重要!</span></span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"keyword\">const</span> GridNode&amp; node)<span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;index &lt; node.index;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&gt;(<span class=\"keyword\">const</span> GridNode&amp; node)<span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;index &gt; node.index;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tGridNode(<span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> c, <span class=\"keyword\">int</span> i) :row(r), col(c), index(i) &#123;&#125;;</span><br><span class=\"line\">\tGridNode() &#123;&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">swimInWater</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">priority_queue</span>&lt;GridNode,<span class=\"built_in\">vector</span>&lt;GridNode&gt;,greater&lt;GridNode&gt;&gt; q;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n = grid.size();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//初始化</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> minshuiwei = grid[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">\tgrid[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\tq.push(GridNode(<span class=\"number\">0</span>, <span class=\"number\">1</span>, grid[<span class=\"number\">0</span>][<span class=\"number\">1</span>]));</span><br><span class=\"line\">\tq.push(GridNode(<span class=\"number\">1</span>, <span class=\"number\">0</span>, grid[<span class=\"number\">1</span>][<span class=\"number\">0</span>]));</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (grid[n - <span class=\"number\">1</span>][n - <span class=\"number\">1</span>] != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//找出当前最小的水位</span></span><br><span class=\"line\">\t\tGridNode temp = q.top();</span><br><span class=\"line\">\t\tq.pop();</span><br><span class=\"line\">\t\tgrid[temp.row][temp.col] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (temp.index &gt; minshuiwei) &#123;</span><br><span class=\"line\">\t\t\tminshuiwei = temp.index;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//加入其上下左右</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (temp.row != <span class=\"number\">0</span> &amp;&amp; grid[temp.row - <span class=\"number\">1</span>][temp.col] != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">\t\t\tq.push(GridNode(temp.row - <span class=\"number\">1</span>, temp.col, grid[temp.row - <span class=\"number\">1</span>][temp.col]));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (temp.col != <span class=\"number\">0</span> &amp;&amp; grid[temp.row][temp.col - <span class=\"number\">1</span>] != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">\t\t\tq.push(GridNode(temp.row, temp.col - <span class=\"number\">1</span>, grid[temp.row][temp.col - <span class=\"number\">1</span>]));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (temp.row != n - <span class=\"number\">1</span> &amp;&amp; grid[temp.row + <span class=\"number\">1</span>][temp.col] != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">\t\t\tq.push(GridNode(temp.row + <span class=\"number\">1</span>, temp.col, grid[temp.row + <span class=\"number\">1</span>][temp.col]));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (temp.col != n - <span class=\"number\">1</span> &amp;&amp; grid[temp.row][temp.col + <span class=\"number\">1</span>] != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">\t\t\tq.push(GridNode(temp.row, temp.col + <span class=\"number\">1</span>, grid[temp.row][temp.col + <span class=\"number\">1</span>]));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> minshuiwei;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"游戏 | 联机版五子棋 v0.1","date":"2021-01-11T04:00:00.000Z","description":"菜鸡的第一次尝试","cover":"https://s3.ax1x.com/2021/01/11/s8aeKJ.jpg","_content":"\n## 项目简介\n\n版本：0.1\n\n项目地址：https://github.com/wangwangwang23333/Five-Son-s-Chess-Online\n\n介绍：\n\n一个可以支持联机进行五子棋的游戏\n\n目前支持功能：等待其他玩家加入、查看上一步下棋位置\n\n未来预期加入功能：悔棋、聊天、选择黑白方、积分功能\n\n\n\n## 代码环境\n\n编译器：vscode\n\n语言：python\n\n版本：3.7+\n\n库：pygame、socket等\n\n\n\n## 项目方法\n\n1.将server.py中ip地址更改为服务器的私网ip\n\n2.将playchess.py中ip地址更改为服务器的公网ip\n\n3.打开服务器\n\n4.两端即可同时开始游戏\n\n注：可以通过Pyinstall库部署为.exe文件\n\n\n\n## 项目截图\n\n开始游戏界面：\n\n[![s8ai5V.md.png](https://s3.ax1x.com/2021/01/11/s8ai5V.md.png)](https://imgchr.com/i/s8ai5V)\n\n等待其他玩家加入界面：\n\n[![s8aA8U.md.jpg](https://s3.ax1x.com/2021/01/11/s8aA8U.md.jpg)](https://imgchr.com/i/s8aA8U)\n\n游戏界面：\n\n[![s8aeKJ.md.jpg](https://s3.ax1x.com/2021/01/11/s8aeKJ.md.jpg)](https://imgchr.com/i/s8aeKJ)","source":"_posts/五子棋联机游戏介绍.md","raw":"---\ntitle: 游戏 | 联机版五子棋 v0.1\ndate: 2021-1-11 12:00:00\ndescription: 菜鸡的第一次尝试\ncover: https://s3.ax1x.com/2021/01/11/s8aeKJ.jpg\n---\n\n## 项目简介\n\n版本：0.1\n\n项目地址：https://github.com/wangwangwang23333/Five-Son-s-Chess-Online\n\n介绍：\n\n一个可以支持联机进行五子棋的游戏\n\n目前支持功能：等待其他玩家加入、查看上一步下棋位置\n\n未来预期加入功能：悔棋、聊天、选择黑白方、积分功能\n\n\n\n## 代码环境\n\n编译器：vscode\n\n语言：python\n\n版本：3.7+\n\n库：pygame、socket等\n\n\n\n## 项目方法\n\n1.将server.py中ip地址更改为服务器的私网ip\n\n2.将playchess.py中ip地址更改为服务器的公网ip\n\n3.打开服务器\n\n4.两端即可同时开始游戏\n\n注：可以通过Pyinstall库部署为.exe文件\n\n\n\n## 项目截图\n\n开始游戏界面：\n\n[![s8ai5V.md.png](https://s3.ax1x.com/2021/01/11/s8ai5V.md.png)](https://imgchr.com/i/s8ai5V)\n\n等待其他玩家加入界面：\n\n[![s8aA8U.md.jpg](https://s3.ax1x.com/2021/01/11/s8aA8U.md.jpg)](https://imgchr.com/i/s8aA8U)\n\n游戏界面：\n\n[![s8aeKJ.md.jpg](https://s3.ax1x.com/2021/01/11/s8aeKJ.md.jpg)](https://imgchr.com/i/s8aeKJ)","slug":"五子棋联机游戏介绍","published":1,"updated":"2021-01-11T09:24:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clrfw2jfg0006stfa1y3y6az3","content":"<h2 id=\"项目简介\"><a href=\"#项目简介\" class=\"headerlink\" title=\"项目简介\"></a>项目简介</h2><p>版本：0.1</p>\n<p>项目地址：<a href=\"https://github.com/wangwangwang23333/Five-Son-s-Chess-Online\">https://github.com/wangwangwang23333/Five-Son-s-Chess-Online</a></p>\n<p>介绍：</p>\n<p>一个可以支持联机进行五子棋的游戏</p>\n<p>目前支持功能：等待其他玩家加入、查看上一步下棋位置</p>\n<p>未来预期加入功能：悔棋、聊天、选择黑白方、积分功能</p>\n<h2 id=\"代码环境\"><a href=\"#代码环境\" class=\"headerlink\" title=\"代码环境\"></a>代码环境</h2><p>编译器：vscode</p>\n<p>语言：python</p>\n<p>版本：3.7+</p>\n<p>库：pygame、socket等</p>\n<h2 id=\"项目方法\"><a href=\"#项目方法\" class=\"headerlink\" title=\"项目方法\"></a>项目方法</h2><p>1.将server.py中ip地址更改为服务器的私网ip</p>\n<p>2.将playchess.py中ip地址更改为服务器的公网ip</p>\n<p>3.打开服务器</p>\n<p>4.两端即可同时开始游戏</p>\n<p>注：可以通过Pyinstall库部署为.exe文件</p>\n<h2 id=\"项目截图\"><a href=\"#项目截图\" class=\"headerlink\" title=\"项目截图\"></a>项目截图</h2><p>开始游戏界面：</p>\n<p><a href=\"https://imgchr.com/i/s8ai5V\"><img src=\"https://s3.ax1x.com/2021/01/11/s8ai5V.md.png\" alt=\"s8ai5V.md.png\"></a></p>\n<p>等待其他玩家加入界面：</p>\n<p><a href=\"https://imgchr.com/i/s8aA8U\"><img src=\"https://s3.ax1x.com/2021/01/11/s8aA8U.md.jpg\" alt=\"s8aA8U.md.jpg\"></a></p>\n<p>游戏界面：</p>\n<p><a href=\"https://imgchr.com/i/s8aeKJ\"><img src=\"https://s3.ax1x.com/2021/01/11/s8aeKJ.md.jpg\" alt=\"s8aeKJ.md.jpg\"></a></p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<h2 id=\"项目简介\"><a href=\"#项目简介\" class=\"headerlink\" title=\"项目简介\"></a>项目简介</h2><p>版本：0.1</p>\n<p>项目地址：<a href=\"https://github.com/wangwangwang23333/Five-Son-s-Chess-Online\">https://github.com/wangwangwang23333/Five-Son-s-Chess-Online</a></p>\n<p>介绍：</p>\n<p>一个可以支持联机进行五子棋的游戏</p>\n<p>目前支持功能：等待其他玩家加入、查看上一步下棋位置</p>\n<p>未来预期加入功能：悔棋、聊天、选择黑白方、积分功能</p>\n<h2 id=\"代码环境\"><a href=\"#代码环境\" class=\"headerlink\" title=\"代码环境\"></a>代码环境</h2><p>编译器：vscode</p>\n<p>语言：python</p>\n<p>版本：3.7+</p>\n<p>库：pygame、socket等</p>\n<h2 id=\"项目方法\"><a href=\"#项目方法\" class=\"headerlink\" title=\"项目方法\"></a>项目方法</h2><p>1.将server.py中ip地址更改为服务器的私网ip</p>\n<p>2.将playchess.py中ip地址更改为服务器的公网ip</p>\n<p>3.打开服务器</p>\n<p>4.两端即可同时开始游戏</p>\n<p>注：可以通过Pyinstall库部署为.exe文件</p>\n<h2 id=\"项目截图\"><a href=\"#项目截图\" class=\"headerlink\" title=\"项目截图\"></a>项目截图</h2><p>开始游戏界面：</p>\n<p><a href=\"https://imgchr.com/i/s8ai5V\"><img src=\"https://s3.ax1x.com/2021/01/11/s8ai5V.md.png\" alt=\"s8ai5V.md.png\"></a></p>\n<p>等待其他玩家加入界面：</p>\n<p><a href=\"https://imgchr.com/i/s8aA8U\"><img src=\"https://s3.ax1x.com/2021/01/11/s8aA8U.md.jpg\" alt=\"s8aA8U.md.jpg\"></a></p>\n<p>游戏界面：</p>\n<p><a href=\"https://imgchr.com/i/s8aeKJ\"><img src=\"https://s3.ax1x.com/2021/01/11/s8aeKJ.md.jpg\" alt=\"s8aeKJ.md.jpg\"></a></p>\n"},{"title":"前端--节流与防抖","date":"2022-03-18T16:00:00.000Z","description":"两个重要的概念","_content":"\n节流与防抖是前端中比较重要的两个概念。\n\n# 函数防抖\n\n当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。\n\n如下图，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。\n\n<img src='https://img-blog.csdnimg.cn/img_convert/525e0fb3b1b982c626003319f07de623.png'>\n\n下面的代码可以实现防抖的功能：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <style>\n        body{\n            height: 5000px;\n        }\n    </style>\n</head>\n<body>\n    <script>\n        function debounce(fn, wait) {\n            var timeout = null;\n            return function() {\n                if(timeout !== null)\n                    clearTimeout(timeout);\n                timeout = setTimeout(fn, wait);\n            }\n        }\n        // 处理函数\n        function handle() {\n            console.log(Math.random());\n        }\n        // 滚动事件\n        window.addEventListener('scroll', debounce(handle, 1000));\n    </script>\n</body>\n</html>\n```\n\n可以实现以下的效果：\n\n<img src='https://img-blog.csdn.net/20180917111553767?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDAwODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70'>\n\n# 函数节流\n\n当持续触发事件时，保证一定时间段内只调用一次事件处理函数。\n\n节流通俗解释就比如我们水龙头防水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。\n\n有以下的方案：\n\n## 时间戳方案\n\n```javascript\nvar throttle = function(func, delay) {\n    var prev = Date.now();\n    return function() {\n        var context = this;\n        var args = arguments;\n        var now = Date.now();\n        if (now - prev >= delay) {\n            func.apply(context, args);\n            prev = Date.now();\n        }\n    }\n}\nfunction handle() {\n    console.log(Math.random());\n}\nwindow.addEventListener('scroll', throttle(handle, 1000));\n```\n\n## 定时器方案\n\n```javascript\nvar throttle = function(func, delay) {\n    var timer = null;\n    return function() {\n        var context = this;\n        var args = arguments;\n        if (!timer) {\n            timer = setTimeout(function() {\n                func.apply(context, args);\n                timer = null;\n            }, delay);\n        }\n    }\n}\nfunction handle() {\n    console.log(Math.random());\n}\nwindow.addEventListener('scroll', throttle(handle, 1000));\n```\n\n## 时间戳+定时器\n\n```javascript\nvar throttle = function(func, delay) {\n    var timer = null;\n    var startTime = Date.now();\n    return function() {\n        var curTime = Date.now();\n        var remaining = delay - (curTime - startTime);\n        var context = this;\n        var args = arguments;\n        clearTimeout(timer);\n        if (remaining <= 0) {\n            func.apply(context, args);\n            startTime = Date.now();\n        } else {\n            timer = setTimeout(func, remaining);\n        }\n    }\n}\nfunction handle() {\n      console.log(Math.random());\n}\n window.addEventListener('scroll', throttle(handle, 1000));\n```\n\n效果如下所示：\n\n<img src='https://img-blog.csdn.net/20180917111627196?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDAwODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70'>\n\n# 总结\n\n**函数防抖**：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。\n\n**函数节流**：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。\n\n**区别**： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。","source":"_posts/前端——节流与防抖.md","raw":"---\ntitle: 前端--节流与防抖\ndate: 2022-3-19 00:00:00\ndescription: 两个重要的概念\n---\n\n节流与防抖是前端中比较重要的两个概念。\n\n# 函数防抖\n\n当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。\n\n如下图，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。\n\n<img src='https://img-blog.csdnimg.cn/img_convert/525e0fb3b1b982c626003319f07de623.png'>\n\n下面的代码可以实现防抖的功能：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <style>\n        body{\n            height: 5000px;\n        }\n    </style>\n</head>\n<body>\n    <script>\n        function debounce(fn, wait) {\n            var timeout = null;\n            return function() {\n                if(timeout !== null)\n                    clearTimeout(timeout);\n                timeout = setTimeout(fn, wait);\n            }\n        }\n        // 处理函数\n        function handle() {\n            console.log(Math.random());\n        }\n        // 滚动事件\n        window.addEventListener('scroll', debounce(handle, 1000));\n    </script>\n</body>\n</html>\n```\n\n可以实现以下的效果：\n\n<img src='https://img-blog.csdn.net/20180917111553767?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDAwODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70'>\n\n# 函数节流\n\n当持续触发事件时，保证一定时间段内只调用一次事件处理函数。\n\n节流通俗解释就比如我们水龙头防水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。\n\n有以下的方案：\n\n## 时间戳方案\n\n```javascript\nvar throttle = function(func, delay) {\n    var prev = Date.now();\n    return function() {\n        var context = this;\n        var args = arguments;\n        var now = Date.now();\n        if (now - prev >= delay) {\n            func.apply(context, args);\n            prev = Date.now();\n        }\n    }\n}\nfunction handle() {\n    console.log(Math.random());\n}\nwindow.addEventListener('scroll', throttle(handle, 1000));\n```\n\n## 定时器方案\n\n```javascript\nvar throttle = function(func, delay) {\n    var timer = null;\n    return function() {\n        var context = this;\n        var args = arguments;\n        if (!timer) {\n            timer = setTimeout(function() {\n                func.apply(context, args);\n                timer = null;\n            }, delay);\n        }\n    }\n}\nfunction handle() {\n    console.log(Math.random());\n}\nwindow.addEventListener('scroll', throttle(handle, 1000));\n```\n\n## 时间戳+定时器\n\n```javascript\nvar throttle = function(func, delay) {\n    var timer = null;\n    var startTime = Date.now();\n    return function() {\n        var curTime = Date.now();\n        var remaining = delay - (curTime - startTime);\n        var context = this;\n        var args = arguments;\n        clearTimeout(timer);\n        if (remaining <= 0) {\n            func.apply(context, args);\n            startTime = Date.now();\n        } else {\n            timer = setTimeout(func, remaining);\n        }\n    }\n}\nfunction handle() {\n      console.log(Math.random());\n}\n window.addEventListener('scroll', throttle(handle, 1000));\n```\n\n效果如下所示：\n\n<img src='https://img-blog.csdn.net/20180917111627196?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDAwODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70'>\n\n# 总结\n\n**函数防抖**：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。\n\n**函数节流**：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。\n\n**区别**： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。","slug":"前端——节流与防抖","published":1,"updated":"2022-03-19T06:45:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clrfw2jfg0007stfadwxqdfbv","content":"<p>节流与防抖是前端中比较重要的两个概念。</p>\n<h1 id=\"函数防抖\"><a href=\"#函数防抖\" class=\"headerlink\" title=\"函数防抖\"></a>函数防抖</h1><p>当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。</p>\n<p>如下图，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。</p>\n<img src='https://img-blog.csdnimg.cn/img_convert/525e0fb3b1b982c626003319f07de623.png'>\n\n<p>下面的代码可以实现防抖的功能：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Title<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\">        body&#123;</span><br><span class=\"line\">            height: 5000px;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">fn, wait</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> timeout = <span class=\"literal\">null</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">if</span>(timeout !== <span class=\"literal\">null</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">                    <span class=\"built_in\">clearTimeout</span>(timeout);</span></span><br><span class=\"line\"><span class=\"javascript\">                timeout = <span class=\"built_in\">setTimeout</span>(fn, wait);</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 处理函数</span></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Math</span>.random());</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 滚动事件</span></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&#x27;scroll&#x27;</span>, debounce(handle, <span class=\"number\">1000</span>));</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>可以实现以下的效果：</p>\n<img src='https://img-blog.csdn.net/20180917111553767?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDAwODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70'>\n\n<h1 id=\"函数节流\"><a href=\"#函数节流\" class=\"headerlink\" title=\"函数节流\"></a>函数节流</h1><p>当持续触发事件时，保证一定时间段内只调用一次事件处理函数。</p>\n<p>节流通俗解释就比如我们水龙头防水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。</p>\n<p>有以下的方案：</p>\n<h2 id=\"时间戳方案\"><a href=\"#时间戳方案\" class=\"headerlink\" title=\"时间戳方案\"></a>时间戳方案</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> throttle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, delay</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> prev = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> context = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> now = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (now - prev &gt;= delay) &#123;</span><br><span class=\"line\">            func.apply(context, args);</span><br><span class=\"line\">            prev = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Math</span>.random());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&#x27;scroll&#x27;</span>, throttle(handle, <span class=\"number\">1000</span>));</span><br></pre></td></tr></table></figure>\n<h2 id=\"定时器方案\"><a href=\"#定时器方案\" class=\"headerlink\" title=\"定时器方案\"></a>定时器方案</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> throttle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, delay</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> context = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!timer) &#123;</span><br><span class=\"line\">            timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                func.apply(context, args);</span><br><span class=\"line\">                timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            &#125;, delay);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Math</span>.random());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&#x27;scroll&#x27;</span>, throttle(handle, <span class=\"number\">1000</span>));</span><br></pre></td></tr></table></figure>\n<h2 id=\"时间戳-定时器\"><a href=\"#时间戳-定时器\" class=\"headerlink\" title=\"时间戳+定时器\"></a>时间戳+定时器</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> throttle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, delay</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> startTime = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> curTime = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">        <span class=\"keyword\">var</span> remaining = delay - (curTime - startTime);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> context = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">        <span class=\"built_in\">clearTimeout</span>(timer);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (remaining &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            func.apply(context, args);</span><br><span class=\"line\">            startTime = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            timer = <span class=\"built_in\">setTimeout</span>(func, remaining);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Math</span>.random());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&#x27;scroll&#x27;</span>, throttle(handle, <span class=\"number\">1000</span>));</span><br></pre></td></tr></table></figure>\n<p>效果如下所示：</p>\n<img src='https://img-blog.csdn.net/20180917111627196?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDAwODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70'>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p><strong>函数防抖</strong>：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。</p>\n<p><strong>函数节流</strong>：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。</p>\n<p><strong>区别</strong>： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p>节流与防抖是前端中比较重要的两个概念。</p>\n<h1 id=\"函数防抖\"><a href=\"#函数防抖\" class=\"headerlink\" title=\"函数防抖\"></a>函数防抖</h1><p>当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。</p>\n<p>如下图，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。</p>\n<img src='https://img-blog.csdnimg.cn/img_convert/525e0fb3b1b982c626003319f07de623.png'>\n\n<p>下面的代码可以实现防抖的功能：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Title<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\">        body&#123;</span><br><span class=\"line\">            height: 5000px;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">fn, wait</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> timeout = <span class=\"literal\">null</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">if</span>(timeout !== <span class=\"literal\">null</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">                    <span class=\"built_in\">clearTimeout</span>(timeout);</span></span><br><span class=\"line\"><span class=\"javascript\">                timeout = <span class=\"built_in\">setTimeout</span>(fn, wait);</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 处理函数</span></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Math</span>.random());</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 滚动事件</span></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&#x27;scroll&#x27;</span>, debounce(handle, <span class=\"number\">1000</span>));</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>可以实现以下的效果：</p>\n<img src='https://img-blog.csdn.net/20180917111553767?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDAwODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70'>\n\n<h1 id=\"函数节流\"><a href=\"#函数节流\" class=\"headerlink\" title=\"函数节流\"></a>函数节流</h1><p>当持续触发事件时，保证一定时间段内只调用一次事件处理函数。</p>\n<p>节流通俗解释就比如我们水龙头防水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。</p>\n<p>有以下的方案：</p>\n<h2 id=\"时间戳方案\"><a href=\"#时间戳方案\" class=\"headerlink\" title=\"时间戳方案\"></a>时间戳方案</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> throttle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, delay</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> prev = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> context = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> now = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (now - prev &gt;= delay) &#123;</span><br><span class=\"line\">            func.apply(context, args);</span><br><span class=\"line\">            prev = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Math</span>.random());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&#x27;scroll&#x27;</span>, throttle(handle, <span class=\"number\">1000</span>));</span><br></pre></td></tr></table></figure>\n<h2 id=\"定时器方案\"><a href=\"#定时器方案\" class=\"headerlink\" title=\"定时器方案\"></a>定时器方案</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> throttle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, delay</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> context = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!timer) &#123;</span><br><span class=\"line\">            timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                func.apply(context, args);</span><br><span class=\"line\">                timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            &#125;, delay);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Math</span>.random());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&#x27;scroll&#x27;</span>, throttle(handle, <span class=\"number\">1000</span>));</span><br></pre></td></tr></table></figure>\n<h2 id=\"时间戳-定时器\"><a href=\"#时间戳-定时器\" class=\"headerlink\" title=\"时间戳+定时器\"></a>时间戳+定时器</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> throttle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, delay</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> startTime = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> curTime = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">        <span class=\"keyword\">var</span> remaining = delay - (curTime - startTime);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> context = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">        <span class=\"built_in\">clearTimeout</span>(timer);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (remaining &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            func.apply(context, args);</span><br><span class=\"line\">            startTime = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            timer = <span class=\"built_in\">setTimeout</span>(func, remaining);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Math</span>.random());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&#x27;scroll&#x27;</span>, throttle(handle, <span class=\"number\">1000</span>));</span><br></pre></td></tr></table></figure>\n<p>效果如下所示：</p>\n<img src='https://img-blog.csdn.net/20180917111627196?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDAwODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70'>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p><strong>函数防抖</strong>：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。</p>\n<p><strong>函数节流</strong>：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。</p>\n<p><strong>区别</strong>： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。</p>\n"},{"title":"单调栈的应用","date":"2022-03-31T12:00:00.000Z","description":"LeetCode中单调栈的一些应用","cover":"https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg","_content":"\n## 84 柱状图中最大的矩形\n\n> 题目链接：https://leetcode-cn.com/problems/largest-rectangle-in-histogram/\n>\n> 给定 `n `个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n>\n> 求在该柱状图中，能够勾勒出来的矩形的最大面积。\n\n<img src='https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg' width='50%'>\n\n### 思考\n\n我们可以反过来考虑针对于每一个元素，都可以求出**以它为高的最大矩形面积**。\n\n那么这样一个矩形，它的底应该是多少呢？\n\n自然而然，我们可以发现：这一个矩形的左侧就是左边比它小的元素的位置，右侧自然也是比它小的元素的位置。\n\n以下图的元素5为例，它的最左侧就应该是比它小的元素1的右边，它的最右侧就应该是比它小的元素2的左边。\n\n![image-20220331205119619](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220331205119619.png)\n\n因此，问题就转化成了：针对于每一个元素，我们都需要求出左边比它小的元素的位置以及右边比它小的元素的位置。\n\n### 单调栈\n\n那么在从左往右遍历一遍的过程中，如何找出比它小的元素呢？\n\n我们自然而然的想到了单调递增栈（严格单调递增）：每当一个元素到达时候，不断出栈直到栈为空或者栈顶元素小于该元素，那么这个元素就一定是比它小的最近的元素。\n\n### 代码\n\n```typescript\nfunction largestRectangleArea(heights: number[]): number {\n    // 元素个数\n    let n = heights.length;\n\n    let left = new Array(n).fill(-1);\n    let right = new Array(n).fill(n);\n\n    // 单调递增栈：严格单调递增，存储的是元素下标\n    let s = new Array();\n\n    // 从左往右遍历，计算left数组\n    for (let i = 0; i < n; ++i) {\n        // 出栈，直到栈空或者满足栈顶元素 < 当前元素\n        while (s.length != 0 && heights[s[s.length - 1]] >= heights[i]) {\n            s.pop();\n        }\n        if (s.length != 0) {\n            left[i] = s[s.length - 1];\n        }\n        // 入栈\n        s.push(i);\n    }\n    \n    s.splice(0, s.length);\n    // 从右往左遍历，计算right数组\n    for (let i = n - 1; i >= 0; --i) {\n        // 出栈，直到栈空或者满足栈顶元素 < 当前元素\n        while (s.length != 0 && heights[s[s.length - 1]] >= heights[i]) {\n            s.pop();\n        }\n        if (s.length != 0) {\n            right[i] = s[s.length - 1];\n        }\n        // 入栈\n        s.push(i);\n    }\n\n    let maxRes = 0;\n    for (let i = 0; i < n; ++i) {\n        maxRes = Math.max(maxRes, (right[i] - left[i] - 1) * heights[i]);\n    }\n\n    return maxRes;\n};\n```\n\n\n\n## 42 接雨水\n\n> 题目链接：https://leetcode-cn.com/problems/trapping-rain-water/\n>\n> 给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)\n\n### 思考\n\n我们可以考虑计算每一根柱子所能接的雨水的高度。\n\n这个高度应该是：左右两侧柱子的高度。其中这根柱子满足，它是这根柱子左边（或右边）比它高的那一根柱子所能接到雨水的高度。\n\n` 注意：不是左边（或）右边比它高的柱子的高度，因为可能还有更高的柱子。实际上应该是接到雨水的高度，因为比它高的雨水能借到的柱子，它自己也一定能接到。`\n\n这样问题实际上就转化成了，寻找左边（或右边）最近的比它大的元素。\n\n自然而然，我们应该使用单调递减栈（严格单调递减）：每遍历到一个元素的时候，不断出栈直到栈空或者栈顶元素大于该元素。\n\n### 代码\n\n```typescript\nfunction trap(height: number[]): number {\n    let n = height.length;\n    let left = new Array(n);\n    let right = new Array(n);\n\n    let s = [];\n\n    for (let i = 0; i < n; ++i) {\n        // 出栈，直到栈空或者栈顶元素>该元素\n        while (s.length != 0 && height[s[s.length - 1]] <= height[i]) {\n            s.pop();\n        }\n        if (s.length == 0) {\n            left[i] = height[i];\n        }\n        else {\n            left[i] = left[s[s.length - 1]];\n        }\n        s.push(i);\n    }\n    s.splice(0, s.length);\n    for (let i = n - 1; i >= 0; --i) {\n        // 出栈，直到栈空或者栈顶元素>该元素\n        while (s.length != 0 && height[s[s.length - 1]] <= height[i]) {\n            s.pop();\n        }\n        if (s.length == 0) {\n            right[i] = height[i];\n        }\n        else {\n            right[i] = right[s[s.length - 1]];\n        }\n        s.push(i);\n    }\n    let ans = 0;\n    for (let i = 0; i < n; ++i) {\n        ans += Math.min(left[i], right[i]) - height[i];\n    }\n\n    return ans;\n};\n```\n\n","source":"_posts/单调栈的应用.md","raw":"---\ntitle: 单调栈的应用\ndate: 2022-3-31 20:00:00\ndescription: LeetCode中单调栈的一些应用\ncover: https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg\n---\n\n## 84 柱状图中最大的矩形\n\n> 题目链接：https://leetcode-cn.com/problems/largest-rectangle-in-histogram/\n>\n> 给定 `n `个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n>\n> 求在该柱状图中，能够勾勒出来的矩形的最大面积。\n\n<img src='https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg' width='50%'>\n\n### 思考\n\n我们可以反过来考虑针对于每一个元素，都可以求出**以它为高的最大矩形面积**。\n\n那么这样一个矩形，它的底应该是多少呢？\n\n自然而然，我们可以发现：这一个矩形的左侧就是左边比它小的元素的位置，右侧自然也是比它小的元素的位置。\n\n以下图的元素5为例，它的最左侧就应该是比它小的元素1的右边，它的最右侧就应该是比它小的元素2的左边。\n\n![image-20220331205119619](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220331205119619.png)\n\n因此，问题就转化成了：针对于每一个元素，我们都需要求出左边比它小的元素的位置以及右边比它小的元素的位置。\n\n### 单调栈\n\n那么在从左往右遍历一遍的过程中，如何找出比它小的元素呢？\n\n我们自然而然的想到了单调递增栈（严格单调递增）：每当一个元素到达时候，不断出栈直到栈为空或者栈顶元素小于该元素，那么这个元素就一定是比它小的最近的元素。\n\n### 代码\n\n```typescript\nfunction largestRectangleArea(heights: number[]): number {\n    // 元素个数\n    let n = heights.length;\n\n    let left = new Array(n).fill(-1);\n    let right = new Array(n).fill(n);\n\n    // 单调递增栈：严格单调递增，存储的是元素下标\n    let s = new Array();\n\n    // 从左往右遍历，计算left数组\n    for (let i = 0; i < n; ++i) {\n        // 出栈，直到栈空或者满足栈顶元素 < 当前元素\n        while (s.length != 0 && heights[s[s.length - 1]] >= heights[i]) {\n            s.pop();\n        }\n        if (s.length != 0) {\n            left[i] = s[s.length - 1];\n        }\n        // 入栈\n        s.push(i);\n    }\n    \n    s.splice(0, s.length);\n    // 从右往左遍历，计算right数组\n    for (let i = n - 1; i >= 0; --i) {\n        // 出栈，直到栈空或者满足栈顶元素 < 当前元素\n        while (s.length != 0 && heights[s[s.length - 1]] >= heights[i]) {\n            s.pop();\n        }\n        if (s.length != 0) {\n            right[i] = s[s.length - 1];\n        }\n        // 入栈\n        s.push(i);\n    }\n\n    let maxRes = 0;\n    for (let i = 0; i < n; ++i) {\n        maxRes = Math.max(maxRes, (right[i] - left[i] - 1) * heights[i]);\n    }\n\n    return maxRes;\n};\n```\n\n\n\n## 42 接雨水\n\n> 题目链接：https://leetcode-cn.com/problems/trapping-rain-water/\n>\n> 给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)\n\n### 思考\n\n我们可以考虑计算每一根柱子所能接的雨水的高度。\n\n这个高度应该是：左右两侧柱子的高度。其中这根柱子满足，它是这根柱子左边（或右边）比它高的那一根柱子所能接到雨水的高度。\n\n` 注意：不是左边（或）右边比它高的柱子的高度，因为可能还有更高的柱子。实际上应该是接到雨水的高度，因为比它高的雨水能借到的柱子，它自己也一定能接到。`\n\n这样问题实际上就转化成了，寻找左边（或右边）最近的比它大的元素。\n\n自然而然，我们应该使用单调递减栈（严格单调递减）：每遍历到一个元素的时候，不断出栈直到栈空或者栈顶元素大于该元素。\n\n### 代码\n\n```typescript\nfunction trap(height: number[]): number {\n    let n = height.length;\n    let left = new Array(n);\n    let right = new Array(n);\n\n    let s = [];\n\n    for (let i = 0; i < n; ++i) {\n        // 出栈，直到栈空或者栈顶元素>该元素\n        while (s.length != 0 && height[s[s.length - 1]] <= height[i]) {\n            s.pop();\n        }\n        if (s.length == 0) {\n            left[i] = height[i];\n        }\n        else {\n            left[i] = left[s[s.length - 1]];\n        }\n        s.push(i);\n    }\n    s.splice(0, s.length);\n    for (let i = n - 1; i >= 0; --i) {\n        // 出栈，直到栈空或者栈顶元素>该元素\n        while (s.length != 0 && height[s[s.length - 1]] <= height[i]) {\n            s.pop();\n        }\n        if (s.length == 0) {\n            right[i] = height[i];\n        }\n        else {\n            right[i] = right[s[s.length - 1]];\n        }\n        s.push(i);\n    }\n    let ans = 0;\n    for (let i = 0; i < n; ++i) {\n        ans += Math.min(left[i], right[i]) - height[i];\n    }\n\n    return ans;\n};\n```\n\n","slug":"单调栈的应用","published":1,"updated":"2022-04-01T05:59:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clrfw2jfh0008stfaeocj6qek","content":"<h2 id=\"84-柱状图中最大的矩形\"><a href=\"#84-柱状图中最大的矩形\" class=\"headerlink\" title=\"84 柱状图中最大的矩形\"></a>84 柱状图中最大的矩形</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode-cn.com/problems/largest-rectangle-in-histogram/\">https://leetcode-cn.com/problems/largest-rectangle-in-histogram/</a></p>\n<p>给定 <code>n </code>个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>\n<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>\n</blockquote>\n<img src='https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg' width='50%'>\n\n<h3 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h3><p>我们可以反过来考虑针对于每一个元素，都可以求出<strong>以它为高的最大矩形面积</strong>。</p>\n<p>那么这样一个矩形，它的底应该是多少呢？</p>\n<p>自然而然，我们可以发现：这一个矩形的左侧就是左边比它小的元素的位置，右侧自然也是比它小的元素的位置。</p>\n<p>以下图的元素5为例，它的最左侧就应该是比它小的元素1的右边，它的最右侧就应该是比它小的元素2的左边。</p>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220331205119619.png\" alt=\"image-20220331205119619\"></p>\n<p>因此，问题就转化成了：针对于每一个元素，我们都需要求出左边比它小的元素的位置以及右边比它小的元素的位置。</p>\n<h3 id=\"单调栈\"><a href=\"#单调栈\" class=\"headerlink\" title=\"单调栈\"></a>单调栈</h3><p>那么在从左往右遍历一遍的过程中，如何找出比它小的元素呢？</p>\n<p>我们自然而然的想到了单调递增栈（严格单调递增）：每当一个元素到达时候，不断出栈直到栈为空或者栈顶元素小于该元素，那么这个元素就一定是比它小的最近的元素。</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">largestRectangleArea</span>(<span class=\"params\">heights: <span class=\"built_in\">number</span>[]</span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 元素个数</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> n = heights.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> left = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(n).fill(-<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> right = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(n).fill(n);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 单调递增栈：严格单调递增，存储的是元素下标</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从左往右遍历，计算left数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 出栈，直到栈空或者满足栈顶元素 &lt; 当前元素</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (s.length != <span class=\"number\">0</span> &amp;&amp; heights[s[s.length - <span class=\"number\">1</span>]] &gt;= heights[i]) &#123;</span><br><span class=\"line\">            s.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            left[i] = s[s.length - <span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 入栈</span></span><br><span class=\"line\">        s.push(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    s.splice(<span class=\"number\">0</span>, s.length);</span><br><span class=\"line\">    <span class=\"comment\">// 从右往左遍历，计算right数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 出栈，直到栈空或者满足栈顶元素 &lt; 当前元素</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (s.length != <span class=\"number\">0</span> &amp;&amp; heights[s[s.length - <span class=\"number\">1</span>]] &gt;= heights[i]) &#123;</span><br><span class=\"line\">            s.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            right[i] = s[s.length - <span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 入栈</span></span><br><span class=\"line\">        s.push(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> maxRes = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        maxRes = <span class=\"built_in\">Math</span>.max(maxRes, (right[i] - left[i] - <span class=\"number\">1</span>) * heights[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> maxRes;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"42-接雨水\"><a href=\"#42-接雨水\" class=\"headerlink\" title=\"42 接雨水\"></a>42 接雨水</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode-cn.com/problems/trapping-rain-water/\">https://leetcode-cn.com/problems/trapping-rain-water/</a></p>\n<p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>\n</blockquote>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png\" alt=\"img\"></p>\n<h3 id=\"思考-1\"><a href=\"#思考-1\" class=\"headerlink\" title=\"思考\"></a>思考</h3><p>我们可以考虑计算每一根柱子所能接的雨水的高度。</p>\n<p>这个高度应该是：左右两侧柱子的高度。其中这根柱子满足，它是这根柱子左边（或右边）比它高的那一根柱子所能接到雨水的高度。</p>\n<p><code> 注意：不是左边（或）右边比它高的柱子的高度，因为可能还有更高的柱子。实际上应该是接到雨水的高度，因为比它高的雨水能借到的柱子，它自己也一定能接到。</code></p>\n<p>这样问题实际上就转化成了，寻找左边（或右边）最近的比它大的元素。</p>\n<p>自然而然，我们应该使用单调递减栈（严格单调递减）：每遍历到一个元素的时候，不断出栈直到栈空或者栈顶元素大于该元素。</p>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">trap</span>(<span class=\"params\">height: <span class=\"built_in\">number</span>[]</span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> n = height.length;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> left = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(n);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> right = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(n);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> s = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 出栈，直到栈空或者栈顶元素&gt;该元素</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (s.length != <span class=\"number\">0</span> &amp;&amp; height[s[s.length - <span class=\"number\">1</span>]] &lt;= height[i]) &#123;</span><br><span class=\"line\">            s.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            left[i] = height[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            left[i] = left[s[s.length - <span class=\"number\">1</span>]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        s.push(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s.splice(<span class=\"number\">0</span>, s.length);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 出栈，直到栈空或者栈顶元素&gt;该元素</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (s.length != <span class=\"number\">0</span> &amp;&amp; height[s[s.length - <span class=\"number\">1</span>]] &lt;= height[i]) &#123;</span><br><span class=\"line\">            s.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            right[i] = height[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            right[i] = right[s[s.length - <span class=\"number\">1</span>]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        s.push(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        ans += <span class=\"built_in\">Math</span>.min(left[i], right[i]) - height[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<h2 id=\"84-柱状图中最大的矩形\"><a href=\"#84-柱状图中最大的矩形\" class=\"headerlink\" title=\"84 柱状图中最大的矩形\"></a>84 柱状图中最大的矩形</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode-cn.com/problems/largest-rectangle-in-histogram/\">https://leetcode-cn.com/problems/largest-rectangle-in-histogram/</a></p>\n<p>给定 <code>n </code>个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>\n<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>\n</blockquote>\n<img src='https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg' width='50%'>\n\n<h3 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h3><p>我们可以反过来考虑针对于每一个元素，都可以求出<strong>以它为高的最大矩形面积</strong>。</p>\n<p>那么这样一个矩形，它的底应该是多少呢？</p>\n<p>自然而然，我们可以发现：这一个矩形的左侧就是左边比它小的元素的位置，右侧自然也是比它小的元素的位置。</p>\n<p>以下图的元素5为例，它的最左侧就应该是比它小的元素1的右边，它的最右侧就应该是比它小的元素2的左边。</p>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220331205119619.png\" alt=\"image-20220331205119619\"></p>\n<p>因此，问题就转化成了：针对于每一个元素，我们都需要求出左边比它小的元素的位置以及右边比它小的元素的位置。</p>\n<h3 id=\"单调栈\"><a href=\"#单调栈\" class=\"headerlink\" title=\"单调栈\"></a>单调栈</h3><p>那么在从左往右遍历一遍的过程中，如何找出比它小的元素呢？</p>\n<p>我们自然而然的想到了单调递增栈（严格单调递增）：每当一个元素到达时候，不断出栈直到栈为空或者栈顶元素小于该元素，那么这个元素就一定是比它小的最近的元素。</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">largestRectangleArea</span>(<span class=\"params\">heights: <span class=\"built_in\">number</span>[]</span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 元素个数</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> n = heights.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> left = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(n).fill(-<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> right = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(n).fill(n);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 单调递增栈：严格单调递增，存储的是元素下标</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从左往右遍历，计算left数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 出栈，直到栈空或者满足栈顶元素 &lt; 当前元素</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (s.length != <span class=\"number\">0</span> &amp;&amp; heights[s[s.length - <span class=\"number\">1</span>]] &gt;= heights[i]) &#123;</span><br><span class=\"line\">            s.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            left[i] = s[s.length - <span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 入栈</span></span><br><span class=\"line\">        s.push(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    s.splice(<span class=\"number\">0</span>, s.length);</span><br><span class=\"line\">    <span class=\"comment\">// 从右往左遍历，计算right数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 出栈，直到栈空或者满足栈顶元素 &lt; 当前元素</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (s.length != <span class=\"number\">0</span> &amp;&amp; heights[s[s.length - <span class=\"number\">1</span>]] &gt;= heights[i]) &#123;</span><br><span class=\"line\">            s.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            right[i] = s[s.length - <span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 入栈</span></span><br><span class=\"line\">        s.push(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> maxRes = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        maxRes = <span class=\"built_in\">Math</span>.max(maxRes, (right[i] - left[i] - <span class=\"number\">1</span>) * heights[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> maxRes;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"42-接雨水\"><a href=\"#42-接雨水\" class=\"headerlink\" title=\"42 接雨水\"></a>42 接雨水</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode-cn.com/problems/trapping-rain-water/\">https://leetcode-cn.com/problems/trapping-rain-water/</a></p>\n<p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>\n</blockquote>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png\" alt=\"img\"></p>\n<h3 id=\"思考-1\"><a href=\"#思考-1\" class=\"headerlink\" title=\"思考\"></a>思考</h3><p>我们可以考虑计算每一根柱子所能接的雨水的高度。</p>\n<p>这个高度应该是：左右两侧柱子的高度。其中这根柱子满足，它是这根柱子左边（或右边）比它高的那一根柱子所能接到雨水的高度。</p>\n<p><code> 注意：不是左边（或）右边比它高的柱子的高度，因为可能还有更高的柱子。实际上应该是接到雨水的高度，因为比它高的雨水能借到的柱子，它自己也一定能接到。</code></p>\n<p>这样问题实际上就转化成了，寻找左边（或右边）最近的比它大的元素。</p>\n<p>自然而然，我们应该使用单调递减栈（严格单调递减）：每遍历到一个元素的时候，不断出栈直到栈空或者栈顶元素大于该元素。</p>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">trap</span>(<span class=\"params\">height: <span class=\"built_in\">number</span>[]</span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> n = height.length;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> left = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(n);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> right = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(n);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> s = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 出栈，直到栈空或者栈顶元素&gt;该元素</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (s.length != <span class=\"number\">0</span> &amp;&amp; height[s[s.length - <span class=\"number\">1</span>]] &lt;= height[i]) &#123;</span><br><span class=\"line\">            s.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            left[i] = height[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            left[i] = left[s[s.length - <span class=\"number\">1</span>]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        s.push(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s.splice(<span class=\"number\">0</span>, s.length);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 出栈，直到栈空或者栈顶元素&gt;该元素</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (s.length != <span class=\"number\">0</span> &amp;&amp; height[s[s.length - <span class=\"number\">1</span>]] &lt;= height[i]) &#123;</span><br><span class=\"line\">            s.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            right[i] = height[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            right[i] = right[s[s.length - <span class=\"number\">1</span>]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        s.push(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        ans += <span class=\"built_in\">Math</span>.min(left[i], right[i]) - height[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"数据结构总复习（1）——数组、链表、队列、栈和稀疏矩阵","date":"2021-01-04T16:00:00.000Z","description":"复习专辑","cover":"https://s3.ax1x.com/2021/01/05/sk0Own.jpg","_content":"\n> 数据结构复习\n>\n> 由于复习比较个人向，因此主要记录的是我容易混淆的知识点以及自己一直记不住的一些题\n>\n> 另外题目基本全部来自某考研复习资料，因此建议辅助该书学习为佳\n\n\n\n# 数组和链表\n\n## 重要知识点\n\n略\n\n\n\n## 题目\n\n> 1.找出数组中出现次数最多的元素\n\n**时间复杂度：O(N)**\n\n**空间复杂度：O（1）**\n\n依次扫描所给数组中的每个整数，将第一个遇到的整数Num保存到c中，记录Num出现的次数为1；若遇到的下一个整数仍等于Num，则计数加1，否则计数减1；当计数减到0时，将遇到的下一个整数保存到c中，计数重新记为1，开始新一轮计数，即从当前位置开始重复上述过程，直到扫描全部数组元素。\n\n\n\n> 2.求两个等长升序序列合并后的中位数\n\n**时间复杂度：O（logN）**\n\n**空间复杂度：O（1）**\n\n分别求两个升序序列A、B的中位数，设为a和b，求序列A、B的中位数过程如下：\n\n（1）若a=b，则a或b即为所求中位数，算法结束；\n\n（2）若a<b，则舍弃序列A中较小的一半，同时舍弃序列B中较大的一半，要求两次舍弃的长度相等；\n\n（3）若a>b，则舍弃序列A中较大的一半，同时舍弃序列B中较小的一半，要求两次舍弃的长度相等；\n\n在保留的两个升序序列中，重复过程（1）~（3），直到两个序列中均只含一个元素时为止，较小者即为所求的中位数。\n\n\n\n> 3.从尾到头反向输出带头结点的单链表中每个结点的值\n\n**时间复杂度：O（N）**\n\n**空间复杂度：O（N）**\n\n利用递归函数，思路如下：\n\n```c++\nvoid R_Print(LinkList L)\n{\n    if (L->next != nullptr)\n        R_print(L->next);\n    if (L!=nullptr)\n        cout<<L->data<<\" \";\n}\n```\n\n\n\n> 4.将带头结点的单链表就地逆置。\n\n**时间复杂度：O（N）**\n\n**空间复杂度：O（1）**\n\n将头结点摘下，然后从第一个结点开始，依次插入到头结点之后（即头插法建立单链表）。\n\n\n\n> 5.给定两个单链表，找出两个链表的公共结点。\n\n**时间复杂度：O（len1+len2)**\n\n**空间复杂度：O（1）**\n\n由于两个链表有一个公共结点，则该公共结点之后的所有结点都是重合的。\n\n因此假设一个链表比另一个链表长k个结点，只需在较长的链表上先遍历k个结点，然后再同步遍历。接下来，一一比较即可找出公共结点。\n\n\n\n> 6.**遍历一遍**找出带头结点的单链表倒数第k个结点。\n\n定义两个指针变量p和q，初始时均指向头结点的下一个结点（链表的第一个结点），p指针沿链表移动；当p指针移动到第k个结点时，q指针开始与p指针同步移动；当p指针移动到最后一个结点时，q指针所指结点为倒数第k个结点。**关键：让一个结点先走一定距离。**\n\n\n\n> 7.将线性表L=(a1,a2,...,an-2,an-1,an)重新排列为L'=(a1,an,a2,an-1,a3,an-2...)。\n\n**时间复杂度：O（N）**\n\n**空间复杂度：O（1）**\n\n分为三个重要的步骤：\n\n（1）找出链表L的中间结点：与第6题思路相同，设置两个指针p和q，指针p每走一步，q走两步。当指针q到达链表尾的时候，p恰好在链表的中间结点位置；\n\n（2）原地逆置：参考第4题思路，利用头插法逆置；\n\n（3）从单链表前后两段各取一个结点，按要求重排。\n\n以上三步时间复杂度均为O（N），因此总的时间复杂度也为O（N)。\n\n\n\n# 栈和队列\n\n## 重要知识点\n\n1.n个不同元素进栈，出栈元素不同排列的个数为1/(n+1)*C(2n,n)\n\n2.顺序表存储的队列（**依照ppt**）：\n\nfront指向队头元素的前一个元素，rear指向队尾元素\n\n[![skAnH0.jpg](https://s3.ax1x.com/2021/01/05/skAnH0.jpg)](https://imgchr.com/i/skAnH0)\n\n3.循环队列：\n\n[![skVhcQ.jpg](https://s3.ax1x.com/2021/01/05/skVhcQ.jpg)](https://imgchr.com/i/skVhcQ)\n\n- 队头指针进1: front = (front + 1) % maxSize; \n- 队尾指针进1: rear = (rear + 1) % maxSize ; \n- 队列初始化：front = rear = 0; \n- 队空条件：front == rear; \n- 队满条件：(rear + 1) % maxSize\n\n4.队列中，注意入队只改变rear的值，出队只改变front的值。\n\n5.运算符优先级（中缀表达式转后缀表达式）：\n\n|     操作符      |  (   | *,/  | +,-  |  )   |\n| :-------------: | :--: | :--: | :--: | :--: |\n| isp(栈内优先级) |  1   |  5   |  3   |  6   |\n| icp(栈外优先级) |  6   |  4   |  2   |  1   |\n\n​\t读取字符ch：\n\n- 若ch是操作数，则直接输出，同时继续读取；\n- 若ch是操作符，则需要判断ch的优先级icp和当前位于栈顶的操作符op的优先级isp，执行下面的循环过程：\n  - 若icp(ch)>isp(op)，则ch进栈，继续读取；\n  - 若icp(ch)<isp(op)，则退栈并输出；\n  - 若icp(ch)==isp(op)，退栈但不输出，若退出的是'('则继续读取。\n\n\n\n## 题目\n\n> 1.若一个栈的输入序列是P1,P2,...Pn,输出序列是1,2,3,...n，若P3=1，则P1的值？\n\nP1可以取除了2以外的所有值。\n\nP2可以取除了n以外的所有值。\n\nP4可以取除了n-1,n以外的所有值。\n\n\n\n> 2.一个栈的入栈序列为1,2,3,...,n，出栈数列是P1,P2,P3,...,Pn。若P2=1,则P3的可能取值个数为多少？\n\nn-1个。\n\n很显然：3之后的4,5,...,n都是P3可取的数（持续进栈直到该数入栈后立即出栈）。\n\n接下来考虑1和2：当P1=1时，P3可取2；当P1=2时，P3可取1。\n\n\n\n> 3.若用数组A[0...5]来实现循环队列，且当前rear和front的值分别为1和5，当从队列中删除一个元素，再加入两个元素后，rear和front的值分别为？\n\n3和0。本题需要注意的是从循环队列中删除操作的方法是front=(front+1)%maxSize，注意不要反向。\n\n\n\n# 稀疏矩阵\n\n## 重要知识点\n\n1.稀疏矩阵中采用结构体存储数据：\n\n```c++\nstruct Trituple\n{\n    int row,col; //非零元素所在的行号、列号\n    Type value; //非零元素的值\n}\n```\n\n2.快速转置算法：\n\n> 建立辅助数组rowSize 和 rowStart，记录矩阵转置后各行**非零元素个数**和**各行元素在转置三元组表中开始存放位置**。\n>\n> 扫描矩阵三元组表，根据某项的列号，确定它转置后的行号，查 **rowStart**表，按查到的 位置直接将该项存入转置三元组表中。 ","source":"_posts/数据结构复习.md","raw":"---\ntitle: 数据结构总复习（1）——数组、链表、队列、栈和稀疏矩阵\ndate: 2021-1-5 00:00:00\ndescription: 复习专辑\ncover: https://s3.ax1x.com/2021/01/05/sk0Own.jpg\n---\n\n> 数据结构复习\n>\n> 由于复习比较个人向，因此主要记录的是我容易混淆的知识点以及自己一直记不住的一些题\n>\n> 另外题目基本全部来自某考研复习资料，因此建议辅助该书学习为佳\n\n\n\n# 数组和链表\n\n## 重要知识点\n\n略\n\n\n\n## 题目\n\n> 1.找出数组中出现次数最多的元素\n\n**时间复杂度：O(N)**\n\n**空间复杂度：O（1）**\n\n依次扫描所给数组中的每个整数，将第一个遇到的整数Num保存到c中，记录Num出现的次数为1；若遇到的下一个整数仍等于Num，则计数加1，否则计数减1；当计数减到0时，将遇到的下一个整数保存到c中，计数重新记为1，开始新一轮计数，即从当前位置开始重复上述过程，直到扫描全部数组元素。\n\n\n\n> 2.求两个等长升序序列合并后的中位数\n\n**时间复杂度：O（logN）**\n\n**空间复杂度：O（1）**\n\n分别求两个升序序列A、B的中位数，设为a和b，求序列A、B的中位数过程如下：\n\n（1）若a=b，则a或b即为所求中位数，算法结束；\n\n（2）若a<b，则舍弃序列A中较小的一半，同时舍弃序列B中较大的一半，要求两次舍弃的长度相等；\n\n（3）若a>b，则舍弃序列A中较大的一半，同时舍弃序列B中较小的一半，要求两次舍弃的长度相等；\n\n在保留的两个升序序列中，重复过程（1）~（3），直到两个序列中均只含一个元素时为止，较小者即为所求的中位数。\n\n\n\n> 3.从尾到头反向输出带头结点的单链表中每个结点的值\n\n**时间复杂度：O（N）**\n\n**空间复杂度：O（N）**\n\n利用递归函数，思路如下：\n\n```c++\nvoid R_Print(LinkList L)\n{\n    if (L->next != nullptr)\n        R_print(L->next);\n    if (L!=nullptr)\n        cout<<L->data<<\" \";\n}\n```\n\n\n\n> 4.将带头结点的单链表就地逆置。\n\n**时间复杂度：O（N）**\n\n**空间复杂度：O（1）**\n\n将头结点摘下，然后从第一个结点开始，依次插入到头结点之后（即头插法建立单链表）。\n\n\n\n> 5.给定两个单链表，找出两个链表的公共结点。\n\n**时间复杂度：O（len1+len2)**\n\n**空间复杂度：O（1）**\n\n由于两个链表有一个公共结点，则该公共结点之后的所有结点都是重合的。\n\n因此假设一个链表比另一个链表长k个结点，只需在较长的链表上先遍历k个结点，然后再同步遍历。接下来，一一比较即可找出公共结点。\n\n\n\n> 6.**遍历一遍**找出带头结点的单链表倒数第k个结点。\n\n定义两个指针变量p和q，初始时均指向头结点的下一个结点（链表的第一个结点），p指针沿链表移动；当p指针移动到第k个结点时，q指针开始与p指针同步移动；当p指针移动到最后一个结点时，q指针所指结点为倒数第k个结点。**关键：让一个结点先走一定距离。**\n\n\n\n> 7.将线性表L=(a1,a2,...,an-2,an-1,an)重新排列为L'=(a1,an,a2,an-1,a3,an-2...)。\n\n**时间复杂度：O（N）**\n\n**空间复杂度：O（1）**\n\n分为三个重要的步骤：\n\n（1）找出链表L的中间结点：与第6题思路相同，设置两个指针p和q，指针p每走一步，q走两步。当指针q到达链表尾的时候，p恰好在链表的中间结点位置；\n\n（2）原地逆置：参考第4题思路，利用头插法逆置；\n\n（3）从单链表前后两段各取一个结点，按要求重排。\n\n以上三步时间复杂度均为O（N），因此总的时间复杂度也为O（N)。\n\n\n\n# 栈和队列\n\n## 重要知识点\n\n1.n个不同元素进栈，出栈元素不同排列的个数为1/(n+1)*C(2n,n)\n\n2.顺序表存储的队列（**依照ppt**）：\n\nfront指向队头元素的前一个元素，rear指向队尾元素\n\n[![skAnH0.jpg](https://s3.ax1x.com/2021/01/05/skAnH0.jpg)](https://imgchr.com/i/skAnH0)\n\n3.循环队列：\n\n[![skVhcQ.jpg](https://s3.ax1x.com/2021/01/05/skVhcQ.jpg)](https://imgchr.com/i/skVhcQ)\n\n- 队头指针进1: front = (front + 1) % maxSize; \n- 队尾指针进1: rear = (rear + 1) % maxSize ; \n- 队列初始化：front = rear = 0; \n- 队空条件：front == rear; \n- 队满条件：(rear + 1) % maxSize\n\n4.队列中，注意入队只改变rear的值，出队只改变front的值。\n\n5.运算符优先级（中缀表达式转后缀表达式）：\n\n|     操作符      |  (   | *,/  | +,-  |  )   |\n| :-------------: | :--: | :--: | :--: | :--: |\n| isp(栈内优先级) |  1   |  5   |  3   |  6   |\n| icp(栈外优先级) |  6   |  4   |  2   |  1   |\n\n​\t读取字符ch：\n\n- 若ch是操作数，则直接输出，同时继续读取；\n- 若ch是操作符，则需要判断ch的优先级icp和当前位于栈顶的操作符op的优先级isp，执行下面的循环过程：\n  - 若icp(ch)>isp(op)，则ch进栈，继续读取；\n  - 若icp(ch)<isp(op)，则退栈并输出；\n  - 若icp(ch)==isp(op)，退栈但不输出，若退出的是'('则继续读取。\n\n\n\n## 题目\n\n> 1.若一个栈的输入序列是P1,P2,...Pn,输出序列是1,2,3,...n，若P3=1，则P1的值？\n\nP1可以取除了2以外的所有值。\n\nP2可以取除了n以外的所有值。\n\nP4可以取除了n-1,n以外的所有值。\n\n\n\n> 2.一个栈的入栈序列为1,2,3,...,n，出栈数列是P1,P2,P3,...,Pn。若P2=1,则P3的可能取值个数为多少？\n\nn-1个。\n\n很显然：3之后的4,5,...,n都是P3可取的数（持续进栈直到该数入栈后立即出栈）。\n\n接下来考虑1和2：当P1=1时，P3可取2；当P1=2时，P3可取1。\n\n\n\n> 3.若用数组A[0...5]来实现循环队列，且当前rear和front的值分别为1和5，当从队列中删除一个元素，再加入两个元素后，rear和front的值分别为？\n\n3和0。本题需要注意的是从循环队列中删除操作的方法是front=(front+1)%maxSize，注意不要反向。\n\n\n\n# 稀疏矩阵\n\n## 重要知识点\n\n1.稀疏矩阵中采用结构体存储数据：\n\n```c++\nstruct Trituple\n{\n    int row,col; //非零元素所在的行号、列号\n    Type value; //非零元素的值\n}\n```\n\n2.快速转置算法：\n\n> 建立辅助数组rowSize 和 rowStart，记录矩阵转置后各行**非零元素个数**和**各行元素在转置三元组表中开始存放位置**。\n>\n> 扫描矩阵三元组表，根据某项的列号，确定它转置后的行号，查 **rowStart**表，按查到的 位置直接将该项存入转置三元组表中。 ","slug":"数据结构复习","published":1,"updated":"2021-01-05T08:53:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clrfw2jfh0009stfa7kaqbkbw","content":"<blockquote>\n<p>数据结构复习</p>\n<p>由于复习比较个人向，因此主要记录的是我容易混淆的知识点以及自己一直记不住的一些题</p>\n<p>另外题目基本全部来自某考研复习资料，因此建议辅助该书学习为佳</p>\n</blockquote>\n<h1 id=\"数组和链表\"><a href=\"#数组和链表\" class=\"headerlink\" title=\"数组和链表\"></a>数组和链表</h1><h2 id=\"重要知识点\"><a href=\"#重要知识点\" class=\"headerlink\" title=\"重要知识点\"></a>重要知识点</h2><p>略</p>\n<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><blockquote>\n<p>1.找出数组中出现次数最多的元素</p>\n</blockquote>\n<p><strong>时间复杂度：O(N)</strong></p>\n<p><strong>空间复杂度：O（1）</strong></p>\n<p>依次扫描所给数组中的每个整数，将第一个遇到的整数Num保存到c中，记录Num出现的次数为1；若遇到的下一个整数仍等于Num，则计数加1，否则计数减1；当计数减到0时，将遇到的下一个整数保存到c中，计数重新记为1，开始新一轮计数，即从当前位置开始重复上述过程，直到扫描全部数组元素。</p>\n<blockquote>\n<p>2.求两个等长升序序列合并后的中位数</p>\n</blockquote>\n<p><strong>时间复杂度：O（logN）</strong></p>\n<p><strong>空间复杂度：O（1）</strong></p>\n<p>分别求两个升序序列A、B的中位数，设为a和b，求序列A、B的中位数过程如下：</p>\n<p>（1）若a=b，则a或b即为所求中位数，算法结束；</p>\n<p>（2）若a&lt;b，则舍弃序列A中较小的一半，同时舍弃序列B中较大的一半，要求两次舍弃的长度相等；</p>\n<p>（3）若a&gt;b，则舍弃序列A中较大的一半，同时舍弃序列B中较小的一半，要求两次舍弃的长度相等；</p>\n<p>在保留的两个升序序列中，重复过程（1）~（3），直到两个序列中均只含一个元素时为止，较小者即为所求的中位数。</p>\n<blockquote>\n<p>3.从尾到头反向输出带头结点的单链表中每个结点的值</p>\n</blockquote>\n<p><strong>时间复杂度：O（N）</strong></p>\n<p><strong>空间复杂度：O（N）</strong></p>\n<p>利用递归函数，思路如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">R_Print</span><span class=\"params\">(LinkList L)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (L-&gt;next != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        R_print(L-&gt;next);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (L!=<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;L-&gt;data&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<blockquote>\n<p>4.将带头结点的单链表就地逆置。</p>\n</blockquote>\n<p><strong>时间复杂度：O（N）</strong></p>\n<p><strong>空间复杂度：O（1）</strong></p>\n<p>将头结点摘下，然后从第一个结点开始，依次插入到头结点之后（即头插法建立单链表）。</p>\n<blockquote>\n<p>5.给定两个单链表，找出两个链表的公共结点。</p>\n</blockquote>\n<p><strong>时间复杂度：O（len1+len2)</strong></p>\n<p><strong>空间复杂度：O（1）</strong></p>\n<p>由于两个链表有一个公共结点，则该公共结点之后的所有结点都是重合的。</p>\n<p>因此假设一个链表比另一个链表长k个结点，只需在较长的链表上先遍历k个结点，然后再同步遍历。接下来，一一比较即可找出公共结点。</p>\n<blockquote>\n<p>6.<strong>遍历一遍</strong>找出带头结点的单链表倒数第k个结点。</p>\n</blockquote>\n<p>定义两个指针变量p和q，初始时均指向头结点的下一个结点（链表的第一个结点），p指针沿链表移动；当p指针移动到第k个结点时，q指针开始与p指针同步移动；当p指针移动到最后一个结点时，q指针所指结点为倒数第k个结点。<strong>关键：让一个结点先走一定距离。</strong></p>\n<blockquote>\n<p>7.将线性表L=(a1,a2,…,an-2,an-1,an)重新排列为L’=(a1,an,a2,an-1,a3,an-2…)。</p>\n</blockquote>\n<p><strong>时间复杂度：O（N）</strong></p>\n<p><strong>空间复杂度：O（1）</strong></p>\n<p>分为三个重要的步骤：</p>\n<p>（1）找出链表L的中间结点：与第6题思路相同，设置两个指针p和q，指针p每走一步，q走两步。当指针q到达链表尾的时候，p恰好在链表的中间结点位置；</p>\n<p>（2）原地逆置：参考第4题思路，利用头插法逆置；</p>\n<p>（3）从单链表前后两段各取一个结点，按要求重排。</p>\n<p>以上三步时间复杂度均为O（N），因此总的时间复杂度也为O（N)。</p>\n<h1 id=\"栈和队列\"><a href=\"#栈和队列\" class=\"headerlink\" title=\"栈和队列\"></a>栈和队列</h1><h2 id=\"重要知识点-1\"><a href=\"#重要知识点-1\" class=\"headerlink\" title=\"重要知识点\"></a>重要知识点</h2><p>1.n个不同元素进栈，出栈元素不同排列的个数为1/(n+1)*C(2n,n)</p>\n<p>2.顺序表存储的队列（<strong>依照ppt</strong>）：</p>\n<p>front指向队头元素的前一个元素，rear指向队尾元素</p>\n<p><a href=\"https://imgchr.com/i/skAnH0\"><img src=\"https://s3.ax1x.com/2021/01/05/skAnH0.jpg\" alt=\"skAnH0.jpg\"></a></p>\n<p>3.循环队列：</p>\n<p><a href=\"https://imgchr.com/i/skVhcQ\"><img src=\"https://s3.ax1x.com/2021/01/05/skVhcQ.jpg\" alt=\"skVhcQ.jpg\"></a></p>\n<ul>\n<li>队头指针进1: front = (front + 1) % maxSize; </li>\n<li>队尾指针进1: rear = (rear + 1) % maxSize ; </li>\n<li>队列初始化：front = rear = 0; </li>\n<li>队空条件：front == rear; </li>\n<li>队满条件：(rear + 1) % maxSize</li>\n</ul>\n<p>4.队列中，注意入队只改变rear的值，出队只改变front的值。</p>\n<p>5.运算符优先级（中缀表达式转后缀表达式）：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">操作符</th>\n<th align=\"center\">(</th>\n<th align=\"center\">*,/</th>\n<th align=\"center\">+,-</th>\n<th align=\"center\">)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">isp(栈内优先级)</td>\n<td align=\"center\">1</td>\n<td align=\"center\">5</td>\n<td align=\"center\">3</td>\n<td align=\"center\">6</td>\n</tr>\n<tr>\n<td align=\"center\">icp(栈外优先级)</td>\n<td align=\"center\">6</td>\n<td align=\"center\">4</td>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n</tr>\n</tbody></table>\n<p>​    读取字符ch：</p>\n<ul>\n<li>若ch是操作数，则直接输出，同时继续读取；</li>\n<li>若ch是操作符，则需要判断ch的优先级icp和当前位于栈顶的操作符op的优先级isp，执行下面的循环过程：<ul>\n<li>若icp(ch)&gt;isp(op)，则ch进栈，继续读取；</li>\n<li>若icp(ch)&lt;isp(op)，则退栈并输出；</li>\n<li>若icp(ch)==isp(op)，退栈但不输出，若退出的是’(‘则继续读取。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"题目-1\"><a href=\"#题目-1\" class=\"headerlink\" title=\"题目\"></a>题目</h2><blockquote>\n<p>1.若一个栈的输入序列是P1,P2,…Pn,输出序列是1,2,3,…n，若P3=1，则P1的值？</p>\n</blockquote>\n<p>P1可以取除了2以外的所有值。</p>\n<p>P2可以取除了n以外的所有值。</p>\n<p>P4可以取除了n-1,n以外的所有值。</p>\n<blockquote>\n<p>2.一个栈的入栈序列为1,2,3,…,n，出栈数列是P1,P2,P3,…,Pn。若P2=1,则P3的可能取值个数为多少？</p>\n</blockquote>\n<p>n-1个。</p>\n<p>很显然：3之后的4,5,…,n都是P3可取的数（持续进栈直到该数入栈后立即出栈）。</p>\n<p>接下来考虑1和2：当P1=1时，P3可取2；当P1=2时，P3可取1。</p>\n<blockquote>\n<p>3.若用数组A[0…5]来实现循环队列，且当前rear和front的值分别为1和5，当从队列中删除一个元素，再加入两个元素后，rear和front的值分别为？</p>\n</blockquote>\n<p>3和0。本题需要注意的是从循环队列中删除操作的方法是front=(front+1)%maxSize，注意不要反向。</p>\n<h1 id=\"稀疏矩阵\"><a href=\"#稀疏矩阵\" class=\"headerlink\" title=\"稀疏矩阵\"></a>稀疏矩阵</h1><h2 id=\"重要知识点-2\"><a href=\"#重要知识点-2\" class=\"headerlink\" title=\"重要知识点\"></a>重要知识点</h2><p>1.稀疏矩阵中采用结构体存储数据：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Trituple</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> row,col; <span class=\"comment\">//非零元素所在的行号、列号</span></span><br><span class=\"line\">    Type value; <span class=\"comment\">//非零元素的值</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2.快速转置算法：</p>\n<blockquote>\n<p>建立辅助数组rowSize 和 rowStart，记录矩阵转置后各行<strong>非零元素个数</strong>和<strong>各行元素在转置三元组表中开始存放位置</strong>。</p>\n<p>扫描矩阵三元组表，根据某项的列号，确定它转置后的行号，查 <strong>rowStart</strong>表，按查到的 位置直接将该项存入转置三元组表中。 </p>\n</blockquote>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<blockquote>\n<p>数据结构复习</p>\n<p>由于复习比较个人向，因此主要记录的是我容易混淆的知识点以及自己一直记不住的一些题</p>\n<p>另外题目基本全部来自某考研复习资料，因此建议辅助该书学习为佳</p>\n</blockquote>\n<h1 id=\"数组和链表\"><a href=\"#数组和链表\" class=\"headerlink\" title=\"数组和链表\"></a>数组和链表</h1><h2 id=\"重要知识点\"><a href=\"#重要知识点\" class=\"headerlink\" title=\"重要知识点\"></a>重要知识点</h2><p>略</p>\n<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><blockquote>\n<p>1.找出数组中出现次数最多的元素</p>\n</blockquote>\n<p><strong>时间复杂度：O(N)</strong></p>\n<p><strong>空间复杂度：O（1）</strong></p>\n<p>依次扫描所给数组中的每个整数，将第一个遇到的整数Num保存到c中，记录Num出现的次数为1；若遇到的下一个整数仍等于Num，则计数加1，否则计数减1；当计数减到0时，将遇到的下一个整数保存到c中，计数重新记为1，开始新一轮计数，即从当前位置开始重复上述过程，直到扫描全部数组元素。</p>\n<blockquote>\n<p>2.求两个等长升序序列合并后的中位数</p>\n</blockquote>\n<p><strong>时间复杂度：O（logN）</strong></p>\n<p><strong>空间复杂度：O（1）</strong></p>\n<p>分别求两个升序序列A、B的中位数，设为a和b，求序列A、B的中位数过程如下：</p>\n<p>（1）若a=b，则a或b即为所求中位数，算法结束；</p>\n<p>（2）若a&lt;b，则舍弃序列A中较小的一半，同时舍弃序列B中较大的一半，要求两次舍弃的长度相等；</p>\n<p>（3）若a&gt;b，则舍弃序列A中较大的一半，同时舍弃序列B中较小的一半，要求两次舍弃的长度相等；</p>\n<p>在保留的两个升序序列中，重复过程（1）~（3），直到两个序列中均只含一个元素时为止，较小者即为所求的中位数。</p>\n<blockquote>\n<p>3.从尾到头反向输出带头结点的单链表中每个结点的值</p>\n</blockquote>\n<p><strong>时间复杂度：O（N）</strong></p>\n<p><strong>空间复杂度：O（N）</strong></p>\n<p>利用递归函数，思路如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">R_Print</span><span class=\"params\">(LinkList L)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (L-&gt;next != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        R_print(L-&gt;next);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (L!=<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;L-&gt;data&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<blockquote>\n<p>4.将带头结点的单链表就地逆置。</p>\n</blockquote>\n<p><strong>时间复杂度：O（N）</strong></p>\n<p><strong>空间复杂度：O（1）</strong></p>\n<p>将头结点摘下，然后从第一个结点开始，依次插入到头结点之后（即头插法建立单链表）。</p>\n<blockquote>\n<p>5.给定两个单链表，找出两个链表的公共结点。</p>\n</blockquote>\n<p><strong>时间复杂度：O（len1+len2)</strong></p>\n<p><strong>空间复杂度：O（1）</strong></p>\n<p>由于两个链表有一个公共结点，则该公共结点之后的所有结点都是重合的。</p>\n<p>因此假设一个链表比另一个链表长k个结点，只需在较长的链表上先遍历k个结点，然后再同步遍历。接下来，一一比较即可找出公共结点。</p>\n<blockquote>\n<p>6.<strong>遍历一遍</strong>找出带头结点的单链表倒数第k个结点。</p>\n</blockquote>\n<p>定义两个指针变量p和q，初始时均指向头结点的下一个结点（链表的第一个结点），p指针沿链表移动；当p指针移动到第k个结点时，q指针开始与p指针同步移动；当p指针移动到最后一个结点时，q指针所指结点为倒数第k个结点。<strong>关键：让一个结点先走一定距离。</strong></p>\n<blockquote>\n<p>7.将线性表L=(a1,a2,…,an-2,an-1,an)重新排列为L’=(a1,an,a2,an-1,a3,an-2…)。</p>\n</blockquote>\n<p><strong>时间复杂度：O（N）</strong></p>\n<p><strong>空间复杂度：O（1）</strong></p>\n<p>分为三个重要的步骤：</p>\n<p>（1）找出链表L的中间结点：与第6题思路相同，设置两个指针p和q，指针p每走一步，q走两步。当指针q到达链表尾的时候，p恰好在链表的中间结点位置；</p>\n<p>（2）原地逆置：参考第4题思路，利用头插法逆置；</p>\n<p>（3）从单链表前后两段各取一个结点，按要求重排。</p>\n<p>以上三步时间复杂度均为O（N），因此总的时间复杂度也为O（N)。</p>\n<h1 id=\"栈和队列\"><a href=\"#栈和队列\" class=\"headerlink\" title=\"栈和队列\"></a>栈和队列</h1><h2 id=\"重要知识点-1\"><a href=\"#重要知识点-1\" class=\"headerlink\" title=\"重要知识点\"></a>重要知识点</h2><p>1.n个不同元素进栈，出栈元素不同排列的个数为1/(n+1)*C(2n,n)</p>\n<p>2.顺序表存储的队列（<strong>依照ppt</strong>）：</p>\n<p>front指向队头元素的前一个元素，rear指向队尾元素</p>\n<p><a href=\"https://imgchr.com/i/skAnH0\"><img src=\"https://s3.ax1x.com/2021/01/05/skAnH0.jpg\" alt=\"skAnH0.jpg\"></a></p>\n<p>3.循环队列：</p>\n<p><a href=\"https://imgchr.com/i/skVhcQ\"><img src=\"https://s3.ax1x.com/2021/01/05/skVhcQ.jpg\" alt=\"skVhcQ.jpg\"></a></p>\n<ul>\n<li>队头指针进1: front = (front + 1) % maxSize; </li>\n<li>队尾指针进1: rear = (rear + 1) % maxSize ; </li>\n<li>队列初始化：front = rear = 0; </li>\n<li>队空条件：front == rear; </li>\n<li>队满条件：(rear + 1) % maxSize</li>\n</ul>\n<p>4.队列中，注意入队只改变rear的值，出队只改变front的值。</p>\n<p>5.运算符优先级（中缀表达式转后缀表达式）：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">操作符</th>\n<th align=\"center\">(</th>\n<th align=\"center\">*,/</th>\n<th align=\"center\">+,-</th>\n<th align=\"center\">)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">isp(栈内优先级)</td>\n<td align=\"center\">1</td>\n<td align=\"center\">5</td>\n<td align=\"center\">3</td>\n<td align=\"center\">6</td>\n</tr>\n<tr>\n<td align=\"center\">icp(栈外优先级)</td>\n<td align=\"center\">6</td>\n<td align=\"center\">4</td>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n</tr>\n</tbody></table>\n<p>​    读取字符ch：</p>\n<ul>\n<li>若ch是操作数，则直接输出，同时继续读取；</li>\n<li>若ch是操作符，则需要判断ch的优先级icp和当前位于栈顶的操作符op的优先级isp，执行下面的循环过程：<ul>\n<li>若icp(ch)&gt;isp(op)，则ch进栈，继续读取；</li>\n<li>若icp(ch)&lt;isp(op)，则退栈并输出；</li>\n<li>若icp(ch)==isp(op)，退栈但不输出，若退出的是’(‘则继续读取。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"题目-1\"><a href=\"#题目-1\" class=\"headerlink\" title=\"题目\"></a>题目</h2><blockquote>\n<p>1.若一个栈的输入序列是P1,P2,…Pn,输出序列是1,2,3,…n，若P3=1，则P1的值？</p>\n</blockquote>\n<p>P1可以取除了2以外的所有值。</p>\n<p>P2可以取除了n以外的所有值。</p>\n<p>P4可以取除了n-1,n以外的所有值。</p>\n<blockquote>\n<p>2.一个栈的入栈序列为1,2,3,…,n，出栈数列是P1,P2,P3,…,Pn。若P2=1,则P3的可能取值个数为多少？</p>\n</blockquote>\n<p>n-1个。</p>\n<p>很显然：3之后的4,5,…,n都是P3可取的数（持续进栈直到该数入栈后立即出栈）。</p>\n<p>接下来考虑1和2：当P1=1时，P3可取2；当P1=2时，P3可取1。</p>\n<blockquote>\n<p>3.若用数组A[0…5]来实现循环队列，且当前rear和front的值分别为1和5，当从队列中删除一个元素，再加入两个元素后，rear和front的值分别为？</p>\n</blockquote>\n<p>3和0。本题需要注意的是从循环队列中删除操作的方法是front=(front+1)%maxSize，注意不要反向。</p>\n<h1 id=\"稀疏矩阵\"><a href=\"#稀疏矩阵\" class=\"headerlink\" title=\"稀疏矩阵\"></a>稀疏矩阵</h1><h2 id=\"重要知识点-2\"><a href=\"#重要知识点-2\" class=\"headerlink\" title=\"重要知识点\"></a>重要知识点</h2><p>1.稀疏矩阵中采用结构体存储数据：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Trituple</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> row,col; <span class=\"comment\">//非零元素所在的行号、列号</span></span><br><span class=\"line\">    Type value; <span class=\"comment\">//非零元素的值</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2.快速转置算法：</p>\n<blockquote>\n<p>建立辅助数组rowSize 和 rowStart，记录矩阵转置后各行<strong>非零元素个数</strong>和<strong>各行元素在转置三元组表中开始存放位置</strong>。</p>\n<p>扫描矩阵三元组表，根据某项的列号，确定它转置后的行号，查 <strong>rowStart</strong>表，按查到的 位置直接将该项存入转置三元组表中。 </p>\n</blockquote>\n"},{"title":"四种平衡二叉树","date":"2021-01-06T14:00:00.000Z","description":"速来学习","cover":"https://s3.ax1x.com/2021/01/06/sZE6yD.png","_content":"\n二叉树（Binary Tree）指的是树中结点的度不大于2的有序树，其递归定义是：二叉树是一棵空树，或者是一棵由一个根节点和两棵互不相交的，分别称作根的左子树和右子树组成的非空树；左子树和右子树同样也是二叉树。\n\n二叉树是树形结构的一个重要类型，许多实际问题抽象出来的数据结构往往都是二叉树的类型。即使是一般的树也可以转化为二叉树，并且二叉树的存储结构和算法相对而言都比较简单。因此研究二叉树对于研究数据结构有着重要的意义。\n\n基于二叉树在数据结构中的重要作用，本篇文章中将探讨二叉树的一个重要应用，即作为二叉搜索树时能够发挥的作用。同时，本文也进一步探讨研究了较常使用的平衡二叉树和六种不同的平衡二叉树的性能并对其做了对比分析，为未来计算机应用提供了可供参考的意见。\n\n# **1**  **二叉搜索树**\n\n## **1.1**  二叉搜索树（BST）\n\n二叉搜索树（Binary Search Tree）又称二叉查找树或二叉排序树。作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势。\n\n二叉搜索树的定义也是递归的。它是一棵空树，或者是满足下列性质的二叉树：\n\n1. 每个结点都有一个作为搜索依据的关键码（key），所有节点的关键码互不相同；\n2. 左子树（如果存在）上所有结点的关键码都小于根；\n3. 右子树（如果存在）上所有结点的关键码都大于根；\n4. 左子树和右子树也是一棵二叉搜索树。\n\n如下图所示，就是一棵标准的二叉搜索树：\n\n[![sZAigU.png](https://s3.ax1x.com/2021/01/06/sZAigU.png)](https://imgchr.com/i/sZAigU)\n\n### 1.1.1 搜索\n\n二叉树的搜索是一个递归的过程，流程图如下所示：\n\n[![sZAeER.png](https://s3.ax1x.com/2021/01/06/sZAeER.png)](https://imgchr.com/i/sZAeER)\n\n从树根出发，逐步的缩小查找范围，直到发现目标（成功）或者缩小至空结点（失败）。对于该过程而言，在二叉搜索树的每一层，查找算法至多访问一个结点，并且只需要常数时间。因此，总体所需时间应当线性正比于查找路径的长度，或最终返回结点的深度。对于规模为n的二叉搜索树，深度在最坏情况下可达(n)。\n\n### 1.1.2 插入\n\n 二叉搜索树的插入的流程图如下所示：\n\n[![sZAEDJ.png](https://s3.ax1x.com/2021/01/06/sZAEDJ.png)](https://imgchr.com/i/sZAEDJ)\n\n为了在二叉搜索树中插入一个结点，首先需要利用其搜索操作查找到插入的位置，然后再将新结点作为叶子结点插入（或者更新已存在结点的值）。由于该操作依赖于搜索操作，因此时间复杂度也为O(n)。\n\n### 1.1.3 删除\n\n二叉搜索树的删除的流程图如下所示：\n\n[![sZAVb9.png](https://s3.ax1x.com/2021/01/06/sZAVb9.png)](https://imgchr.com/i/sZAVb9)\n\n二叉搜索树的删除过程也依赖于其查找过程，故时间复杂度也为O(n)。\n\n## **1.2**  平衡二叉搜索树（BBST）\n\n由于二叉搜索树在最坏情况下可能退化为列表，此时的各种效率降至O(n)。因此如果不能有效的控制树高，二叉搜索树无法体现出明显的优势。因此，需要依照某种宽松的标准，重新定义二叉搜索树的平衡性。\n\n平衡二叉搜索树（Balanced Binary Search Tree）指的是在某种约束条件下，树高渐进地不超过O(logN)。在这一约束条件下，各种操作的时间复杂度即可降低为O(logN)。它为每一个结点v的平衡因子（balance factor）定义为左、右子树的高度差，即\n\n **balFac(v) = height(lc(v)) - height(rc(v))**\n\n下图即为定义了平衡因子的二叉搜索树：\n\n[![sZArrQ.png](https://s3.ax1x.com/2021/01/06/sZArrQ.png)](https://imgchr.com/i/sZArrQ)\n\n通过设定这种约束条件，即可达到搜索树的最佳性能。后续将介绍六种二叉搜索树。\n\n# **2** **六种平衡二叉搜索树**\n\n## **2.1** **高度平衡树（AVL**）\n\nAVL是最早发明自平衡二叉树，它被称作高度平衡树。在ALV树中，任意结点平衡因子的绝对值不超过1，即：\n\n **|balFac(v)|≤1**\n\n### 2.1.1 平衡性\n\n[![sZAhxU.png](https://s3.ax1x.com/2021/01/06/sZAhxU.png)](https://imgchr.com/i/sZAhxU)\n\n如上图所示，不妨设结点数最少的AVL树S的根结点为r，r的左、右子树分别为lc和rc，记规模为|lc|和|rc|，高度为h_l和h_r，则有：\n|S|=1+|lc|+|rc|\n由于S的子树lc和rc也是AVL树，并且高度不超过h-1。因此，不妨取：\nh_l=h-1, h_r=h-2,\n|S|=1+| S_(h-1) |+| S_(h-2) |,\n由归纳假设，可以获得如下关系：\n|S|=1+(fib(h+2)-1)+(fib(h+1)-1)\n而根据Fibonacci数列的定义，可以获得：\n|S|=fib(h+2)+fib(h+1)-1=fib(h+3)-1                          \n因此，可以知道：高度为h的AVL树至少包含fib(h+3)-1个结点。由于fib(h)和n次方正比，于是包含n个结点的AVL树的高度应为O(log⁡n )。\n综上可知，AVL树的确是平衡的。\n\n### 2.1.2 旋转\n\nAVL树的插入过程和一般二叉搜索树的过程相同，即：从树根出发，逐步的缩小查找范围，直到发现目标（成功）或者缩小至空结点（失败）。\n\n不同之处在于，二叉树在插入或者删除时，需要维持其平衡。而维持平衡这一过程，正是通过旋转（Rotate）操作来实现的。AVL树的旋转可以归纳为四种：LL单右旋、RR单左旋、LR先左旋再右旋和RL先右旋再左旋。\n\n- LL单右旋：当失衡位置发生在失衡结点左子树的左子树时，需要进行LL单右旋。\n\n[![sZAIr4.png](https://s3.ax1x.com/2021/01/06/sZAIr4.png)](https://imgchr.com/i/sZAIr4)\n\n- RR单左旋：当失衡位置发生在失衡结点右子树的右子树时，需要进行RR单左旋。\n\n[![sZAjxO.png](https://s3.ax1x.com/2021/01/06/sZAjxO.png)](https://imgchr.com/i/sZAjxO)\n\n- LR先左旋再右旋：当失衡位置发生在失衡结点左子树的右子树时，需要进行LR先左旋再右旋。\n\n[![sZESqH.png](https://s3.ax1x.com/2021/01/06/sZESqH.png)](https://imgchr.com/i/sZESqH)\n\n- RL先右旋再左旋：当失衡位置发生在失衡结点右子树的左子树时，需要进行RL先右旋再左旋。\n\n[![sZEFit.png](https://s3.ax1x.com/2021/01/06/sZEFit.png)](https://imgchr.com/i/sZEFit)\n\n### 2.1.3 性能分析\n\n通过2.1.2的旋转操作，AVL树可以满足其性质的定义，通过2.1.1证明可知：包含n个结点的AVL树的高度应为logn 。\n\n由于二叉搜索树的查找操作时间正比于树高，因此AVL树查找的时间复杂度为O(logN) 。同理，插入和删除的时间复杂度也为(logN)。\n\n## **2.2** **伸展树（ST**）\n\n伸展树（Splay Tree）也叫分裂树，相对于AVL树实现更为简捷。伸展树无需时刻都严格地保持全树的平衡，但却能够在任何足够长的真实操作序列中，保持分摊意义上的高效率。伸展树也不需要对基本的二叉树节点结构，做任何附加的要求或改动，更不需要记录平衡因子或高度之类的额外信息，故适用范围更广。\n\n每次查找节点之后对树进行重构，把被查找的节点搬移到树根。每次对伸展树进行操作后，它均会通过伸展（Splay）的方法使得被访问结点置于根结点的位置。\n\n### 2.2.1 伸展\n\n与普通的二叉搜索树的区别在于，伸展树通过伸展操作将元素调整至根结点的位置。这一调整根据结点所在位置的不同，采用不同的调整方法：\n\n| 情形  |     旋转方法     |\n| :---: | :--------------: |\n| 单R型 |      左旋转      |\n| 单L型 |      右旋转      |\n| RR型  |    两次左旋转    |\n| LL型  |    两次右旋转    |\n| RL型  | 先右旋转再左旋转 |\n| LR型  | 先左旋转再右旋转 |\n\n### 2.2.2 性能分析\n\n伸展树能够在O(log⁡n)内完成插入、查找和删除操作。它在不保证最坏情况下的时间复杂度是O(log⁡n)，其边界是均摊的。但是，它有一个最显著的缺点，即有可能变成一条链，这种情况下时间复杂度高达O(n)。\n\n## **2.3** **红黑树（RBT**）\n\n红黑树（Red Black Tree）是一种自平衡二叉搜索树，它等价于4阶B-树。它实际上是一种特化的AVL，均是在进行插入和删除操作时通过特定操作保持二叉搜索树的平衡，从而获得了较高的查找性能。\n\n红黑树保持适度平衡的关键在于：任一结点左、右子树的高度，相差不得超过两倍。为了保持这一平衡，红黑树为其内部的每一个结点定义了颜色属性黑色或者红色（本文章中红黑树黑底表示黑色结点，白底表示红色结点）。\n\n[![sZEliq.png](https://s3.ax1x.com/2021/01/06/sZEliq.png)](https://imgchr.com/i/sZEliq)\n\n与上述二叉搜索树不同，红黑树引入了外部结点作为叶结点（图11中的黑色矩形即为叶结点），它满足下述性质：\n\n1. 每个结点要么是黑色，要么是红色；\n2. 根结点是黑色的；\n3. 每个叶结点（NIL）是黑色的；\n4. 每个红色结点的两个子结点一定都是黑色的；\n5. 任意一个结点到每个叶结点的路径都包含相同数量的黑色结点。\n\n事实上，正是由于性质（5），红黑树的这种平衡被称作黑色完美平衡。红黑树维持平衡主要依靠三种方法：左旋、右旋和染色（结点的颜色由黑变红或者由红变黑）。\n\n### 2.3.1 平衡性\n\n略\n\n### 2.3.2 三种操作\n\n由于红黑树是一棵二叉搜索树，并且查找并不会破坏树的平衡，因此查找和二叉搜索树的查找无异，是一个递归的过程。\n\n红黑树的插入过程分为两步，第一步是查找到插入位置，第二步则是插入后的自平衡。因此，其插入过程可分为下述情况（如图11所示）：\n\n1. 红黑树为空树：将插入的结点作为根结点，并且染色为黑色；\n\n2. 插入结点的父结点为黑色结点：直接插入即可；\n\n3. 插入结点的父结点为红色结点：\n\n   若叔叔结点存在并且为红色结点，则只需将P和S设置为黑色，PP设置为红色，接下来递归的处理PP结点即可；\n\n   [![sZEJQU.png](https://s3.ax1x.com/2021/01/06/sZEJQU.png)](https://imgchr.com/i/sZEJQU)\n\n   若叔叔结点不存在或者为黑色结点，插入结点是父结点的左子结点，父结点是祖先结点的左子结点。该种情况需要将P设为黑色，PP设为红色，同时对PP进行右旋，如下图所示。其余情况实际为该种情况的对称形式，在此不再赘述。\n\n   [![sZEYyF.png](https://s3.ax1x.com/2021/01/06/sZEYyF.png)](https://imgchr.com/i/sZEYyF)\n\n红黑树的删除过程也是先查找到删除位置，然后通过旋转和染色来实现再次平衡。\n\n## **2.4** **替罪羊树（ST**）\n\n替罪羊树（Scapegoat Tree）不同于上述通过旋转来维持相对平衡的二叉搜索树，它是基于一种暴力重构的操作来保持相对平衡的。\n\n### 2.4.1 平衡因子\n\n替罪羊树中定义了一个平衡因子α的概念，范围在0.5到1之间。当某个结点的总结点数* α <它某个子树的总结点数，便会对该结点执行重构操作。\n对于α的取值，如果α越小，那么对平衡的要求越高，重构的次数会更多；α越大，树的平衡程度越低，重构的次数也会随之减少。一般而言，α取0.7左右比较合适。\n\n### 2.4.2 平衡性\n\n略\n\n### 2.4.3 重构\n\n[![sZEaw9.png](https://s3.ax1x.com/2021/01/06/sZEaw9.png)](https://imgchr.com/i/sZEaw9)\n\n如上图所示的替罪羊树，若平衡因子  ，则结点v已发生失衡。重构过程如下：\n\n1. 将这棵树压扁，存入向量中：\n\n[![sZEsSK.png](https://s3.ax1x.com/2021/01/06/sZEsSK.png)](https://imgchr.com/i/sZEsSK)\n\n​\t2.重新建树：每次取区间中点作为根结点，递归左右两边子树建树：\n\n[![sZE6yD.md.png](https://s3.ax1x.com/2021/01/06/sZE6yD.md.png)](https://imgchr.com/i/sZE6yD)\n\n通过上述操作，替罪羊树即完成了其重构操作。并且由2.4.2中结论可知，每次插入后的重构仍然能保证替罪羊树各种操作的时间复杂度达到  。\n\n# **3** **平衡搜索树的性能对比**\n\n根据上述介绍可以看出，AVL、伸展树、红黑树和替罪羊树分别采取了不同的方法实现了相对平衡，复杂度如表2所示。在实际使用时，应当根据工作情景选用：\n\n|  平衡树  |  时间复杂度  |     应用     |\n| :------: | :----------: | :----------: |\n|   AVL    |   O(log n)   | 最早的平衡树 |\n|  伸展树  | 均摊O(log n) |  对区间操作  |\n|  红黑树  |   O(log n)   | 综合效率最高 |\n| 替罪羊树 |   O(log n)   |   实现较易   |\n\n \n\n","source":"_posts/数据结构论文.md","raw":"---\ntitle: 四种平衡二叉树\ndate: 2021-1-6 22:00:00\ndescription: 速来学习\ncover: https://s3.ax1x.com/2021/01/06/sZE6yD.png\n---\n\n二叉树（Binary Tree）指的是树中结点的度不大于2的有序树，其递归定义是：二叉树是一棵空树，或者是一棵由一个根节点和两棵互不相交的，分别称作根的左子树和右子树组成的非空树；左子树和右子树同样也是二叉树。\n\n二叉树是树形结构的一个重要类型，许多实际问题抽象出来的数据结构往往都是二叉树的类型。即使是一般的树也可以转化为二叉树，并且二叉树的存储结构和算法相对而言都比较简单。因此研究二叉树对于研究数据结构有着重要的意义。\n\n基于二叉树在数据结构中的重要作用，本篇文章中将探讨二叉树的一个重要应用，即作为二叉搜索树时能够发挥的作用。同时，本文也进一步探讨研究了较常使用的平衡二叉树和六种不同的平衡二叉树的性能并对其做了对比分析，为未来计算机应用提供了可供参考的意见。\n\n# **1**  **二叉搜索树**\n\n## **1.1**  二叉搜索树（BST）\n\n二叉搜索树（Binary Search Tree）又称二叉查找树或二叉排序树。作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势。\n\n二叉搜索树的定义也是递归的。它是一棵空树，或者是满足下列性质的二叉树：\n\n1. 每个结点都有一个作为搜索依据的关键码（key），所有节点的关键码互不相同；\n2. 左子树（如果存在）上所有结点的关键码都小于根；\n3. 右子树（如果存在）上所有结点的关键码都大于根；\n4. 左子树和右子树也是一棵二叉搜索树。\n\n如下图所示，就是一棵标准的二叉搜索树：\n\n[![sZAigU.png](https://s3.ax1x.com/2021/01/06/sZAigU.png)](https://imgchr.com/i/sZAigU)\n\n### 1.1.1 搜索\n\n二叉树的搜索是一个递归的过程，流程图如下所示：\n\n[![sZAeER.png](https://s3.ax1x.com/2021/01/06/sZAeER.png)](https://imgchr.com/i/sZAeER)\n\n从树根出发，逐步的缩小查找范围，直到发现目标（成功）或者缩小至空结点（失败）。对于该过程而言，在二叉搜索树的每一层，查找算法至多访问一个结点，并且只需要常数时间。因此，总体所需时间应当线性正比于查找路径的长度，或最终返回结点的深度。对于规模为n的二叉搜索树，深度在最坏情况下可达(n)。\n\n### 1.1.2 插入\n\n 二叉搜索树的插入的流程图如下所示：\n\n[![sZAEDJ.png](https://s3.ax1x.com/2021/01/06/sZAEDJ.png)](https://imgchr.com/i/sZAEDJ)\n\n为了在二叉搜索树中插入一个结点，首先需要利用其搜索操作查找到插入的位置，然后再将新结点作为叶子结点插入（或者更新已存在结点的值）。由于该操作依赖于搜索操作，因此时间复杂度也为O(n)。\n\n### 1.1.3 删除\n\n二叉搜索树的删除的流程图如下所示：\n\n[![sZAVb9.png](https://s3.ax1x.com/2021/01/06/sZAVb9.png)](https://imgchr.com/i/sZAVb9)\n\n二叉搜索树的删除过程也依赖于其查找过程，故时间复杂度也为O(n)。\n\n## **1.2**  平衡二叉搜索树（BBST）\n\n由于二叉搜索树在最坏情况下可能退化为列表，此时的各种效率降至O(n)。因此如果不能有效的控制树高，二叉搜索树无法体现出明显的优势。因此，需要依照某种宽松的标准，重新定义二叉搜索树的平衡性。\n\n平衡二叉搜索树（Balanced Binary Search Tree）指的是在某种约束条件下，树高渐进地不超过O(logN)。在这一约束条件下，各种操作的时间复杂度即可降低为O(logN)。它为每一个结点v的平衡因子（balance factor）定义为左、右子树的高度差，即\n\n **balFac(v) = height(lc(v)) - height(rc(v))**\n\n下图即为定义了平衡因子的二叉搜索树：\n\n[![sZArrQ.png](https://s3.ax1x.com/2021/01/06/sZArrQ.png)](https://imgchr.com/i/sZArrQ)\n\n通过设定这种约束条件，即可达到搜索树的最佳性能。后续将介绍六种二叉搜索树。\n\n# **2** **六种平衡二叉搜索树**\n\n## **2.1** **高度平衡树（AVL**）\n\nAVL是最早发明自平衡二叉树，它被称作高度平衡树。在ALV树中，任意结点平衡因子的绝对值不超过1，即：\n\n **|balFac(v)|≤1**\n\n### 2.1.1 平衡性\n\n[![sZAhxU.png](https://s3.ax1x.com/2021/01/06/sZAhxU.png)](https://imgchr.com/i/sZAhxU)\n\n如上图所示，不妨设结点数最少的AVL树S的根结点为r，r的左、右子树分别为lc和rc，记规模为|lc|和|rc|，高度为h_l和h_r，则有：\n|S|=1+|lc|+|rc|\n由于S的子树lc和rc也是AVL树，并且高度不超过h-1。因此，不妨取：\nh_l=h-1, h_r=h-2,\n|S|=1+| S_(h-1) |+| S_(h-2) |,\n由归纳假设，可以获得如下关系：\n|S|=1+(fib(h+2)-1)+(fib(h+1)-1)\n而根据Fibonacci数列的定义，可以获得：\n|S|=fib(h+2)+fib(h+1)-1=fib(h+3)-1                          \n因此，可以知道：高度为h的AVL树至少包含fib(h+3)-1个结点。由于fib(h)和n次方正比，于是包含n个结点的AVL树的高度应为O(log⁡n )。\n综上可知，AVL树的确是平衡的。\n\n### 2.1.2 旋转\n\nAVL树的插入过程和一般二叉搜索树的过程相同，即：从树根出发，逐步的缩小查找范围，直到发现目标（成功）或者缩小至空结点（失败）。\n\n不同之处在于，二叉树在插入或者删除时，需要维持其平衡。而维持平衡这一过程，正是通过旋转（Rotate）操作来实现的。AVL树的旋转可以归纳为四种：LL单右旋、RR单左旋、LR先左旋再右旋和RL先右旋再左旋。\n\n- LL单右旋：当失衡位置发生在失衡结点左子树的左子树时，需要进行LL单右旋。\n\n[![sZAIr4.png](https://s3.ax1x.com/2021/01/06/sZAIr4.png)](https://imgchr.com/i/sZAIr4)\n\n- RR单左旋：当失衡位置发生在失衡结点右子树的右子树时，需要进行RR单左旋。\n\n[![sZAjxO.png](https://s3.ax1x.com/2021/01/06/sZAjxO.png)](https://imgchr.com/i/sZAjxO)\n\n- LR先左旋再右旋：当失衡位置发生在失衡结点左子树的右子树时，需要进行LR先左旋再右旋。\n\n[![sZESqH.png](https://s3.ax1x.com/2021/01/06/sZESqH.png)](https://imgchr.com/i/sZESqH)\n\n- RL先右旋再左旋：当失衡位置发生在失衡结点右子树的左子树时，需要进行RL先右旋再左旋。\n\n[![sZEFit.png](https://s3.ax1x.com/2021/01/06/sZEFit.png)](https://imgchr.com/i/sZEFit)\n\n### 2.1.3 性能分析\n\n通过2.1.2的旋转操作，AVL树可以满足其性质的定义，通过2.1.1证明可知：包含n个结点的AVL树的高度应为logn 。\n\n由于二叉搜索树的查找操作时间正比于树高，因此AVL树查找的时间复杂度为O(logN) 。同理，插入和删除的时间复杂度也为(logN)。\n\n## **2.2** **伸展树（ST**）\n\n伸展树（Splay Tree）也叫分裂树，相对于AVL树实现更为简捷。伸展树无需时刻都严格地保持全树的平衡，但却能够在任何足够长的真实操作序列中，保持分摊意义上的高效率。伸展树也不需要对基本的二叉树节点结构，做任何附加的要求或改动，更不需要记录平衡因子或高度之类的额外信息，故适用范围更广。\n\n每次查找节点之后对树进行重构，把被查找的节点搬移到树根。每次对伸展树进行操作后，它均会通过伸展（Splay）的方法使得被访问结点置于根结点的位置。\n\n### 2.2.1 伸展\n\n与普通的二叉搜索树的区别在于，伸展树通过伸展操作将元素调整至根结点的位置。这一调整根据结点所在位置的不同，采用不同的调整方法：\n\n| 情形  |     旋转方法     |\n| :---: | :--------------: |\n| 单R型 |      左旋转      |\n| 单L型 |      右旋转      |\n| RR型  |    两次左旋转    |\n| LL型  |    两次右旋转    |\n| RL型  | 先右旋转再左旋转 |\n| LR型  | 先左旋转再右旋转 |\n\n### 2.2.2 性能分析\n\n伸展树能够在O(log⁡n)内完成插入、查找和删除操作。它在不保证最坏情况下的时间复杂度是O(log⁡n)，其边界是均摊的。但是，它有一个最显著的缺点，即有可能变成一条链，这种情况下时间复杂度高达O(n)。\n\n## **2.3** **红黑树（RBT**）\n\n红黑树（Red Black Tree）是一种自平衡二叉搜索树，它等价于4阶B-树。它实际上是一种特化的AVL，均是在进行插入和删除操作时通过特定操作保持二叉搜索树的平衡，从而获得了较高的查找性能。\n\n红黑树保持适度平衡的关键在于：任一结点左、右子树的高度，相差不得超过两倍。为了保持这一平衡，红黑树为其内部的每一个结点定义了颜色属性黑色或者红色（本文章中红黑树黑底表示黑色结点，白底表示红色结点）。\n\n[![sZEliq.png](https://s3.ax1x.com/2021/01/06/sZEliq.png)](https://imgchr.com/i/sZEliq)\n\n与上述二叉搜索树不同，红黑树引入了外部结点作为叶结点（图11中的黑色矩形即为叶结点），它满足下述性质：\n\n1. 每个结点要么是黑色，要么是红色；\n2. 根结点是黑色的；\n3. 每个叶结点（NIL）是黑色的；\n4. 每个红色结点的两个子结点一定都是黑色的；\n5. 任意一个结点到每个叶结点的路径都包含相同数量的黑色结点。\n\n事实上，正是由于性质（5），红黑树的这种平衡被称作黑色完美平衡。红黑树维持平衡主要依靠三种方法：左旋、右旋和染色（结点的颜色由黑变红或者由红变黑）。\n\n### 2.3.1 平衡性\n\n略\n\n### 2.3.2 三种操作\n\n由于红黑树是一棵二叉搜索树，并且查找并不会破坏树的平衡，因此查找和二叉搜索树的查找无异，是一个递归的过程。\n\n红黑树的插入过程分为两步，第一步是查找到插入位置，第二步则是插入后的自平衡。因此，其插入过程可分为下述情况（如图11所示）：\n\n1. 红黑树为空树：将插入的结点作为根结点，并且染色为黑色；\n\n2. 插入结点的父结点为黑色结点：直接插入即可；\n\n3. 插入结点的父结点为红色结点：\n\n   若叔叔结点存在并且为红色结点，则只需将P和S设置为黑色，PP设置为红色，接下来递归的处理PP结点即可；\n\n   [![sZEJQU.png](https://s3.ax1x.com/2021/01/06/sZEJQU.png)](https://imgchr.com/i/sZEJQU)\n\n   若叔叔结点不存在或者为黑色结点，插入结点是父结点的左子结点，父结点是祖先结点的左子结点。该种情况需要将P设为黑色，PP设为红色，同时对PP进行右旋，如下图所示。其余情况实际为该种情况的对称形式，在此不再赘述。\n\n   [![sZEYyF.png](https://s3.ax1x.com/2021/01/06/sZEYyF.png)](https://imgchr.com/i/sZEYyF)\n\n红黑树的删除过程也是先查找到删除位置，然后通过旋转和染色来实现再次平衡。\n\n## **2.4** **替罪羊树（ST**）\n\n替罪羊树（Scapegoat Tree）不同于上述通过旋转来维持相对平衡的二叉搜索树，它是基于一种暴力重构的操作来保持相对平衡的。\n\n### 2.4.1 平衡因子\n\n替罪羊树中定义了一个平衡因子α的概念，范围在0.5到1之间。当某个结点的总结点数* α <它某个子树的总结点数，便会对该结点执行重构操作。\n对于α的取值，如果α越小，那么对平衡的要求越高，重构的次数会更多；α越大，树的平衡程度越低，重构的次数也会随之减少。一般而言，α取0.7左右比较合适。\n\n### 2.4.2 平衡性\n\n略\n\n### 2.4.3 重构\n\n[![sZEaw9.png](https://s3.ax1x.com/2021/01/06/sZEaw9.png)](https://imgchr.com/i/sZEaw9)\n\n如上图所示的替罪羊树，若平衡因子  ，则结点v已发生失衡。重构过程如下：\n\n1. 将这棵树压扁，存入向量中：\n\n[![sZEsSK.png](https://s3.ax1x.com/2021/01/06/sZEsSK.png)](https://imgchr.com/i/sZEsSK)\n\n​\t2.重新建树：每次取区间中点作为根结点，递归左右两边子树建树：\n\n[![sZE6yD.md.png](https://s3.ax1x.com/2021/01/06/sZE6yD.md.png)](https://imgchr.com/i/sZE6yD)\n\n通过上述操作，替罪羊树即完成了其重构操作。并且由2.4.2中结论可知，每次插入后的重构仍然能保证替罪羊树各种操作的时间复杂度达到  。\n\n# **3** **平衡搜索树的性能对比**\n\n根据上述介绍可以看出，AVL、伸展树、红黑树和替罪羊树分别采取了不同的方法实现了相对平衡，复杂度如表2所示。在实际使用时，应当根据工作情景选用：\n\n|  平衡树  |  时间复杂度  |     应用     |\n| :------: | :----------: | :----------: |\n|   AVL    |   O(log n)   | 最早的平衡树 |\n|  伸展树  | 均摊O(log n) |  对区间操作  |\n|  红黑树  |   O(log n)   | 综合效率最高 |\n| 替罪羊树 |   O(log n)   |   实现较易   |\n\n \n\n","slug":"数据结构论文","published":1,"updated":"2021-01-06T14:40:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clrfw2jfi000astfag6gs6e1w","content":"<p>二叉树（Binary Tree）指的是树中结点的度不大于2的有序树，其递归定义是：二叉树是一棵空树，或者是一棵由一个根节点和两棵互不相交的，分别称作根的左子树和右子树组成的非空树；左子树和右子树同样也是二叉树。</p>\n<p>二叉树是树形结构的一个重要类型，许多实际问题抽象出来的数据结构往往都是二叉树的类型。即使是一般的树也可以转化为二叉树，并且二叉树的存储结构和算法相对而言都比较简单。因此研究二叉树对于研究数据结构有着重要的意义。</p>\n<p>基于二叉树在数据结构中的重要作用，本篇文章中将探讨二叉树的一个重要应用，即作为二叉搜索树时能够发挥的作用。同时，本文也进一步探讨研究了较常使用的平衡二叉树和六种不同的平衡二叉树的性能并对其做了对比分析，为未来计算机应用提供了可供参考的意见。</p>\n<h1 id=\"1-二叉搜索树\"><a href=\"#1-二叉搜索树\" class=\"headerlink\" title=\"1  二叉搜索树\"></a><strong>1</strong>  <strong>二叉搜索树</strong></h1><h2 id=\"1-1-二叉搜索树（BST）\"><a href=\"#1-1-二叉搜索树（BST）\" class=\"headerlink\" title=\"1.1  二叉搜索树（BST）\"></a><strong>1.1</strong>  二叉搜索树（BST）</h2><p>二叉搜索树（Binary Search Tree）又称二叉查找树或二叉排序树。作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势。</p>\n<p>二叉搜索树的定义也是递归的。它是一棵空树，或者是满足下列性质的二叉树：</p>\n<ol>\n<li>每个结点都有一个作为搜索依据的关键码（key），所有节点的关键码互不相同；</li>\n<li>左子树（如果存在）上所有结点的关键码都小于根；</li>\n<li>右子树（如果存在）上所有结点的关键码都大于根；</li>\n<li>左子树和右子树也是一棵二叉搜索树。</li>\n</ol>\n<p>如下图所示，就是一棵标准的二叉搜索树：</p>\n<p><a href=\"https://imgchr.com/i/sZAigU\"><img src=\"https://s3.ax1x.com/2021/01/06/sZAigU.png\" alt=\"sZAigU.png\"></a></p>\n<h3 id=\"1-1-1-搜索\"><a href=\"#1-1-1-搜索\" class=\"headerlink\" title=\"1.1.1 搜索\"></a>1.1.1 搜索</h3><p>二叉树的搜索是一个递归的过程，流程图如下所示：</p>\n<p><a href=\"https://imgchr.com/i/sZAeER\"><img src=\"https://s3.ax1x.com/2021/01/06/sZAeER.png\" alt=\"sZAeER.png\"></a></p>\n<p>从树根出发，逐步的缩小查找范围，直到发现目标（成功）或者缩小至空结点（失败）。对于该过程而言，在二叉搜索树的每一层，查找算法至多访问一个结点，并且只需要常数时间。因此，总体所需时间应当线性正比于查找路径的长度，或最终返回结点的深度。对于规模为n的二叉搜索树，深度在最坏情况下可达(n)。</p>\n<h3 id=\"1-1-2-插入\"><a href=\"#1-1-2-插入\" class=\"headerlink\" title=\"1.1.2 插入\"></a>1.1.2 插入</h3><p> 二叉搜索树的插入的流程图如下所示：</p>\n<p><a href=\"https://imgchr.com/i/sZAEDJ\"><img src=\"https://s3.ax1x.com/2021/01/06/sZAEDJ.png\" alt=\"sZAEDJ.png\"></a></p>\n<p>为了在二叉搜索树中插入一个结点，首先需要利用其搜索操作查找到插入的位置，然后再将新结点作为叶子结点插入（或者更新已存在结点的值）。由于该操作依赖于搜索操作，因此时间复杂度也为O(n)。</p>\n<h3 id=\"1-1-3-删除\"><a href=\"#1-1-3-删除\" class=\"headerlink\" title=\"1.1.3 删除\"></a>1.1.3 删除</h3><p>二叉搜索树的删除的流程图如下所示：</p>\n<p><a href=\"https://imgchr.com/i/sZAVb9\"><img src=\"https://s3.ax1x.com/2021/01/06/sZAVb9.png\" alt=\"sZAVb9.png\"></a></p>\n<p>二叉搜索树的删除过程也依赖于其查找过程，故时间复杂度也为O(n)。</p>\n<h2 id=\"1-2-平衡二叉搜索树（BBST）\"><a href=\"#1-2-平衡二叉搜索树（BBST）\" class=\"headerlink\" title=\"1.2  平衡二叉搜索树（BBST）\"></a><strong>1.2</strong>  平衡二叉搜索树（BBST）</h2><p>由于二叉搜索树在最坏情况下可能退化为列表，此时的各种效率降至O(n)。因此如果不能有效的控制树高，二叉搜索树无法体现出明显的优势。因此，需要依照某种宽松的标准，重新定义二叉搜索树的平衡性。</p>\n<p>平衡二叉搜索树（Balanced Binary Search Tree）指的是在某种约束条件下，树高渐进地不超过O(logN)。在这一约束条件下，各种操作的时间复杂度即可降低为O(logN)。它为每一个结点v的平衡因子（balance factor）定义为左、右子树的高度差，即</p>\n<p> <strong>balFac(v) = height(lc(v)) - height(rc(v))</strong></p>\n<p>下图即为定义了平衡因子的二叉搜索树：</p>\n<p><a href=\"https://imgchr.com/i/sZArrQ\"><img src=\"https://s3.ax1x.com/2021/01/06/sZArrQ.png\" alt=\"sZArrQ.png\"></a></p>\n<p>通过设定这种约束条件，即可达到搜索树的最佳性能。后续将介绍六种二叉搜索树。</p>\n<h1 id=\"2-六种平衡二叉搜索树\"><a href=\"#2-六种平衡二叉搜索树\" class=\"headerlink\" title=\"2 六种平衡二叉搜索树\"></a><strong>2</strong> <strong>六种平衡二叉搜索树</strong></h1><h2 id=\"2-1-高度平衡树（AVL）\"><a href=\"#2-1-高度平衡树（AVL）\" class=\"headerlink\" title=\"2.1 高度平衡树（AVL）\"></a><strong>2.1</strong> <strong>高度平衡树（AVL</strong>）</h2><p>AVL是最早发明自平衡二叉树，它被称作高度平衡树。在ALV树中，任意结点平衡因子的绝对值不超过1，即：</p>\n<p> <strong>|balFac(v)|≤1</strong></p>\n<h3 id=\"2-1-1-平衡性\"><a href=\"#2-1-1-平衡性\" class=\"headerlink\" title=\"2.1.1 平衡性\"></a>2.1.1 平衡性</h3><p><a href=\"https://imgchr.com/i/sZAhxU\"><img src=\"https://s3.ax1x.com/2021/01/06/sZAhxU.png\" alt=\"sZAhxU.png\"></a></p>\n<p>如上图所示，不妨设结点数最少的AVL树S的根结点为r，r的左、右子树分别为lc和rc，记规模为|lc|和|rc|，高度为h_l和h_r，则有：<br>|S|=1+|lc|+|rc|<br>由于S的子树lc和rc也是AVL树，并且高度不超过h-1。因此，不妨取：<br>h_l=h-1, h_r=h-2,<br>|S|=1+| S_(h-1) |+| S_(h-2) |,<br>由归纳假设，可以获得如下关系：<br>|S|=1+(fib(h+2)-1)+(fib(h+1)-1)<br>而根据Fibonacci数列的定义，可以获得：<br>|S|=fib(h+2)+fib(h+1)-1=fib(h+3)-1<br>因此，可以知道：高度为h的AVL树至少包含fib(h+3)-1个结点。由于fib(h)和n次方正比，于是包含n个结点的AVL树的高度应为O(log⁡n )。<br>综上可知，AVL树的确是平衡的。</p>\n<h3 id=\"2-1-2-旋转\"><a href=\"#2-1-2-旋转\" class=\"headerlink\" title=\"2.1.2 旋转\"></a>2.1.2 旋转</h3><p>AVL树的插入过程和一般二叉搜索树的过程相同，即：从树根出发，逐步的缩小查找范围，直到发现目标（成功）或者缩小至空结点（失败）。</p>\n<p>不同之处在于，二叉树在插入或者删除时，需要维持其平衡。而维持平衡这一过程，正是通过旋转（Rotate）操作来实现的。AVL树的旋转可以归纳为四种：LL单右旋、RR单左旋、LR先左旋再右旋和RL先右旋再左旋。</p>\n<ul>\n<li>LL单右旋：当失衡位置发生在失衡结点左子树的左子树时，需要进行LL单右旋。</li>\n</ul>\n<p><a href=\"https://imgchr.com/i/sZAIr4\"><img src=\"https://s3.ax1x.com/2021/01/06/sZAIr4.png\" alt=\"sZAIr4.png\"></a></p>\n<ul>\n<li>RR单左旋：当失衡位置发生在失衡结点右子树的右子树时，需要进行RR单左旋。</li>\n</ul>\n<p><a href=\"https://imgchr.com/i/sZAjxO\"><img src=\"https://s3.ax1x.com/2021/01/06/sZAjxO.png\" alt=\"sZAjxO.png\"></a></p>\n<ul>\n<li>LR先左旋再右旋：当失衡位置发生在失衡结点左子树的右子树时，需要进行LR先左旋再右旋。</li>\n</ul>\n<p><a href=\"https://imgchr.com/i/sZESqH\"><img src=\"https://s3.ax1x.com/2021/01/06/sZESqH.png\" alt=\"sZESqH.png\"></a></p>\n<ul>\n<li>RL先右旋再左旋：当失衡位置发生在失衡结点右子树的左子树时，需要进行RL先右旋再左旋。</li>\n</ul>\n<p><a href=\"https://imgchr.com/i/sZEFit\"><img src=\"https://s3.ax1x.com/2021/01/06/sZEFit.png\" alt=\"sZEFit.png\"></a></p>\n<h3 id=\"2-1-3-性能分析\"><a href=\"#2-1-3-性能分析\" class=\"headerlink\" title=\"2.1.3 性能分析\"></a>2.1.3 性能分析</h3><p>通过2.1.2的旋转操作，AVL树可以满足其性质的定义，通过2.1.1证明可知：包含n个结点的AVL树的高度应为logn 。</p>\n<p>由于二叉搜索树的查找操作时间正比于树高，因此AVL树查找的时间复杂度为O(logN) 。同理，插入和删除的时间复杂度也为(logN)。</p>\n<h2 id=\"2-2-伸展树（ST）\"><a href=\"#2-2-伸展树（ST）\" class=\"headerlink\" title=\"2.2 伸展树（ST）\"></a><strong>2.2</strong> <strong>伸展树（ST</strong>）</h2><p>伸展树（Splay Tree）也叫分裂树，相对于AVL树实现更为简捷。伸展树无需时刻都严格地保持全树的平衡，但却能够在任何足够长的真实操作序列中，保持分摊意义上的高效率。伸展树也不需要对基本的二叉树节点结构，做任何附加的要求或改动，更不需要记录平衡因子或高度之类的额外信息，故适用范围更广。</p>\n<p>每次查找节点之后对树进行重构，把被查找的节点搬移到树根。每次对伸展树进行操作后，它均会通过伸展（Splay）的方法使得被访问结点置于根结点的位置。</p>\n<h3 id=\"2-2-1-伸展\"><a href=\"#2-2-1-伸展\" class=\"headerlink\" title=\"2.2.1 伸展\"></a>2.2.1 伸展</h3><p>与普通的二叉搜索树的区别在于，伸展树通过伸展操作将元素调整至根结点的位置。这一调整根据结点所在位置的不同，采用不同的调整方法：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">情形</th>\n<th align=\"center\">旋转方法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">单R型</td>\n<td align=\"center\">左旋转</td>\n</tr>\n<tr>\n<td align=\"center\">单L型</td>\n<td align=\"center\">右旋转</td>\n</tr>\n<tr>\n<td align=\"center\">RR型</td>\n<td align=\"center\">两次左旋转</td>\n</tr>\n<tr>\n<td align=\"center\">LL型</td>\n<td align=\"center\">两次右旋转</td>\n</tr>\n<tr>\n<td align=\"center\">RL型</td>\n<td align=\"center\">先右旋转再左旋转</td>\n</tr>\n<tr>\n<td align=\"center\">LR型</td>\n<td align=\"center\">先左旋转再右旋转</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-2-2-性能分析\"><a href=\"#2-2-2-性能分析\" class=\"headerlink\" title=\"2.2.2 性能分析\"></a>2.2.2 性能分析</h3><p>伸展树能够在O(log⁡n)内完成插入、查找和删除操作。它在不保证最坏情况下的时间复杂度是O(log⁡n)，其边界是均摊的。但是，它有一个最显著的缺点，即有可能变成一条链，这种情况下时间复杂度高达O(n)。</p>\n<h2 id=\"2-3-红黑树（RBT）\"><a href=\"#2-3-红黑树（RBT）\" class=\"headerlink\" title=\"2.3 红黑树（RBT）\"></a><strong>2.3</strong> <strong>红黑树（RBT</strong>）</h2><p>红黑树（Red Black Tree）是一种自平衡二叉搜索树，它等价于4阶B-树。它实际上是一种特化的AVL，均是在进行插入和删除操作时通过特定操作保持二叉搜索树的平衡，从而获得了较高的查找性能。</p>\n<p>红黑树保持适度平衡的关键在于：任一结点左、右子树的高度，相差不得超过两倍。为了保持这一平衡，红黑树为其内部的每一个结点定义了颜色属性黑色或者红色（本文章中红黑树黑底表示黑色结点，白底表示红色结点）。</p>\n<p><a href=\"https://imgchr.com/i/sZEliq\"><img src=\"https://s3.ax1x.com/2021/01/06/sZEliq.png\" alt=\"sZEliq.png\"></a></p>\n<p>与上述二叉搜索树不同，红黑树引入了外部结点作为叶结点（图11中的黑色矩形即为叶结点），它满足下述性质：</p>\n<ol>\n<li>每个结点要么是黑色，要么是红色；</li>\n<li>根结点是黑色的；</li>\n<li>每个叶结点（NIL）是黑色的；</li>\n<li>每个红色结点的两个子结点一定都是黑色的；</li>\n<li>任意一个结点到每个叶结点的路径都包含相同数量的黑色结点。</li>\n</ol>\n<p>事实上，正是由于性质（5），红黑树的这种平衡被称作黑色完美平衡。红黑树维持平衡主要依靠三种方法：左旋、右旋和染色（结点的颜色由黑变红或者由红变黑）。</p>\n<h3 id=\"2-3-1-平衡性\"><a href=\"#2-3-1-平衡性\" class=\"headerlink\" title=\"2.3.1 平衡性\"></a>2.3.1 平衡性</h3><p>略</p>\n<h3 id=\"2-3-2-三种操作\"><a href=\"#2-3-2-三种操作\" class=\"headerlink\" title=\"2.3.2 三种操作\"></a>2.3.2 三种操作</h3><p>由于红黑树是一棵二叉搜索树，并且查找并不会破坏树的平衡，因此查找和二叉搜索树的查找无异，是一个递归的过程。</p>\n<p>红黑树的插入过程分为两步，第一步是查找到插入位置，第二步则是插入后的自平衡。因此，其插入过程可分为下述情况（如图11所示）：</p>\n<ol>\n<li><p>红黑树为空树：将插入的结点作为根结点，并且染色为黑色；</p>\n</li>\n<li><p>插入结点的父结点为黑色结点：直接插入即可；</p>\n</li>\n<li><p>插入结点的父结点为红色结点：</p>\n<p>若叔叔结点存在并且为红色结点，则只需将P和S设置为黑色，PP设置为红色，接下来递归的处理PP结点即可；</p>\n<p><a href=\"https://imgchr.com/i/sZEJQU\"><img src=\"https://s3.ax1x.com/2021/01/06/sZEJQU.png\" alt=\"sZEJQU.png\"></a></p>\n<p>若叔叔结点不存在或者为黑色结点，插入结点是父结点的左子结点，父结点是祖先结点的左子结点。该种情况需要将P设为黑色，PP设为红色，同时对PP进行右旋，如下图所示。其余情况实际为该种情况的对称形式，在此不再赘述。</p>\n<p><a href=\"https://imgchr.com/i/sZEYyF\"><img src=\"https://s3.ax1x.com/2021/01/06/sZEYyF.png\" alt=\"sZEYyF.png\"></a></p>\n</li>\n</ol>\n<p>红黑树的删除过程也是先查找到删除位置，然后通过旋转和染色来实现再次平衡。</p>\n<h2 id=\"2-4-替罪羊树（ST）\"><a href=\"#2-4-替罪羊树（ST）\" class=\"headerlink\" title=\"2.4 替罪羊树（ST）\"></a><strong>2.4</strong> <strong>替罪羊树（ST</strong>）</h2><p>替罪羊树（Scapegoat Tree）不同于上述通过旋转来维持相对平衡的二叉搜索树，它是基于一种暴力重构的操作来保持相对平衡的。</p>\n<h3 id=\"2-4-1-平衡因子\"><a href=\"#2-4-1-平衡因子\" class=\"headerlink\" title=\"2.4.1 平衡因子\"></a>2.4.1 平衡因子</h3><p>替罪羊树中定义了一个平衡因子α的概念，范围在0.5到1之间。当某个结点的总结点数* α &lt;它某个子树的总结点数，便会对该结点执行重构操作。<br>对于α的取值，如果α越小，那么对平衡的要求越高，重构的次数会更多；α越大，树的平衡程度越低，重构的次数也会随之减少。一般而言，α取0.7左右比较合适。</p>\n<h3 id=\"2-4-2-平衡性\"><a href=\"#2-4-2-平衡性\" class=\"headerlink\" title=\"2.4.2 平衡性\"></a>2.4.2 平衡性</h3><p>略</p>\n<h3 id=\"2-4-3-重构\"><a href=\"#2-4-3-重构\" class=\"headerlink\" title=\"2.4.3 重构\"></a>2.4.3 重构</h3><p><a href=\"https://imgchr.com/i/sZEaw9\"><img src=\"https://s3.ax1x.com/2021/01/06/sZEaw9.png\" alt=\"sZEaw9.png\"></a></p>\n<p>如上图所示的替罪羊树，若平衡因子  ，则结点v已发生失衡。重构过程如下：</p>\n<ol>\n<li>将这棵树压扁，存入向量中：</li>\n</ol>\n<p><a href=\"https://imgchr.com/i/sZEsSK\"><img src=\"https://s3.ax1x.com/2021/01/06/sZEsSK.png\" alt=\"sZEsSK.png\"></a></p>\n<p>​    2.重新建树：每次取区间中点作为根结点，递归左右两边子树建树：</p>\n<p><a href=\"https://imgchr.com/i/sZE6yD\"><img src=\"https://s3.ax1x.com/2021/01/06/sZE6yD.md.png\" alt=\"sZE6yD.md.png\"></a></p>\n<p>通过上述操作，替罪羊树即完成了其重构操作。并且由2.4.2中结论可知，每次插入后的重构仍然能保证替罪羊树各种操作的时间复杂度达到  。</p>\n<h1 id=\"3-平衡搜索树的性能对比\"><a href=\"#3-平衡搜索树的性能对比\" class=\"headerlink\" title=\"3 平衡搜索树的性能对比\"></a><strong>3</strong> <strong>平衡搜索树的性能对比</strong></h1><p>根据上述介绍可以看出，AVL、伸展树、红黑树和替罪羊树分别采取了不同的方法实现了相对平衡，复杂度如表2所示。在实际使用时，应当根据工作情景选用：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">平衡树</th>\n<th align=\"center\">时间复杂度</th>\n<th align=\"center\">应用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">AVL</td>\n<td align=\"center\">O(log n)</td>\n<td align=\"center\">最早的平衡树</td>\n</tr>\n<tr>\n<td align=\"center\">伸展树</td>\n<td align=\"center\">均摊O(log n)</td>\n<td align=\"center\">对区间操作</td>\n</tr>\n<tr>\n<td align=\"center\">红黑树</td>\n<td align=\"center\">O(log n)</td>\n<td align=\"center\">综合效率最高</td>\n</tr>\n<tr>\n<td align=\"center\">替罪羊树</td>\n<td align=\"center\">O(log n)</td>\n<td align=\"center\">实现较易</td>\n</tr>\n</tbody></table>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<p>二叉树（Binary Tree）指的是树中结点的度不大于2的有序树，其递归定义是：二叉树是一棵空树，或者是一棵由一个根节点和两棵互不相交的，分别称作根的左子树和右子树组成的非空树；左子树和右子树同样也是二叉树。</p>\n<p>二叉树是树形结构的一个重要类型，许多实际问题抽象出来的数据结构往往都是二叉树的类型。即使是一般的树也可以转化为二叉树，并且二叉树的存储结构和算法相对而言都比较简单。因此研究二叉树对于研究数据结构有着重要的意义。</p>\n<p>基于二叉树在数据结构中的重要作用，本篇文章中将探讨二叉树的一个重要应用，即作为二叉搜索树时能够发挥的作用。同时，本文也进一步探讨研究了较常使用的平衡二叉树和六种不同的平衡二叉树的性能并对其做了对比分析，为未来计算机应用提供了可供参考的意见。</p>\n<h1 id=\"1-二叉搜索树\"><a href=\"#1-二叉搜索树\" class=\"headerlink\" title=\"1  二叉搜索树\"></a><strong>1</strong>  <strong>二叉搜索树</strong></h1><h2 id=\"1-1-二叉搜索树（BST）\"><a href=\"#1-1-二叉搜索树（BST）\" class=\"headerlink\" title=\"1.1  二叉搜索树（BST）\"></a><strong>1.1</strong>  二叉搜索树（BST）</h2><p>二叉搜索树（Binary Search Tree）又称二叉查找树或二叉排序树。作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势。</p>\n<p>二叉搜索树的定义也是递归的。它是一棵空树，或者是满足下列性质的二叉树：</p>\n<ol>\n<li>每个结点都有一个作为搜索依据的关键码（key），所有节点的关键码互不相同；</li>\n<li>左子树（如果存在）上所有结点的关键码都小于根；</li>\n<li>右子树（如果存在）上所有结点的关键码都大于根；</li>\n<li>左子树和右子树也是一棵二叉搜索树。</li>\n</ol>\n<p>如下图所示，就是一棵标准的二叉搜索树：</p>\n<p><a href=\"https://imgchr.com/i/sZAigU\"><img src=\"https://s3.ax1x.com/2021/01/06/sZAigU.png\" alt=\"sZAigU.png\"></a></p>\n<h3 id=\"1-1-1-搜索\"><a href=\"#1-1-1-搜索\" class=\"headerlink\" title=\"1.1.1 搜索\"></a>1.1.1 搜索</h3><p>二叉树的搜索是一个递归的过程，流程图如下所示：</p>\n<p><a href=\"https://imgchr.com/i/sZAeER\"><img src=\"https://s3.ax1x.com/2021/01/06/sZAeER.png\" alt=\"sZAeER.png\"></a></p>\n<p>从树根出发，逐步的缩小查找范围，直到发现目标（成功）或者缩小至空结点（失败）。对于该过程而言，在二叉搜索树的每一层，查找算法至多访问一个结点，并且只需要常数时间。因此，总体所需时间应当线性正比于查找路径的长度，或最终返回结点的深度。对于规模为n的二叉搜索树，深度在最坏情况下可达(n)。</p>\n<h3 id=\"1-1-2-插入\"><a href=\"#1-1-2-插入\" class=\"headerlink\" title=\"1.1.2 插入\"></a>1.1.2 插入</h3><p> 二叉搜索树的插入的流程图如下所示：</p>\n<p><a href=\"https://imgchr.com/i/sZAEDJ\"><img src=\"https://s3.ax1x.com/2021/01/06/sZAEDJ.png\" alt=\"sZAEDJ.png\"></a></p>\n<p>为了在二叉搜索树中插入一个结点，首先需要利用其搜索操作查找到插入的位置，然后再将新结点作为叶子结点插入（或者更新已存在结点的值）。由于该操作依赖于搜索操作，因此时间复杂度也为O(n)。</p>\n<h3 id=\"1-1-3-删除\"><a href=\"#1-1-3-删除\" class=\"headerlink\" title=\"1.1.3 删除\"></a>1.1.3 删除</h3><p>二叉搜索树的删除的流程图如下所示：</p>\n<p><a href=\"https://imgchr.com/i/sZAVb9\"><img src=\"https://s3.ax1x.com/2021/01/06/sZAVb9.png\" alt=\"sZAVb9.png\"></a></p>\n<p>二叉搜索树的删除过程也依赖于其查找过程，故时间复杂度也为O(n)。</p>\n<h2 id=\"1-2-平衡二叉搜索树（BBST）\"><a href=\"#1-2-平衡二叉搜索树（BBST）\" class=\"headerlink\" title=\"1.2  平衡二叉搜索树（BBST）\"></a><strong>1.2</strong>  平衡二叉搜索树（BBST）</h2><p>由于二叉搜索树在最坏情况下可能退化为列表，此时的各种效率降至O(n)。因此如果不能有效的控制树高，二叉搜索树无法体现出明显的优势。因此，需要依照某种宽松的标准，重新定义二叉搜索树的平衡性。</p>\n<p>平衡二叉搜索树（Balanced Binary Search Tree）指的是在某种约束条件下，树高渐进地不超过O(logN)。在这一约束条件下，各种操作的时间复杂度即可降低为O(logN)。它为每一个结点v的平衡因子（balance factor）定义为左、右子树的高度差，即</p>\n<p> <strong>balFac(v) = height(lc(v)) - height(rc(v))</strong></p>\n<p>下图即为定义了平衡因子的二叉搜索树：</p>\n<p><a href=\"https://imgchr.com/i/sZArrQ\"><img src=\"https://s3.ax1x.com/2021/01/06/sZArrQ.png\" alt=\"sZArrQ.png\"></a></p>\n<p>通过设定这种约束条件，即可达到搜索树的最佳性能。后续将介绍六种二叉搜索树。</p>\n<h1 id=\"2-六种平衡二叉搜索树\"><a href=\"#2-六种平衡二叉搜索树\" class=\"headerlink\" title=\"2 六种平衡二叉搜索树\"></a><strong>2</strong> <strong>六种平衡二叉搜索树</strong></h1><h2 id=\"2-1-高度平衡树（AVL）\"><a href=\"#2-1-高度平衡树（AVL）\" class=\"headerlink\" title=\"2.1 高度平衡树（AVL）\"></a><strong>2.1</strong> <strong>高度平衡树（AVL</strong>）</h2><p>AVL是最早发明自平衡二叉树，它被称作高度平衡树。在ALV树中，任意结点平衡因子的绝对值不超过1，即：</p>\n<p> <strong>|balFac(v)|≤1</strong></p>\n<h3 id=\"2-1-1-平衡性\"><a href=\"#2-1-1-平衡性\" class=\"headerlink\" title=\"2.1.1 平衡性\"></a>2.1.1 平衡性</h3><p><a href=\"https://imgchr.com/i/sZAhxU\"><img src=\"https://s3.ax1x.com/2021/01/06/sZAhxU.png\" alt=\"sZAhxU.png\"></a></p>\n<p>如上图所示，不妨设结点数最少的AVL树S的根结点为r，r的左、右子树分别为lc和rc，记规模为|lc|和|rc|，高度为h_l和h_r，则有：<br>|S|=1+|lc|+|rc|<br>由于S的子树lc和rc也是AVL树，并且高度不超过h-1。因此，不妨取：<br>h_l=h-1, h_r=h-2,<br>|S|=1+| S_(h-1) |+| S_(h-2) |,<br>由归纳假设，可以获得如下关系：<br>|S|=1+(fib(h+2)-1)+(fib(h+1)-1)<br>而根据Fibonacci数列的定义，可以获得：<br>|S|=fib(h+2)+fib(h+1)-1=fib(h+3)-1<br>因此，可以知道：高度为h的AVL树至少包含fib(h+3)-1个结点。由于fib(h)和n次方正比，于是包含n个结点的AVL树的高度应为O(log⁡n )。<br>综上可知，AVL树的确是平衡的。</p>\n<h3 id=\"2-1-2-旋转\"><a href=\"#2-1-2-旋转\" class=\"headerlink\" title=\"2.1.2 旋转\"></a>2.1.2 旋转</h3><p>AVL树的插入过程和一般二叉搜索树的过程相同，即：从树根出发，逐步的缩小查找范围，直到发现目标（成功）或者缩小至空结点（失败）。</p>\n<p>不同之处在于，二叉树在插入或者删除时，需要维持其平衡。而维持平衡这一过程，正是通过旋转（Rotate）操作来实现的。AVL树的旋转可以归纳为四种：LL单右旋、RR单左旋、LR先左旋再右旋和RL先右旋再左旋。</p>\n<ul>\n<li>LL单右旋：当失衡位置发生在失衡结点左子树的左子树时，需要进行LL单右旋。</li>\n</ul>\n<p><a href=\"https://imgchr.com/i/sZAIr4\"><img src=\"https://s3.ax1x.com/2021/01/06/sZAIr4.png\" alt=\"sZAIr4.png\"></a></p>\n<ul>\n<li>RR单左旋：当失衡位置发生在失衡结点右子树的右子树时，需要进行RR单左旋。</li>\n</ul>\n<p><a href=\"https://imgchr.com/i/sZAjxO\"><img src=\"https://s3.ax1x.com/2021/01/06/sZAjxO.png\" alt=\"sZAjxO.png\"></a></p>\n<ul>\n<li>LR先左旋再右旋：当失衡位置发生在失衡结点左子树的右子树时，需要进行LR先左旋再右旋。</li>\n</ul>\n<p><a href=\"https://imgchr.com/i/sZESqH\"><img src=\"https://s3.ax1x.com/2021/01/06/sZESqH.png\" alt=\"sZESqH.png\"></a></p>\n<ul>\n<li>RL先右旋再左旋：当失衡位置发生在失衡结点右子树的左子树时，需要进行RL先右旋再左旋。</li>\n</ul>\n<p><a href=\"https://imgchr.com/i/sZEFit\"><img src=\"https://s3.ax1x.com/2021/01/06/sZEFit.png\" alt=\"sZEFit.png\"></a></p>\n<h3 id=\"2-1-3-性能分析\"><a href=\"#2-1-3-性能分析\" class=\"headerlink\" title=\"2.1.3 性能分析\"></a>2.1.3 性能分析</h3><p>通过2.1.2的旋转操作，AVL树可以满足其性质的定义，通过2.1.1证明可知：包含n个结点的AVL树的高度应为logn 。</p>\n<p>由于二叉搜索树的查找操作时间正比于树高，因此AVL树查找的时间复杂度为O(logN) 。同理，插入和删除的时间复杂度也为(logN)。</p>\n<h2 id=\"2-2-伸展树（ST）\"><a href=\"#2-2-伸展树（ST）\" class=\"headerlink\" title=\"2.2 伸展树（ST）\"></a><strong>2.2</strong> <strong>伸展树（ST</strong>）</h2><p>伸展树（Splay Tree）也叫分裂树，相对于AVL树实现更为简捷。伸展树无需时刻都严格地保持全树的平衡，但却能够在任何足够长的真实操作序列中，保持分摊意义上的高效率。伸展树也不需要对基本的二叉树节点结构，做任何附加的要求或改动，更不需要记录平衡因子或高度之类的额外信息，故适用范围更广。</p>\n<p>每次查找节点之后对树进行重构，把被查找的节点搬移到树根。每次对伸展树进行操作后，它均会通过伸展（Splay）的方法使得被访问结点置于根结点的位置。</p>\n<h3 id=\"2-2-1-伸展\"><a href=\"#2-2-1-伸展\" class=\"headerlink\" title=\"2.2.1 伸展\"></a>2.2.1 伸展</h3><p>与普通的二叉搜索树的区别在于，伸展树通过伸展操作将元素调整至根结点的位置。这一调整根据结点所在位置的不同，采用不同的调整方法：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">情形</th>\n<th align=\"center\">旋转方法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">单R型</td>\n<td align=\"center\">左旋转</td>\n</tr>\n<tr>\n<td align=\"center\">单L型</td>\n<td align=\"center\">右旋转</td>\n</tr>\n<tr>\n<td align=\"center\">RR型</td>\n<td align=\"center\">两次左旋转</td>\n</tr>\n<tr>\n<td align=\"center\">LL型</td>\n<td align=\"center\">两次右旋转</td>\n</tr>\n<tr>\n<td align=\"center\">RL型</td>\n<td align=\"center\">先右旋转再左旋转</td>\n</tr>\n<tr>\n<td align=\"center\">LR型</td>\n<td align=\"center\">先左旋转再右旋转</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-2-2-性能分析\"><a href=\"#2-2-2-性能分析\" class=\"headerlink\" title=\"2.2.2 性能分析\"></a>2.2.2 性能分析</h3><p>伸展树能够在O(log⁡n)内完成插入、查找和删除操作。它在不保证最坏情况下的时间复杂度是O(log⁡n)，其边界是均摊的。但是，它有一个最显著的缺点，即有可能变成一条链，这种情况下时间复杂度高达O(n)。</p>\n<h2 id=\"2-3-红黑树（RBT）\"><a href=\"#2-3-红黑树（RBT）\" class=\"headerlink\" title=\"2.3 红黑树（RBT）\"></a><strong>2.3</strong> <strong>红黑树（RBT</strong>）</h2><p>红黑树（Red Black Tree）是一种自平衡二叉搜索树，它等价于4阶B-树。它实际上是一种特化的AVL，均是在进行插入和删除操作时通过特定操作保持二叉搜索树的平衡，从而获得了较高的查找性能。</p>\n<p>红黑树保持适度平衡的关键在于：任一结点左、右子树的高度，相差不得超过两倍。为了保持这一平衡，红黑树为其内部的每一个结点定义了颜色属性黑色或者红色（本文章中红黑树黑底表示黑色结点，白底表示红色结点）。</p>\n<p><a href=\"https://imgchr.com/i/sZEliq\"><img src=\"https://s3.ax1x.com/2021/01/06/sZEliq.png\" alt=\"sZEliq.png\"></a></p>\n<p>与上述二叉搜索树不同，红黑树引入了外部结点作为叶结点（图11中的黑色矩形即为叶结点），它满足下述性质：</p>\n<ol>\n<li>每个结点要么是黑色，要么是红色；</li>\n<li>根结点是黑色的；</li>\n<li>每个叶结点（NIL）是黑色的；</li>\n<li>每个红色结点的两个子结点一定都是黑色的；</li>\n<li>任意一个结点到每个叶结点的路径都包含相同数量的黑色结点。</li>\n</ol>\n<p>事实上，正是由于性质（5），红黑树的这种平衡被称作黑色完美平衡。红黑树维持平衡主要依靠三种方法：左旋、右旋和染色（结点的颜色由黑变红或者由红变黑）。</p>\n<h3 id=\"2-3-1-平衡性\"><a href=\"#2-3-1-平衡性\" class=\"headerlink\" title=\"2.3.1 平衡性\"></a>2.3.1 平衡性</h3><p>略</p>\n<h3 id=\"2-3-2-三种操作\"><a href=\"#2-3-2-三种操作\" class=\"headerlink\" title=\"2.3.2 三种操作\"></a>2.3.2 三种操作</h3><p>由于红黑树是一棵二叉搜索树，并且查找并不会破坏树的平衡，因此查找和二叉搜索树的查找无异，是一个递归的过程。</p>\n<p>红黑树的插入过程分为两步，第一步是查找到插入位置，第二步则是插入后的自平衡。因此，其插入过程可分为下述情况（如图11所示）：</p>\n<ol>\n<li><p>红黑树为空树：将插入的结点作为根结点，并且染色为黑色；</p>\n</li>\n<li><p>插入结点的父结点为黑色结点：直接插入即可；</p>\n</li>\n<li><p>插入结点的父结点为红色结点：</p>\n<p>若叔叔结点存在并且为红色结点，则只需将P和S设置为黑色，PP设置为红色，接下来递归的处理PP结点即可；</p>\n<p><a href=\"https://imgchr.com/i/sZEJQU\"><img src=\"https://s3.ax1x.com/2021/01/06/sZEJQU.png\" alt=\"sZEJQU.png\"></a></p>\n<p>若叔叔结点不存在或者为黑色结点，插入结点是父结点的左子结点，父结点是祖先结点的左子结点。该种情况需要将P设为黑色，PP设为红色，同时对PP进行右旋，如下图所示。其余情况实际为该种情况的对称形式，在此不再赘述。</p>\n<p><a href=\"https://imgchr.com/i/sZEYyF\"><img src=\"https://s3.ax1x.com/2021/01/06/sZEYyF.png\" alt=\"sZEYyF.png\"></a></p>\n</li>\n</ol>\n<p>红黑树的删除过程也是先查找到删除位置，然后通过旋转和染色来实现再次平衡。</p>\n<h2 id=\"2-4-替罪羊树（ST）\"><a href=\"#2-4-替罪羊树（ST）\" class=\"headerlink\" title=\"2.4 替罪羊树（ST）\"></a><strong>2.4</strong> <strong>替罪羊树（ST</strong>）</h2><p>替罪羊树（Scapegoat Tree）不同于上述通过旋转来维持相对平衡的二叉搜索树，它是基于一种暴力重构的操作来保持相对平衡的。</p>\n<h3 id=\"2-4-1-平衡因子\"><a href=\"#2-4-1-平衡因子\" class=\"headerlink\" title=\"2.4.1 平衡因子\"></a>2.4.1 平衡因子</h3><p>替罪羊树中定义了一个平衡因子α的概念，范围在0.5到1之间。当某个结点的总结点数* α &lt;它某个子树的总结点数，便会对该结点执行重构操作。<br>对于α的取值，如果α越小，那么对平衡的要求越高，重构的次数会更多；α越大，树的平衡程度越低，重构的次数也会随之减少。一般而言，α取0.7左右比较合适。</p>\n<h3 id=\"2-4-2-平衡性\"><a href=\"#2-4-2-平衡性\" class=\"headerlink\" title=\"2.4.2 平衡性\"></a>2.4.2 平衡性</h3><p>略</p>\n<h3 id=\"2-4-3-重构\"><a href=\"#2-4-3-重构\" class=\"headerlink\" title=\"2.4.3 重构\"></a>2.4.3 重构</h3><p><a href=\"https://imgchr.com/i/sZEaw9\"><img src=\"https://s3.ax1x.com/2021/01/06/sZEaw9.png\" alt=\"sZEaw9.png\"></a></p>\n<p>如上图所示的替罪羊树，若平衡因子  ，则结点v已发生失衡。重构过程如下：</p>\n<ol>\n<li>将这棵树压扁，存入向量中：</li>\n</ol>\n<p><a href=\"https://imgchr.com/i/sZEsSK\"><img src=\"https://s3.ax1x.com/2021/01/06/sZEsSK.png\" alt=\"sZEsSK.png\"></a></p>\n<p>​    2.重新建树：每次取区间中点作为根结点，递归左右两边子树建树：</p>\n<p><a href=\"https://imgchr.com/i/sZE6yD\"><img src=\"https://s3.ax1x.com/2021/01/06/sZE6yD.md.png\" alt=\"sZE6yD.md.png\"></a></p>\n<p>通过上述操作，替罪羊树即完成了其重构操作。并且由2.4.2中结论可知，每次插入后的重构仍然能保证替罪羊树各种操作的时间复杂度达到  。</p>\n<h1 id=\"3-平衡搜索树的性能对比\"><a href=\"#3-平衡搜索树的性能对比\" class=\"headerlink\" title=\"3 平衡搜索树的性能对比\"></a><strong>3</strong> <strong>平衡搜索树的性能对比</strong></h1><p>根据上述介绍可以看出，AVL、伸展树、红黑树和替罪羊树分别采取了不同的方法实现了相对平衡，复杂度如表2所示。在实际使用时，应当根据工作情景选用：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">平衡树</th>\n<th align=\"center\">时间复杂度</th>\n<th align=\"center\">应用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">AVL</td>\n<td align=\"center\">O(log n)</td>\n<td align=\"center\">最早的平衡树</td>\n</tr>\n<tr>\n<td align=\"center\">伸展树</td>\n<td align=\"center\">均摊O(log n)</td>\n<td align=\"center\">对区间操作</td>\n</tr>\n<tr>\n<td align=\"center\">红黑树</td>\n<td align=\"center\">O(log n)</td>\n<td align=\"center\">综合效率最高</td>\n</tr>\n<tr>\n<td align=\"center\">替罪羊树</td>\n<td align=\"center\">O(log n)</td>\n<td align=\"center\">实现较易</td>\n</tr>\n</tbody></table>\n"},{"title":"第一篇博客","date":"2020-12-28T16:00:00.000Z","cover":"https://s3.ax1x.com/2020/12/29/rbaWHf.jpg","_content":"\n\n\n# 第一篇博客\n\n2020年12月29日，在C楼教室写下了第一篇博客。\n\n[![rbaWHf.jpg](https://s3.ax1x.com/2020/12/29/rbaWHf.jpg)](https://imgchr.com/i/rbaWHf)\n\n天气灰蒙蒙的，因为正在下雨，并且今晚要大降温。\n\n**看到这条消息的你记得加件衣服哦**\n\n建立这个博客没什么特别大的意义，主要就是想一方面能整活一下，另一方面还可以熟悉一下git的使用。\n\n首先，感谢下**lltdl**（lltdl的博客见友链）在百忙之冲帮我解决了不少问题。\n\n捣鼓捣鼓了一下午，终于在16:10这个时间点成功的搞起来了。\n\n在用github的链接能登录上后，然后花了六块钱买了一年的域名（也就是这个啦：**http://wangwangwang.website**），终于能成功访问了。\n\n虽然现在还有一个奇怪的问题，就是为啥校园网不能访问，以后再解决吧。（**十分钟后我就发现域名能成功访问了**）\n\n记得收藏这个域名哦，可能会不定时和公众号同步更新一些奇奇怪怪的内容（公众号：**汪汪汪233**）。\n\n今天就讲到这里吧，现在我要准备去吃饭了，虽然不知道吃点什么。\n\n然后可能晚上会再美化一下网站什么的。\n\n拜拜！","source":"_posts/第一篇博客.md","raw":"---\ntitle: 第一篇博客\ndate: 2020-12-29 00:00:00\ncover: https://s3.ax1x.com/2020/12/29/rbaWHf.jpg\n---\n\n\n\n# 第一篇博客\n\n2020年12月29日，在C楼教室写下了第一篇博客。\n\n[![rbaWHf.jpg](https://s3.ax1x.com/2020/12/29/rbaWHf.jpg)](https://imgchr.com/i/rbaWHf)\n\n天气灰蒙蒙的，因为正在下雨，并且今晚要大降温。\n\n**看到这条消息的你记得加件衣服哦**\n\n建立这个博客没什么特别大的意义，主要就是想一方面能整活一下，另一方面还可以熟悉一下git的使用。\n\n首先，感谢下**lltdl**（lltdl的博客见友链）在百忙之冲帮我解决了不少问题。\n\n捣鼓捣鼓了一下午，终于在16:10这个时间点成功的搞起来了。\n\n在用github的链接能登录上后，然后花了六块钱买了一年的域名（也就是这个啦：**http://wangwangwang.website**），终于能成功访问了。\n\n虽然现在还有一个奇怪的问题，就是为啥校园网不能访问，以后再解决吧。（**十分钟后我就发现域名能成功访问了**）\n\n记得收藏这个域名哦，可能会不定时和公众号同步更新一些奇奇怪怪的内容（公众号：**汪汪汪233**）。\n\n今天就讲到这里吧，现在我要准备去吃饭了，虽然不知道吃点什么。\n\n然后可能晚上会再美化一下网站什么的。\n\n拜拜！","slug":"第一篇博客","published":1,"updated":"2020-12-30T15:48:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clrfw2jfi000bstfah0v3cxc7","content":"<h1 id=\"第一篇博客\"><a href=\"#第一篇博客\" class=\"headerlink\" title=\"第一篇博客\"></a>第一篇博客</h1><p>2020年12月29日，在C楼教室写下了第一篇博客。</p>\n<p><a href=\"https://imgchr.com/i/rbaWHf\"><img src=\"https://s3.ax1x.com/2020/12/29/rbaWHf.jpg\" alt=\"rbaWHf.jpg\"></a></p>\n<p>天气灰蒙蒙的，因为正在下雨，并且今晚要大降温。</p>\n<p><strong>看到这条消息的你记得加件衣服哦</strong></p>\n<p>建立这个博客没什么特别大的意义，主要就是想一方面能整活一下，另一方面还可以熟悉一下git的使用。</p>\n<p>首先，感谢下<strong>lltdl</strong>（lltdl的博客见友链）在百忙之冲帮我解决了不少问题。</p>\n<p>捣鼓捣鼓了一下午，终于在16:10这个时间点成功的搞起来了。</p>\n<p>在用github的链接能登录上后，然后花了六块钱买了一年的域名（也就是这个啦：<strong><a href=\"http://wangwangwang.website/\">http://wangwangwang.website</a></strong>），终于能成功访问了。</p>\n<p>虽然现在还有一个奇怪的问题，就是为啥校园网不能访问，以后再解决吧。（<strong>十分钟后我就发现域名能成功访问了</strong>）</p>\n<p>记得收藏这个域名哦，可能会不定时和公众号同步更新一些奇奇怪怪的内容（公众号：<strong>汪汪汪233</strong>）。</p>\n<p>今天就讲到这里吧，现在我要准备去吃饭了，虽然不知道吃点什么。</p>\n<p>然后可能晚上会再美化一下网站什么的。</p>\n<p>拜拜！</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<h1 id=\"第一篇博客\"><a href=\"#第一篇博客\" class=\"headerlink\" title=\"第一篇博客\"></a>第一篇博客</h1><p>2020年12月29日，在C楼教室写下了第一篇博客。</p>\n<p><a href=\"https://imgchr.com/i/rbaWHf\"><img src=\"https://s3.ax1x.com/2020/12/29/rbaWHf.jpg\" alt=\"rbaWHf.jpg\"></a></p>\n<p>天气灰蒙蒙的，因为正在下雨，并且今晚要大降温。</p>\n<p><strong>看到这条消息的你记得加件衣服哦</strong></p>\n<p>建立这个博客没什么特别大的意义，主要就是想一方面能整活一下，另一方面还可以熟悉一下git的使用。</p>\n<p>首先，感谢下<strong>lltdl</strong>（lltdl的博客见友链）在百忙之冲帮我解决了不少问题。</p>\n<p>捣鼓捣鼓了一下午，终于在16:10这个时间点成功的搞起来了。</p>\n<p>在用github的链接能登录上后，然后花了六块钱买了一年的域名（也就是这个啦：<strong><a href=\"http://wangwangwang.website/\">http://wangwangwang.website</a></strong>），终于能成功访问了。</p>\n<p>虽然现在还有一个奇怪的问题，就是为啥校园网不能访问，以后再解决吧。（<strong>十分钟后我就发现域名能成功访问了</strong>）</p>\n<p>记得收藏这个域名哦，可能会不定时和公众号同步更新一些奇奇怪怪的内容（公众号：<strong>汪汪汪233</strong>）。</p>\n<p>今天就讲到这里吧，现在我要准备去吃饭了，虽然不知道吃点什么。</p>\n<p>然后可能晚上会再美化一下网站什么的。</p>\n<p>拜拜！</p>\n"},{"title":"离散数学复习","date":"2021-01-11T04:00:00.000Z","description":"比较水的复习","cover":"https://s3.ax1x.com/2021/01/11/s8GD8H.jpg","_content":"\n\n\n## 第一章 集合\n\n比较简单，就是高中知识\n\n\n\n## 第二章 命题逻辑\n\n- 命题判断：\n\n  - 下列句子中那些是命题？  \n    (1) 北京是中华人民共和国的首都.\n    (2)  2 + 5 ＝8.\n    (3)  x + 5 ＞ 3.\n    (4)  你会开车吗？\n    (5) 2050年元旦北京是晴天.\n    (6) 这只兔子跑得真快呀！\n    (7) 请关上门！\n    (8) 我正在说谎话.\n\n    (1),(2),(5)是命题, (3),(4),(6)~(8)都不是命题\n\n- 永真式、永假式\n\n- 等值式：\n\n  [![s3voPs.jpg](https://s3.ax1x.com/2021/01/11/s3voPs.jpg)](https://imgchr.com/i/s3voPs)\n\n  [![s3v72q.jpg](https://s3.ax1x.com/2021/01/11/s3v72q.jpg)](https://imgchr.com/i/s3v72q)\n\n  \n\n- 范式：析取是V，合取是∩\n\n  [![s3xNJs.md.jpg](https://s3.ax1x.com/2021/01/11/s3xNJs.md.jpg)](https://imgchr.com/i/s3xNJs)\n\n  p,q形成的极小项和极大项：\n\n  - 极小项：\n\n    | 公式     | 成真赋值 | 名称 |\n    | -------- | -------- | ---- |\n    | 非p且非q | 0 0      | m0   |\n    | 非p且q   | 0 1      | m1   |\n    | p且非q   | 1 0      | m2   |\n    | p且q     | 1 1      | m3   |\n\n  - 极大项：\n\n    | 公式     | 成假赋值 | 名称 |\n    | -------- | -------- | ---- |\n    | p或q     | 0 0      | M0   |\n    | p或非q   | 0 1      | M1   |\n    | 非p或q   | 1 0      | M2   |\n    | 非p或非q | 1 1      | M3   |\n\n  【题】\n\n  [![s8p8eK.md.jpg](https://s3.ax1x.com/2021/01/11/s8p8eK.md.jpg)](https://imgchr.com/i/s8p8eK)\n\n\n\n## 第三章 一阶逻辑\n\n1.**约束出现**和**自由出现**的概念\n\n2.前束范式：一个量词非否定出现在全式的开头，并且作用域延伸到公式末尾\n\n\n\n## 第四章 关系\n\n1.自反性、对称性、传递性（充要条件：RoR是R的子集）\n\n2.闭包：满足某一性质的最小关系\n\n3.等价关系：自反、对称、传递（记作x~y）\n\n​\t等价类：与x等价的y都是其等价类。比如模三同余的等价关系中，1的等价类是{ ...,-2,1,4,... }\n\n4.商集：设R 为非空集合A 上的等价关系, 以R 的所有等价类作为元素的集合称为A关于R 的商集, 记做 A/R\n\n​\t令A={ 1, 2, …, 8 }，A关于模 3 等价关系R 的商集为 A/R = {  { 1, 4,7 }, { 2, 5, 8 }, { 3, 6 }  }\n\n5.集合的划分：设A＝{ a, b, c, d }, 给定1,2,3,4,5,6如下：     \n     1= { { a, b, c } , { d } }，     \n\n​\t2={ { a, b }, { c },{ d } }\n\n​\t3={ { a } , { a, b, c, d } }\n\n​\t4={ { a, b } ,  { c } }\n\n​\t5={ ∅, { a, b }, { c, d } }\n\n​\t6={ { a, { a } }, { b, c, d } }\n\n​\t则1和2是A的划分, 其他都不是A的划分. \n\n6.偏序关系：自反、反对称、传递\n\n7.哈赛图：最大下界、最小上界（根据偏序来画就好了）\n\n\n\n\n\n","source":"_posts/离散数学-复习.md","raw":"---\ntitle: 离散数学复习\ndate: 2021-1-11 12:00:00\ndescription: 比较水的复习\ncover: https://s3.ax1x.com/2021/01/11/s8GD8H.jpg\n---\n\n\n\n## 第一章 集合\n\n比较简单，就是高中知识\n\n\n\n## 第二章 命题逻辑\n\n- 命题判断：\n\n  - 下列句子中那些是命题？  \n    (1) 北京是中华人民共和国的首都.\n    (2)  2 + 5 ＝8.\n    (3)  x + 5 ＞ 3.\n    (4)  你会开车吗？\n    (5) 2050年元旦北京是晴天.\n    (6) 这只兔子跑得真快呀！\n    (7) 请关上门！\n    (8) 我正在说谎话.\n\n    (1),(2),(5)是命题, (3),(4),(6)~(8)都不是命题\n\n- 永真式、永假式\n\n- 等值式：\n\n  [![s3voPs.jpg](https://s3.ax1x.com/2021/01/11/s3voPs.jpg)](https://imgchr.com/i/s3voPs)\n\n  [![s3v72q.jpg](https://s3.ax1x.com/2021/01/11/s3v72q.jpg)](https://imgchr.com/i/s3v72q)\n\n  \n\n- 范式：析取是V，合取是∩\n\n  [![s3xNJs.md.jpg](https://s3.ax1x.com/2021/01/11/s3xNJs.md.jpg)](https://imgchr.com/i/s3xNJs)\n\n  p,q形成的极小项和极大项：\n\n  - 极小项：\n\n    | 公式     | 成真赋值 | 名称 |\n    | -------- | -------- | ---- |\n    | 非p且非q | 0 0      | m0   |\n    | 非p且q   | 0 1      | m1   |\n    | p且非q   | 1 0      | m2   |\n    | p且q     | 1 1      | m3   |\n\n  - 极大项：\n\n    | 公式     | 成假赋值 | 名称 |\n    | -------- | -------- | ---- |\n    | p或q     | 0 0      | M0   |\n    | p或非q   | 0 1      | M1   |\n    | 非p或q   | 1 0      | M2   |\n    | 非p或非q | 1 1      | M3   |\n\n  【题】\n\n  [![s8p8eK.md.jpg](https://s3.ax1x.com/2021/01/11/s8p8eK.md.jpg)](https://imgchr.com/i/s8p8eK)\n\n\n\n## 第三章 一阶逻辑\n\n1.**约束出现**和**自由出现**的概念\n\n2.前束范式：一个量词非否定出现在全式的开头，并且作用域延伸到公式末尾\n\n\n\n## 第四章 关系\n\n1.自反性、对称性、传递性（充要条件：RoR是R的子集）\n\n2.闭包：满足某一性质的最小关系\n\n3.等价关系：自反、对称、传递（记作x~y）\n\n​\t等价类：与x等价的y都是其等价类。比如模三同余的等价关系中，1的等价类是{ ...,-2,1,4,... }\n\n4.商集：设R 为非空集合A 上的等价关系, 以R 的所有等价类作为元素的集合称为A关于R 的商集, 记做 A/R\n\n​\t令A={ 1, 2, …, 8 }，A关于模 3 等价关系R 的商集为 A/R = {  { 1, 4,7 }, { 2, 5, 8 }, { 3, 6 }  }\n\n5.集合的划分：设A＝{ a, b, c, d }, 给定1,2,3,4,5,6如下：     \n     1= { { a, b, c } , { d } }，     \n\n​\t2={ { a, b }, { c },{ d } }\n\n​\t3={ { a } , { a, b, c, d } }\n\n​\t4={ { a, b } ,  { c } }\n\n​\t5={ ∅, { a, b }, { c, d } }\n\n​\t6={ { a, { a } }, { b, c, d } }\n\n​\t则1和2是A的划分, 其他都不是A的划分. \n\n6.偏序关系：自反、反对称、传递\n\n7.哈赛图：最大下界、最小上界（根据偏序来画就好了）\n\n\n\n\n\n","slug":"离散数学-复习","published":1,"updated":"2021-01-11T09:01:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clrfw2jfj000cstfafrjcbrgl","content":"<h2 id=\"第一章-集合\"><a href=\"#第一章-集合\" class=\"headerlink\" title=\"第一章 集合\"></a>第一章 集合</h2><p>比较简单，就是高中知识</p>\n<h2 id=\"第二章-命题逻辑\"><a href=\"#第二章-命题逻辑\" class=\"headerlink\" title=\"第二章 命题逻辑\"></a>第二章 命题逻辑</h2><ul>\n<li><p>命题判断：</p>\n<ul>\n<li><p>下列句子中那些是命题？<br>(1) 北京是中华人民共和国的首都.<br>(2)  2 + 5 ＝8.<br>(3)  x + 5 ＞ 3.<br>(4)  你会开车吗？<br>(5) 2050年元旦北京是晴天.<br>(6) 这只兔子跑得真快呀！<br>(7) 请关上门！<br>(8) 我正在说谎话.</p>\n<p>(1),(2),(5)是命题, (3),(4),(6)~(8)都不是命题</p>\n</li>\n</ul>\n</li>\n<li><p>永真式、永假式</p>\n</li>\n<li><p>等值式：</p>\n<p><a href=\"https://imgchr.com/i/s3voPs\"><img src=\"https://s3.ax1x.com/2021/01/11/s3voPs.jpg\" alt=\"s3voPs.jpg\"></a></p>\n<p><a href=\"https://imgchr.com/i/s3v72q\"><img src=\"https://s3.ax1x.com/2021/01/11/s3v72q.jpg\" alt=\"s3v72q.jpg\"></a></p>\n</li>\n</ul>\n<ul>\n<li><p>范式：析取是V，合取是∩</p>\n<p><a href=\"https://imgchr.com/i/s3xNJs\"><img src=\"https://s3.ax1x.com/2021/01/11/s3xNJs.md.jpg\" alt=\"s3xNJs.md.jpg\"></a></p>\n<p>p,q形成的极小项和极大项：</p>\n<ul>\n<li><p>极小项：</p>\n<table>\n<thead>\n<tr>\n<th>公式</th>\n<th>成真赋值</th>\n<th>名称</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>非p且非q</td>\n<td>0 0</td>\n<td>m0</td>\n</tr>\n<tr>\n<td>非p且q</td>\n<td>0 1</td>\n<td>m1</td>\n</tr>\n<tr>\n<td>p且非q</td>\n<td>1 0</td>\n<td>m2</td>\n</tr>\n<tr>\n<td>p且q</td>\n<td>1 1</td>\n<td>m3</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>极大项：</p>\n<table>\n<thead>\n<tr>\n<th>公式</th>\n<th>成假赋值</th>\n<th>名称</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>p或q</td>\n<td>0 0</td>\n<td>M0</td>\n</tr>\n<tr>\n<td>p或非q</td>\n<td>0 1</td>\n<td>M1</td>\n</tr>\n<tr>\n<td>非p或q</td>\n<td>1 0</td>\n<td>M2</td>\n</tr>\n<tr>\n<td>非p或非q</td>\n<td>1 1</td>\n<td>M3</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<p>【题】</p>\n<p><a href=\"https://imgchr.com/i/s8p8eK\"><img src=\"https://s3.ax1x.com/2021/01/11/s8p8eK.md.jpg\" alt=\"s8p8eK.md.jpg\"></a></p>\n</li>\n</ul>\n<h2 id=\"第三章-一阶逻辑\"><a href=\"#第三章-一阶逻辑\" class=\"headerlink\" title=\"第三章 一阶逻辑\"></a>第三章 一阶逻辑</h2><p>1.<strong>约束出现</strong>和<strong>自由出现</strong>的概念</p>\n<p>2.前束范式：一个量词非否定出现在全式的开头，并且作用域延伸到公式末尾</p>\n<h2 id=\"第四章-关系\"><a href=\"#第四章-关系\" class=\"headerlink\" title=\"第四章 关系\"></a>第四章 关系</h2><p>1.自反性、对称性、传递性（充要条件：RoR是R的子集）</p>\n<p>2.闭包：满足某一性质的最小关系</p>\n<p>3.等价关系：自反、对称、传递（记作x~y）</p>\n<p>​    等价类：与x等价的y都是其等价类。比如模三同余的等价关系中，1的等价类是{ …,-2,1,4,… }</p>\n<p>4.商集：设R 为非空集合A 上的等价关系, 以R 的所有等价类作为元素的集合称为A关于R 的商集, 记做 A/R</p>\n<p>​    令A={ 1, 2, …, 8 }，A关于模 3 等价关系R 的商集为 A/R = {  { 1, 4,7 }, { 2, 5, 8 }, { 3, 6 }  }</p>\n<p>5.集合的划分：设A＝{ a, b, c, d }, 给定1,2,3,4,5,6如下：<br>     1= { { a, b, c } , { d } }，     </p>\n<p>​    2={ { a, b }, { c },{ d } }</p>\n<p>​    3={ { a } , { a, b, c, d } }</p>\n<p>​    4={ { a, b } ,  { c } }</p>\n<p>​    5={ ∅, { a, b }, { c, d } }</p>\n<p>​    6={ { a, { a } }, { b, c, d } }</p>\n<p>​    则1和2是A的划分, 其他都不是A的划分. </p>\n<p>6.偏序关系：自反、反对称、传递</p>\n<p>7.哈赛图：最大下界、最小上界（根据偏序来画就好了）</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<h2 id=\"第一章-集合\"><a href=\"#第一章-集合\" class=\"headerlink\" title=\"第一章 集合\"></a>第一章 集合</h2><p>比较简单，就是高中知识</p>\n<h2 id=\"第二章-命题逻辑\"><a href=\"#第二章-命题逻辑\" class=\"headerlink\" title=\"第二章 命题逻辑\"></a>第二章 命题逻辑</h2><ul>\n<li><p>命题判断：</p>\n<ul>\n<li><p>下列句子中那些是命题？<br>(1) 北京是中华人民共和国的首都.<br>(2)  2 + 5 ＝8.<br>(3)  x + 5 ＞ 3.<br>(4)  你会开车吗？<br>(5) 2050年元旦北京是晴天.<br>(6) 这只兔子跑得真快呀！<br>(7) 请关上门！<br>(8) 我正在说谎话.</p>\n<p>(1),(2),(5)是命题, (3),(4),(6)~(8)都不是命题</p>\n</li>\n</ul>\n</li>\n<li><p>永真式、永假式</p>\n</li>\n<li><p>等值式：</p>\n<p><a href=\"https://imgchr.com/i/s3voPs\"><img src=\"https://s3.ax1x.com/2021/01/11/s3voPs.jpg\" alt=\"s3voPs.jpg\"></a></p>\n<p><a href=\"https://imgchr.com/i/s3v72q\"><img src=\"https://s3.ax1x.com/2021/01/11/s3v72q.jpg\" alt=\"s3v72q.jpg\"></a></p>\n</li>\n</ul>\n<ul>\n<li><p>范式：析取是V，合取是∩</p>\n<p><a href=\"https://imgchr.com/i/s3xNJs\"><img src=\"https://s3.ax1x.com/2021/01/11/s3xNJs.md.jpg\" alt=\"s3xNJs.md.jpg\"></a></p>\n<p>p,q形成的极小项和极大项：</p>\n<ul>\n<li><p>极小项：</p>\n<table>\n<thead>\n<tr>\n<th>公式</th>\n<th>成真赋值</th>\n<th>名称</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>非p且非q</td>\n<td>0 0</td>\n<td>m0</td>\n</tr>\n<tr>\n<td>非p且q</td>\n<td>0 1</td>\n<td>m1</td>\n</tr>\n<tr>\n<td>p且非q</td>\n<td>1 0</td>\n<td>m2</td>\n</tr>\n<tr>\n<td>p且q</td>\n<td>1 1</td>\n<td>m3</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>极大项：</p>\n<table>\n<thead>\n<tr>\n<th>公式</th>\n<th>成假赋值</th>\n<th>名称</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>p或q</td>\n<td>0 0</td>\n<td>M0</td>\n</tr>\n<tr>\n<td>p或非q</td>\n<td>0 1</td>\n<td>M1</td>\n</tr>\n<tr>\n<td>非p或q</td>\n<td>1 0</td>\n<td>M2</td>\n</tr>\n<tr>\n<td>非p或非q</td>\n<td>1 1</td>\n<td>M3</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<p>【题】</p>\n<p><a href=\"https://imgchr.com/i/s8p8eK\"><img src=\"https://s3.ax1x.com/2021/01/11/s8p8eK.md.jpg\" alt=\"s8p8eK.md.jpg\"></a></p>\n</li>\n</ul>\n<h2 id=\"第三章-一阶逻辑\"><a href=\"#第三章-一阶逻辑\" class=\"headerlink\" title=\"第三章 一阶逻辑\"></a>第三章 一阶逻辑</h2><p>1.<strong>约束出现</strong>和<strong>自由出现</strong>的概念</p>\n<p>2.前束范式：一个量词非否定出现在全式的开头，并且作用域延伸到公式末尾</p>\n<h2 id=\"第四章-关系\"><a href=\"#第四章-关系\" class=\"headerlink\" title=\"第四章 关系\"></a>第四章 关系</h2><p>1.自反性、对称性、传递性（充要条件：RoR是R的子集）</p>\n<p>2.闭包：满足某一性质的最小关系</p>\n<p>3.等价关系：自反、对称、传递（记作x~y）</p>\n<p>​    等价类：与x等价的y都是其等价类。比如模三同余的等价关系中，1的等价类是{ …,-2,1,4,… }</p>\n<p>4.商集：设R 为非空集合A 上的等价关系, 以R 的所有等价类作为元素的集合称为A关于R 的商集, 记做 A/R</p>\n<p>​    令A={ 1, 2, …, 8 }，A关于模 3 等价关系R 的商集为 A/R = {  { 1, 4,7 }, { 2, 5, 8 }, { 3, 6 }  }</p>\n<p>5.集合的划分：设A＝{ a, b, c, d }, 给定1,2,3,4,5,6如下：<br>     1= { { a, b, c } , { d } }，     </p>\n<p>​    2={ { a, b }, { c },{ d } }</p>\n<p>​    3={ { a } , { a, b, c, d } }</p>\n<p>​    4={ { a, b } ,  { c } }</p>\n<p>​    5={ ∅, { a, b }, { c, d } }</p>\n<p>​    6={ { a, { a } }, { b, c, d } }</p>\n<p>​    则1和2是A的划分, 其他都不是A的划分. </p>\n<p>6.偏序关系：自反、反对称、传递</p>\n<p>7.哈赛图：最大下界、最小上界（根据偏序来画就好了）</p>\n"},{"title":"计算机组成原理实验知识点总结","date":"2020-12-29T16:00:00.000Z","description":"软件工程专业计算机组成原理实验下半部分小结","top_img":"https://s3.ax1x.com/2020/12/30/rO9C4J.jpg","cover":"https://s3.ax1x.com/2020/12/30/rO9C4J.jpg","_content":"\n> 这学期的计算机组成原理课程终于结束了，明天就要去最后答辩了。大概可能就是要回答一些问题什么的吧，所以今天剩下的时间就用来总结一下这学期学过的比较重要的一些内容。\n\n\n\n# 组成原理实验\n\n> 由于似乎后半部分是考核的重点，因此主要需要复习的是后半部分知识。\n>\n> 后半部分包括了六个实验，其中比较重要的是：**微程序控制器实验**和**简单模型机设计实验**。此外，掌握各种信号的作用也是相对比较重要的。\n>\n> 在本文档中，所有标注***关键*** 为必须掌握内容\n\n\n\n## 计算机系统认识实验\n\n1.后半部分的实验主要建立在**TD-DMA实验箱**基础上；\n\n2.**（关键）**计算机系统组成的五大部件：\n\n[![rLI8oT.jpg](https://s3.ax1x.com/2020/12/30/rLI8oT.jpg)](https://imgchr.com/i/rLI8oT)\n\n- [x] 运算器\n- [x] 控制器\n- [x] 存储器\n- [x] 输入设备\n- [x] 输出设备\n\n3.计算机系统操作过程概括：\n\n（1）通过**输入设备**接受程序和数据信息，传送到**存储器**；\n\n（2）通过**控制器**分析存放在存储器中的程序，将其中的数据信息读取到**运算器**进行处理；\n\n（3）将处理结果送到计算机的**输出设备**或**存储器**\n\n4.冯诺依曼体系：\n\n（1）指令和数据由**二进制代码**表示，即0和1；\n\n（2）采用**存储程序**方式，程序存放在连续的存储器地址中；\n\n（3）以**控制信息流**为驱动，由控制器控制整个程序和数据的存取以及程序的执行；\n\n（4）以运算器为核心，**数据信息流**被调用处理，所有的数据处理执行都经过运算器；\n\n（5）通过**程序计数器PC**来存放下一次执行的指令单元地址，顺序加1或跳转\n\n\n\n## 基本运算器实验\n\n1.运算器是计算机进行数据处理的核心部件，其核心是**算术逻辑单元（ALU）**\n\n2.运算器组成：\n\n- 三个独立的运算部件：算数、逻辑、移位\n- 暂存器：A和B\n- 控制信号：S3-S0、CN\n- 进位标志：FC\n- 判零标志：FZ\n\n3.**（关键）**三个信号的作用：\n\n（1）ALU-B置低电平：运算器单元的运算结果进入总线\n\n（2）IN-B置低电平：输入单元的数据进入总线\n\n（3）LDA/LDB置高电平：两个暂存器可以接受数据\n\n4.运算器的控制信号作用（可以控制运算）：\n\n[![rLIRld.jpg](https://s3.ax1x.com/2020/12/30/rLIRld.jpg)](https://imgchr.com/i/rLIRld)\n\n\n\n## 静态随机存储器实验\n\n1.基本存储单元：\n\n（1）能够存储一位二进制信息；\n\n（2）是一个可控制的双稳态二进制触发器；\n\n（3）选择信号、读写信号、数据信号\n\n2.**（关键）**几个控制信号的作用（前三个信号在总线那一节还会讲到）：\n\n（1）IOM：决定对I/0设备还是对存储器进行读写操作，置低电平代表对存储器进行读写操作；\n\n（2）WR：置高电平进行写操作；\n\n（3）RD：置高电平进行读操作；\n\n（4）LDAR置高电平：对地址存储器AR写数据；\n\n（5）IOR：置低电平代表从输入单元获取数据\n\n\n\n## 微程序控制器实验\n\n1.微程序控制器的基本任务：\n\n（1）完成当前指令的翻译和执行；\n\n（2）将当前指令的功能转换为可控制的硬件逻辑部件工作\n\n2.**（关键）**重要概念：\n\n| 名称             | 定义                                                         |\n| ---------------- | ------------------------------------------------------------ |\n| 微命令（微信号） | 直接作用于控制电路的控制命令                                 |\n| 微操作           | 由微命令控制实现的最基本操作：<br />取指令地址、读指令、译码、取操作数地址、取操作数、运算、写回结果等都是微操作 |\n| 微指令           | 1.一个微周期所需的微命令集，用二进制编码表示；<br />2.同时发出的控制信号所执行的一组微操作<br />一个典型的加法指令的执行可分为：取指令、计算地址、取操作数和加法运算四步，每一步都由一组微操作实现 |\n| 微周期           | 读取一条微指令并完成相应微操作所用时间，通常为一个机器周期   |\n| 微程序           | 1.若干条微指令的有序序列；<br />2.每条机器指令对应一段微程序 |\n\n- 一段程序由一系列机器指令组成\n\n  比如：in、add、out、jump……\n\n- 每一条机器指令由一段微程序实现\n\n- 每一段微程序由一组微指令表示\n\n- 每一条微指令由一组微操作实现\n\n- 一个微操作对应一条微命令\n\n3.**（关键）**微程序控制器组成：\n\n- [x] 控制存储器CM：\n  - 用于存放微程序\n  - 每个单元存放一条微指令代码，只读\n- [x] 微指令寄存器uIR：\n  - 用于存放正在指令的微指令\n  - 包括微命令控制字段和顺序控制字段两部分\n- [x] 微地址寄存器uAR：\n  - 用于保存下一条微指令的地址\n\n4.**（关键）**微指令格式：\n\n| **23** | **22** | **21** | **20** | **19** | **18 - 15** | 14-12 | 11-9 | 8-6  | **5 – 0** |\n| :----: | ------ | :----: | :----: | :----: | :---------: | :---: | :--: | :--: | :-------: |\n|        |        |   WR   |   RD   |  IOMS  |    S3-S0    |   A   |  B   |  C   |  uA5-uA0  |\n\n- 24位字长\n- uA5-uA0是6位**后续微地址**\n- A、B、C是三个译码字段\n\n3.三个字段和二进制微代码表（了解即可）：\n\n[![rL7z7t.jpg](https://s3.ax1x.com/2020/12/30/rL7z7t.jpg)](https://imgchr.com/i/rL7z7t)\n\n[![rLHF1g.jpg](https://s3.ax1x.com/2020/12/30/rLHF1g.jpg)](https://imgchr.com/i/rLHF1g)\n\n4.**（关键）**微程序流程图：\n\n[![rLHUN6.jpg](https://s3.ax1x.com/2020/12/30/rLHUN6.jpg)](https://imgchr.com/i/rLHUN6)\n\n本实验中有四条机器指令：\n\n| 指令名 | 二进制代码 |\n| :----: | :--------: |\n|  ADD   | 0000 0000  |\n|   IN   | 0010 0000  |\n|  OUT   | 0011 0000  |\n|  HLT   | 0101 0000  |\n\n四条机器指令高四位在P<1>处与30进行运算，决定了后续执行哪条分支。\n\n5.**（关键）**微程序控制器工作过程：\n\n- 机器周期开始，执行**公共取指**操作\n- 读机器指令，送入**指令译码器**（同时修改PC）\n- 进行**指令译码**，取出操作码产生对应的**微程序入口地址**，送入微地址寄存器\n- 取出对应的一条微指令，送入**微指令寄存器**\n- 微指令操作字段经译码产生**一组微命令**，送入相应的执行部件\n- 在**时序控制**下完成微操作（T2/T4）\n- 产生**后续微地址**，读取下一条微指令\n- 执行完一段微程序后，开始新的机器周期\n\n\n\n## 总线基本实验\n\n1.总线是计算机各部件之间进行数据传输的公共通路，是一组导线和相关的控制、驱动电路的集合\n\n- 数据总线\n- 地址总线\n- 控制总线\n\n2.**（关键）**关于WR、RD、IOM控制信号：\n\n| **WR** | **RD** | **IOM** | **功能** |\n| :----: | :----: | :-----: | :------: |\n|   0    |   1    |    0    | 读存储器 |\n|   1    |   0    |    0    | 写存储器 |\n|   0    |   1    |    1    |  读I/O   |\n|   1    |   0    |    1    |  写I/O   |\n\n3.关于R0-B、LDR0、LDAR控制信号：\n\n- R0-B\n  - 置1时，R0寄存器输出关闭\n  - 置0时，R0寄存器输出打开\n\n- LDR0\n\n  - 置1时，R0寄存器输入打开\n\n  - 置0时，R0寄存器输入关闭\n\n- LDAR\n\n  - 置1时，允许访问地址寄存器\n\n  - 置0时，不允许访问地址寄存器\n\n\n\n## （关键）简单模型机设计实验\n\n1.**（关键）**CPU的组成\n\n[![rLX8Ts.jpg](https://s3.ax1x.com/2020/12/30/rLX8Ts.jpg)](https://imgchr.com/i/rLX8Ts)\n\n- 运算器\n  - ALU：完成数据计算或处理\n  - 暂存器A、B\n- 控制器MC：控制数据和指令的进出\n- 寄存器：用于暂存数据或指令\n  - 通用寄存器R0\n  - 指令寄存器IR\n  - 地址寄存器AR\n  - 程序计数器PC\n\n2.CPU基本功能：读取并执行指令\n\n3.CPU要完成的工作：\n\n- 取指令：读主存，装入寄存器\n- 分析指令：指令译码，决定动作\n- 取指令：从主存或I/O读取操作数\n- 处理数据：对操作数进行算术或逻辑运算\n  - 写数据：将执行结果写到主存或I/O\n\n4.**(关键)**微指令执行：\n\n[![rLjAjU.jpg](https://s3.ax1x.com/2020/12/30/rLjAjU.jpg)](https://imgchr.com/i/rLjAjU)\n\n（1）采用P(1)测试字，测试条件是指令寄存器高六位 IR7~IR2；\n\n（2）五条机器指令：\n\n- ADD（二进制加法）\n\n- IN（输入）\n- OUT（输出）\n- HLT（停机）\n- JMP（转移）\n\n\n\n## 总结\n\n除了上述标记关键的点之外，还有几个地方需要知道：\n\n- 机器周期工作过程：\n\n  单周期包括四个单节拍，单机器指令要执行多个单周期\n\n- 各种信号：见上述标注\n\n> 好了，走神了两节课整理完的机组实验结束了（虽然基本都是复制ppt内容\n>\n> 不过水了一篇推送，很快乐","source":"_posts/计算机组成原理实验.md","raw":"---\ntitle: 计算机组成原理实验知识点总结\ndate: 2020-12-30 00:00:00\ndescription: 软件工程专业计算机组成原理实验下半部分小结\ntop_img: https://s3.ax1x.com/2020/12/30/rO9C4J.jpg\ncover: https://s3.ax1x.com/2020/12/30/rO9C4J.jpg\n---\n\n> 这学期的计算机组成原理课程终于结束了，明天就要去最后答辩了。大概可能就是要回答一些问题什么的吧，所以今天剩下的时间就用来总结一下这学期学过的比较重要的一些内容。\n\n\n\n# 组成原理实验\n\n> 由于似乎后半部分是考核的重点，因此主要需要复习的是后半部分知识。\n>\n> 后半部分包括了六个实验，其中比较重要的是：**微程序控制器实验**和**简单模型机设计实验**。此外，掌握各种信号的作用也是相对比较重要的。\n>\n> 在本文档中，所有标注***关键*** 为必须掌握内容\n\n\n\n## 计算机系统认识实验\n\n1.后半部分的实验主要建立在**TD-DMA实验箱**基础上；\n\n2.**（关键）**计算机系统组成的五大部件：\n\n[![rLI8oT.jpg](https://s3.ax1x.com/2020/12/30/rLI8oT.jpg)](https://imgchr.com/i/rLI8oT)\n\n- [x] 运算器\n- [x] 控制器\n- [x] 存储器\n- [x] 输入设备\n- [x] 输出设备\n\n3.计算机系统操作过程概括：\n\n（1）通过**输入设备**接受程序和数据信息，传送到**存储器**；\n\n（2）通过**控制器**分析存放在存储器中的程序，将其中的数据信息读取到**运算器**进行处理；\n\n（3）将处理结果送到计算机的**输出设备**或**存储器**\n\n4.冯诺依曼体系：\n\n（1）指令和数据由**二进制代码**表示，即0和1；\n\n（2）采用**存储程序**方式，程序存放在连续的存储器地址中；\n\n（3）以**控制信息流**为驱动，由控制器控制整个程序和数据的存取以及程序的执行；\n\n（4）以运算器为核心，**数据信息流**被调用处理，所有的数据处理执行都经过运算器；\n\n（5）通过**程序计数器PC**来存放下一次执行的指令单元地址，顺序加1或跳转\n\n\n\n## 基本运算器实验\n\n1.运算器是计算机进行数据处理的核心部件，其核心是**算术逻辑单元（ALU）**\n\n2.运算器组成：\n\n- 三个独立的运算部件：算数、逻辑、移位\n- 暂存器：A和B\n- 控制信号：S3-S0、CN\n- 进位标志：FC\n- 判零标志：FZ\n\n3.**（关键）**三个信号的作用：\n\n（1）ALU-B置低电平：运算器单元的运算结果进入总线\n\n（2）IN-B置低电平：输入单元的数据进入总线\n\n（3）LDA/LDB置高电平：两个暂存器可以接受数据\n\n4.运算器的控制信号作用（可以控制运算）：\n\n[![rLIRld.jpg](https://s3.ax1x.com/2020/12/30/rLIRld.jpg)](https://imgchr.com/i/rLIRld)\n\n\n\n## 静态随机存储器实验\n\n1.基本存储单元：\n\n（1）能够存储一位二进制信息；\n\n（2）是一个可控制的双稳态二进制触发器；\n\n（3）选择信号、读写信号、数据信号\n\n2.**（关键）**几个控制信号的作用（前三个信号在总线那一节还会讲到）：\n\n（1）IOM：决定对I/0设备还是对存储器进行读写操作，置低电平代表对存储器进行读写操作；\n\n（2）WR：置高电平进行写操作；\n\n（3）RD：置高电平进行读操作；\n\n（4）LDAR置高电平：对地址存储器AR写数据；\n\n（5）IOR：置低电平代表从输入单元获取数据\n\n\n\n## 微程序控制器实验\n\n1.微程序控制器的基本任务：\n\n（1）完成当前指令的翻译和执行；\n\n（2）将当前指令的功能转换为可控制的硬件逻辑部件工作\n\n2.**（关键）**重要概念：\n\n| 名称             | 定义                                                         |\n| ---------------- | ------------------------------------------------------------ |\n| 微命令（微信号） | 直接作用于控制电路的控制命令                                 |\n| 微操作           | 由微命令控制实现的最基本操作：<br />取指令地址、读指令、译码、取操作数地址、取操作数、运算、写回结果等都是微操作 |\n| 微指令           | 1.一个微周期所需的微命令集，用二进制编码表示；<br />2.同时发出的控制信号所执行的一组微操作<br />一个典型的加法指令的执行可分为：取指令、计算地址、取操作数和加法运算四步，每一步都由一组微操作实现 |\n| 微周期           | 读取一条微指令并完成相应微操作所用时间，通常为一个机器周期   |\n| 微程序           | 1.若干条微指令的有序序列；<br />2.每条机器指令对应一段微程序 |\n\n- 一段程序由一系列机器指令组成\n\n  比如：in、add、out、jump……\n\n- 每一条机器指令由一段微程序实现\n\n- 每一段微程序由一组微指令表示\n\n- 每一条微指令由一组微操作实现\n\n- 一个微操作对应一条微命令\n\n3.**（关键）**微程序控制器组成：\n\n- [x] 控制存储器CM：\n  - 用于存放微程序\n  - 每个单元存放一条微指令代码，只读\n- [x] 微指令寄存器uIR：\n  - 用于存放正在指令的微指令\n  - 包括微命令控制字段和顺序控制字段两部分\n- [x] 微地址寄存器uAR：\n  - 用于保存下一条微指令的地址\n\n4.**（关键）**微指令格式：\n\n| **23** | **22** | **21** | **20** | **19** | **18 - 15** | 14-12 | 11-9 | 8-6  | **5 – 0** |\n| :----: | ------ | :----: | :----: | :----: | :---------: | :---: | :--: | :--: | :-------: |\n|        |        |   WR   |   RD   |  IOMS  |    S3-S0    |   A   |  B   |  C   |  uA5-uA0  |\n\n- 24位字长\n- uA5-uA0是6位**后续微地址**\n- A、B、C是三个译码字段\n\n3.三个字段和二进制微代码表（了解即可）：\n\n[![rL7z7t.jpg](https://s3.ax1x.com/2020/12/30/rL7z7t.jpg)](https://imgchr.com/i/rL7z7t)\n\n[![rLHF1g.jpg](https://s3.ax1x.com/2020/12/30/rLHF1g.jpg)](https://imgchr.com/i/rLHF1g)\n\n4.**（关键）**微程序流程图：\n\n[![rLHUN6.jpg](https://s3.ax1x.com/2020/12/30/rLHUN6.jpg)](https://imgchr.com/i/rLHUN6)\n\n本实验中有四条机器指令：\n\n| 指令名 | 二进制代码 |\n| :----: | :--------: |\n|  ADD   | 0000 0000  |\n|   IN   | 0010 0000  |\n|  OUT   | 0011 0000  |\n|  HLT   | 0101 0000  |\n\n四条机器指令高四位在P<1>处与30进行运算，决定了后续执行哪条分支。\n\n5.**（关键）**微程序控制器工作过程：\n\n- 机器周期开始，执行**公共取指**操作\n- 读机器指令，送入**指令译码器**（同时修改PC）\n- 进行**指令译码**，取出操作码产生对应的**微程序入口地址**，送入微地址寄存器\n- 取出对应的一条微指令，送入**微指令寄存器**\n- 微指令操作字段经译码产生**一组微命令**，送入相应的执行部件\n- 在**时序控制**下完成微操作（T2/T4）\n- 产生**后续微地址**，读取下一条微指令\n- 执行完一段微程序后，开始新的机器周期\n\n\n\n## 总线基本实验\n\n1.总线是计算机各部件之间进行数据传输的公共通路，是一组导线和相关的控制、驱动电路的集合\n\n- 数据总线\n- 地址总线\n- 控制总线\n\n2.**（关键）**关于WR、RD、IOM控制信号：\n\n| **WR** | **RD** | **IOM** | **功能** |\n| :----: | :----: | :-----: | :------: |\n|   0    |   1    |    0    | 读存储器 |\n|   1    |   0    |    0    | 写存储器 |\n|   0    |   1    |    1    |  读I/O   |\n|   1    |   0    |    1    |  写I/O   |\n\n3.关于R0-B、LDR0、LDAR控制信号：\n\n- R0-B\n  - 置1时，R0寄存器输出关闭\n  - 置0时，R0寄存器输出打开\n\n- LDR0\n\n  - 置1时，R0寄存器输入打开\n\n  - 置0时，R0寄存器输入关闭\n\n- LDAR\n\n  - 置1时，允许访问地址寄存器\n\n  - 置0时，不允许访问地址寄存器\n\n\n\n## （关键）简单模型机设计实验\n\n1.**（关键）**CPU的组成\n\n[![rLX8Ts.jpg](https://s3.ax1x.com/2020/12/30/rLX8Ts.jpg)](https://imgchr.com/i/rLX8Ts)\n\n- 运算器\n  - ALU：完成数据计算或处理\n  - 暂存器A、B\n- 控制器MC：控制数据和指令的进出\n- 寄存器：用于暂存数据或指令\n  - 通用寄存器R0\n  - 指令寄存器IR\n  - 地址寄存器AR\n  - 程序计数器PC\n\n2.CPU基本功能：读取并执行指令\n\n3.CPU要完成的工作：\n\n- 取指令：读主存，装入寄存器\n- 分析指令：指令译码，决定动作\n- 取指令：从主存或I/O读取操作数\n- 处理数据：对操作数进行算术或逻辑运算\n  - 写数据：将执行结果写到主存或I/O\n\n4.**(关键)**微指令执行：\n\n[![rLjAjU.jpg](https://s3.ax1x.com/2020/12/30/rLjAjU.jpg)](https://imgchr.com/i/rLjAjU)\n\n（1）采用P(1)测试字，测试条件是指令寄存器高六位 IR7~IR2；\n\n（2）五条机器指令：\n\n- ADD（二进制加法）\n\n- IN（输入）\n- OUT（输出）\n- HLT（停机）\n- JMP（转移）\n\n\n\n## 总结\n\n除了上述标记关键的点之外，还有几个地方需要知道：\n\n- 机器周期工作过程：\n\n  单周期包括四个单节拍，单机器指令要执行多个单周期\n\n- 各种信号：见上述标注\n\n> 好了，走神了两节课整理完的机组实验结束了（虽然基本都是复制ppt内容\n>\n> 不过水了一篇推送，很快乐","slug":"计算机组成原理实验","published":1,"updated":"2020-12-30T15:47:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clrfw2jfj000dstfa324p5ztx","content":"<blockquote>\n<p>这学期的计算机组成原理课程终于结束了，明天就要去最后答辩了。大概可能就是要回答一些问题什么的吧，所以今天剩下的时间就用来总结一下这学期学过的比较重要的一些内容。</p>\n</blockquote>\n<h1 id=\"组成原理实验\"><a href=\"#组成原理实验\" class=\"headerlink\" title=\"组成原理实验\"></a>组成原理实验</h1><blockquote>\n<p>由于似乎后半部分是考核的重点，因此主要需要复习的是后半部分知识。</p>\n<p>后半部分包括了六个实验，其中比较重要的是：<strong>微程序控制器实验</strong>和<strong>简单模型机设计实验</strong>。此外，掌握各种信号的作用也是相对比较重要的。</p>\n<p>在本文档中，所有标注**<em>关键**</em> 为必须掌握内容</p>\n</blockquote>\n<h2 id=\"计算机系统认识实验\"><a href=\"#计算机系统认识实验\" class=\"headerlink\" title=\"计算机系统认识实验\"></a>计算机系统认识实验</h2><p>1.后半部分的实验主要建立在<strong>TD-DMA实验箱</strong>基础上；</p>\n<p>2.<strong>（关键）</strong>计算机系统组成的五大部件：</p>\n<p><a href=\"https://imgchr.com/i/rLI8oT\"><img src=\"https://s3.ax1x.com/2020/12/30/rLI8oT.jpg\" alt=\"rLI8oT.jpg\"></a></p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 运算器</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 控制器</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 存储器</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 输入设备</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 输出设备</li>\n</ul>\n<p>3.计算机系统操作过程概括：</p>\n<p>（1）通过<strong>输入设备</strong>接受程序和数据信息，传送到<strong>存储器</strong>；</p>\n<p>（2）通过<strong>控制器</strong>分析存放在存储器中的程序，将其中的数据信息读取到<strong>运算器</strong>进行处理；</p>\n<p>（3）将处理结果送到计算机的<strong>输出设备</strong>或<strong>存储器</strong></p>\n<p>4.冯诺依曼体系：</p>\n<p>（1）指令和数据由<strong>二进制代码</strong>表示，即0和1；</p>\n<p>（2）采用<strong>存储程序</strong>方式，程序存放在连续的存储器地址中；</p>\n<p>（3）以<strong>控制信息流</strong>为驱动，由控制器控制整个程序和数据的存取以及程序的执行；</p>\n<p>（4）以运算器为核心，<strong>数据信息流</strong>被调用处理，所有的数据处理执行都经过运算器；</p>\n<p>（5）通过<strong>程序计数器PC</strong>来存放下一次执行的指令单元地址，顺序加1或跳转</p>\n<h2 id=\"基本运算器实验\"><a href=\"#基本运算器实验\" class=\"headerlink\" title=\"基本运算器实验\"></a>基本运算器实验</h2><p>1.运算器是计算机进行数据处理的核心部件，其核心是<strong>算术逻辑单元（ALU）</strong></p>\n<p>2.运算器组成：</p>\n<ul>\n<li>三个独立的运算部件：算数、逻辑、移位</li>\n<li>暂存器：A和B</li>\n<li>控制信号：S3-S0、CN</li>\n<li>进位标志：FC</li>\n<li>判零标志：FZ</li>\n</ul>\n<p>3.<strong>（关键）</strong>三个信号的作用：</p>\n<p>（1）ALU-B置低电平：运算器单元的运算结果进入总线</p>\n<p>（2）IN-B置低电平：输入单元的数据进入总线</p>\n<p>（3）LDA/LDB置高电平：两个暂存器可以接受数据</p>\n<p>4.运算器的控制信号作用（可以控制运算）：</p>\n<p><a href=\"https://imgchr.com/i/rLIRld\"><img src=\"https://s3.ax1x.com/2020/12/30/rLIRld.jpg\" alt=\"rLIRld.jpg\"></a></p>\n<h2 id=\"静态随机存储器实验\"><a href=\"#静态随机存储器实验\" class=\"headerlink\" title=\"静态随机存储器实验\"></a>静态随机存储器实验</h2><p>1.基本存储单元：</p>\n<p>（1）能够存储一位二进制信息；</p>\n<p>（2）是一个可控制的双稳态二进制触发器；</p>\n<p>（3）选择信号、读写信号、数据信号</p>\n<p>2.<strong>（关键）</strong>几个控制信号的作用（前三个信号在总线那一节还会讲到）：</p>\n<p>（1）IOM：决定对I/0设备还是对存储器进行读写操作，置低电平代表对存储器进行读写操作；</p>\n<p>（2）WR：置高电平进行写操作；</p>\n<p>（3）RD：置高电平进行读操作；</p>\n<p>（4）LDAR置高电平：对地址存储器AR写数据；</p>\n<p>（5）IOR：置低电平代表从输入单元获取数据</p>\n<h2 id=\"微程序控制器实验\"><a href=\"#微程序控制器实验\" class=\"headerlink\" title=\"微程序控制器实验\"></a>微程序控制器实验</h2><p>1.微程序控制器的基本任务：</p>\n<p>（1）完成当前指令的翻译和执行；</p>\n<p>（2）将当前指令的功能转换为可控制的硬件逻辑部件工作</p>\n<p>2.<strong>（关键）</strong>重要概念：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>定义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>微命令（微信号）</td>\n<td>直接作用于控制电路的控制命令</td>\n</tr>\n<tr>\n<td>微操作</td>\n<td>由微命令控制实现的最基本操作：<br />取指令地址、读指令、译码、取操作数地址、取操作数、运算、写回结果等都是微操作</td>\n</tr>\n<tr>\n<td>微指令</td>\n<td>1.一个微周期所需的微命令集，用二进制编码表示；<br />2.同时发出的控制信号所执行的一组微操作<br />一个典型的加法指令的执行可分为：取指令、计算地址、取操作数和加法运算四步，每一步都由一组微操作实现</td>\n</tr>\n<tr>\n<td>微周期</td>\n<td>读取一条微指令并完成相应微操作所用时间，通常为一个机器周期</td>\n</tr>\n<tr>\n<td>微程序</td>\n<td>1.若干条微指令的有序序列；<br />2.每条机器指令对应一段微程序</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>一段程序由一系列机器指令组成</p>\n<p>比如：in、add、out、jump……</p>\n</li>\n<li><p>每一条机器指令由一段微程序实现</p>\n</li>\n<li><p>每一段微程序由一组微指令表示</p>\n</li>\n<li><p>每一条微指令由一组微操作实现</p>\n</li>\n<li><p>一个微操作对应一条微命令</p>\n</li>\n</ul>\n<p>3.<strong>（关键）</strong>微程序控制器组成：</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 控制存储器CM：<ul>\n<li>用于存放微程序</li>\n<li>每个单元存放一条微指令代码，只读</li>\n</ul>\n</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 微指令寄存器uIR：<ul>\n<li>用于存放正在指令的微指令</li>\n<li>包括微命令控制字段和顺序控制字段两部分</li>\n</ul>\n</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 微地址寄存器uAR：<ul>\n<li>用于保存下一条微指令的地址</li>\n</ul>\n</li>\n</ul>\n<p>4.<strong>（关键）</strong>微指令格式：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>23</strong></th>\n<th><strong>22</strong></th>\n<th align=\"center\"><strong>21</strong></th>\n<th align=\"center\"><strong>20</strong></th>\n<th align=\"center\"><strong>19</strong></th>\n<th align=\"center\"><strong>18 - 15</strong></th>\n<th align=\"center\">14-12</th>\n<th align=\"center\">11-9</th>\n<th align=\"center\">8-6</th>\n<th align=\"center\"><strong>5 – 0</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"></td>\n<td></td>\n<td align=\"center\">WR</td>\n<td align=\"center\">RD</td>\n<td align=\"center\">IOMS</td>\n<td align=\"center\">S3-S0</td>\n<td align=\"center\">A</td>\n<td align=\"center\">B</td>\n<td align=\"center\">C</td>\n<td align=\"center\">uA5-uA0</td>\n</tr>\n</tbody></table>\n<ul>\n<li>24位字长</li>\n<li>uA5-uA0是6位<strong>后续微地址</strong></li>\n<li>A、B、C是三个译码字段</li>\n</ul>\n<p>3.三个字段和二进制微代码表（了解即可）：</p>\n<p><a href=\"https://imgchr.com/i/rL7z7t\"><img src=\"https://s3.ax1x.com/2020/12/30/rL7z7t.jpg\" alt=\"rL7z7t.jpg\"></a></p>\n<p><a href=\"https://imgchr.com/i/rLHF1g\"><img src=\"https://s3.ax1x.com/2020/12/30/rLHF1g.jpg\" alt=\"rLHF1g.jpg\"></a></p>\n<p>4.<strong>（关键）</strong>微程序流程图：</p>\n<p><a href=\"https://imgchr.com/i/rLHUN6\"><img src=\"https://s3.ax1x.com/2020/12/30/rLHUN6.jpg\" alt=\"rLHUN6.jpg\"></a></p>\n<p>本实验中有四条机器指令：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">指令名</th>\n<th align=\"center\">二进制代码</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">ADD</td>\n<td align=\"center\">0000 0000</td>\n</tr>\n<tr>\n<td align=\"center\">IN</td>\n<td align=\"center\">0010 0000</td>\n</tr>\n<tr>\n<td align=\"center\">OUT</td>\n<td align=\"center\">0011 0000</td>\n</tr>\n<tr>\n<td align=\"center\">HLT</td>\n<td align=\"center\">0101 0000</td>\n</tr>\n</tbody></table>\n<p>四条机器指令高四位在P&lt;1&gt;处与30进行运算，决定了后续执行哪条分支。</p>\n<p>5.<strong>（关键）</strong>微程序控制器工作过程：</p>\n<ul>\n<li>机器周期开始，执行<strong>公共取指</strong>操作</li>\n<li>读机器指令，送入<strong>指令译码器</strong>（同时修改PC）</li>\n<li>进行<strong>指令译码</strong>，取出操作码产生对应的<strong>微程序入口地址</strong>，送入微地址寄存器</li>\n<li>取出对应的一条微指令，送入<strong>微指令寄存器</strong></li>\n<li>微指令操作字段经译码产生<strong>一组微命令</strong>，送入相应的执行部件</li>\n<li>在<strong>时序控制</strong>下完成微操作（T2/T4）</li>\n<li>产生<strong>后续微地址</strong>，读取下一条微指令</li>\n<li>执行完一段微程序后，开始新的机器周期</li>\n</ul>\n<h2 id=\"总线基本实验\"><a href=\"#总线基本实验\" class=\"headerlink\" title=\"总线基本实验\"></a>总线基本实验</h2><p>1.总线是计算机各部件之间进行数据传输的公共通路，是一组导线和相关的控制、驱动电路的集合</p>\n<ul>\n<li>数据总线</li>\n<li>地址总线</li>\n<li>控制总线</li>\n</ul>\n<p>2.<strong>（关键）</strong>关于WR、RD、IOM控制信号：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>WR</strong></th>\n<th align=\"center\"><strong>RD</strong></th>\n<th align=\"center\"><strong>IOM</strong></th>\n<th align=\"center\"><strong>功能</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">读存储器</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">写存储器</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">读I/O</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">写I/O</td>\n</tr>\n</tbody></table>\n<p>3.关于R0-B、LDR0、LDAR控制信号：</p>\n<ul>\n<li><p>R0-B</p>\n<ul>\n<li>置1时，R0寄存器输出关闭</li>\n<li>置0时，R0寄存器输出打开</li>\n</ul>\n</li>\n<li><p>LDR0</p>\n<ul>\n<li><p>置1时，R0寄存器输入打开</p>\n</li>\n<li><p>置0时，R0寄存器输入关闭</p>\n</li>\n</ul>\n</li>\n<li><p>LDAR</p>\n<ul>\n<li><p>置1时，允许访问地址寄存器</p>\n</li>\n<li><p>置0时，不允许访问地址寄存器</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"（关键）简单模型机设计实验\"><a href=\"#（关键）简单模型机设计实验\" class=\"headerlink\" title=\"（关键）简单模型机设计实验\"></a>（关键）简单模型机设计实验</h2><p>1.<strong>（关键）</strong>CPU的组成</p>\n<p><a href=\"https://imgchr.com/i/rLX8Ts\"><img src=\"https://s3.ax1x.com/2020/12/30/rLX8Ts.jpg\" alt=\"rLX8Ts.jpg\"></a></p>\n<ul>\n<li>运算器<ul>\n<li>ALU：完成数据计算或处理</li>\n<li>暂存器A、B</li>\n</ul>\n</li>\n<li>控制器MC：控制数据和指令的进出</li>\n<li>寄存器：用于暂存数据或指令<ul>\n<li>通用寄存器R0</li>\n<li>指令寄存器IR</li>\n<li>地址寄存器AR</li>\n<li>程序计数器PC</li>\n</ul>\n</li>\n</ul>\n<p>2.CPU基本功能：读取并执行指令</p>\n<p>3.CPU要完成的工作：</p>\n<ul>\n<li>取指令：读主存，装入寄存器</li>\n<li>分析指令：指令译码，决定动作</li>\n<li>取指令：从主存或I/O读取操作数</li>\n<li>处理数据：对操作数进行算术或逻辑运算<ul>\n<li>写数据：将执行结果写到主存或I/O</li>\n</ul>\n</li>\n</ul>\n<p>4.**(关键)**微指令执行：</p>\n<p><a href=\"https://imgchr.com/i/rLjAjU\"><img src=\"https://s3.ax1x.com/2020/12/30/rLjAjU.jpg\" alt=\"rLjAjU.jpg\"></a></p>\n<p>（1）采用P(1)测试字，测试条件是指令寄存器高六位 IR7~IR2；</p>\n<p>（2）五条机器指令：</p>\n<ul>\n<li><p>ADD（二进制加法）</p>\n</li>\n<li><p>IN（输入）</p>\n</li>\n<li><p>OUT（输出）</p>\n</li>\n<li><p>HLT（停机）</p>\n</li>\n<li><p>JMP（转移）</p>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>除了上述标记关键的点之外，还有几个地方需要知道：</p>\n<ul>\n<li><p>机器周期工作过程：</p>\n<p>单周期包括四个单节拍，单机器指令要执行多个单周期</p>\n</li>\n<li><p>各种信号：见上述标注</p>\n</li>\n</ul>\n<blockquote>\n<p>好了，走神了两节课整理完的机组实验结束了（虽然基本都是复制ppt内容</p>\n<p>不过水了一篇推送，很快乐</p>\n</blockquote>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<blockquote>\n<p>这学期的计算机组成原理课程终于结束了，明天就要去最后答辩了。大概可能就是要回答一些问题什么的吧，所以今天剩下的时间就用来总结一下这学期学过的比较重要的一些内容。</p>\n</blockquote>\n<h1 id=\"组成原理实验\"><a href=\"#组成原理实验\" class=\"headerlink\" title=\"组成原理实验\"></a>组成原理实验</h1><blockquote>\n<p>由于似乎后半部分是考核的重点，因此主要需要复习的是后半部分知识。</p>\n<p>后半部分包括了六个实验，其中比较重要的是：<strong>微程序控制器实验</strong>和<strong>简单模型机设计实验</strong>。此外，掌握各种信号的作用也是相对比较重要的。</p>\n<p>在本文档中，所有标注**<em>关键**</em> 为必须掌握内容</p>\n</blockquote>\n<h2 id=\"计算机系统认识实验\"><a href=\"#计算机系统认识实验\" class=\"headerlink\" title=\"计算机系统认识实验\"></a>计算机系统认识实验</h2><p>1.后半部分的实验主要建立在<strong>TD-DMA实验箱</strong>基础上；</p>\n<p>2.<strong>（关键）</strong>计算机系统组成的五大部件：</p>\n<p><a href=\"https://imgchr.com/i/rLI8oT\"><img src=\"https://s3.ax1x.com/2020/12/30/rLI8oT.jpg\" alt=\"rLI8oT.jpg\"></a></p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 运算器</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 控制器</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 存储器</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 输入设备</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 输出设备</li>\n</ul>\n<p>3.计算机系统操作过程概括：</p>\n<p>（1）通过<strong>输入设备</strong>接受程序和数据信息，传送到<strong>存储器</strong>；</p>\n<p>（2）通过<strong>控制器</strong>分析存放在存储器中的程序，将其中的数据信息读取到<strong>运算器</strong>进行处理；</p>\n<p>（3）将处理结果送到计算机的<strong>输出设备</strong>或<strong>存储器</strong></p>\n<p>4.冯诺依曼体系：</p>\n<p>（1）指令和数据由<strong>二进制代码</strong>表示，即0和1；</p>\n<p>（2）采用<strong>存储程序</strong>方式，程序存放在连续的存储器地址中；</p>\n<p>（3）以<strong>控制信息流</strong>为驱动，由控制器控制整个程序和数据的存取以及程序的执行；</p>\n<p>（4）以运算器为核心，<strong>数据信息流</strong>被调用处理，所有的数据处理执行都经过运算器；</p>\n<p>（5）通过<strong>程序计数器PC</strong>来存放下一次执行的指令单元地址，顺序加1或跳转</p>\n<h2 id=\"基本运算器实验\"><a href=\"#基本运算器实验\" class=\"headerlink\" title=\"基本运算器实验\"></a>基本运算器实验</h2><p>1.运算器是计算机进行数据处理的核心部件，其核心是<strong>算术逻辑单元（ALU）</strong></p>\n<p>2.运算器组成：</p>\n<ul>\n<li>三个独立的运算部件：算数、逻辑、移位</li>\n<li>暂存器：A和B</li>\n<li>控制信号：S3-S0、CN</li>\n<li>进位标志：FC</li>\n<li>判零标志：FZ</li>\n</ul>\n<p>3.<strong>（关键）</strong>三个信号的作用：</p>\n<p>（1）ALU-B置低电平：运算器单元的运算结果进入总线</p>\n<p>（2）IN-B置低电平：输入单元的数据进入总线</p>\n<p>（3）LDA/LDB置高电平：两个暂存器可以接受数据</p>\n<p>4.运算器的控制信号作用（可以控制运算）：</p>\n<p><a href=\"https://imgchr.com/i/rLIRld\"><img src=\"https://s3.ax1x.com/2020/12/30/rLIRld.jpg\" alt=\"rLIRld.jpg\"></a></p>\n<h2 id=\"静态随机存储器实验\"><a href=\"#静态随机存储器实验\" class=\"headerlink\" title=\"静态随机存储器实验\"></a>静态随机存储器实验</h2><p>1.基本存储单元：</p>\n<p>（1）能够存储一位二进制信息；</p>\n<p>（2）是一个可控制的双稳态二进制触发器；</p>\n<p>（3）选择信号、读写信号、数据信号</p>\n<p>2.<strong>（关键）</strong>几个控制信号的作用（前三个信号在总线那一节还会讲到）：</p>\n<p>（1）IOM：决定对I/0设备还是对存储器进行读写操作，置低电平代表对存储器进行读写操作；</p>\n<p>（2）WR：置高电平进行写操作；</p>\n<p>（3）RD：置高电平进行读操作；</p>\n<p>（4）LDAR置高电平：对地址存储器AR写数据；</p>\n<p>（5）IOR：置低电平代表从输入单元获取数据</p>\n<h2 id=\"微程序控制器实验\"><a href=\"#微程序控制器实验\" class=\"headerlink\" title=\"微程序控制器实验\"></a>微程序控制器实验</h2><p>1.微程序控制器的基本任务：</p>\n<p>（1）完成当前指令的翻译和执行；</p>\n<p>（2）将当前指令的功能转换为可控制的硬件逻辑部件工作</p>\n<p>2.<strong>（关键）</strong>重要概念：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>定义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>微命令（微信号）</td>\n<td>直接作用于控制电路的控制命令</td>\n</tr>\n<tr>\n<td>微操作</td>\n<td>由微命令控制实现的最基本操作：<br />取指令地址、读指令、译码、取操作数地址、取操作数、运算、写回结果等都是微操作</td>\n</tr>\n<tr>\n<td>微指令</td>\n<td>1.一个微周期所需的微命令集，用二进制编码表示；<br />2.同时发出的控制信号所执行的一组微操作<br />一个典型的加法指令的执行可分为：取指令、计算地址、取操作数和加法运算四步，每一步都由一组微操作实现</td>\n</tr>\n<tr>\n<td>微周期</td>\n<td>读取一条微指令并完成相应微操作所用时间，通常为一个机器周期</td>\n</tr>\n<tr>\n<td>微程序</td>\n<td>1.若干条微指令的有序序列；<br />2.每条机器指令对应一段微程序</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>一段程序由一系列机器指令组成</p>\n<p>比如：in、add、out、jump……</p>\n</li>\n<li><p>每一条机器指令由一段微程序实现</p>\n</li>\n<li><p>每一段微程序由一组微指令表示</p>\n</li>\n<li><p>每一条微指令由一组微操作实现</p>\n</li>\n<li><p>一个微操作对应一条微命令</p>\n</li>\n</ul>\n<p>3.<strong>（关键）</strong>微程序控制器组成：</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 控制存储器CM：<ul>\n<li>用于存放微程序</li>\n<li>每个单元存放一条微指令代码，只读</li>\n</ul>\n</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 微指令寄存器uIR：<ul>\n<li>用于存放正在指令的微指令</li>\n<li>包括微命令控制字段和顺序控制字段两部分</li>\n</ul>\n</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 微地址寄存器uAR：<ul>\n<li>用于保存下一条微指令的地址</li>\n</ul>\n</li>\n</ul>\n<p>4.<strong>（关键）</strong>微指令格式：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>23</strong></th>\n<th><strong>22</strong></th>\n<th align=\"center\"><strong>21</strong></th>\n<th align=\"center\"><strong>20</strong></th>\n<th align=\"center\"><strong>19</strong></th>\n<th align=\"center\"><strong>18 - 15</strong></th>\n<th align=\"center\">14-12</th>\n<th align=\"center\">11-9</th>\n<th align=\"center\">8-6</th>\n<th align=\"center\"><strong>5 – 0</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"></td>\n<td></td>\n<td align=\"center\">WR</td>\n<td align=\"center\">RD</td>\n<td align=\"center\">IOMS</td>\n<td align=\"center\">S3-S0</td>\n<td align=\"center\">A</td>\n<td align=\"center\">B</td>\n<td align=\"center\">C</td>\n<td align=\"center\">uA5-uA0</td>\n</tr>\n</tbody></table>\n<ul>\n<li>24位字长</li>\n<li>uA5-uA0是6位<strong>后续微地址</strong></li>\n<li>A、B、C是三个译码字段</li>\n</ul>\n<p>3.三个字段和二进制微代码表（了解即可）：</p>\n<p><a href=\"https://imgchr.com/i/rL7z7t\"><img src=\"https://s3.ax1x.com/2020/12/30/rL7z7t.jpg\" alt=\"rL7z7t.jpg\"></a></p>\n<p><a href=\"https://imgchr.com/i/rLHF1g\"><img src=\"https://s3.ax1x.com/2020/12/30/rLHF1g.jpg\" alt=\"rLHF1g.jpg\"></a></p>\n<p>4.<strong>（关键）</strong>微程序流程图：</p>\n<p><a href=\"https://imgchr.com/i/rLHUN6\"><img src=\"https://s3.ax1x.com/2020/12/30/rLHUN6.jpg\" alt=\"rLHUN6.jpg\"></a></p>\n<p>本实验中有四条机器指令：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">指令名</th>\n<th align=\"center\">二进制代码</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">ADD</td>\n<td align=\"center\">0000 0000</td>\n</tr>\n<tr>\n<td align=\"center\">IN</td>\n<td align=\"center\">0010 0000</td>\n</tr>\n<tr>\n<td align=\"center\">OUT</td>\n<td align=\"center\">0011 0000</td>\n</tr>\n<tr>\n<td align=\"center\">HLT</td>\n<td align=\"center\">0101 0000</td>\n</tr>\n</tbody></table>\n<p>四条机器指令高四位在P&lt;1&gt;处与30进行运算，决定了后续执行哪条分支。</p>\n<p>5.<strong>（关键）</strong>微程序控制器工作过程：</p>\n<ul>\n<li>机器周期开始，执行<strong>公共取指</strong>操作</li>\n<li>读机器指令，送入<strong>指令译码器</strong>（同时修改PC）</li>\n<li>进行<strong>指令译码</strong>，取出操作码产生对应的<strong>微程序入口地址</strong>，送入微地址寄存器</li>\n<li>取出对应的一条微指令，送入<strong>微指令寄存器</strong></li>\n<li>微指令操作字段经译码产生<strong>一组微命令</strong>，送入相应的执行部件</li>\n<li>在<strong>时序控制</strong>下完成微操作（T2/T4）</li>\n<li>产生<strong>后续微地址</strong>，读取下一条微指令</li>\n<li>执行完一段微程序后，开始新的机器周期</li>\n</ul>\n<h2 id=\"总线基本实验\"><a href=\"#总线基本实验\" class=\"headerlink\" title=\"总线基本实验\"></a>总线基本实验</h2><p>1.总线是计算机各部件之间进行数据传输的公共通路，是一组导线和相关的控制、驱动电路的集合</p>\n<ul>\n<li>数据总线</li>\n<li>地址总线</li>\n<li>控制总线</li>\n</ul>\n<p>2.<strong>（关键）</strong>关于WR、RD、IOM控制信号：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>WR</strong></th>\n<th align=\"center\"><strong>RD</strong></th>\n<th align=\"center\"><strong>IOM</strong></th>\n<th align=\"center\"><strong>功能</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">读存储器</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">写存储器</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">读I/O</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">写I/O</td>\n</tr>\n</tbody></table>\n<p>3.关于R0-B、LDR0、LDAR控制信号：</p>\n<ul>\n<li><p>R0-B</p>\n<ul>\n<li>置1时，R0寄存器输出关闭</li>\n<li>置0时，R0寄存器输出打开</li>\n</ul>\n</li>\n<li><p>LDR0</p>\n<ul>\n<li><p>置1时，R0寄存器输入打开</p>\n</li>\n<li><p>置0时，R0寄存器输入关闭</p>\n</li>\n</ul>\n</li>\n<li><p>LDAR</p>\n<ul>\n<li><p>置1时，允许访问地址寄存器</p>\n</li>\n<li><p>置0时，不允许访问地址寄存器</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"（关键）简单模型机设计实验\"><a href=\"#（关键）简单模型机设计实验\" class=\"headerlink\" title=\"（关键）简单模型机设计实验\"></a>（关键）简单模型机设计实验</h2><p>1.<strong>（关键）</strong>CPU的组成</p>\n<p><a href=\"https://imgchr.com/i/rLX8Ts\"><img src=\"https://s3.ax1x.com/2020/12/30/rLX8Ts.jpg\" alt=\"rLX8Ts.jpg\"></a></p>\n<ul>\n<li>运算器<ul>\n<li>ALU：完成数据计算或处理</li>\n<li>暂存器A、B</li>\n</ul>\n</li>\n<li>控制器MC：控制数据和指令的进出</li>\n<li>寄存器：用于暂存数据或指令<ul>\n<li>通用寄存器R0</li>\n<li>指令寄存器IR</li>\n<li>地址寄存器AR</li>\n<li>程序计数器PC</li>\n</ul>\n</li>\n</ul>\n<p>2.CPU基本功能：读取并执行指令</p>\n<p>3.CPU要完成的工作：</p>\n<ul>\n<li>取指令：读主存，装入寄存器</li>\n<li>分析指令：指令译码，决定动作</li>\n<li>取指令：从主存或I/O读取操作数</li>\n<li>处理数据：对操作数进行算术或逻辑运算<ul>\n<li>写数据：将执行结果写到主存或I/O</li>\n</ul>\n</li>\n</ul>\n<p>4.**(关键)**微指令执行：</p>\n<p><a href=\"https://imgchr.com/i/rLjAjU\"><img src=\"https://s3.ax1x.com/2020/12/30/rLjAjU.jpg\" alt=\"rLjAjU.jpg\"></a></p>\n<p>（1）采用P(1)测试字，测试条件是指令寄存器高六位 IR7~IR2；</p>\n<p>（2）五条机器指令：</p>\n<ul>\n<li><p>ADD（二进制加法）</p>\n</li>\n<li><p>IN（输入）</p>\n</li>\n<li><p>OUT（输出）</p>\n</li>\n<li><p>HLT（停机）</p>\n</li>\n<li><p>JMP（转移）</p>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>除了上述标记关键的点之外，还有几个地方需要知道：</p>\n<ul>\n<li><p>机器周期工作过程：</p>\n<p>单周期包括四个单节拍，单机器指令要执行多个单周期</p>\n</li>\n<li><p>各种信号：见上述标注</p>\n</li>\n</ul>\n<blockquote>\n<p>好了，走神了两节课整理完的机组实验结束了（虽然基本都是复制ppt内容</p>\n<p>不过水了一篇推送，很快乐</p>\n</blockquote>\n"},{"title":"高等讲堂小技巧","date":"2023-12-28T16:00:00.000Z","cover":"https://s3.ax1x.com/2020/12/29/rbaWHf.jpg","_content":"### code\n\n```javascript\nsetInterval(function() {\n    var video = document.getElementById('example_media_1_html5_api');\n    if (video.paused) {\n        video.play();\n    }\n    console.log('自动续播')\n}, 60000);  // 60000毫秒即1分钟\n\n```\n\n如何让ID为example_media_1_html5_api的视频跳转到1小时57分的时间\n\n```javascript\nvar video = document.getElementById('example_media_1_html5_api');\nvideo.currentTime = 7020;  // 设置视频的当前时间为7020秒\nvideo.play();  // 开始播放\n```\n","source":"_posts/高等讲堂.md","raw":"---\ntitle: 高等讲堂小技巧\ndate: 2023-12-29 00:00:00\ncover: https://s3.ax1x.com/2020/12/29/rbaWHf.jpg\n---\n### code\n\n```javascript\nsetInterval(function() {\n    var video = document.getElementById('example_media_1_html5_api');\n    if (video.paused) {\n        video.play();\n    }\n    console.log('自动续播')\n}, 60000);  // 60000毫秒即1分钟\n\n```\n\n如何让ID为example_media_1_html5_api的视频跳转到1小时57分的时间\n\n```javascript\nvar video = document.getElementById('example_media_1_html5_api');\nvideo.currentTime = 7020;  // 设置视频的当前时间为7020秒\nvideo.play();  // 开始播放\n```\n","slug":"高等讲堂","published":1,"updated":"2024-01-16T05:03:31.535Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clrfw2jfj000estfa1g6gaota","content":"<h3 id=\"code\"><a href=\"#code\" class=\"headerlink\" title=\"code\"></a>code</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">setInterval</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> video = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;example_media_1_html5_api&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (video.paused) &#123;</span><br><span class=\"line\">        video.play();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;自动续播&#x27;</span>)</span><br><span class=\"line\">&#125;, <span class=\"number\">60000</span>);  <span class=\"comment\">// 60000毫秒即1分钟</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>如何让ID为example_media_1_html5_api的视频跳转到1小时57分的时间</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> video = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;example_media_1_html5_api&#x27;</span>);</span><br><span class=\"line\">video.currentTime = <span class=\"number\">7020</span>;  <span class=\"comment\">// 设置视频的当前时间为7020秒</span></span><br><span class=\"line\">video.play();  <span class=\"comment\">// 开始播放</span></span><br></pre></td></tr></table></figure>","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<h3 id=\"code\"><a href=\"#code\" class=\"headerlink\" title=\"code\"></a>code</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">setInterval</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> video = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;example_media_1_html5_api&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (video.paused) &#123;</span><br><span class=\"line\">        video.play();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;自动续播&#x27;</span>)</span><br><span class=\"line\">&#125;, <span class=\"number\">60000</span>);  <span class=\"comment\">// 60000毫秒即1分钟</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>如何让ID为example_media_1_html5_api的视频跳转到1小时57分的时间</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> video = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;example_media_1_html5_api&#x27;</span>);</span><br><span class=\"line\">video.currentTime = <span class=\"number\">7020</span>;  <span class=\"comment\">// 设置视频的当前时间为7020秒</span></span><br><span class=\"line\">video.play();  <span class=\"comment\">// 开始播放</span></span><br></pre></td></tr></table></figure>"},{"title":"Mac的常用操作","date":"2023-04-25T14:50:56.000Z","_content":"## 环境变量配置\n\n打开文件进行编辑\n\n```shell\nopen -e .zshrc\n```\n\n配置变量，然后Command + S 保存退出\n\n输入：\n\n```shell\nsource .zshrc\n```\n","source":"_posts/Mac的常用操作.md","raw":"---\ntitle: Mac的常用操作\ndate: 2023-04-25 22:50:56\ntags:\n---\n## 环境变量配置\n\n打开文件进行编辑\n\n```shell\nopen -e .zshrc\n```\n\n配置变量，然后Command + S 保存退出\n\n输入：\n\n```shell\nsource .zshrc\n```\n","slug":"Mac的常用操作","published":1,"updated":"2023-04-25T14:51:42.677Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clrfw2jfk000fstfa877uh7q2","content":"<h2 id=\"环境变量配置\"><a href=\"#环境变量配置\" class=\"headerlink\" title=\"环境变量配置\"></a>环境变量配置</h2><p>打开文件进行编辑</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open -e .zshrc</span><br></pre></td></tr></table></figure>\n<p>配置变量，然后Command + S 保存退出</p>\n<p>输入：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source .zshrc</span><br></pre></td></tr></table></figure>","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h2 id=\"环境变量配置\"><a href=\"#环境变量配置\" class=\"headerlink\" title=\"环境变量配置\"></a>环境变量配置</h2><p>打开文件进行编辑</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open -e .zshrc</span><br></pre></td></tr></table></figure>\n<p>配置变量，然后Command + S 保存退出</p>\n<p>输入：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source .zshrc</span><br></pre></td></tr></table></figure>"},{"_content":"\n\n本科五年酬金\n\n\n\n![image-20230824122230091](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230824122230091.png)\n\n\n\n![image-20230824122247073](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230824122247073.png)\n\n\n\n![image-20230824122311716](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230824122311716.png)\n\n![image-20230824122319335](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230824122319335.png)\n\n\n\n![image-20230824122331583](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230824122331583.png)\n\n\n\n![image-20230824122344387](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230824122344387.png)\n\n\n\n![image-20230824122413267](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230824122413267.png)","source":"_posts/本科四年个人酬金.md","raw":"\n\n本科五年酬金\n\n\n\n![image-20230824122230091](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230824122230091.png)\n\n\n\n![image-20230824122247073](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230824122247073.png)\n\n\n\n![image-20230824122311716](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230824122311716.png)\n\n![image-20230824122319335](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230824122319335.png)\n\n\n\n![image-20230824122331583](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230824122331583.png)\n\n\n\n![image-20230824122344387](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230824122344387.png)\n\n\n\n![image-20230824122413267](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230824122413267.png)","slug":"本科四年个人酬金","published":1,"date":"2023-08-24T04:24:44.134Z","updated":"2023-08-24T04:24:44.134Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clrfw2jfk000gstfado9of3fa","content":"<p>本科五年酬金</p>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230824122230091.png\" alt=\"image-20230824122230091\"></p>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230824122247073.png\" alt=\"image-20230824122247073\"></p>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230824122311716.png\" alt=\"image-20230824122311716\"></p>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230824122319335.png\" alt=\"image-20230824122319335\"></p>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230824122331583.png\" alt=\"image-20230824122331583\"></p>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230824122344387.png\" alt=\"image-20230824122344387\"></p>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230824122413267.png\" alt=\"image-20230824122413267\"></p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p>本科五年酬金</p>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230824122230091.png\" alt=\"image-20230824122230091\"></p>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230824122247073.png\" alt=\"image-20230824122247073\"></p>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230824122311716.png\" alt=\"image-20230824122311716\"></p>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230824122319335.png\" alt=\"image-20230824122319335\"></p>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230824122331583.png\" alt=\"image-20230824122331583\"></p>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230824122344387.png\" alt=\"image-20230824122344387\"></p>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230824122413267.png\" alt=\"image-20230824122413267\"></p>\n"},{"title":"Git基本操作整理","date":"2022-03-29T04:00:00.000Z","description":"git的一些基本操作，一起交流学习","cover":"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f9be0486.png","_content":"\n# Git 基本操作整理\n\n## 前言\n\n本文档通过整理CS-Notes中的Git命令操作与实战Learn Git Branching来学习掌握Git方法。因为文档主要分为两部分，第一部分参考CS-Notes并查阅资料为Git理论知识，第二部分为实战Learn Git Branching给出个人思考与过程。\n\n参考资料来源:\n\n1. [CS-Notes Git部分](http://www.cyc2018.xyz/%E5%85%B6%E5%AE%83/%E7%BC%96%E7%A0%81%E5%AE%9E%E8%B7%B5/Git.html#%E9%9B%86%E4%B8%AD%E5%BC%8F%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F)\n\n2. [Learn Git Branching](https://learngitbranching.js.org/?demo=&locale=zh_CN)\n\n## Git知识\n\n\n\n## Learn Git Branching\n\n### Level 1. Git基础内容\n\n#### Git Commit\n\nGit 仓库中的提交记录保存的是你的目录下所有文件的快照，就像是把整个目录复制，然后再粘贴一样，但比复制粘贴优雅许多！\n\nGit 希望提交记录尽可能地轻量，因此在你每次进行提交时，它并不会盲目地复制整个目录。条件允许的情况下，它会将当前版本与仓库中的上一个版本进行对比，并把所有的差异打包到一起作为一个提交记录。Git 还保存了提交的历史记录。这也是为什么大多数提交记录的上面都有父节点的原因。对于项目组的成员来说，维护提交历史对大家都有好处。\n\nGit Commit 就是在父节点下进行一次内容的提交。使用的命令很简单为：\n\n💯==**git commit**==\n\n\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f9be0486.png)\n\n------\n\n#### Git Branch\n\nGit 的分支也非常轻量。它们只是简单地指向某个提交纪录 —— 仅此而已。\n\n所以许多 Git 爱好者传颂：😍**早建分支，多用分支！**\n\n这是因为即使创建再多的分支也不会造成储存或内存上的开销，并且按逻辑分解工作到不同的分支要比维护那些特别臃肿的分支简单多了。\n\n在将分支和提交记录结合起来后，我们会看到两者如何协作。现在只要记住使用分支其实就相当于在说：“**我想基于这个提交以及它所有的父提交进行新的工作。**”\n\n创建分支的命令最基础的就是：\n\n💯==**git branch <branch_name>**==\n\n创建好的分支会指向当前的提交记录。但是通过上述命令创建的分支并不是我们现在所使用的分支，如果我们此刻进行了git commit操作，那么我们的行为仍然是操作于原来的分支。所以我们如果想要使用这个新分支，我们需要使用切换分支的命令：\n\n💯==**git checkout <branch_name>**==\n\n有一个简洁的方式，如果你想创建一个新的分支同时切换到新创建的分支的话，可以通过 \n\n💯==**git checkout -b \\<your-branch-name\\>**==\n\n\n\n![](https://i0.hdslb.com/bfs/album/a11e89444b0b5c7d221325a9637f26e54ebe12c6.png)\n\n------\n\n#### Git Merge\n\n在知道如何提交以及如何使用分支的前提下，接下来是如何将两个分支合并到一起。就是说我们新建一个分支，在其上开发某个新功能，开发完成后再合并回主线。\n\n第一种方法是通过git merge实现的。在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个父节点。翻译成自然语言相当于：“我要把这两个父节点本身及它们所有的祖先都包含进来。”因此，git合并分支的命令是：\n\n💯==**git merge <branch_name>**==\n\n该命令是将branch_name合并到当前的分支下\n\n例如：我们有这两个分支main与bugFix，我们可以通过git merge命令来将两者合并：\n\n<img src=\"https://i0.hdslb.com/bfs/album/1a7e02089e6db4f76cec7be3ca3766caa38c1fd7.png\" style=\"zoom:50%;\" />\n\n合并后，我们发现新的分支是保留了两条路径指向父节点，并没有断了与任何一条分支的联系，因此这个过程支持了Git对历史版本信息的维护。\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f858fa9e.png\" style=\"zoom:50%;\" />\n\n接下来，可以将main分支合并到bugFix中\n\n通过`git checkout bugFix; git merge main`\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f8526a06.png\" style=\"zoom:50%;\" />\n\n因为 main 继承自 bugFix ，Git 什么都不用做，只是简单地把 bugFix 移动到 main 所指向的那个提交记录。\n\n![](https://i0.hdslb.com/bfs/album/08d9d8343a7164f9c6b01eccca5471872790f07f.png)\n\n------\n\n#### Git Rebase\n\n第二种合并分支的方法是 git rebase。Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。\n\nRebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。Rebase的命令如下：\n\n💯==**git rebase <branch_name>**==\n\n例如：同样我们有两个分支main和bugFix，我们可以通过rebase来将两者合并：\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f857516e.png\" style=\"zoom:50%;\" />\n\n通过rebase命令后，不同于原来的merge建立两条关于父节点的链接，而是通过提取一系列的提交记录然后建立一个基于main的副本，这样生成的线性的提交历史：\n\n<img src=\"https://i0.hdslb.com/bfs/album/59f7e1df1314389ddbbcb14fda46a0a679d6c999.png\" style=\"zoom:50%;\" />\n\n此时，原先分支的C3并没有被删除，接下来可以切换到main分支，通过rebase向前推进一个版本\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f857627e.png\" style=\"zoom:50%;\" />\n\nrebase命令维护一条线性的提交记录使得历史提交很清晰。我理解的话，主要是通过在代合并的分支上补充原有分支的一些历史提交信息，然后类似于“复制”了一个版本到待合并分支下，实现一个合并操作。\n\n![](https://i0.hdslb.com/bfs/album/8ee6ba5797dbd7b567f3a9f05c43a9d88472e13d.png)\n\n------\n\n### Level 2. Git高级内容\n\n#### 分离HEAD\n\nHEAD 是一个对当前检出记录的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。\n\nHEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。\n\nHEAD 通常情况下是指向分支名的（如 bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。\n\n**分离的 HEAD 就是让其指向了某个具体的提交记录而不是分支名。**在命令执行之前的状态如下所示：\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242631f0352b.png\" style=\"zoom:50%;\" />\n\nHEAD -> main -> C1\n\nHEAD 指向 main， main 指向 C1\n\n再通过 **git checkout C1** 后变成了：\n\nHEAD -> C1\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624263c60010b.png\" style=\"zoom:50%;\" />\n\n\n\n所以分离当前HEAD是通过：\n\n💯==**git checkout \\<hash_commit\\>**==\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624264090b652.png)\n\n------\n\n#### 相对引用(^)\n\n通过指定提交记录哈希值的方式在 Git 中移动不太方便。在实际应用时，并没有像本程序中这么漂亮的可视化提交树供你参考，所以你就不得不用 `git log` 来查查看提交记录的哈希值。\n\n并且哈希值在真实的 Git 世界中也会更长（e.g. 基于 SHA-1，共 40 位）。例如前一关的介绍中的提交记录的哈希值可能是 `fed2da64c0efc5293610bdd892f82a58e8cbc5d8`。比较令人欣慰的是，Git 对哈希的处理很智能。你只需要提供能够唯一标识提交记录的前几个字符即可。因此我可以仅输入`fed2` 而不是上面的一长串字符。\n\n通过哈希值提交记录很不方便，所以git引用了相对引用。使用相对引用的话，就可以从一个易于记忆的地方（比如 `bugFix` 分支或 `HEAD`）开始计算。\n\n相对引用非常给力，这里我介绍两个简单的用法：\n\n- 使用 `^` 向上移动 1 个提交记录\n- 使用 `~<num>` 向上移动多个提交记录，如 `~3`\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624274834cddb.png\" style=\"zoom:50%;\" />\n\n通过使用(\\^)可以相对很方便找到main的父节点，而不是通过哈希的方式，以此类推，可以通过main\\^\\^来实现寻找父节点的父节点\n💯==**git checkout main\\^**==\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624274aea1027.png\" style=\"zoom:50%;\" />\n\n\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624276378ff5f.png)\n\n------\n\n#### 相对引用2(~)\n\n如果你想在提交树中向上移动很多步的话，敲那么多 `^` 貌似也挺烦人的，Git 当然也考虑到了这一点，于是又引入了操作符 `~`。该操作符后面可以跟一个数字（可选，不跟数字时与 `^` 相同，向上移动一次），指定向上移动多少次。\n\n通过多次移动的相对引用命令，实现简洁的后退操作：\n\n💯==**git checkout HEAD\\~\\<num\\>**==\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624276db5423e.png\" style=\"zoom:50%;\" />\n\n\n\n使用相对引用比较多的场景就是移动分支。可以直接使用 `-f` 选项让分支指向另一个提交，达到强制修改分支的目的，例如:\n\n💯==**git branch -f main HEAD~3**==\n\n上面的命令会将 main 分支强制指向 HEAD 的第 3 级父提交。\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62427882a6119.png\" style=\"zoom:50%;\" />\n\n可以发现main分支指向了是HEAD向后移动3级父提交记录上\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a3729f60c.png\" style=\"zoom:50%;\" />\n\n合理使用git branch -f 与git checkout 可以实现对当前提交节点与分支的转换。\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a5ae757e9.png)\n\n------\n\n#### 撤销变更\n\n在 Git 里撤销变更的方法很多。和提交一样，撤销变更由底层部分（暂存区的独立文件或者片段）和上层部分（变更到底是通过哪种方式被撤销的）组成。我们这个应用主要关注的是后者。\n\n主要有两种方法用来撤销变更 —— 一是 `git reset`，还有就是 `git revert`。\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a6fb59604.png\" style=\"zoom:50%;\" />\n\n通过一下撤销变更的命令：\n\n💯==**git reset HEAD~1**==\n\nGit 把 main 分支移回到 C1；现在我们的本地代码库根本就不知道有 C2 这个提交了。但是在reset后， C2 所做的变更还在，但是处于未加入暂存区状态。\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a76660edc.png\" style=\"zoom:50%;\" />\n\ngit reset 撤销的方式对大家一起使用的远端分支是无效的，为了撤销更改并分享给别人，我们需要使用：\n\n💯==**git revert HEAD**==\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a82f31d87.png\" style=\"zoom:50%;\" />\n\n在我们要撤销的提交记录后面居然多了一个新提交！这是因为新提交记录 C2' 引入了**更改** —— 这些更改刚好是用来撤销 C2 这个提交的。也就是说 C2' 的状态与 C1 是相同的。revert 之后就可以把你的更改推送到远程仓库与别人分享啦。\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a9486b1f8.png)\n\n刚才试了一下reset的作用，其实就是本地回退到上一个版本得话，可以在更改一些功能后，通过rebase或者merge指定遗弃分支进行合并或者完全放弃？🤔\n\n------\n\n### Level 3. Git移动提交记录\n\n#### Git Cherry-pick\n\n接下来要讨论的这个话题是“整理提交记录” —— 开发人员有时会说“我想要把这个提交放到这里, 那个提交放到刚才那个提交的后面”, 而接下来就讲的就是它的实现方式，非常清晰、灵活，还很生动。\n\n如果你想将一些提交复制到当前所在的位置（`HEAD`）下面的话， Cherry-pick 是最直接的方式了。命令为：\n\n💯==**git cherry-pick \\<commit_version\\>**==\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242aab507c99.png\" style=\"zoom:50%;\" />\n\n这里有一个仓库, 我们想将 side 分支上的工作复制到 main 分支，rebase 可以解决这个问题，但是也可以通过 cherry-pick, 我们执行命令 git cherry-pick C2 C4\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ab6297234.png\" style=\"zoom:50%;\" />\n\n通过cherry-pick可以直接选取我们要的提交记录在当前分支之下，感觉git的整理提交记录的思想在于维护一条提交的线(主干线)\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242abd0e399a.png)\n\n------\n\n#### 交互式rebase\n\n当你知道你所需要的提交记录（**并且**还知道这些提交记录的哈希值）时, 用 cherry-pick 再好不过了 —— 没有比这更简单的方式了。但是如果你不清楚你想要的提交记录的哈希值呢? 幸好 Git 帮你想到了这一点, 我们可以利用交互式的 rebase —— 如果你想从一系列的提交记录中找到想要的记录, 这就是最好的方法了。\n\n交互式 rebase 指的是使用带参数 `--interactive` 的 rebase 命令, 简写为 `-i`\n\n如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。\n\n在实际使用时，所谓的 UI 窗口一般会在文本编辑器 —— 如 Vim —— 中打开一个文件。\n\n当 rebase UI界面打开时, 你能做3件事:\n\n- 调整提交记录的顺序（通过鼠标拖放来完成）\n- 删除你不想要的提交（通过切换 `pick` 的状态来完成，关闭就意味着你不想要这个提交记录）\n- 合并提交。\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242af2c739cb.png\" style=\"zoom:50%;\" />\n\n输入交互式rebase命令后：\n\n💯==**git rebase -i HEAD[~\\<num\\>|^]**==\n\n通过rebase -i HEAD~4实现对后续提交内容进行调整顺序，删除omit提交与合并\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242b17d54c69.png\" style=\"zoom:50%;\" />\n\n完全重新整理了commit的顺序，但是感觉需要以合理的机会使用，要不然真的会很艰难。\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242b33615af6.png)\n\n------\n\n### Level 4. 杂项\n\n#### 只取一个提交记录\n\n来看一个在开发中经常会遇到的情况：我正在解决某个特别棘手的 Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息。\n\n这些调试和打印语句都在它们各自的提交记录里。最后我终于找到了造成这个 Bug 的根本原因，解决掉以后觉得沾沾自喜！\n\n最后就差把 `bugFix` 分支里的工作合并回 `main` 分支了。你可以选择通过 fast-forward 快速合并到 `main` 分支上，但这样的话 `main` 分支就会包含我这些调试语句了。你肯定不想这样，应该还有更好的方式……\n\n实际我们只要让 Git 复制解决问题的那一个提交记录就可以了。跟之前我们在“整理提交记录”中学到的一样，我们可以使用\n\n- `git rebase -i`\n- `git cherry-pick`\n\n来达到目的。\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242b98be1504.png)\n\n------\n\n#### 提交的技巧 #1\n\n接下来这种情况也是很常见的：你之前在 newImage 分支上进行了一次提交，然后又基于它创建了 caption 分支，然后又提交了一次。\n\n此时你想对某个以前的提交记录进行一些小小的调整。比如设计师想修改一下 `newImage` 中图片的分辨率，尽管那个提交记录并不是最新的了。\n\n我们可以通过下面的方法来克服困难：\n\n- 先用 `git rebase -i` 将提交重新排序，然后把我们想要修改的提交记录挪到最前\n- 然后用 `git commit --amend` 来进行一些小修改\n- 接着再用 `git rebase -i` 来将他们调回原来的顺序\n- 最后我们把 main 移到修改的最前端（用你自己喜欢的方法），就大功告成啦！\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242dbc3cd20f.png)\n\n------\n\n#### 提交的技巧 #2\n\n正如你在上一关所见到的，我们可以使用 `rebase -i` 对提交记录进行重新排序。只要把我们想要的提交记录挪到最前端，我们就可以很轻松的用 `--amend` 修改它，然后把它们重新排成我们想要的顺序。\n\n但这样做就唯一的问题就是要进行两次排序，而这有可能造成由 rebase 而导致的冲突。因此选择使用cherry-pick来实现上述问题。\n\ncherry-pick 可以将提交树上任何地方的提交记录取过来追加到 HEAD 上\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ddc84217c.png)\n\n------\n\n#### Git Tag\n\n分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。有没有什么可以永远指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢？\n\nGit 的 tag 可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。更难得的是，它们并不会随着新的提交而移动。你也不能切换到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。\n\ntag的命令是：\n\n💯==**git tag \\<tag_name\\> \\<commit_name\\>**==\n\n![image-20220329183103581](C:\\Users\\14218\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220329183103581.png)\n\n------\n\n#### Git Describe\n\n由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来**描述**离你最近的锚点（也就是标签），它就是 `git describe`！\n\nGit Describe 能帮你在提交历史中移动了多次以后找到方向；当你用 `git bisect`（一个查找产生 Bug 的提交记录的指令）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时， 可能会用到这个命令。\n\ngit describe的语法是：\n\n💯==**git describe \\<ref\\>**==\t\n\nref 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（HEAD）.\n\n返回类型为💯==**\\<tag\\>\\_\\<numCommits\\>\\_g\\<hash\\>**==\t\n\ntag 表示的是离 ref 最近的标签， numCommits 是表示这个 ref 与 tag 相差有多少个提交记录， hash 表示的是你所给定的 ref 所表示的提交记录哈希值的前几位。当 ref 提交记录上有某个标签时，则只输出标签名称。\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e388a4335.png)\n\n------\n\n### Level 5. Git 高级话题(某些应用)\n\n#### 多分支rebase\n\n通过rebase实现多个分支的合并操作，其实通过rebase branch1 branch2 可以很快的实现，并且记住的是branch1是branch2的父分支的话就很容易实现了，每次rebase应该省略的是branch2的参数(如果不给的话)\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e564c9d33.png)\n\n------\n\n#### 两个父节点\n\n操作符 `^` 与 `~` 符一样，后面也可以跟一个数字。\n\n但是该操作符后面的数字与 `~` 后面的不同，并不是用来指定向上返回几代，而是指定合并提交记录的某个父提交。还记得前面提到过的一个合并提交有两个父提交吧，所以遇到这样的节点时该选择哪条路径就不是很清晰了。\n\nGit 默认选择合并提交的“第一个”父提交，在操作符 `^` 后跟一个数字可以改变这一默认行为。\n\n例如，执行 git checkout main^2 的过程就是回到第二个父提交节点的意思。\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e67ed88f1.png\" style=\"zoom:50%;\" />\n\n并且git支持两个操作符的链式操作 git checkout main\\~\\^2\\~2\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e6cb0c441.png\" style=\"zoom:50%;\" />\n\n\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e85b0e9c3.png)\n\n------\n\n#### 纠缠不清的分支\n\n实现这种不同分支梳理最好的方式是通过cherry-pick，如果方便知道commit的提交哈希值的话。\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e9658f176.png)\n\n------\n\n### Level 6. Push & Pull —— Git 远程仓库\n\n#### Git Clone\n\n远程仓库并不复杂, 在如今的云计算盛行的世界很容易把远程仓库想象成一个富有魔力的东西, 但实际上它们只是你的仓库在另个一台计算机上的拷贝。你可以通过因特网与这台计算机通信 —— 也就是增加或是获取提交记录\n\n话虽如此, 远程仓库却有一系列强大的特性\n\n- 首先也是最重要的的点, 远程仓库是一个强大的备份。本地仓库也有恢复文件到指定版本的能力, 但所有的信息都是保存在本地的。有了远程仓库以后，即使丢失了本地所有数据, 你仍可以通过远程仓库拿回你丢失的数据。\n- 还有就是, 远程让代码社交化了! 既然你的项目被托管到别的地方了, 你的朋友可以更容易地为你的项目做贡献(或者拉取最新的变更)\n\n💯==**git clone**==\n\n通过git clone 可以从远端拉取仓库到本地\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ea37dc283.png)\n\n------\n\n#### 远端分支\n\n你可能注意到的第一个事就是在我们的本地仓库多了一个名为 `o/main` 的分支, 这种类型的分支就叫**远程**分支。由于远程分支的特性导致其拥有一些特殊属性。\n\n远程分支反映了远程仓库(在你上次和它通信时)的**状态**。这会有助于你理解本地的工作与公共工作的差别 —— 这是你与别人分享工作成果前至关重要的一步.\n\n远程分支有一个特别的属性，在你检出时自动进入分离 HEAD 状态。Git 这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作, （更新了远程分支之后）再用远程分享你的工作成果。\n\no/main的意思就是\\<remote name\\>/\\<branch name\\>\n\n如果当前选择的是远端分支的话，进行commit操作是不会直接进行远端分支的更新，而是使本地处于分离HEAD的状态。\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242eb32490c4.png)\n\n------\n\n#### Git Fetch\n\nGit 远程仓库相当的操作实际可以归纳为两点：向远程仓库传输数据以及从远程仓库获取数据。既然我们能与远程仓库同步，那么就可以分享任何能被 Git 管理的更新（因此可以分享代码、文件、想法、情书等等）。\n\n如何从远程仓库获取数据 —— 命令如其名，它就是 git fetch 。\n\n💯==**git fetch**==\n\n**Git Fetch Do:**\n\ngit fetch 完成了仅有的但是很重要的两步:\n\n- 从远程仓库下载本地仓库中缺失的提交记录\n- 更新远程分支指针(如 `o/main`)\n\ngit fetch 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。\n\n如果你还记得上一节课程中我们说过的，远程分支反映了远程仓库在你**最后一次与它通信时**的状态，git fetch 就是你与远程仓库通信的方式了！\n\n**Git Fetch Not Do:**\n\ngit fetch 并不会改变你本地仓库的状态。它不会更新你的 main 分支，也不会修改你磁盘上的文件。\n\n理解这一点很重要，因为许多开发人员误以为执行了 git fetch 以后，他们本地仓库就与远程仓库同步了。它可能已经将进行这一操作所需的所有数据都下载了下来，但是**并没有**修改你本地的文件。git fetch 就是单纯的下载资源的操作。\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ecb8f2bac.png)\n\n------\n\n#### Git Pull\n\n其实有很多方法的 —— 当远程分支中有新的提交时，你可以像合并本地分支那样来合并远程分支。也就是说就是你可以执行以下命令:\n\n- `git cherry-pick o/main`\n- `git rebase o/main`\n- `git merge o/main`\n- 等等\n\n实际上，由于先抓取更新再合并到本地分支这个流程很常用，因此 Git 提供了一个专门的命令来完成这两个操作。\n\n💯==**git pull**==\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ed89ae9c4.png\" style=\"zoom:50%;\" />\n\ngit pull 就是 git fetch 和 git merge的缩写\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ee13e8cad.png)\n\n------\n\n#### 模拟团队合作\n\n在远端操作进行一定更新后，可以通过pull进行及时的拉去更新本地分支\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ee9fb29ea.png)\n\n------\n\n#### Git Push\n\n传自己分享内容与下载他人的分享刚好相反，git push 负责将**你的**变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录。一旦 git push 完成, 你的朋友们就可以从这个远程仓库下载你分享的成果了！\n\n💯==**git push**==\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ef5af3f83.png)\n\n------\n\n#### 偏离的提交历史\n\n假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕，可以发布了。但是 —— 天啊！你的同事这周写了一堆代码，还改了许多你的功能中使用的 API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库了，因此你的工作就变成了基于项目**旧版**的代码，与远程仓库最新的代码不匹配了。\n\n这种情况下, `git push` 就不知道该如何操作了。如果你执行 `git push`，Git 应该让远程仓库回到星期一那天的状态吗？还是直接在新代码的基础上添加你的代码，亦或由于你的提交已经过时而直接忽略你的提交？\n\n因为这情况（历史偏离）有许多的不确定性，Git 是不会允许你 `push` 变更的。实际上它会强制你先合并远程最新的代码，然后才能分享你的工作。\n\n因此主要的解决办法就是先把远端的分支pull下来，然后再merge或者rebase自己的工作到远端分支，然后再合并分支到远端仓库\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242f10bed8b1.png)\n\n------\n\n#### Locked Main\n\n如果你是在一个大的合作团队中工作, 很可能是main被锁定了, 需要一些Pull Request流程来合并修改。如果你直接提交(commit)到本地main, 然后试图推送(push)修改, 你将会收到这样类似的信息:\n\n*! [远程服务器拒绝] main -> main (TF402455: 不允许推送(push)这个分支; 你必须使用pull request来更新这个分支.)*\n\n就是在团队合作的时候，防止过多人频繁push自己的代码到远端仓库，因此需要走pr的审查流程。\n\n解决办法为：新建一个分支feature, 推送到远程服务器. 然后reset你的main分支和远程服务器保持一致, 否则下次你pull并且他人的提交和你冲突的时候就会有问题.\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242f48497d61.png)\n\n------\n\n### Level 7. 关于 origin 和它的周边 —— Git 远程仓库高级操作\n\n#### 推送主分支\n\n在大型项目中开发人员通常会在（从 `main` 上分出来的）特性分支上工作，工作完成后只做一次集成。这跟前面课程的描述很相像（把 side 分支推送到远程仓库），不过本节我们会深入一些.\n\n但是有些开发人员只在 main 上做 push、pull —— 这样的话 main 总是最新的，始终与远程分支 (o/main) 保持一致。\n\n对于接下来这个工作流，我们集成了两个步骤：\n\n- 将特性分支集成到 `main` 上\n- 推送并更新远程分支\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242fc03cb835.png)\n\n过程就是先 git pull --rebase 然后再rebase 合并分支\n\n------\n\n#### 合并远端仓库\n\n在开发社区里，有许多关于 merge 与 rebase 的讨论。以下是关于 rebase 的优缺点：\n\n优点:\n\n- Rebase 使你的提交树变得很干净, 所有的提交都在一条线上\n\n缺点:\n\n- Rebase 修改了提交树的历史\n\n比如, 提交 C1 可以被 rebase 到 C3 之后。这看起来 C1 中的工作是在 C3 之后进行的，但实际上是在 C3 之前。\n\n一些开发人员喜欢保留提交历史，因此更偏爱 merge。而其他人（比如我自己）可能更喜欢干净的提交树，于是偏爱 rebase。仁者见仁，智者见智。 \n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242fd476265d.png)\n\n相对来说，更有细节，更能体现提交历史\n\n#### 远程追踪\n\nGit 好像知道 `main` 与 `o/main` 是相关的。当然这些分支的名字是相似的，可能会让你觉得是依此将远程分支 main 和本地的 main 分支进行了关联。这种关联在以下两种情况下可以清楚地得到展示：\n\n- pull 操作时, 提交记录会被先下载到 o/main 上，之后再合并到本地的 main 分支。隐含的合并目标由这个关联确定的。\n- push 操作时, 我们把工作从 `main` 推到远程仓库中的 `main` 分支(同时会更新远程分支 `o/main`) 。这个推送的目的地也是由这种关联确定的！\n\n直接了当地讲，`main` 和 `o/main` 的关联关系就是由分支的“remote tracking”属性决定的。`main` 被设定为跟踪 `o/main` —— 这意味着为 `main` 分支指定了推送的目的地以及拉取后合并的目标。\n\n你可能想知道 `main` 分支上这个属性是怎么被设定的，你并没有用任何命令指定过这个属性呀！好吧, 当你克隆仓库的时候, Git 就自动帮你把这个属性设置好了。\n\n当你克隆时, Git 会为远程仓库中的每个分支在本地仓库中创建一个远程分支（比如 `o/main`）。然后再创建一个跟踪远程仓库中活动分支的本地分支，默认情况下这个本地分支会被命名为 `main`。\n\n克隆完成后，你会得到一个本地分支（如果没有这个本地分支的话，你的目录就是“空白”的），但是可以查看远程仓库中所有的分支（如果你好奇心很强的话）。这样做对于本地仓库和远程仓库来说，都是最佳选择。\n\n💯==**git checkout -b totallyNotMain o/main**==\n\n可以创建一个totallyNotMain来追踪远程分支o/main\n\n💯==**git branch -u o/main foo**==\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ff7627ed3.png)\n\n------\n\n#### Git Push的参数\n\n首先来看 `git push`。在远程跟踪课程中，你已经学到了 Git 是通过当前检出分支的属性来确定远程仓库以及要 push 的目的地的。这是未指定参数时的行为，我们可以为 push 指定参数，语法是：\n\n💯==**git push \\<remote\\> \\<place\\>**==\n\n把这个命令翻译过来就是：\n\n*切到本地仓库中的“main”分支，获取所有的提交，再到远程仓库“origin”中找到“main”分支，将远程仓库中没有的提交记录都添加上去，搞定之后告诉我。*\n\n我们通过“place”参数来告诉 Git 提交记录来自于 main, 要推送到远程仓库中的 main。它实际就是要同步的两个仓库的位置。\n\n需要注意的是，因为我们通过指定参数告诉了 Git 所有它需要的信息, 所以它就忽略了我们所检出的分支的属性！\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624300d69d378.png)\n\n------\n\n#### Git Push的参数2\n\n，当为 git push 指定 place 参数为 `main` 时，我们同时指定了提交记录的来源和去向。\n\n你可能想问 —— 如果来源和去向分支的名称不同呢？比如你想把本地的 `foo` 分支推送到远程仓库中的 `bar` 分支。\n\n要同时为源和目的地指定 `<place>` 的话，只需要用冒号 `:` 将二者连起来就可以了：\n\n💯==**git push origin \\<source\\>:\\<destination\\>**==\n\n这个参数实际的值是个 refspec，“refspec” 是一个自造的词，意思是 Git 能识别的位置（比如分支 `foo` 或者 `HEAD~1`）\n\n一旦你指定了独立的来源和目的地，就可以组织出言简意赅的远程操作命令了.\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624301c9cddfe.png)\n\n------\n\n#### Git Fetch的参数\n\n`git fetch` 的参数和 `git push` 极其相似。他们的概念是相同的，只是方向相反罢了（因为现在你是下载，而非上传）\n\n💯==**git fetch \\<remote\\> \\<place\\>**==\n\nGit 会到远程仓库的分支上，然后获取所有本地不存在的提交，放到本地的相应分支上。\n\n💯==**git fetch origin \\<source\\>:\\<destination\\>**==\n\n但是命令很不常用就是了\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624301c9cddfe.png)\n\n------\n\n#### 没有source的source\n\nGit 有两种关于 `<source>` 的用法是比较诡异的，即你可以在 git push 或 git fetch 时不指定任何 `source`，方法就是仅保留冒号和 destination 部分，source 部分留空。\n\n- `git push origin :side`\n- `git fetch origin :bugFix`\n\n我们分别来看一下这两条命令的作用……\n\n如果 push 空 到远程仓库会如何呢？它会删除远程仓库中的分支！\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624313c20ceea.png\" style=\"zoom:50%;\" />\n\n如果 fetch 空 到本地，会在本地创建一个新分支。\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624314368592a.png\" style=\"zoom:50%;\" />\n\n\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6243147a70f05.png)\n\n------\n\n#### Git Pull的参数\n\n git pull 到头来就是 fetch 后跟 merge 的缩写。你可以理解为用同样的参数执行 git fetch，然后再 merge 你所抓取到的提交记录。\n\n`git pull origin foo` 相当于：\n\n```\ngit fetch origin foo; git merge o/foo\n```\n\n还有...\n\n`git pull origin bar~1:bugFix` 相当于：\n\n```\ngit fetch origin bar~1:bugFix; git merge bugFix\n```\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624316d49f61c.png)\n\n------\n\n\n\n## Git操作实例\n\n> 在这一个月多的工作里，我也遇到了需要用到git的一些操作，在此总结如下情景：\n\n### 先暂存当前工作而去完成另一个工作\n\n> 遇到过这种情况：在做某个工作到一半还没完成的时候，突然被提醒先去做另外一个工作。这种情况下，现在没做完的工作咋办？\n\n首先，在看了上面的内容之后，不管如果我们一定要先进行 `git commit` 操作。\n\n因为只有在commit之后，当前工作才会成为一个结点。\n\n同时，为了唯一标识当前结点，我们可以采用新建分支或者新建tag的方式标记当前结点：\n\n```\ngit tag tag_name HEAD\n```\n\n在完成该操作后，我们就回到上一个结点，也就是远端所在结点：\n\n```\ngit checkout HEAD^\n\ngit branch -f master HEAD\n\ngit checkout master\n```\n\n此后，我们便可以开始新的工作，以正常的方式进行新的操作（commit啊，push啊都可以）。\n\n当前工作完成之后，我们就可以通过 ` git checkout tag_name ` 回到之前没有完成的工作中去了！\n\n### 更改两次提交的顺序\n\n> 这是今天遇到的一个情况：先完成了一个提交，之后去做另一个工作提交了一次。但这时被提示之前的提交有问题，需要修改。\n>\n> 这个时候，后一次的提交没有问题，可以被点进主分支中。但由于它的父结点是前一次的提交，因此点不进去，怎么办呢？\n\n这个时候，我们就要考虑切换两个分支的顺序了。\n\n首先最重要的是，我们还是要加一个标签标记当前的位置，否则以后就找不到了：\n\n```\ngit tag tag_name HEAD\n```\n\n然后，我们回到上上一次的位置：\n\n```\ngit checkout HEAD~2\n\ngit branch -f master HEAD\n\ngit checkout master\n```\n\n这个时候，我们只要通过 ` cherry-pick ` 操作把刚刚的两个操作反过来串联在一起就行了。\n\n当然，通过前面的学习，我们知道  ` git rebase -i `也是可行的，在这里不再赘述。\n\n","source":"_posts/git基本操作整理.md","raw":"---\ntitle: Git基本操作整理\ndate: 2022-3-29 12:00:00\ndescription: git的一些基本操作，一起交流学习\ncover: https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f9be0486.png\n---\n\n# Git 基本操作整理\n\n## 前言\n\n本文档通过整理CS-Notes中的Git命令操作与实战Learn Git Branching来学习掌握Git方法。因为文档主要分为两部分，第一部分参考CS-Notes并查阅资料为Git理论知识，第二部分为实战Learn Git Branching给出个人思考与过程。\n\n参考资料来源:\n\n1. [CS-Notes Git部分](http://www.cyc2018.xyz/%E5%85%B6%E5%AE%83/%E7%BC%96%E7%A0%81%E5%AE%9E%E8%B7%B5/Git.html#%E9%9B%86%E4%B8%AD%E5%BC%8F%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F)\n\n2. [Learn Git Branching](https://learngitbranching.js.org/?demo=&locale=zh_CN)\n\n## Git知识\n\n\n\n## Learn Git Branching\n\n### Level 1. Git基础内容\n\n#### Git Commit\n\nGit 仓库中的提交记录保存的是你的目录下所有文件的快照，就像是把整个目录复制，然后再粘贴一样，但比复制粘贴优雅许多！\n\nGit 希望提交记录尽可能地轻量，因此在你每次进行提交时，它并不会盲目地复制整个目录。条件允许的情况下，它会将当前版本与仓库中的上一个版本进行对比，并把所有的差异打包到一起作为一个提交记录。Git 还保存了提交的历史记录。这也是为什么大多数提交记录的上面都有父节点的原因。对于项目组的成员来说，维护提交历史对大家都有好处。\n\nGit Commit 就是在父节点下进行一次内容的提交。使用的命令很简单为：\n\n💯==**git commit**==\n\n\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f9be0486.png)\n\n------\n\n#### Git Branch\n\nGit 的分支也非常轻量。它们只是简单地指向某个提交纪录 —— 仅此而已。\n\n所以许多 Git 爱好者传颂：😍**早建分支，多用分支！**\n\n这是因为即使创建再多的分支也不会造成储存或内存上的开销，并且按逻辑分解工作到不同的分支要比维护那些特别臃肿的分支简单多了。\n\n在将分支和提交记录结合起来后，我们会看到两者如何协作。现在只要记住使用分支其实就相当于在说：“**我想基于这个提交以及它所有的父提交进行新的工作。**”\n\n创建分支的命令最基础的就是：\n\n💯==**git branch <branch_name>**==\n\n创建好的分支会指向当前的提交记录。但是通过上述命令创建的分支并不是我们现在所使用的分支，如果我们此刻进行了git commit操作，那么我们的行为仍然是操作于原来的分支。所以我们如果想要使用这个新分支，我们需要使用切换分支的命令：\n\n💯==**git checkout <branch_name>**==\n\n有一个简洁的方式，如果你想创建一个新的分支同时切换到新创建的分支的话，可以通过 \n\n💯==**git checkout -b \\<your-branch-name\\>**==\n\n\n\n![](https://i0.hdslb.com/bfs/album/a11e89444b0b5c7d221325a9637f26e54ebe12c6.png)\n\n------\n\n#### Git Merge\n\n在知道如何提交以及如何使用分支的前提下，接下来是如何将两个分支合并到一起。就是说我们新建一个分支，在其上开发某个新功能，开发完成后再合并回主线。\n\n第一种方法是通过git merge实现的。在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个父节点。翻译成自然语言相当于：“我要把这两个父节点本身及它们所有的祖先都包含进来。”因此，git合并分支的命令是：\n\n💯==**git merge <branch_name>**==\n\n该命令是将branch_name合并到当前的分支下\n\n例如：我们有这两个分支main与bugFix，我们可以通过git merge命令来将两者合并：\n\n<img src=\"https://i0.hdslb.com/bfs/album/1a7e02089e6db4f76cec7be3ca3766caa38c1fd7.png\" style=\"zoom:50%;\" />\n\n合并后，我们发现新的分支是保留了两条路径指向父节点，并没有断了与任何一条分支的联系，因此这个过程支持了Git对历史版本信息的维护。\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f858fa9e.png\" style=\"zoom:50%;\" />\n\n接下来，可以将main分支合并到bugFix中\n\n通过`git checkout bugFix; git merge main`\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f8526a06.png\" style=\"zoom:50%;\" />\n\n因为 main 继承自 bugFix ，Git 什么都不用做，只是简单地把 bugFix 移动到 main 所指向的那个提交记录。\n\n![](https://i0.hdslb.com/bfs/album/08d9d8343a7164f9c6b01eccca5471872790f07f.png)\n\n------\n\n#### Git Rebase\n\n第二种合并分支的方法是 git rebase。Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。\n\nRebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。Rebase的命令如下：\n\n💯==**git rebase <branch_name>**==\n\n例如：同样我们有两个分支main和bugFix，我们可以通过rebase来将两者合并：\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f857516e.png\" style=\"zoom:50%;\" />\n\n通过rebase命令后，不同于原来的merge建立两条关于父节点的链接，而是通过提取一系列的提交记录然后建立一个基于main的副本，这样生成的线性的提交历史：\n\n<img src=\"https://i0.hdslb.com/bfs/album/59f7e1df1314389ddbbcb14fda46a0a679d6c999.png\" style=\"zoom:50%;\" />\n\n此时，原先分支的C3并没有被删除，接下来可以切换到main分支，通过rebase向前推进一个版本\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f857627e.png\" style=\"zoom:50%;\" />\n\nrebase命令维护一条线性的提交记录使得历史提交很清晰。我理解的话，主要是通过在代合并的分支上补充原有分支的一些历史提交信息，然后类似于“复制”了一个版本到待合并分支下，实现一个合并操作。\n\n![](https://i0.hdslb.com/bfs/album/8ee6ba5797dbd7b567f3a9f05c43a9d88472e13d.png)\n\n------\n\n### Level 2. Git高级内容\n\n#### 分离HEAD\n\nHEAD 是一个对当前检出记录的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。\n\nHEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。\n\nHEAD 通常情况下是指向分支名的（如 bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。\n\n**分离的 HEAD 就是让其指向了某个具体的提交记录而不是分支名。**在命令执行之前的状态如下所示：\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242631f0352b.png\" style=\"zoom:50%;\" />\n\nHEAD -> main -> C1\n\nHEAD 指向 main， main 指向 C1\n\n再通过 **git checkout C1** 后变成了：\n\nHEAD -> C1\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624263c60010b.png\" style=\"zoom:50%;\" />\n\n\n\n所以分离当前HEAD是通过：\n\n💯==**git checkout \\<hash_commit\\>**==\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624264090b652.png)\n\n------\n\n#### 相对引用(^)\n\n通过指定提交记录哈希值的方式在 Git 中移动不太方便。在实际应用时，并没有像本程序中这么漂亮的可视化提交树供你参考，所以你就不得不用 `git log` 来查查看提交记录的哈希值。\n\n并且哈希值在真实的 Git 世界中也会更长（e.g. 基于 SHA-1，共 40 位）。例如前一关的介绍中的提交记录的哈希值可能是 `fed2da64c0efc5293610bdd892f82a58e8cbc5d8`。比较令人欣慰的是，Git 对哈希的处理很智能。你只需要提供能够唯一标识提交记录的前几个字符即可。因此我可以仅输入`fed2` 而不是上面的一长串字符。\n\n通过哈希值提交记录很不方便，所以git引用了相对引用。使用相对引用的话，就可以从一个易于记忆的地方（比如 `bugFix` 分支或 `HEAD`）开始计算。\n\n相对引用非常给力，这里我介绍两个简单的用法：\n\n- 使用 `^` 向上移动 1 个提交记录\n- 使用 `~<num>` 向上移动多个提交记录，如 `~3`\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624274834cddb.png\" style=\"zoom:50%;\" />\n\n通过使用(\\^)可以相对很方便找到main的父节点，而不是通过哈希的方式，以此类推，可以通过main\\^\\^来实现寻找父节点的父节点\n💯==**git checkout main\\^**==\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624274aea1027.png\" style=\"zoom:50%;\" />\n\n\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624276378ff5f.png)\n\n------\n\n#### 相对引用2(~)\n\n如果你想在提交树中向上移动很多步的话，敲那么多 `^` 貌似也挺烦人的，Git 当然也考虑到了这一点，于是又引入了操作符 `~`。该操作符后面可以跟一个数字（可选，不跟数字时与 `^` 相同，向上移动一次），指定向上移动多少次。\n\n通过多次移动的相对引用命令，实现简洁的后退操作：\n\n💯==**git checkout HEAD\\~\\<num\\>**==\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624276db5423e.png\" style=\"zoom:50%;\" />\n\n\n\n使用相对引用比较多的场景就是移动分支。可以直接使用 `-f` 选项让分支指向另一个提交，达到强制修改分支的目的，例如:\n\n💯==**git branch -f main HEAD~3**==\n\n上面的命令会将 main 分支强制指向 HEAD 的第 3 级父提交。\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62427882a6119.png\" style=\"zoom:50%;\" />\n\n可以发现main分支指向了是HEAD向后移动3级父提交记录上\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a3729f60c.png\" style=\"zoom:50%;\" />\n\n合理使用git branch -f 与git checkout 可以实现对当前提交节点与分支的转换。\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a5ae757e9.png)\n\n------\n\n#### 撤销变更\n\n在 Git 里撤销变更的方法很多。和提交一样，撤销变更由底层部分（暂存区的独立文件或者片段）和上层部分（变更到底是通过哪种方式被撤销的）组成。我们这个应用主要关注的是后者。\n\n主要有两种方法用来撤销变更 —— 一是 `git reset`，还有就是 `git revert`。\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a6fb59604.png\" style=\"zoom:50%;\" />\n\n通过一下撤销变更的命令：\n\n💯==**git reset HEAD~1**==\n\nGit 把 main 分支移回到 C1；现在我们的本地代码库根本就不知道有 C2 这个提交了。但是在reset后， C2 所做的变更还在，但是处于未加入暂存区状态。\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a76660edc.png\" style=\"zoom:50%;\" />\n\ngit reset 撤销的方式对大家一起使用的远端分支是无效的，为了撤销更改并分享给别人，我们需要使用：\n\n💯==**git revert HEAD**==\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a82f31d87.png\" style=\"zoom:50%;\" />\n\n在我们要撤销的提交记录后面居然多了一个新提交！这是因为新提交记录 C2' 引入了**更改** —— 这些更改刚好是用来撤销 C2 这个提交的。也就是说 C2' 的状态与 C1 是相同的。revert 之后就可以把你的更改推送到远程仓库与别人分享啦。\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a9486b1f8.png)\n\n刚才试了一下reset的作用，其实就是本地回退到上一个版本得话，可以在更改一些功能后，通过rebase或者merge指定遗弃分支进行合并或者完全放弃？🤔\n\n------\n\n### Level 3. Git移动提交记录\n\n#### Git Cherry-pick\n\n接下来要讨论的这个话题是“整理提交记录” —— 开发人员有时会说“我想要把这个提交放到这里, 那个提交放到刚才那个提交的后面”, 而接下来就讲的就是它的实现方式，非常清晰、灵活，还很生动。\n\n如果你想将一些提交复制到当前所在的位置（`HEAD`）下面的话， Cherry-pick 是最直接的方式了。命令为：\n\n💯==**git cherry-pick \\<commit_version\\>**==\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242aab507c99.png\" style=\"zoom:50%;\" />\n\n这里有一个仓库, 我们想将 side 分支上的工作复制到 main 分支，rebase 可以解决这个问题，但是也可以通过 cherry-pick, 我们执行命令 git cherry-pick C2 C4\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ab6297234.png\" style=\"zoom:50%;\" />\n\n通过cherry-pick可以直接选取我们要的提交记录在当前分支之下，感觉git的整理提交记录的思想在于维护一条提交的线(主干线)\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242abd0e399a.png)\n\n------\n\n#### 交互式rebase\n\n当你知道你所需要的提交记录（**并且**还知道这些提交记录的哈希值）时, 用 cherry-pick 再好不过了 —— 没有比这更简单的方式了。但是如果你不清楚你想要的提交记录的哈希值呢? 幸好 Git 帮你想到了这一点, 我们可以利用交互式的 rebase —— 如果你想从一系列的提交记录中找到想要的记录, 这就是最好的方法了。\n\n交互式 rebase 指的是使用带参数 `--interactive` 的 rebase 命令, 简写为 `-i`\n\n如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。\n\n在实际使用时，所谓的 UI 窗口一般会在文本编辑器 —— 如 Vim —— 中打开一个文件。\n\n当 rebase UI界面打开时, 你能做3件事:\n\n- 调整提交记录的顺序（通过鼠标拖放来完成）\n- 删除你不想要的提交（通过切换 `pick` 的状态来完成，关闭就意味着你不想要这个提交记录）\n- 合并提交。\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242af2c739cb.png\" style=\"zoom:50%;\" />\n\n输入交互式rebase命令后：\n\n💯==**git rebase -i HEAD[~\\<num\\>|^]**==\n\n通过rebase -i HEAD~4实现对后续提交内容进行调整顺序，删除omit提交与合并\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242b17d54c69.png\" style=\"zoom:50%;\" />\n\n完全重新整理了commit的顺序，但是感觉需要以合理的机会使用，要不然真的会很艰难。\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242b33615af6.png)\n\n------\n\n### Level 4. 杂项\n\n#### 只取一个提交记录\n\n来看一个在开发中经常会遇到的情况：我正在解决某个特别棘手的 Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息。\n\n这些调试和打印语句都在它们各自的提交记录里。最后我终于找到了造成这个 Bug 的根本原因，解决掉以后觉得沾沾自喜！\n\n最后就差把 `bugFix` 分支里的工作合并回 `main` 分支了。你可以选择通过 fast-forward 快速合并到 `main` 分支上，但这样的话 `main` 分支就会包含我这些调试语句了。你肯定不想这样，应该还有更好的方式……\n\n实际我们只要让 Git 复制解决问题的那一个提交记录就可以了。跟之前我们在“整理提交记录”中学到的一样，我们可以使用\n\n- `git rebase -i`\n- `git cherry-pick`\n\n来达到目的。\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242b98be1504.png)\n\n------\n\n#### 提交的技巧 #1\n\n接下来这种情况也是很常见的：你之前在 newImage 分支上进行了一次提交，然后又基于它创建了 caption 分支，然后又提交了一次。\n\n此时你想对某个以前的提交记录进行一些小小的调整。比如设计师想修改一下 `newImage` 中图片的分辨率，尽管那个提交记录并不是最新的了。\n\n我们可以通过下面的方法来克服困难：\n\n- 先用 `git rebase -i` 将提交重新排序，然后把我们想要修改的提交记录挪到最前\n- 然后用 `git commit --amend` 来进行一些小修改\n- 接着再用 `git rebase -i` 来将他们调回原来的顺序\n- 最后我们把 main 移到修改的最前端（用你自己喜欢的方法），就大功告成啦！\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242dbc3cd20f.png)\n\n------\n\n#### 提交的技巧 #2\n\n正如你在上一关所见到的，我们可以使用 `rebase -i` 对提交记录进行重新排序。只要把我们想要的提交记录挪到最前端，我们就可以很轻松的用 `--amend` 修改它，然后把它们重新排成我们想要的顺序。\n\n但这样做就唯一的问题就是要进行两次排序，而这有可能造成由 rebase 而导致的冲突。因此选择使用cherry-pick来实现上述问题。\n\ncherry-pick 可以将提交树上任何地方的提交记录取过来追加到 HEAD 上\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ddc84217c.png)\n\n------\n\n#### Git Tag\n\n分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。有没有什么可以永远指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢？\n\nGit 的 tag 可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。更难得的是，它们并不会随着新的提交而移动。你也不能切换到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。\n\ntag的命令是：\n\n💯==**git tag \\<tag_name\\> \\<commit_name\\>**==\n\n![image-20220329183103581](C:\\Users\\14218\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220329183103581.png)\n\n------\n\n#### Git Describe\n\n由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来**描述**离你最近的锚点（也就是标签），它就是 `git describe`！\n\nGit Describe 能帮你在提交历史中移动了多次以后找到方向；当你用 `git bisect`（一个查找产生 Bug 的提交记录的指令）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时， 可能会用到这个命令。\n\ngit describe的语法是：\n\n💯==**git describe \\<ref\\>**==\t\n\nref 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（HEAD）.\n\n返回类型为💯==**\\<tag\\>\\_\\<numCommits\\>\\_g\\<hash\\>**==\t\n\ntag 表示的是离 ref 最近的标签， numCommits 是表示这个 ref 与 tag 相差有多少个提交记录， hash 表示的是你所给定的 ref 所表示的提交记录哈希值的前几位。当 ref 提交记录上有某个标签时，则只输出标签名称。\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e388a4335.png)\n\n------\n\n### Level 5. Git 高级话题(某些应用)\n\n#### 多分支rebase\n\n通过rebase实现多个分支的合并操作，其实通过rebase branch1 branch2 可以很快的实现，并且记住的是branch1是branch2的父分支的话就很容易实现了，每次rebase应该省略的是branch2的参数(如果不给的话)\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e564c9d33.png)\n\n------\n\n#### 两个父节点\n\n操作符 `^` 与 `~` 符一样，后面也可以跟一个数字。\n\n但是该操作符后面的数字与 `~` 后面的不同，并不是用来指定向上返回几代，而是指定合并提交记录的某个父提交。还记得前面提到过的一个合并提交有两个父提交吧，所以遇到这样的节点时该选择哪条路径就不是很清晰了。\n\nGit 默认选择合并提交的“第一个”父提交，在操作符 `^` 后跟一个数字可以改变这一默认行为。\n\n例如，执行 git checkout main^2 的过程就是回到第二个父提交节点的意思。\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e67ed88f1.png\" style=\"zoom:50%;\" />\n\n并且git支持两个操作符的链式操作 git checkout main\\~\\^2\\~2\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e6cb0c441.png\" style=\"zoom:50%;\" />\n\n\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e85b0e9c3.png)\n\n------\n\n#### 纠缠不清的分支\n\n实现这种不同分支梳理最好的方式是通过cherry-pick，如果方便知道commit的提交哈希值的话。\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e9658f176.png)\n\n------\n\n### Level 6. Push & Pull —— Git 远程仓库\n\n#### Git Clone\n\n远程仓库并不复杂, 在如今的云计算盛行的世界很容易把远程仓库想象成一个富有魔力的东西, 但实际上它们只是你的仓库在另个一台计算机上的拷贝。你可以通过因特网与这台计算机通信 —— 也就是增加或是获取提交记录\n\n话虽如此, 远程仓库却有一系列强大的特性\n\n- 首先也是最重要的的点, 远程仓库是一个强大的备份。本地仓库也有恢复文件到指定版本的能力, 但所有的信息都是保存在本地的。有了远程仓库以后，即使丢失了本地所有数据, 你仍可以通过远程仓库拿回你丢失的数据。\n- 还有就是, 远程让代码社交化了! 既然你的项目被托管到别的地方了, 你的朋友可以更容易地为你的项目做贡献(或者拉取最新的变更)\n\n💯==**git clone**==\n\n通过git clone 可以从远端拉取仓库到本地\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ea37dc283.png)\n\n------\n\n#### 远端分支\n\n你可能注意到的第一个事就是在我们的本地仓库多了一个名为 `o/main` 的分支, 这种类型的分支就叫**远程**分支。由于远程分支的特性导致其拥有一些特殊属性。\n\n远程分支反映了远程仓库(在你上次和它通信时)的**状态**。这会有助于你理解本地的工作与公共工作的差别 —— 这是你与别人分享工作成果前至关重要的一步.\n\n远程分支有一个特别的属性，在你检出时自动进入分离 HEAD 状态。Git 这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作, （更新了远程分支之后）再用远程分享你的工作成果。\n\no/main的意思就是\\<remote name\\>/\\<branch name\\>\n\n如果当前选择的是远端分支的话，进行commit操作是不会直接进行远端分支的更新，而是使本地处于分离HEAD的状态。\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242eb32490c4.png)\n\n------\n\n#### Git Fetch\n\nGit 远程仓库相当的操作实际可以归纳为两点：向远程仓库传输数据以及从远程仓库获取数据。既然我们能与远程仓库同步，那么就可以分享任何能被 Git 管理的更新（因此可以分享代码、文件、想法、情书等等）。\n\n如何从远程仓库获取数据 —— 命令如其名，它就是 git fetch 。\n\n💯==**git fetch**==\n\n**Git Fetch Do:**\n\ngit fetch 完成了仅有的但是很重要的两步:\n\n- 从远程仓库下载本地仓库中缺失的提交记录\n- 更新远程分支指针(如 `o/main`)\n\ngit fetch 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。\n\n如果你还记得上一节课程中我们说过的，远程分支反映了远程仓库在你**最后一次与它通信时**的状态，git fetch 就是你与远程仓库通信的方式了！\n\n**Git Fetch Not Do:**\n\ngit fetch 并不会改变你本地仓库的状态。它不会更新你的 main 分支，也不会修改你磁盘上的文件。\n\n理解这一点很重要，因为许多开发人员误以为执行了 git fetch 以后，他们本地仓库就与远程仓库同步了。它可能已经将进行这一操作所需的所有数据都下载了下来，但是**并没有**修改你本地的文件。git fetch 就是单纯的下载资源的操作。\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ecb8f2bac.png)\n\n------\n\n#### Git Pull\n\n其实有很多方法的 —— 当远程分支中有新的提交时，你可以像合并本地分支那样来合并远程分支。也就是说就是你可以执行以下命令:\n\n- `git cherry-pick o/main`\n- `git rebase o/main`\n- `git merge o/main`\n- 等等\n\n实际上，由于先抓取更新再合并到本地分支这个流程很常用，因此 Git 提供了一个专门的命令来完成这两个操作。\n\n💯==**git pull**==\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ed89ae9c4.png\" style=\"zoom:50%;\" />\n\ngit pull 就是 git fetch 和 git merge的缩写\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ee13e8cad.png)\n\n------\n\n#### 模拟团队合作\n\n在远端操作进行一定更新后，可以通过pull进行及时的拉去更新本地分支\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ee9fb29ea.png)\n\n------\n\n#### Git Push\n\n传自己分享内容与下载他人的分享刚好相反，git push 负责将**你的**变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录。一旦 git push 完成, 你的朋友们就可以从这个远程仓库下载你分享的成果了！\n\n💯==**git push**==\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ef5af3f83.png)\n\n------\n\n#### 偏离的提交历史\n\n假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕，可以发布了。但是 —— 天啊！你的同事这周写了一堆代码，还改了许多你的功能中使用的 API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库了，因此你的工作就变成了基于项目**旧版**的代码，与远程仓库最新的代码不匹配了。\n\n这种情况下, `git push` 就不知道该如何操作了。如果你执行 `git push`，Git 应该让远程仓库回到星期一那天的状态吗？还是直接在新代码的基础上添加你的代码，亦或由于你的提交已经过时而直接忽略你的提交？\n\n因为这情况（历史偏离）有许多的不确定性，Git 是不会允许你 `push` 变更的。实际上它会强制你先合并远程最新的代码，然后才能分享你的工作。\n\n因此主要的解决办法就是先把远端的分支pull下来，然后再merge或者rebase自己的工作到远端分支，然后再合并分支到远端仓库\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242f10bed8b1.png)\n\n------\n\n#### Locked Main\n\n如果你是在一个大的合作团队中工作, 很可能是main被锁定了, 需要一些Pull Request流程来合并修改。如果你直接提交(commit)到本地main, 然后试图推送(push)修改, 你将会收到这样类似的信息:\n\n*! [远程服务器拒绝] main -> main (TF402455: 不允许推送(push)这个分支; 你必须使用pull request来更新这个分支.)*\n\n就是在团队合作的时候，防止过多人频繁push自己的代码到远端仓库，因此需要走pr的审查流程。\n\n解决办法为：新建一个分支feature, 推送到远程服务器. 然后reset你的main分支和远程服务器保持一致, 否则下次你pull并且他人的提交和你冲突的时候就会有问题.\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242f48497d61.png)\n\n------\n\n### Level 7. 关于 origin 和它的周边 —— Git 远程仓库高级操作\n\n#### 推送主分支\n\n在大型项目中开发人员通常会在（从 `main` 上分出来的）特性分支上工作，工作完成后只做一次集成。这跟前面课程的描述很相像（把 side 分支推送到远程仓库），不过本节我们会深入一些.\n\n但是有些开发人员只在 main 上做 push、pull —— 这样的话 main 总是最新的，始终与远程分支 (o/main) 保持一致。\n\n对于接下来这个工作流，我们集成了两个步骤：\n\n- 将特性分支集成到 `main` 上\n- 推送并更新远程分支\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242fc03cb835.png)\n\n过程就是先 git pull --rebase 然后再rebase 合并分支\n\n------\n\n#### 合并远端仓库\n\n在开发社区里，有许多关于 merge 与 rebase 的讨论。以下是关于 rebase 的优缺点：\n\n优点:\n\n- Rebase 使你的提交树变得很干净, 所有的提交都在一条线上\n\n缺点:\n\n- Rebase 修改了提交树的历史\n\n比如, 提交 C1 可以被 rebase 到 C3 之后。这看起来 C1 中的工作是在 C3 之后进行的，但实际上是在 C3 之前。\n\n一些开发人员喜欢保留提交历史，因此更偏爱 merge。而其他人（比如我自己）可能更喜欢干净的提交树，于是偏爱 rebase。仁者见仁，智者见智。 \n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242fd476265d.png)\n\n相对来说，更有细节，更能体现提交历史\n\n#### 远程追踪\n\nGit 好像知道 `main` 与 `o/main` 是相关的。当然这些分支的名字是相似的，可能会让你觉得是依此将远程分支 main 和本地的 main 分支进行了关联。这种关联在以下两种情况下可以清楚地得到展示：\n\n- pull 操作时, 提交记录会被先下载到 o/main 上，之后再合并到本地的 main 分支。隐含的合并目标由这个关联确定的。\n- push 操作时, 我们把工作从 `main` 推到远程仓库中的 `main` 分支(同时会更新远程分支 `o/main`) 。这个推送的目的地也是由这种关联确定的！\n\n直接了当地讲，`main` 和 `o/main` 的关联关系就是由分支的“remote tracking”属性决定的。`main` 被设定为跟踪 `o/main` —— 这意味着为 `main` 分支指定了推送的目的地以及拉取后合并的目标。\n\n你可能想知道 `main` 分支上这个属性是怎么被设定的，你并没有用任何命令指定过这个属性呀！好吧, 当你克隆仓库的时候, Git 就自动帮你把这个属性设置好了。\n\n当你克隆时, Git 会为远程仓库中的每个分支在本地仓库中创建一个远程分支（比如 `o/main`）。然后再创建一个跟踪远程仓库中活动分支的本地分支，默认情况下这个本地分支会被命名为 `main`。\n\n克隆完成后，你会得到一个本地分支（如果没有这个本地分支的话，你的目录就是“空白”的），但是可以查看远程仓库中所有的分支（如果你好奇心很强的话）。这样做对于本地仓库和远程仓库来说，都是最佳选择。\n\n💯==**git checkout -b totallyNotMain o/main**==\n\n可以创建一个totallyNotMain来追踪远程分支o/main\n\n💯==**git branch -u o/main foo**==\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ff7627ed3.png)\n\n------\n\n#### Git Push的参数\n\n首先来看 `git push`。在远程跟踪课程中，你已经学到了 Git 是通过当前检出分支的属性来确定远程仓库以及要 push 的目的地的。这是未指定参数时的行为，我们可以为 push 指定参数，语法是：\n\n💯==**git push \\<remote\\> \\<place\\>**==\n\n把这个命令翻译过来就是：\n\n*切到本地仓库中的“main”分支，获取所有的提交，再到远程仓库“origin”中找到“main”分支，将远程仓库中没有的提交记录都添加上去，搞定之后告诉我。*\n\n我们通过“place”参数来告诉 Git 提交记录来自于 main, 要推送到远程仓库中的 main。它实际就是要同步的两个仓库的位置。\n\n需要注意的是，因为我们通过指定参数告诉了 Git 所有它需要的信息, 所以它就忽略了我们所检出的分支的属性！\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624300d69d378.png)\n\n------\n\n#### Git Push的参数2\n\n，当为 git push 指定 place 参数为 `main` 时，我们同时指定了提交记录的来源和去向。\n\n你可能想问 —— 如果来源和去向分支的名称不同呢？比如你想把本地的 `foo` 分支推送到远程仓库中的 `bar` 分支。\n\n要同时为源和目的地指定 `<place>` 的话，只需要用冒号 `:` 将二者连起来就可以了：\n\n💯==**git push origin \\<source\\>:\\<destination\\>**==\n\n这个参数实际的值是个 refspec，“refspec” 是一个自造的词，意思是 Git 能识别的位置（比如分支 `foo` 或者 `HEAD~1`）\n\n一旦你指定了独立的来源和目的地，就可以组织出言简意赅的远程操作命令了.\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624301c9cddfe.png)\n\n------\n\n#### Git Fetch的参数\n\n`git fetch` 的参数和 `git push` 极其相似。他们的概念是相同的，只是方向相反罢了（因为现在你是下载，而非上传）\n\n💯==**git fetch \\<remote\\> \\<place\\>**==\n\nGit 会到远程仓库的分支上，然后获取所有本地不存在的提交，放到本地的相应分支上。\n\n💯==**git fetch origin \\<source\\>:\\<destination\\>**==\n\n但是命令很不常用就是了\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624301c9cddfe.png)\n\n------\n\n#### 没有source的source\n\nGit 有两种关于 `<source>` 的用法是比较诡异的，即你可以在 git push 或 git fetch 时不指定任何 `source`，方法就是仅保留冒号和 destination 部分，source 部分留空。\n\n- `git push origin :side`\n- `git fetch origin :bugFix`\n\n我们分别来看一下这两条命令的作用……\n\n如果 push 空 到远程仓库会如何呢？它会删除远程仓库中的分支！\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624313c20ceea.png\" style=\"zoom:50%;\" />\n\n如果 fetch 空 到本地，会在本地创建一个新分支。\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624314368592a.png\" style=\"zoom:50%;\" />\n\n\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6243147a70f05.png)\n\n------\n\n#### Git Pull的参数\n\n git pull 到头来就是 fetch 后跟 merge 的缩写。你可以理解为用同样的参数执行 git fetch，然后再 merge 你所抓取到的提交记录。\n\n`git pull origin foo` 相当于：\n\n```\ngit fetch origin foo; git merge o/foo\n```\n\n还有...\n\n`git pull origin bar~1:bugFix` 相当于：\n\n```\ngit fetch origin bar~1:bugFix; git merge bugFix\n```\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624316d49f61c.png)\n\n------\n\n\n\n## Git操作实例\n\n> 在这一个月多的工作里，我也遇到了需要用到git的一些操作，在此总结如下情景：\n\n### 先暂存当前工作而去完成另一个工作\n\n> 遇到过这种情况：在做某个工作到一半还没完成的时候，突然被提醒先去做另外一个工作。这种情况下，现在没做完的工作咋办？\n\n首先，在看了上面的内容之后，不管如果我们一定要先进行 `git commit` 操作。\n\n因为只有在commit之后，当前工作才会成为一个结点。\n\n同时，为了唯一标识当前结点，我们可以采用新建分支或者新建tag的方式标记当前结点：\n\n```\ngit tag tag_name HEAD\n```\n\n在完成该操作后，我们就回到上一个结点，也就是远端所在结点：\n\n```\ngit checkout HEAD^\n\ngit branch -f master HEAD\n\ngit checkout master\n```\n\n此后，我们便可以开始新的工作，以正常的方式进行新的操作（commit啊，push啊都可以）。\n\n当前工作完成之后，我们就可以通过 ` git checkout tag_name ` 回到之前没有完成的工作中去了！\n\n### 更改两次提交的顺序\n\n> 这是今天遇到的一个情况：先完成了一个提交，之后去做另一个工作提交了一次。但这时被提示之前的提交有问题，需要修改。\n>\n> 这个时候，后一次的提交没有问题，可以被点进主分支中。但由于它的父结点是前一次的提交，因此点不进去，怎么办呢？\n\n这个时候，我们就要考虑切换两个分支的顺序了。\n\n首先最重要的是，我们还是要加一个标签标记当前的位置，否则以后就找不到了：\n\n```\ngit tag tag_name HEAD\n```\n\n然后，我们回到上上一次的位置：\n\n```\ngit checkout HEAD~2\n\ngit branch -f master HEAD\n\ngit checkout master\n```\n\n这个时候，我们只要通过 ` cherry-pick ` 操作把刚刚的两个操作反过来串联在一起就行了。\n\n当然，通过前面的学习，我们知道  ` git rebase -i `也是可行的，在这里不再赘述。\n\n","slug":"git基本操作整理","published":1,"updated":"2022-04-03T12:19:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clrfw2jgk000hstfadvjwcplc","content":"<h1 id=\"Git-基本操作整理\"><a href=\"#Git-基本操作整理\" class=\"headerlink\" title=\"Git 基本操作整理\"></a>Git 基本操作整理</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文档通过整理CS-Notes中的Git命令操作与实战Learn Git Branching来学习掌握Git方法。因为文档主要分为两部分，第一部分参考CS-Notes并查阅资料为Git理论知识，第二部分为实战Learn Git Branching给出个人思考与过程。</p>\n<p>参考资料来源:</p>\n<ol>\n<li><p><a href=\"http://www.cyc2018.xyz/%E5%85%B6%E5%AE%83/%E7%BC%96%E7%A0%81%E5%AE%9E%E8%B7%B5/Git.html#%E9%9B%86%E4%B8%AD%E5%BC%8F%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F\">CS-Notes Git部分</a></p>\n</li>\n<li><p><a href=\"https://learngitbranching.js.org/?demo=&locale=zh_CN\">Learn Git Branching</a></p>\n</li>\n</ol>\n<h2 id=\"Git知识\"><a href=\"#Git知识\" class=\"headerlink\" title=\"Git知识\"></a>Git知识</h2><h2 id=\"Learn-Git-Branching\"><a href=\"#Learn-Git-Branching\" class=\"headerlink\" title=\"Learn Git Branching\"></a>Learn Git Branching</h2><h3 id=\"Level-1-Git基础内容\"><a href=\"#Level-1-Git基础内容\" class=\"headerlink\" title=\"Level 1. Git基础内容\"></a>Level 1. Git基础内容</h3><h4 id=\"Git-Commit\"><a href=\"#Git-Commit\" class=\"headerlink\" title=\"Git Commit\"></a>Git Commit</h4><p>Git 仓库中的提交记录保存的是你的目录下所有文件的快照，就像是把整个目录复制，然后再粘贴一样，但比复制粘贴优雅许多！</p>\n<p>Git 希望提交记录尽可能地轻量，因此在你每次进行提交时，它并不会盲目地复制整个目录。条件允许的情况下，它会将当前版本与仓库中的上一个版本进行对比，并把所有的差异打包到一起作为一个提交记录。Git 还保存了提交的历史记录。这也是为什么大多数提交记录的上面都有父节点的原因。对于项目组的成员来说，维护提交历史对大家都有好处。</p>\n<p>Git Commit 就是在父节点下进行一次内容的提交。使用的命令很简单为：</p>\n<p>💯==<strong>git commit</strong>==</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f9be0486.png\"></p>\n<hr>\n<h4 id=\"Git-Branch\"><a href=\"#Git-Branch\" class=\"headerlink\" title=\"Git Branch\"></a>Git Branch</h4><p>Git 的分支也非常轻量。它们只是简单地指向某个提交纪录 —— 仅此而已。</p>\n<p>所以许多 Git 爱好者传颂：😍<strong>早建分支，多用分支！</strong></p>\n<p>这是因为即使创建再多的分支也不会造成储存或内存上的开销，并且按逻辑分解工作到不同的分支要比维护那些特别臃肿的分支简单多了。</p>\n<p>在将分支和提交记录结合起来后，我们会看到两者如何协作。现在只要记住使用分支其实就相当于在说：“<strong>我想基于这个提交以及它所有的父提交进行新的工作。</strong>”</p>\n<p>创建分支的命令最基础的就是：</p>\n<p>💯==<strong>git branch <branch_name></strong>==</p>\n<p>创建好的分支会指向当前的提交记录。但是通过上述命令创建的分支并不是我们现在所使用的分支，如果我们此刻进行了git commit操作，那么我们的行为仍然是操作于原来的分支。所以我们如果想要使用这个新分支，我们需要使用切换分支的命令：</p>\n<p>💯==<strong>git checkout <branch_name></strong>==</p>\n<p>有一个简洁的方式，如果你想创建一个新的分支同时切换到新创建的分支的话，可以通过 </p>\n<p>💯==<strong>git checkout -b &lt;your-branch-name&gt;</strong>==</p>\n<p><img src=\"https://i0.hdslb.com/bfs/album/a11e89444b0b5c7d221325a9637f26e54ebe12c6.png\"></p>\n<hr>\n<h4 id=\"Git-Merge\"><a href=\"#Git-Merge\" class=\"headerlink\" title=\"Git Merge\"></a>Git Merge</h4><p>在知道如何提交以及如何使用分支的前提下，接下来是如何将两个分支合并到一起。就是说我们新建一个分支，在其上开发某个新功能，开发完成后再合并回主线。</p>\n<p>第一种方法是通过git merge实现的。在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个父节点。翻译成自然语言相当于：“我要把这两个父节点本身及它们所有的祖先都包含进来。”因此，git合并分支的命令是：</p>\n<p>💯==<strong>git merge <branch_name></strong>==</p>\n<p>该命令是将branch_name合并到当前的分支下</p>\n<p>例如：我们有这两个分支main与bugFix，我们可以通过git merge命令来将两者合并：</p>\n<img src=\"https://i0.hdslb.com/bfs/album/1a7e02089e6db4f76cec7be3ca3766caa38c1fd7.png\" style=\"zoom:50%;\" />\n\n<p>合并后，我们发现新的分支是保留了两条路径指向父节点，并没有断了与任何一条分支的联系，因此这个过程支持了Git对历史版本信息的维护。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f858fa9e.png\" style=\"zoom:50%;\" />\n\n<p>接下来，可以将main分支合并到bugFix中</p>\n<p>通过<code>git checkout bugFix; git merge main</code></p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f8526a06.png\" style=\"zoom:50%;\" />\n\n<p>因为 main 继承自 bugFix ，Git 什么都不用做，只是简单地把 bugFix 移动到 main 所指向的那个提交记录。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/album/08d9d8343a7164f9c6b01eccca5471872790f07f.png\"></p>\n<hr>\n<h4 id=\"Git-Rebase\"><a href=\"#Git-Rebase\" class=\"headerlink\" title=\"Git Rebase\"></a>Git Rebase</h4><p>第二种合并分支的方法是 git rebase。Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。</p>\n<p>Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。Rebase的命令如下：</p>\n<p>💯==<strong>git rebase <branch_name></strong>==</p>\n<p>例如：同样我们有两个分支main和bugFix，我们可以通过rebase来将两者合并：</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f857516e.png\" style=\"zoom:50%;\" />\n\n<p>通过rebase命令后，不同于原来的merge建立两条关于父节点的链接，而是通过提取一系列的提交记录然后建立一个基于main的副本，这样生成的线性的提交历史：</p>\n<img src=\"https://i0.hdslb.com/bfs/album/59f7e1df1314389ddbbcb14fda46a0a679d6c999.png\" style=\"zoom:50%;\" />\n\n<p>此时，原先分支的C3并没有被删除，接下来可以切换到main分支，通过rebase向前推进一个版本</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f857627e.png\" style=\"zoom:50%;\" />\n\n<p>rebase命令维护一条线性的提交记录使得历史提交很清晰。我理解的话，主要是通过在代合并的分支上补充原有分支的一些历史提交信息，然后类似于“复制”了一个版本到待合并分支下，实现一个合并操作。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/album/8ee6ba5797dbd7b567f3a9f05c43a9d88472e13d.png\"></p>\n<hr>\n<h3 id=\"Level-2-Git高级内容\"><a href=\"#Level-2-Git高级内容\" class=\"headerlink\" title=\"Level 2. Git高级内容\"></a>Level 2. Git高级内容</h3><h4 id=\"分离HEAD\"><a href=\"#分离HEAD\" class=\"headerlink\" title=\"分离HEAD\"></a>分离HEAD</h4><p>HEAD 是一个对当前检出记录的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。</p>\n<p>HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。</p>\n<p>HEAD 通常情况下是指向分支名的（如 bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。</p>\n<p><strong>分离的 HEAD 就是让其指向了某个具体的提交记录而不是分支名。</strong>在命令执行之前的状态如下所示：</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242631f0352b.png\" style=\"zoom:50%;\" />\n\n<p>HEAD -&gt; main -&gt; C1</p>\n<p>HEAD 指向 main， main 指向 C1</p>\n<p>再通过 <strong>git checkout C1</strong> 后变成了：</p>\n<p>HEAD -&gt; C1</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624263c60010b.png\" style=\"zoom:50%;\" />\n\n\n\n<p>所以分离当前HEAD是通过：</p>\n<p>💯==<strong>git checkout &lt;hash_commit&gt;</strong>==</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624264090b652.png\"></p>\n<hr>\n<h4 id=\"相对引用\"><a href=\"#相对引用\" class=\"headerlink\" title=\"相对引用(^)\"></a>相对引用(^)</h4><p>通过指定提交记录哈希值的方式在 Git 中移动不太方便。在实际应用时，并没有像本程序中这么漂亮的可视化提交树供你参考，所以你就不得不用 <code>git log</code> 来查查看提交记录的哈希值。</p>\n<p>并且哈希值在真实的 Git 世界中也会更长（e.g. 基于 SHA-1，共 40 位）。例如前一关的介绍中的提交记录的哈希值可能是 <code>fed2da64c0efc5293610bdd892f82a58e8cbc5d8</code>。比较令人欣慰的是，Git 对哈希的处理很智能。你只需要提供能够唯一标识提交记录的前几个字符即可。因此我可以仅输入<code>fed2</code> 而不是上面的一长串字符。</p>\n<p>通过哈希值提交记录很不方便，所以git引用了相对引用。使用相对引用的话，就可以从一个易于记忆的地方（比如 <code>bugFix</code> 分支或 <code>HEAD</code>）开始计算。</p>\n<p>相对引用非常给力，这里我介绍两个简单的用法：</p>\n<ul>\n<li>使用 <code>^</code> 向上移动 1 个提交记录</li>\n<li>使用 <code>~&lt;num&gt;</code> 向上移动多个提交记录，如 <code>~3</code></li>\n</ul>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624274834cddb.png\" style=\"zoom:50%;\" />\n\n<p>通过使用(^)可以相对很方便找到main的父节点，而不是通过哈希的方式，以此类推，可以通过main^^来实现寻找父节点的父节点<br>💯==<strong>git checkout main^</strong>==</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624274aea1027.png\" style=\"zoom:50%;\" />\n\n\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624276378ff5f.png\"></p>\n<hr>\n<h4 id=\"相对引用2\"><a href=\"#相对引用2\" class=\"headerlink\" title=\"相对引用2(~)\"></a>相对引用2(~)</h4><p>如果你想在提交树中向上移动很多步的话，敲那么多 <code>^</code> 貌似也挺烦人的，Git 当然也考虑到了这一点，于是又引入了操作符 <code>~</code>。该操作符后面可以跟一个数字（可选，不跟数字时与 <code>^</code> 相同，向上移动一次），指定向上移动多少次。</p>\n<p>通过多次移动的相对引用命令，实现简洁的后退操作：</p>\n<p>💯==<strong>git checkout HEAD~&lt;num&gt;</strong>==</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624276db5423e.png\" style=\"zoom:50%;\" />\n\n\n\n<p>使用相对引用比较多的场景就是移动分支。可以直接使用 <code>-f</code> 选项让分支指向另一个提交，达到强制修改分支的目的，例如:</p>\n<p>💯==<strong>git branch -f main HEAD~3</strong>==</p>\n<p>上面的命令会将 main 分支强制指向 HEAD 的第 3 级父提交。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62427882a6119.png\" style=\"zoom:50%;\" />\n\n<p>可以发现main分支指向了是HEAD向后移动3级父提交记录上</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a3729f60c.png\" style=\"zoom:50%;\" />\n\n<p>合理使用git branch -f 与git checkout 可以实现对当前提交节点与分支的转换。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a5ae757e9.png\"></p>\n<hr>\n<h4 id=\"撤销变更\"><a href=\"#撤销变更\" class=\"headerlink\" title=\"撤销变更\"></a>撤销变更</h4><p>在 Git 里撤销变更的方法很多。和提交一样，撤销变更由底层部分（暂存区的独立文件或者片段）和上层部分（变更到底是通过哪种方式被撤销的）组成。我们这个应用主要关注的是后者。</p>\n<p>主要有两种方法用来撤销变更 —— 一是 <code>git reset</code>，还有就是 <code>git revert</code>。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a6fb59604.png\" style=\"zoom:50%;\" />\n\n<p>通过一下撤销变更的命令：</p>\n<p>💯==<strong>git reset HEAD~1</strong>==</p>\n<p>Git 把 main 分支移回到 C1；现在我们的本地代码库根本就不知道有 C2 这个提交了。但是在reset后， C2 所做的变更还在，但是处于未加入暂存区状态。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a76660edc.png\" style=\"zoom:50%;\" />\n\n<p>git reset 撤销的方式对大家一起使用的远端分支是无效的，为了撤销更改并分享给别人，我们需要使用：</p>\n<p>💯==<strong>git revert HEAD</strong>==</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a82f31d87.png\" style=\"zoom:50%;\" />\n\n<p>在我们要撤销的提交记录后面居然多了一个新提交！这是因为新提交记录 C2’ 引入了<strong>更改</strong> —— 这些更改刚好是用来撤销 C2 这个提交的。也就是说 C2’ 的状态与 C1 是相同的。revert 之后就可以把你的更改推送到远程仓库与别人分享啦。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a9486b1f8.png\"></p>\n<p>刚才试了一下reset的作用，其实就是本地回退到上一个版本得话，可以在更改一些功能后，通过rebase或者merge指定遗弃分支进行合并或者完全放弃？🤔</p>\n<hr>\n<h3 id=\"Level-3-Git移动提交记录\"><a href=\"#Level-3-Git移动提交记录\" class=\"headerlink\" title=\"Level 3. Git移动提交记录\"></a>Level 3. Git移动提交记录</h3><h4 id=\"Git-Cherry-pick\"><a href=\"#Git-Cherry-pick\" class=\"headerlink\" title=\"Git Cherry-pick\"></a>Git Cherry-pick</h4><p>接下来要讨论的这个话题是“整理提交记录” —— 开发人员有时会说“我想要把这个提交放到这里, 那个提交放到刚才那个提交的后面”, 而接下来就讲的就是它的实现方式，非常清晰、灵活，还很生动。</p>\n<p>如果你想将一些提交复制到当前所在的位置（<code>HEAD</code>）下面的话， Cherry-pick 是最直接的方式了。命令为：</p>\n<p>💯==<strong>git cherry-pick &lt;commit_version&gt;</strong>==</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242aab507c99.png\" style=\"zoom:50%;\" />\n\n<p>这里有一个仓库, 我们想将 side 分支上的工作复制到 main 分支，rebase 可以解决这个问题，但是也可以通过 cherry-pick, 我们执行命令 git cherry-pick C2 C4</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ab6297234.png\" style=\"zoom:50%;\" />\n\n<p>通过cherry-pick可以直接选取我们要的提交记录在当前分支之下，感觉git的整理提交记录的思想在于维护一条提交的线(主干线)</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242abd0e399a.png\"></p>\n<hr>\n<h4 id=\"交互式rebase\"><a href=\"#交互式rebase\" class=\"headerlink\" title=\"交互式rebase\"></a>交互式rebase</h4><p>当你知道你所需要的提交记录（<strong>并且</strong>还知道这些提交记录的哈希值）时, 用 cherry-pick 再好不过了 —— 没有比这更简单的方式了。但是如果你不清楚你想要的提交记录的哈希值呢? 幸好 Git 帮你想到了这一点, 我们可以利用交互式的 rebase —— 如果你想从一系列的提交记录中找到想要的记录, 这就是最好的方法了。</p>\n<p>交互式 rebase 指的是使用带参数 <code>--interactive</code> 的 rebase 命令, 简写为 <code>-i</code></p>\n<p>如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。</p>\n<p>在实际使用时，所谓的 UI 窗口一般会在文本编辑器 —— 如 Vim —— 中打开一个文件。</p>\n<p>当 rebase UI界面打开时, 你能做3件事:</p>\n<ul>\n<li>调整提交记录的顺序（通过鼠标拖放来完成）</li>\n<li>删除你不想要的提交（通过切换 <code>pick</code> 的状态来完成，关闭就意味着你不想要这个提交记录）</li>\n<li>合并提交。</li>\n</ul>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242af2c739cb.png\" style=\"zoom:50%;\" />\n\n<p>输入交互式rebase命令后：</p>\n<p>💯==<strong>git rebase -i HEAD[~&lt;num&gt;|^]</strong>==</p>\n<p>通过rebase -i HEAD~4实现对后续提交内容进行调整顺序，删除omit提交与合并</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242b17d54c69.png\" style=\"zoom:50%;\" />\n\n<p>完全重新整理了commit的顺序，但是感觉需要以合理的机会使用，要不然真的会很艰难。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242b33615af6.png\"></p>\n<hr>\n<h3 id=\"Level-4-杂项\"><a href=\"#Level-4-杂项\" class=\"headerlink\" title=\"Level 4. 杂项\"></a>Level 4. 杂项</h3><h4 id=\"只取一个提交记录\"><a href=\"#只取一个提交记录\" class=\"headerlink\" title=\"只取一个提交记录\"></a>只取一个提交记录</h4><p>来看一个在开发中经常会遇到的情况：我正在解决某个特别棘手的 Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息。</p>\n<p>这些调试和打印语句都在它们各自的提交记录里。最后我终于找到了造成这个 Bug 的根本原因，解决掉以后觉得沾沾自喜！</p>\n<p>最后就差把 <code>bugFix</code> 分支里的工作合并回 <code>main</code> 分支了。你可以选择通过 fast-forward 快速合并到 <code>main</code> 分支上，但这样的话 <code>main</code> 分支就会包含我这些调试语句了。你肯定不想这样，应该还有更好的方式……</p>\n<p>实际我们只要让 Git 复制解决问题的那一个提交记录就可以了。跟之前我们在“整理提交记录”中学到的一样，我们可以使用</p>\n<ul>\n<li><code>git rebase -i</code></li>\n<li><code>git cherry-pick</code></li>\n</ul>\n<p>来达到目的。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242b98be1504.png\"></p>\n<hr>\n<h4 id=\"提交的技巧-1\"><a href=\"#提交的技巧-1\" class=\"headerlink\" title=\"提交的技巧 #1\"></a>提交的技巧 #1</h4><p>接下来这种情况也是很常见的：你之前在 newImage 分支上进行了一次提交，然后又基于它创建了 caption 分支，然后又提交了一次。</p>\n<p>此时你想对某个以前的提交记录进行一些小小的调整。比如设计师想修改一下 <code>newImage</code> 中图片的分辨率，尽管那个提交记录并不是最新的了。</p>\n<p>我们可以通过下面的方法来克服困难：</p>\n<ul>\n<li>先用 <code>git rebase -i</code> 将提交重新排序，然后把我们想要修改的提交记录挪到最前</li>\n<li>然后用 <code>git commit --amend</code> 来进行一些小修改</li>\n<li>接着再用 <code>git rebase -i</code> 来将他们调回原来的顺序</li>\n<li>最后我们把 main 移到修改的最前端（用你自己喜欢的方法），就大功告成啦！</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242dbc3cd20f.png\"></p>\n<hr>\n<h4 id=\"提交的技巧-2\"><a href=\"#提交的技巧-2\" class=\"headerlink\" title=\"提交的技巧 #2\"></a>提交的技巧 #2</h4><p>正如你在上一关所见到的，我们可以使用 <code>rebase -i</code> 对提交记录进行重新排序。只要把我们想要的提交记录挪到最前端，我们就可以很轻松的用 <code>--amend</code> 修改它，然后把它们重新排成我们想要的顺序。</p>\n<p>但这样做就唯一的问题就是要进行两次排序，而这有可能造成由 rebase 而导致的冲突。因此选择使用cherry-pick来实现上述问题。</p>\n<p>cherry-pick 可以将提交树上任何地方的提交记录取过来追加到 HEAD 上</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ddc84217c.png\"></p>\n<hr>\n<h4 id=\"Git-Tag\"><a href=\"#Git-Tag\" class=\"headerlink\" title=\"Git Tag\"></a>Git Tag</h4><p>分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。有没有什么可以永远指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢？</p>\n<p>Git 的 tag 可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。更难得的是，它们并不会随着新的提交而移动。你也不能切换到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。</p>\n<p>tag的命令是：</p>\n<p>💯==<strong>git tag &lt;tag_name&gt; &lt;commit_name&gt;</strong>==</p>\n<p><img src=\"C:\\Users\\14218\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220329183103581.png\" alt=\"image-20220329183103581\"></p>\n<hr>\n<h4 id=\"Git-Describe\"><a href=\"#Git-Describe\" class=\"headerlink\" title=\"Git Describe\"></a>Git Describe</h4><p>由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来<strong>描述</strong>离你最近的锚点（也就是标签），它就是 <code>git describe</code>！</p>\n<p>Git Describe 能帮你在提交历史中移动了多次以后找到方向；当你用 <code>git bisect</code>（一个查找产生 Bug 的提交记录的指令）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时， 可能会用到这个命令。</p>\n<p>git describe的语法是：</p>\n<p>💯==<strong>git describe &lt;ref&gt;</strong>==    </p>\n<p>ref 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（HEAD）.</p>\n<p>返回类型为💯==<strong>&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;</strong>==    </p>\n<p>tag 表示的是离 ref 最近的标签， numCommits 是表示这个 ref 与 tag 相差有多少个提交记录， hash 表示的是你所给定的 ref 所表示的提交记录哈希值的前几位。当 ref 提交记录上有某个标签时，则只输出标签名称。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e388a4335.png\"></p>\n<hr>\n<h3 id=\"Level-5-Git-高级话题-某些应用\"><a href=\"#Level-5-Git-高级话题-某些应用\" class=\"headerlink\" title=\"Level 5. Git 高级话题(某些应用)\"></a>Level 5. Git 高级话题(某些应用)</h3><h4 id=\"多分支rebase\"><a href=\"#多分支rebase\" class=\"headerlink\" title=\"多分支rebase\"></a>多分支rebase</h4><p>通过rebase实现多个分支的合并操作，其实通过rebase branch1 branch2 可以很快的实现，并且记住的是branch1是branch2的父分支的话就很容易实现了，每次rebase应该省略的是branch2的参数(如果不给的话)</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e564c9d33.png\"></p>\n<hr>\n<h4 id=\"两个父节点\"><a href=\"#两个父节点\" class=\"headerlink\" title=\"两个父节点\"></a>两个父节点</h4><p>操作符 <code>^</code> 与 <code>~</code> 符一样，后面也可以跟一个数字。</p>\n<p>但是该操作符后面的数字与 <code>~</code> 后面的不同，并不是用来指定向上返回几代，而是指定合并提交记录的某个父提交。还记得前面提到过的一个合并提交有两个父提交吧，所以遇到这样的节点时该选择哪条路径就不是很清晰了。</p>\n<p>Git 默认选择合并提交的“第一个”父提交，在操作符 <code>^</code> 后跟一个数字可以改变这一默认行为。</p>\n<p>例如，执行 git checkout main^2 的过程就是回到第二个父提交节点的意思。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e67ed88f1.png\" style=\"zoom:50%;\" />\n\n<p>并且git支持两个操作符的链式操作 git checkout main~^2~2</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e6cb0c441.png\" style=\"zoom:50%;\" />\n\n\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e85b0e9c3.png\"></p>\n<hr>\n<h4 id=\"纠缠不清的分支\"><a href=\"#纠缠不清的分支\" class=\"headerlink\" title=\"纠缠不清的分支\"></a>纠缠不清的分支</h4><p>实现这种不同分支梳理最好的方式是通过cherry-pick，如果方便知道commit的提交哈希值的话。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e9658f176.png\"></p>\n<hr>\n<h3 id=\"Level-6-Push-amp-Pull-——-Git-远程仓库\"><a href=\"#Level-6-Push-amp-Pull-——-Git-远程仓库\" class=\"headerlink\" title=\"Level 6. Push &amp; Pull —— Git 远程仓库\"></a>Level 6. Push &amp; Pull —— Git 远程仓库</h3><h4 id=\"Git-Clone\"><a href=\"#Git-Clone\" class=\"headerlink\" title=\"Git Clone\"></a>Git Clone</h4><p>远程仓库并不复杂, 在如今的云计算盛行的世界很容易把远程仓库想象成一个富有魔力的东西, 但实际上它们只是你的仓库在另个一台计算机上的拷贝。你可以通过因特网与这台计算机通信 —— 也就是增加或是获取提交记录</p>\n<p>话虽如此, 远程仓库却有一系列强大的特性</p>\n<ul>\n<li>首先也是最重要的的点, 远程仓库是一个强大的备份。本地仓库也有恢复文件到指定版本的能力, 但所有的信息都是保存在本地的。有了远程仓库以后，即使丢失了本地所有数据, 你仍可以通过远程仓库拿回你丢失的数据。</li>\n<li>还有就是, 远程让代码社交化了! 既然你的项目被托管到别的地方了, 你的朋友可以更容易地为你的项目做贡献(或者拉取最新的变更)</li>\n</ul>\n<p>💯==<strong>git clone</strong>==</p>\n<p>通过git clone 可以从远端拉取仓库到本地</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ea37dc283.png\"></p>\n<hr>\n<h4 id=\"远端分支\"><a href=\"#远端分支\" class=\"headerlink\" title=\"远端分支\"></a>远端分支</h4><p>你可能注意到的第一个事就是在我们的本地仓库多了一个名为 <code>o/main</code> 的分支, 这种类型的分支就叫<strong>远程</strong>分支。由于远程分支的特性导致其拥有一些特殊属性。</p>\n<p>远程分支反映了远程仓库(在你上次和它通信时)的<strong>状态</strong>。这会有助于你理解本地的工作与公共工作的差别 —— 这是你与别人分享工作成果前至关重要的一步.</p>\n<p>远程分支有一个特别的属性，在你检出时自动进入分离 HEAD 状态。Git 这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作, （更新了远程分支之后）再用远程分享你的工作成果。</p>\n<p>o/main的意思就是&lt;remote name&gt;/&lt;branch name&gt;</p>\n<p>如果当前选择的是远端分支的话，进行commit操作是不会直接进行远端分支的更新，而是使本地处于分离HEAD的状态。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242eb32490c4.png\"></p>\n<hr>\n<h4 id=\"Git-Fetch\"><a href=\"#Git-Fetch\" class=\"headerlink\" title=\"Git Fetch\"></a>Git Fetch</h4><p>Git 远程仓库相当的操作实际可以归纳为两点：向远程仓库传输数据以及从远程仓库获取数据。既然我们能与远程仓库同步，那么就可以分享任何能被 Git 管理的更新（因此可以分享代码、文件、想法、情书等等）。</p>\n<p>如何从远程仓库获取数据 —— 命令如其名，它就是 git fetch 。</p>\n<p>💯==<strong>git fetch</strong>==</p>\n<p><strong>Git Fetch Do:</strong></p>\n<p>git fetch 完成了仅有的但是很重要的两步:</p>\n<ul>\n<li>从远程仓库下载本地仓库中缺失的提交记录</li>\n<li>更新远程分支指针(如 <code>o/main</code>)</li>\n</ul>\n<p>git fetch 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。</p>\n<p>如果你还记得上一节课程中我们说过的，远程分支反映了远程仓库在你<strong>最后一次与它通信时</strong>的状态，git fetch 就是你与远程仓库通信的方式了！</p>\n<p><strong>Git Fetch Not Do:</strong></p>\n<p>git fetch 并不会改变你本地仓库的状态。它不会更新你的 main 分支，也不会修改你磁盘上的文件。</p>\n<p>理解这一点很重要，因为许多开发人员误以为执行了 git fetch 以后，他们本地仓库就与远程仓库同步了。它可能已经将进行这一操作所需的所有数据都下载了下来，但是<strong>并没有</strong>修改你本地的文件。git fetch 就是单纯的下载资源的操作。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ecb8f2bac.png\"></p>\n<hr>\n<h4 id=\"Git-Pull\"><a href=\"#Git-Pull\" class=\"headerlink\" title=\"Git Pull\"></a>Git Pull</h4><p>其实有很多方法的 —— 当远程分支中有新的提交时，你可以像合并本地分支那样来合并远程分支。也就是说就是你可以执行以下命令:</p>\n<ul>\n<li><code>git cherry-pick o/main</code></li>\n<li><code>git rebase o/main</code></li>\n<li><code>git merge o/main</code></li>\n<li>等等</li>\n</ul>\n<p>实际上，由于先抓取更新再合并到本地分支这个流程很常用，因此 Git 提供了一个专门的命令来完成这两个操作。</p>\n<p>💯==<strong>git pull</strong>==</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ed89ae9c4.png\" style=\"zoom:50%;\" />\n\n<p>git pull 就是 git fetch 和 git merge的缩写</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ee13e8cad.png\"></p>\n<hr>\n<h4 id=\"模拟团队合作\"><a href=\"#模拟团队合作\" class=\"headerlink\" title=\"模拟团队合作\"></a>模拟团队合作</h4><p>在远端操作进行一定更新后，可以通过pull进行及时的拉去更新本地分支</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ee9fb29ea.png\"></p>\n<hr>\n<h4 id=\"Git-Push\"><a href=\"#Git-Push\" class=\"headerlink\" title=\"Git Push\"></a>Git Push</h4><p>传自己分享内容与下载他人的分享刚好相反，git push 负责将<strong>你的</strong>变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录。一旦 git push 完成, 你的朋友们就可以从这个远程仓库下载你分享的成果了！</p>\n<p>💯==<strong>git push</strong>==</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ef5af3f83.png\"></p>\n<hr>\n<h4 id=\"偏离的提交历史\"><a href=\"#偏离的提交历史\" class=\"headerlink\" title=\"偏离的提交历史\"></a>偏离的提交历史</h4><p>假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕，可以发布了。但是 —— 天啊！你的同事这周写了一堆代码，还改了许多你的功能中使用的 API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库了，因此你的工作就变成了基于项目<strong>旧版</strong>的代码，与远程仓库最新的代码不匹配了。</p>\n<p>这种情况下, <code>git push</code> 就不知道该如何操作了。如果你执行 <code>git push</code>，Git 应该让远程仓库回到星期一那天的状态吗？还是直接在新代码的基础上添加你的代码，亦或由于你的提交已经过时而直接忽略你的提交？</p>\n<p>因为这情况（历史偏离）有许多的不确定性，Git 是不会允许你 <code>push</code> 变更的。实际上它会强制你先合并远程最新的代码，然后才能分享你的工作。</p>\n<p>因此主要的解决办法就是先把远端的分支pull下来，然后再merge或者rebase自己的工作到远端分支，然后再合并分支到远端仓库</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242f10bed8b1.png\"></p>\n<hr>\n<h4 id=\"Locked-Main\"><a href=\"#Locked-Main\" class=\"headerlink\" title=\"Locked Main\"></a>Locked Main</h4><p>如果你是在一个大的合作团队中工作, 很可能是main被锁定了, 需要一些Pull Request流程来合并修改。如果你直接提交(commit)到本地main, 然后试图推送(push)修改, 你将会收到这样类似的信息:</p>\n<p><em>! [远程服务器拒绝] main -&gt; main (TF402455: 不允许推送(push)这个分支; 你必须使用pull request来更新这个分支.)</em></p>\n<p>就是在团队合作的时候，防止过多人频繁push自己的代码到远端仓库，因此需要走pr的审查流程。</p>\n<p>解决办法为：新建一个分支feature, 推送到远程服务器. 然后reset你的main分支和远程服务器保持一致, 否则下次你pull并且他人的提交和你冲突的时候就会有问题.</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242f48497d61.png\"></p>\n<hr>\n<h3 id=\"Level-7-关于-origin-和它的周边-——-Git-远程仓库高级操作\"><a href=\"#Level-7-关于-origin-和它的周边-——-Git-远程仓库高级操作\" class=\"headerlink\" title=\"Level 7. 关于 origin 和它的周边 —— Git 远程仓库高级操作\"></a>Level 7. 关于 origin 和它的周边 —— Git 远程仓库高级操作</h3><h4 id=\"推送主分支\"><a href=\"#推送主分支\" class=\"headerlink\" title=\"推送主分支\"></a>推送主分支</h4><p>在大型项目中开发人员通常会在（从 <code>main</code> 上分出来的）特性分支上工作，工作完成后只做一次集成。这跟前面课程的描述很相像（把 side 分支推送到远程仓库），不过本节我们会深入一些.</p>\n<p>但是有些开发人员只在 main 上做 push、pull —— 这样的话 main 总是最新的，始终与远程分支 (o/main) 保持一致。</p>\n<p>对于接下来这个工作流，我们集成了两个步骤：</p>\n<ul>\n<li>将特性分支集成到 <code>main</code> 上</li>\n<li>推送并更新远程分支</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242fc03cb835.png\"></p>\n<p>过程就是先 git pull –rebase 然后再rebase 合并分支</p>\n<hr>\n<h4 id=\"合并远端仓库\"><a href=\"#合并远端仓库\" class=\"headerlink\" title=\"合并远端仓库\"></a>合并远端仓库</h4><p>在开发社区里，有许多关于 merge 与 rebase 的讨论。以下是关于 rebase 的优缺点：</p>\n<p>优点:</p>\n<ul>\n<li>Rebase 使你的提交树变得很干净, 所有的提交都在一条线上</li>\n</ul>\n<p>缺点:</p>\n<ul>\n<li>Rebase 修改了提交树的历史</li>\n</ul>\n<p>比如, 提交 C1 可以被 rebase 到 C3 之后。这看起来 C1 中的工作是在 C3 之后进行的，但实际上是在 C3 之前。</p>\n<p>一些开发人员喜欢保留提交历史，因此更偏爱 merge。而其他人（比如我自己）可能更喜欢干净的提交树，于是偏爱 rebase。仁者见仁，智者见智。 </p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242fd476265d.png\"></p>\n<p>相对来说，更有细节，更能体现提交历史</p>\n<h4 id=\"远程追踪\"><a href=\"#远程追踪\" class=\"headerlink\" title=\"远程追踪\"></a>远程追踪</h4><p>Git 好像知道 <code>main</code> 与 <code>o/main</code> 是相关的。当然这些分支的名字是相似的，可能会让你觉得是依此将远程分支 main 和本地的 main 分支进行了关联。这种关联在以下两种情况下可以清楚地得到展示：</p>\n<ul>\n<li>pull 操作时, 提交记录会被先下载到 o/main 上，之后再合并到本地的 main 分支。隐含的合并目标由这个关联确定的。</li>\n<li>push 操作时, 我们把工作从 <code>main</code> 推到远程仓库中的 <code>main</code> 分支(同时会更新远程分支 <code>o/main</code>) 。这个推送的目的地也是由这种关联确定的！</li>\n</ul>\n<p>直接了当地讲，<code>main</code> 和 <code>o/main</code> 的关联关系就是由分支的“remote tracking”属性决定的。<code>main</code> 被设定为跟踪 <code>o/main</code> —— 这意味着为 <code>main</code> 分支指定了推送的目的地以及拉取后合并的目标。</p>\n<p>你可能想知道 <code>main</code> 分支上这个属性是怎么被设定的，你并没有用任何命令指定过这个属性呀！好吧, 当你克隆仓库的时候, Git 就自动帮你把这个属性设置好了。</p>\n<p>当你克隆时, Git 会为远程仓库中的每个分支在本地仓库中创建一个远程分支（比如 <code>o/main</code>）。然后再创建一个跟踪远程仓库中活动分支的本地分支，默认情况下这个本地分支会被命名为 <code>main</code>。</p>\n<p>克隆完成后，你会得到一个本地分支（如果没有这个本地分支的话，你的目录就是“空白”的），但是可以查看远程仓库中所有的分支（如果你好奇心很强的话）。这样做对于本地仓库和远程仓库来说，都是最佳选择。</p>\n<p>💯==<strong>git checkout -b totallyNotMain o/main</strong>==</p>\n<p>可以创建一个totallyNotMain来追踪远程分支o/main</p>\n<p>💯==<strong>git branch -u o/main foo</strong>==</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ff7627ed3.png\"></p>\n<hr>\n<h4 id=\"Git-Push的参数\"><a href=\"#Git-Push的参数\" class=\"headerlink\" title=\"Git Push的参数\"></a>Git Push的参数</h4><p>首先来看 <code>git push</code>。在远程跟踪课程中，你已经学到了 Git 是通过当前检出分支的属性来确定远程仓库以及要 push 的目的地的。这是未指定参数时的行为，我们可以为 push 指定参数，语法是：</p>\n<p>💯==<strong>git push &lt;remote&gt; &lt;place&gt;</strong>==</p>\n<p>把这个命令翻译过来就是：</p>\n<p><em>切到本地仓库中的“main”分支，获取所有的提交，再到远程仓库“origin”中找到“main”分支，将远程仓库中没有的提交记录都添加上去，搞定之后告诉我。</em></p>\n<p>我们通过“place”参数来告诉 Git 提交记录来自于 main, 要推送到远程仓库中的 main。它实际就是要同步的两个仓库的位置。</p>\n<p>需要注意的是，因为我们通过指定参数告诉了 Git 所有它需要的信息, 所以它就忽略了我们所检出的分支的属性！</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624300d69d378.png\"></p>\n<hr>\n<h4 id=\"Git-Push的参数2\"><a href=\"#Git-Push的参数2\" class=\"headerlink\" title=\"Git Push的参数2\"></a>Git Push的参数2</h4><p>，当为 git push 指定 place 参数为 <code>main</code> 时，我们同时指定了提交记录的来源和去向。</p>\n<p>你可能想问 —— 如果来源和去向分支的名称不同呢？比如你想把本地的 <code>foo</code> 分支推送到远程仓库中的 <code>bar</code> 分支。</p>\n<p>要同时为源和目的地指定 <code>&lt;place&gt;</code> 的话，只需要用冒号 <code>:</code> 将二者连起来就可以了：</p>\n<p>💯==<strong>git push origin &lt;source&gt;:&lt;destination&gt;</strong>==</p>\n<p>这个参数实际的值是个 refspec，“refspec” 是一个自造的词，意思是 Git 能识别的位置（比如分支 <code>foo</code> 或者 <code>HEAD~1</code>）</p>\n<p>一旦你指定了独立的来源和目的地，就可以组织出言简意赅的远程操作命令了.</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624301c9cddfe.png\"></p>\n<hr>\n<h4 id=\"Git-Fetch的参数\"><a href=\"#Git-Fetch的参数\" class=\"headerlink\" title=\"Git Fetch的参数\"></a>Git Fetch的参数</h4><p><code>git fetch</code> 的参数和 <code>git push</code> 极其相似。他们的概念是相同的，只是方向相反罢了（因为现在你是下载，而非上传）</p>\n<p>💯==<strong>git fetch &lt;remote&gt; &lt;place&gt;</strong>==</p>\n<p>Git 会到远程仓库的分支上，然后获取所有本地不存在的提交，放到本地的相应分支上。</p>\n<p>💯==<strong>git fetch origin &lt;source&gt;:&lt;destination&gt;</strong>==</p>\n<p>但是命令很不常用就是了</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624301c9cddfe.png\"></p>\n<hr>\n<h4 id=\"没有source的source\"><a href=\"#没有source的source\" class=\"headerlink\" title=\"没有source的source\"></a>没有source的source</h4><p>Git 有两种关于 <code>&lt;source&gt;</code> 的用法是比较诡异的，即你可以在 git push 或 git fetch 时不指定任何 <code>source</code>，方法就是仅保留冒号和 destination 部分，source 部分留空。</p>\n<ul>\n<li><code>git push origin :side</code></li>\n<li><code>git fetch origin :bugFix</code></li>\n</ul>\n<p>我们分别来看一下这两条命令的作用……</p>\n<p>如果 push 空 到远程仓库会如何呢？它会删除远程仓库中的分支！</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624313c20ceea.png\" style=\"zoom:50%;\" />\n\n<p>如果 fetch 空 到本地，会在本地创建一个新分支。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624314368592a.png\" style=\"zoom:50%;\" />\n\n\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6243147a70f05.png\"></p>\n<hr>\n<h4 id=\"Git-Pull的参数\"><a href=\"#Git-Pull的参数\" class=\"headerlink\" title=\"Git Pull的参数\"></a>Git Pull的参数</h4><p> git pull 到头来就是 fetch 后跟 merge 的缩写。你可以理解为用同样的参数执行 git fetch，然后再 merge 你所抓取到的提交记录。</p>\n<p><code>git pull origin foo</code> 相当于：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch origin foo; git merge o&#x2F;foo</span><br></pre></td></tr></table></figure>\n<p>还有…</p>\n<p><code>git pull origin bar~1:bugFix</code> 相当于：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch origin bar~1:bugFix; git merge bugFix</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624316d49f61c.png\"></p>\n<hr>\n<h2 id=\"Git操作实例\"><a href=\"#Git操作实例\" class=\"headerlink\" title=\"Git操作实例\"></a>Git操作实例</h2><blockquote>\n<p>在这一个月多的工作里，我也遇到了需要用到git的一些操作，在此总结如下情景：</p>\n</blockquote>\n<h3 id=\"先暂存当前工作而去完成另一个工作\"><a href=\"#先暂存当前工作而去完成另一个工作\" class=\"headerlink\" title=\"先暂存当前工作而去完成另一个工作\"></a>先暂存当前工作而去完成另一个工作</h3><blockquote>\n<p>遇到过这种情况：在做某个工作到一半还没完成的时候，突然被提醒先去做另外一个工作。这种情况下，现在没做完的工作咋办？</p>\n</blockquote>\n<p>首先，在看了上面的内容之后，不管如果我们一定要先进行 <code>git commit</code> 操作。</p>\n<p>因为只有在commit之后，当前工作才会成为一个结点。</p>\n<p>同时，为了唯一标识当前结点，我们可以采用新建分支或者新建tag的方式标记当前结点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag tag_name HEAD</span><br></pre></td></tr></table></figure>\n<p>在完成该操作后，我们就回到上一个结点，也就是远端所在结点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout HEAD^</span><br><span class=\"line\"></span><br><span class=\"line\">git branch -f master HEAD</span><br><span class=\"line\"></span><br><span class=\"line\">git checkout master</span><br></pre></td></tr></table></figure>\n<p>此后，我们便可以开始新的工作，以正常的方式进行新的操作（commit啊，push啊都可以）。</p>\n<p>当前工作完成之后，我们就可以通过 <code>git checkout tag_name</code> 回到之前没有完成的工作中去了！</p>\n<h3 id=\"更改两次提交的顺序\"><a href=\"#更改两次提交的顺序\" class=\"headerlink\" title=\"更改两次提交的顺序\"></a>更改两次提交的顺序</h3><blockquote>\n<p>这是今天遇到的一个情况：先完成了一个提交，之后去做另一个工作提交了一次。但这时被提示之前的提交有问题，需要修改。</p>\n<p>这个时候，后一次的提交没有问题，可以被点进主分支中。但由于它的父结点是前一次的提交，因此点不进去，怎么办呢？</p>\n</blockquote>\n<p>这个时候，我们就要考虑切换两个分支的顺序了。</p>\n<p>首先最重要的是，我们还是要加一个标签标记当前的位置，否则以后就找不到了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag tag_name HEAD</span><br></pre></td></tr></table></figure>\n<p>然后，我们回到上上一次的位置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout HEAD~2</span><br><span class=\"line\"></span><br><span class=\"line\">git branch -f master HEAD</span><br><span class=\"line\"></span><br><span class=\"line\">git checkout master</span><br></pre></td></tr></table></figure>\n<p>这个时候，我们只要通过 <code>cherry-pick</code> 操作把刚刚的两个操作反过来串联在一起就行了。</p>\n<p>当然，通过前面的学习，我们知道  <code>git rebase -i</code>也是可行的，在这里不再赘述。</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<h1 id=\"Git-基本操作整理\"><a href=\"#Git-基本操作整理\" class=\"headerlink\" title=\"Git 基本操作整理\"></a>Git 基本操作整理</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文档通过整理CS-Notes中的Git命令操作与实战Learn Git Branching来学习掌握Git方法。因为文档主要分为两部分，第一部分参考CS-Notes并查阅资料为Git理论知识，第二部分为实战Learn Git Branching给出个人思考与过程。</p>\n<p>参考资料来源:</p>\n<ol>\n<li><p><a href=\"http://www.cyc2018.xyz/%E5%85%B6%E5%AE%83/%E7%BC%96%E7%A0%81%E5%AE%9E%E8%B7%B5/Git.html#%E9%9B%86%E4%B8%AD%E5%BC%8F%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F\">CS-Notes Git部分</a></p>\n</li>\n<li><p><a href=\"https://learngitbranching.js.org/?demo=&locale=zh_CN\">Learn Git Branching</a></p>\n</li>\n</ol>\n<h2 id=\"Git知识\"><a href=\"#Git知识\" class=\"headerlink\" title=\"Git知识\"></a>Git知识</h2><h2 id=\"Learn-Git-Branching\"><a href=\"#Learn-Git-Branching\" class=\"headerlink\" title=\"Learn Git Branching\"></a>Learn Git Branching</h2><h3 id=\"Level-1-Git基础内容\"><a href=\"#Level-1-Git基础内容\" class=\"headerlink\" title=\"Level 1. Git基础内容\"></a>Level 1. Git基础内容</h3><h4 id=\"Git-Commit\"><a href=\"#Git-Commit\" class=\"headerlink\" title=\"Git Commit\"></a>Git Commit</h4><p>Git 仓库中的提交记录保存的是你的目录下所有文件的快照，就像是把整个目录复制，然后再粘贴一样，但比复制粘贴优雅许多！</p>\n<p>Git 希望提交记录尽可能地轻量，因此在你每次进行提交时，它并不会盲目地复制整个目录。条件允许的情况下，它会将当前版本与仓库中的上一个版本进行对比，并把所有的差异打包到一起作为一个提交记录。Git 还保存了提交的历史记录。这也是为什么大多数提交记录的上面都有父节点的原因。对于项目组的成员来说，维护提交历史对大家都有好处。</p>\n<p>Git Commit 就是在父节点下进行一次内容的提交。使用的命令很简单为：</p>\n<p>💯==<strong>git commit</strong>==</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f9be0486.png\"></p>\n<hr>\n<h4 id=\"Git-Branch\"><a href=\"#Git-Branch\" class=\"headerlink\" title=\"Git Branch\"></a>Git Branch</h4><p>Git 的分支也非常轻量。它们只是简单地指向某个提交纪录 —— 仅此而已。</p>\n<p>所以许多 Git 爱好者传颂：😍<strong>早建分支，多用分支！</strong></p>\n<p>这是因为即使创建再多的分支也不会造成储存或内存上的开销，并且按逻辑分解工作到不同的分支要比维护那些特别臃肿的分支简单多了。</p>\n<p>在将分支和提交记录结合起来后，我们会看到两者如何协作。现在只要记住使用分支其实就相当于在说：“<strong>我想基于这个提交以及它所有的父提交进行新的工作。</strong>”</p>\n<p>创建分支的命令最基础的就是：</p>\n<p>💯==<strong>git branch <branch_name></strong>==</p>\n<p>创建好的分支会指向当前的提交记录。但是通过上述命令创建的分支并不是我们现在所使用的分支，如果我们此刻进行了git commit操作，那么我们的行为仍然是操作于原来的分支。所以我们如果想要使用这个新分支，我们需要使用切换分支的命令：</p>\n<p>💯==<strong>git checkout <branch_name></strong>==</p>\n<p>有一个简洁的方式，如果你想创建一个新的分支同时切换到新创建的分支的话，可以通过 </p>\n<p>💯==<strong>git checkout -b &lt;your-branch-name&gt;</strong>==</p>\n<p><img src=\"https://i0.hdslb.com/bfs/album/a11e89444b0b5c7d221325a9637f26e54ebe12c6.png\"></p>\n<hr>\n<h4 id=\"Git-Merge\"><a href=\"#Git-Merge\" class=\"headerlink\" title=\"Git Merge\"></a>Git Merge</h4><p>在知道如何提交以及如何使用分支的前提下，接下来是如何将两个分支合并到一起。就是说我们新建一个分支，在其上开发某个新功能，开发完成后再合并回主线。</p>\n<p>第一种方法是通过git merge实现的。在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个父节点。翻译成自然语言相当于：“我要把这两个父节点本身及它们所有的祖先都包含进来。”因此，git合并分支的命令是：</p>\n<p>💯==<strong>git merge <branch_name></strong>==</p>\n<p>该命令是将branch_name合并到当前的分支下</p>\n<p>例如：我们有这两个分支main与bugFix，我们可以通过git merge命令来将两者合并：</p>\n<img src=\"https://i0.hdslb.com/bfs/album/1a7e02089e6db4f76cec7be3ca3766caa38c1fd7.png\" style=\"zoom:50%;\" />\n\n<p>合并后，我们发现新的分支是保留了两条路径指向父节点，并没有断了与任何一条分支的联系，因此这个过程支持了Git对历史版本信息的维护。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f858fa9e.png\" style=\"zoom:50%;\" />\n\n<p>接下来，可以将main分支合并到bugFix中</p>\n<p>通过<code>git checkout bugFix; git merge main</code></p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f8526a06.png\" style=\"zoom:50%;\" />\n\n<p>因为 main 继承自 bugFix ，Git 什么都不用做，只是简单地把 bugFix 移动到 main 所指向的那个提交记录。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/album/08d9d8343a7164f9c6b01eccca5471872790f07f.png\"></p>\n<hr>\n<h4 id=\"Git-Rebase\"><a href=\"#Git-Rebase\" class=\"headerlink\" title=\"Git Rebase\"></a>Git Rebase</h4><p>第二种合并分支的方法是 git rebase。Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。</p>\n<p>Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。Rebase的命令如下：</p>\n<p>💯==<strong>git rebase <branch_name></strong>==</p>\n<p>例如：同样我们有两个分支main和bugFix，我们可以通过rebase来将两者合并：</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f857516e.png\" style=\"zoom:50%;\" />\n\n<p>通过rebase命令后，不同于原来的merge建立两条关于父节点的链接，而是通过提取一系列的提交记录然后建立一个基于main的副本，这样生成的线性的提交历史：</p>\n<img src=\"https://i0.hdslb.com/bfs/album/59f7e1df1314389ddbbcb14fda46a0a679d6c999.png\" style=\"zoom:50%;\" />\n\n<p>此时，原先分支的C3并没有被删除，接下来可以切换到main分支，通过rebase向前推进一个版本</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f857627e.png\" style=\"zoom:50%;\" />\n\n<p>rebase命令维护一条线性的提交记录使得历史提交很清晰。我理解的话，主要是通过在代合并的分支上补充原有分支的一些历史提交信息，然后类似于“复制”了一个版本到待合并分支下，实现一个合并操作。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/album/8ee6ba5797dbd7b567f3a9f05c43a9d88472e13d.png\"></p>\n<hr>\n<h3 id=\"Level-2-Git高级内容\"><a href=\"#Level-2-Git高级内容\" class=\"headerlink\" title=\"Level 2. Git高级内容\"></a>Level 2. Git高级内容</h3><h4 id=\"分离HEAD\"><a href=\"#分离HEAD\" class=\"headerlink\" title=\"分离HEAD\"></a>分离HEAD</h4><p>HEAD 是一个对当前检出记录的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。</p>\n<p>HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。</p>\n<p>HEAD 通常情况下是指向分支名的（如 bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。</p>\n<p><strong>分离的 HEAD 就是让其指向了某个具体的提交记录而不是分支名。</strong>在命令执行之前的状态如下所示：</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242631f0352b.png\" style=\"zoom:50%;\" />\n\n<p>HEAD -&gt; main -&gt; C1</p>\n<p>HEAD 指向 main， main 指向 C1</p>\n<p>再通过 <strong>git checkout C1</strong> 后变成了：</p>\n<p>HEAD -&gt; C1</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624263c60010b.png\" style=\"zoom:50%;\" />\n\n\n\n<p>所以分离当前HEAD是通过：</p>\n<p>💯==<strong>git checkout &lt;hash_commit&gt;</strong>==</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624264090b652.png\"></p>\n<hr>\n<h4 id=\"相对引用\"><a href=\"#相对引用\" class=\"headerlink\" title=\"相对引用(^)\"></a>相对引用(^)</h4><p>通过指定提交记录哈希值的方式在 Git 中移动不太方便。在实际应用时，并没有像本程序中这么漂亮的可视化提交树供你参考，所以你就不得不用 <code>git log</code> 来查查看提交记录的哈希值。</p>\n<p>并且哈希值在真实的 Git 世界中也会更长（e.g. 基于 SHA-1，共 40 位）。例如前一关的介绍中的提交记录的哈希值可能是 <code>fed2da64c0efc5293610bdd892f82a58e8cbc5d8</code>。比较令人欣慰的是，Git 对哈希的处理很智能。你只需要提供能够唯一标识提交记录的前几个字符即可。因此我可以仅输入<code>fed2</code> 而不是上面的一长串字符。</p>\n<p>通过哈希值提交记录很不方便，所以git引用了相对引用。使用相对引用的话，就可以从一个易于记忆的地方（比如 <code>bugFix</code> 分支或 <code>HEAD</code>）开始计算。</p>\n<p>相对引用非常给力，这里我介绍两个简单的用法：</p>\n<ul>\n<li>使用 <code>^</code> 向上移动 1 个提交记录</li>\n<li>使用 <code>~&lt;num&gt;</code> 向上移动多个提交记录，如 <code>~3</code></li>\n</ul>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624274834cddb.png\" style=\"zoom:50%;\" />\n\n<p>通过使用(^)可以相对很方便找到main的父节点，而不是通过哈希的方式，以此类推，可以通过main^^来实现寻找父节点的父节点<br>💯==<strong>git checkout main^</strong>==</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624274aea1027.png\" style=\"zoom:50%;\" />\n\n\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624276378ff5f.png\"></p>\n<hr>\n<h4 id=\"相对引用2\"><a href=\"#相对引用2\" class=\"headerlink\" title=\"相对引用2(~)\"></a>相对引用2(~)</h4><p>如果你想在提交树中向上移动很多步的话，敲那么多 <code>^</code> 貌似也挺烦人的，Git 当然也考虑到了这一点，于是又引入了操作符 <code>~</code>。该操作符后面可以跟一个数字（可选，不跟数字时与 <code>^</code> 相同，向上移动一次），指定向上移动多少次。</p>\n<p>通过多次移动的相对引用命令，实现简洁的后退操作：</p>\n<p>💯==<strong>git checkout HEAD~&lt;num&gt;</strong>==</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624276db5423e.png\" style=\"zoom:50%;\" />\n\n\n\n<p>使用相对引用比较多的场景就是移动分支。可以直接使用 <code>-f</code> 选项让分支指向另一个提交，达到强制修改分支的目的，例如:</p>\n<p>💯==<strong>git branch -f main HEAD~3</strong>==</p>\n<p>上面的命令会将 main 分支强制指向 HEAD 的第 3 级父提交。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62427882a6119.png\" style=\"zoom:50%;\" />\n\n<p>可以发现main分支指向了是HEAD向后移动3级父提交记录上</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a3729f60c.png\" style=\"zoom:50%;\" />\n\n<p>合理使用git branch -f 与git checkout 可以实现对当前提交节点与分支的转换。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a5ae757e9.png\"></p>\n<hr>\n<h4 id=\"撤销变更\"><a href=\"#撤销变更\" class=\"headerlink\" title=\"撤销变更\"></a>撤销变更</h4><p>在 Git 里撤销变更的方法很多。和提交一样，撤销变更由底层部分（暂存区的独立文件或者片段）和上层部分（变更到底是通过哪种方式被撤销的）组成。我们这个应用主要关注的是后者。</p>\n<p>主要有两种方法用来撤销变更 —— 一是 <code>git reset</code>，还有就是 <code>git revert</code>。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a6fb59604.png\" style=\"zoom:50%;\" />\n\n<p>通过一下撤销变更的命令：</p>\n<p>💯==<strong>git reset HEAD~1</strong>==</p>\n<p>Git 把 main 分支移回到 C1；现在我们的本地代码库根本就不知道有 C2 这个提交了。但是在reset后， C2 所做的变更还在，但是处于未加入暂存区状态。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a76660edc.png\" style=\"zoom:50%;\" />\n\n<p>git reset 撤销的方式对大家一起使用的远端分支是无效的，为了撤销更改并分享给别人，我们需要使用：</p>\n<p>💯==<strong>git revert HEAD</strong>==</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a82f31d87.png\" style=\"zoom:50%;\" />\n\n<p>在我们要撤销的提交记录后面居然多了一个新提交！这是因为新提交记录 C2’ 引入了<strong>更改</strong> —— 这些更改刚好是用来撤销 C2 这个提交的。也就是说 C2’ 的状态与 C1 是相同的。revert 之后就可以把你的更改推送到远程仓库与别人分享啦。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a9486b1f8.png\"></p>\n<p>刚才试了一下reset的作用，其实就是本地回退到上一个版本得话，可以在更改一些功能后，通过rebase或者merge指定遗弃分支进行合并或者完全放弃？🤔</p>\n<hr>\n<h3 id=\"Level-3-Git移动提交记录\"><a href=\"#Level-3-Git移动提交记录\" class=\"headerlink\" title=\"Level 3. Git移动提交记录\"></a>Level 3. Git移动提交记录</h3><h4 id=\"Git-Cherry-pick\"><a href=\"#Git-Cherry-pick\" class=\"headerlink\" title=\"Git Cherry-pick\"></a>Git Cherry-pick</h4><p>接下来要讨论的这个话题是“整理提交记录” —— 开发人员有时会说“我想要把这个提交放到这里, 那个提交放到刚才那个提交的后面”, 而接下来就讲的就是它的实现方式，非常清晰、灵活，还很生动。</p>\n<p>如果你想将一些提交复制到当前所在的位置（<code>HEAD</code>）下面的话， Cherry-pick 是最直接的方式了。命令为：</p>\n<p>💯==<strong>git cherry-pick &lt;commit_version&gt;</strong>==</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242aab507c99.png\" style=\"zoom:50%;\" />\n\n<p>这里有一个仓库, 我们想将 side 分支上的工作复制到 main 分支，rebase 可以解决这个问题，但是也可以通过 cherry-pick, 我们执行命令 git cherry-pick C2 C4</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ab6297234.png\" style=\"zoom:50%;\" />\n\n<p>通过cherry-pick可以直接选取我们要的提交记录在当前分支之下，感觉git的整理提交记录的思想在于维护一条提交的线(主干线)</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242abd0e399a.png\"></p>\n<hr>\n<h4 id=\"交互式rebase\"><a href=\"#交互式rebase\" class=\"headerlink\" title=\"交互式rebase\"></a>交互式rebase</h4><p>当你知道你所需要的提交记录（<strong>并且</strong>还知道这些提交记录的哈希值）时, 用 cherry-pick 再好不过了 —— 没有比这更简单的方式了。但是如果你不清楚你想要的提交记录的哈希值呢? 幸好 Git 帮你想到了这一点, 我们可以利用交互式的 rebase —— 如果你想从一系列的提交记录中找到想要的记录, 这就是最好的方法了。</p>\n<p>交互式 rebase 指的是使用带参数 <code>--interactive</code> 的 rebase 命令, 简写为 <code>-i</code></p>\n<p>如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。</p>\n<p>在实际使用时，所谓的 UI 窗口一般会在文本编辑器 —— 如 Vim —— 中打开一个文件。</p>\n<p>当 rebase UI界面打开时, 你能做3件事:</p>\n<ul>\n<li>调整提交记录的顺序（通过鼠标拖放来完成）</li>\n<li>删除你不想要的提交（通过切换 <code>pick</code> 的状态来完成，关闭就意味着你不想要这个提交记录）</li>\n<li>合并提交。</li>\n</ul>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242af2c739cb.png\" style=\"zoom:50%;\" />\n\n<p>输入交互式rebase命令后：</p>\n<p>💯==<strong>git rebase -i HEAD[~&lt;num&gt;|^]</strong>==</p>\n<p>通过rebase -i HEAD~4实现对后续提交内容进行调整顺序，删除omit提交与合并</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242b17d54c69.png\" style=\"zoom:50%;\" />\n\n<p>完全重新整理了commit的顺序，但是感觉需要以合理的机会使用，要不然真的会很艰难。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242b33615af6.png\"></p>\n<hr>\n<h3 id=\"Level-4-杂项\"><a href=\"#Level-4-杂项\" class=\"headerlink\" title=\"Level 4. 杂项\"></a>Level 4. 杂项</h3><h4 id=\"只取一个提交记录\"><a href=\"#只取一个提交记录\" class=\"headerlink\" title=\"只取一个提交记录\"></a>只取一个提交记录</h4><p>来看一个在开发中经常会遇到的情况：我正在解决某个特别棘手的 Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息。</p>\n<p>这些调试和打印语句都在它们各自的提交记录里。最后我终于找到了造成这个 Bug 的根本原因，解决掉以后觉得沾沾自喜！</p>\n<p>最后就差把 <code>bugFix</code> 分支里的工作合并回 <code>main</code> 分支了。你可以选择通过 fast-forward 快速合并到 <code>main</code> 分支上，但这样的话 <code>main</code> 分支就会包含我这些调试语句了。你肯定不想这样，应该还有更好的方式……</p>\n<p>实际我们只要让 Git 复制解决问题的那一个提交记录就可以了。跟之前我们在“整理提交记录”中学到的一样，我们可以使用</p>\n<ul>\n<li><code>git rebase -i</code></li>\n<li><code>git cherry-pick</code></li>\n</ul>\n<p>来达到目的。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242b98be1504.png\"></p>\n<hr>\n<h4 id=\"提交的技巧-1\"><a href=\"#提交的技巧-1\" class=\"headerlink\" title=\"提交的技巧 #1\"></a>提交的技巧 #1</h4><p>接下来这种情况也是很常见的：你之前在 newImage 分支上进行了一次提交，然后又基于它创建了 caption 分支，然后又提交了一次。</p>\n<p>此时你想对某个以前的提交记录进行一些小小的调整。比如设计师想修改一下 <code>newImage</code> 中图片的分辨率，尽管那个提交记录并不是最新的了。</p>\n<p>我们可以通过下面的方法来克服困难：</p>\n<ul>\n<li>先用 <code>git rebase -i</code> 将提交重新排序，然后把我们想要修改的提交记录挪到最前</li>\n<li>然后用 <code>git commit --amend</code> 来进行一些小修改</li>\n<li>接着再用 <code>git rebase -i</code> 来将他们调回原来的顺序</li>\n<li>最后我们把 main 移到修改的最前端（用你自己喜欢的方法），就大功告成啦！</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242dbc3cd20f.png\"></p>\n<hr>\n<h4 id=\"提交的技巧-2\"><a href=\"#提交的技巧-2\" class=\"headerlink\" title=\"提交的技巧 #2\"></a>提交的技巧 #2</h4><p>正如你在上一关所见到的，我们可以使用 <code>rebase -i</code> 对提交记录进行重新排序。只要把我们想要的提交记录挪到最前端，我们就可以很轻松的用 <code>--amend</code> 修改它，然后把它们重新排成我们想要的顺序。</p>\n<p>但这样做就唯一的问题就是要进行两次排序，而这有可能造成由 rebase 而导致的冲突。因此选择使用cherry-pick来实现上述问题。</p>\n<p>cherry-pick 可以将提交树上任何地方的提交记录取过来追加到 HEAD 上</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ddc84217c.png\"></p>\n<hr>\n<h4 id=\"Git-Tag\"><a href=\"#Git-Tag\" class=\"headerlink\" title=\"Git Tag\"></a>Git Tag</h4><p>分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。有没有什么可以永远指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢？</p>\n<p>Git 的 tag 可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。更难得的是，它们并不会随着新的提交而移动。你也不能切换到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。</p>\n<p>tag的命令是：</p>\n<p>💯==<strong>git tag &lt;tag_name&gt; &lt;commit_name&gt;</strong>==</p>\n<p><img src=\"C:\\Users\\14218\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220329183103581.png\" alt=\"image-20220329183103581\"></p>\n<hr>\n<h4 id=\"Git-Describe\"><a href=\"#Git-Describe\" class=\"headerlink\" title=\"Git Describe\"></a>Git Describe</h4><p>由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来<strong>描述</strong>离你最近的锚点（也就是标签），它就是 <code>git describe</code>！</p>\n<p>Git Describe 能帮你在提交历史中移动了多次以后找到方向；当你用 <code>git bisect</code>（一个查找产生 Bug 的提交记录的指令）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时， 可能会用到这个命令。</p>\n<p>git describe的语法是：</p>\n<p>💯==<strong>git describe &lt;ref&gt;</strong>==    </p>\n<p>ref 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（HEAD）.</p>\n<p>返回类型为💯==<strong>&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;</strong>==    </p>\n<p>tag 表示的是离 ref 最近的标签， numCommits 是表示这个 ref 与 tag 相差有多少个提交记录， hash 表示的是你所给定的 ref 所表示的提交记录哈希值的前几位。当 ref 提交记录上有某个标签时，则只输出标签名称。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e388a4335.png\"></p>\n<hr>\n<h3 id=\"Level-5-Git-高级话题-某些应用\"><a href=\"#Level-5-Git-高级话题-某些应用\" class=\"headerlink\" title=\"Level 5. Git 高级话题(某些应用)\"></a>Level 5. Git 高级话题(某些应用)</h3><h4 id=\"多分支rebase\"><a href=\"#多分支rebase\" class=\"headerlink\" title=\"多分支rebase\"></a>多分支rebase</h4><p>通过rebase实现多个分支的合并操作，其实通过rebase branch1 branch2 可以很快的实现，并且记住的是branch1是branch2的父分支的话就很容易实现了，每次rebase应该省略的是branch2的参数(如果不给的话)</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e564c9d33.png\"></p>\n<hr>\n<h4 id=\"两个父节点\"><a href=\"#两个父节点\" class=\"headerlink\" title=\"两个父节点\"></a>两个父节点</h4><p>操作符 <code>^</code> 与 <code>~</code> 符一样，后面也可以跟一个数字。</p>\n<p>但是该操作符后面的数字与 <code>~</code> 后面的不同，并不是用来指定向上返回几代，而是指定合并提交记录的某个父提交。还记得前面提到过的一个合并提交有两个父提交吧，所以遇到这样的节点时该选择哪条路径就不是很清晰了。</p>\n<p>Git 默认选择合并提交的“第一个”父提交，在操作符 <code>^</code> 后跟一个数字可以改变这一默认行为。</p>\n<p>例如，执行 git checkout main^2 的过程就是回到第二个父提交节点的意思。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e67ed88f1.png\" style=\"zoom:50%;\" />\n\n<p>并且git支持两个操作符的链式操作 git checkout main~^2~2</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e6cb0c441.png\" style=\"zoom:50%;\" />\n\n\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e85b0e9c3.png\"></p>\n<hr>\n<h4 id=\"纠缠不清的分支\"><a href=\"#纠缠不清的分支\" class=\"headerlink\" title=\"纠缠不清的分支\"></a>纠缠不清的分支</h4><p>实现这种不同分支梳理最好的方式是通过cherry-pick，如果方便知道commit的提交哈希值的话。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e9658f176.png\"></p>\n<hr>\n<h3 id=\"Level-6-Push-amp-Pull-——-Git-远程仓库\"><a href=\"#Level-6-Push-amp-Pull-——-Git-远程仓库\" class=\"headerlink\" title=\"Level 6. Push &amp; Pull —— Git 远程仓库\"></a>Level 6. Push &amp; Pull —— Git 远程仓库</h3><h4 id=\"Git-Clone\"><a href=\"#Git-Clone\" class=\"headerlink\" title=\"Git Clone\"></a>Git Clone</h4><p>远程仓库并不复杂, 在如今的云计算盛行的世界很容易把远程仓库想象成一个富有魔力的东西, 但实际上它们只是你的仓库在另个一台计算机上的拷贝。你可以通过因特网与这台计算机通信 —— 也就是增加或是获取提交记录</p>\n<p>话虽如此, 远程仓库却有一系列强大的特性</p>\n<ul>\n<li>首先也是最重要的的点, 远程仓库是一个强大的备份。本地仓库也有恢复文件到指定版本的能力, 但所有的信息都是保存在本地的。有了远程仓库以后，即使丢失了本地所有数据, 你仍可以通过远程仓库拿回你丢失的数据。</li>\n<li>还有就是, 远程让代码社交化了! 既然你的项目被托管到别的地方了, 你的朋友可以更容易地为你的项目做贡献(或者拉取最新的变更)</li>\n</ul>\n<p>💯==<strong>git clone</strong>==</p>\n<p>通过git clone 可以从远端拉取仓库到本地</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ea37dc283.png\"></p>\n<hr>\n<h4 id=\"远端分支\"><a href=\"#远端分支\" class=\"headerlink\" title=\"远端分支\"></a>远端分支</h4><p>你可能注意到的第一个事就是在我们的本地仓库多了一个名为 <code>o/main</code> 的分支, 这种类型的分支就叫<strong>远程</strong>分支。由于远程分支的特性导致其拥有一些特殊属性。</p>\n<p>远程分支反映了远程仓库(在你上次和它通信时)的<strong>状态</strong>。这会有助于你理解本地的工作与公共工作的差别 —— 这是你与别人分享工作成果前至关重要的一步.</p>\n<p>远程分支有一个特别的属性，在你检出时自动进入分离 HEAD 状态。Git 这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作, （更新了远程分支之后）再用远程分享你的工作成果。</p>\n<p>o/main的意思就是&lt;remote name&gt;/&lt;branch name&gt;</p>\n<p>如果当前选择的是远端分支的话，进行commit操作是不会直接进行远端分支的更新，而是使本地处于分离HEAD的状态。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242eb32490c4.png\"></p>\n<hr>\n<h4 id=\"Git-Fetch\"><a href=\"#Git-Fetch\" class=\"headerlink\" title=\"Git Fetch\"></a>Git Fetch</h4><p>Git 远程仓库相当的操作实际可以归纳为两点：向远程仓库传输数据以及从远程仓库获取数据。既然我们能与远程仓库同步，那么就可以分享任何能被 Git 管理的更新（因此可以分享代码、文件、想法、情书等等）。</p>\n<p>如何从远程仓库获取数据 —— 命令如其名，它就是 git fetch 。</p>\n<p>💯==<strong>git fetch</strong>==</p>\n<p><strong>Git Fetch Do:</strong></p>\n<p>git fetch 完成了仅有的但是很重要的两步:</p>\n<ul>\n<li>从远程仓库下载本地仓库中缺失的提交记录</li>\n<li>更新远程分支指针(如 <code>o/main</code>)</li>\n</ul>\n<p>git fetch 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。</p>\n<p>如果你还记得上一节课程中我们说过的，远程分支反映了远程仓库在你<strong>最后一次与它通信时</strong>的状态，git fetch 就是你与远程仓库通信的方式了！</p>\n<p><strong>Git Fetch Not Do:</strong></p>\n<p>git fetch 并不会改变你本地仓库的状态。它不会更新你的 main 分支，也不会修改你磁盘上的文件。</p>\n<p>理解这一点很重要，因为许多开发人员误以为执行了 git fetch 以后，他们本地仓库就与远程仓库同步了。它可能已经将进行这一操作所需的所有数据都下载了下来，但是<strong>并没有</strong>修改你本地的文件。git fetch 就是单纯的下载资源的操作。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ecb8f2bac.png\"></p>\n<hr>\n<h4 id=\"Git-Pull\"><a href=\"#Git-Pull\" class=\"headerlink\" title=\"Git Pull\"></a>Git Pull</h4><p>其实有很多方法的 —— 当远程分支中有新的提交时，你可以像合并本地分支那样来合并远程分支。也就是说就是你可以执行以下命令:</p>\n<ul>\n<li><code>git cherry-pick o/main</code></li>\n<li><code>git rebase o/main</code></li>\n<li><code>git merge o/main</code></li>\n<li>等等</li>\n</ul>\n<p>实际上，由于先抓取更新再合并到本地分支这个流程很常用，因此 Git 提供了一个专门的命令来完成这两个操作。</p>\n<p>💯==<strong>git pull</strong>==</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ed89ae9c4.png\" style=\"zoom:50%;\" />\n\n<p>git pull 就是 git fetch 和 git merge的缩写</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ee13e8cad.png\"></p>\n<hr>\n<h4 id=\"模拟团队合作\"><a href=\"#模拟团队合作\" class=\"headerlink\" title=\"模拟团队合作\"></a>模拟团队合作</h4><p>在远端操作进行一定更新后，可以通过pull进行及时的拉去更新本地分支</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ee9fb29ea.png\"></p>\n<hr>\n<h4 id=\"Git-Push\"><a href=\"#Git-Push\" class=\"headerlink\" title=\"Git Push\"></a>Git Push</h4><p>传自己分享内容与下载他人的分享刚好相反，git push 负责将<strong>你的</strong>变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录。一旦 git push 完成, 你的朋友们就可以从这个远程仓库下载你分享的成果了！</p>\n<p>💯==<strong>git push</strong>==</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ef5af3f83.png\"></p>\n<hr>\n<h4 id=\"偏离的提交历史\"><a href=\"#偏离的提交历史\" class=\"headerlink\" title=\"偏离的提交历史\"></a>偏离的提交历史</h4><p>假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕，可以发布了。但是 —— 天啊！你的同事这周写了一堆代码，还改了许多你的功能中使用的 API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库了，因此你的工作就变成了基于项目<strong>旧版</strong>的代码，与远程仓库最新的代码不匹配了。</p>\n<p>这种情况下, <code>git push</code> 就不知道该如何操作了。如果你执行 <code>git push</code>，Git 应该让远程仓库回到星期一那天的状态吗？还是直接在新代码的基础上添加你的代码，亦或由于你的提交已经过时而直接忽略你的提交？</p>\n<p>因为这情况（历史偏离）有许多的不确定性，Git 是不会允许你 <code>push</code> 变更的。实际上它会强制你先合并远程最新的代码，然后才能分享你的工作。</p>\n<p>因此主要的解决办法就是先把远端的分支pull下来，然后再merge或者rebase自己的工作到远端分支，然后再合并分支到远端仓库</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242f10bed8b1.png\"></p>\n<hr>\n<h4 id=\"Locked-Main\"><a href=\"#Locked-Main\" class=\"headerlink\" title=\"Locked Main\"></a>Locked Main</h4><p>如果你是在一个大的合作团队中工作, 很可能是main被锁定了, 需要一些Pull Request流程来合并修改。如果你直接提交(commit)到本地main, 然后试图推送(push)修改, 你将会收到这样类似的信息:</p>\n<p><em>! [远程服务器拒绝] main -&gt; main (TF402455: 不允许推送(push)这个分支; 你必须使用pull request来更新这个分支.)</em></p>\n<p>就是在团队合作的时候，防止过多人频繁push自己的代码到远端仓库，因此需要走pr的审查流程。</p>\n<p>解决办法为：新建一个分支feature, 推送到远程服务器. 然后reset你的main分支和远程服务器保持一致, 否则下次你pull并且他人的提交和你冲突的时候就会有问题.</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242f48497d61.png\"></p>\n<hr>\n<h3 id=\"Level-7-关于-origin-和它的周边-——-Git-远程仓库高级操作\"><a href=\"#Level-7-关于-origin-和它的周边-——-Git-远程仓库高级操作\" class=\"headerlink\" title=\"Level 7. 关于 origin 和它的周边 —— Git 远程仓库高级操作\"></a>Level 7. 关于 origin 和它的周边 —— Git 远程仓库高级操作</h3><h4 id=\"推送主分支\"><a href=\"#推送主分支\" class=\"headerlink\" title=\"推送主分支\"></a>推送主分支</h4><p>在大型项目中开发人员通常会在（从 <code>main</code> 上分出来的）特性分支上工作，工作完成后只做一次集成。这跟前面课程的描述很相像（把 side 分支推送到远程仓库），不过本节我们会深入一些.</p>\n<p>但是有些开发人员只在 main 上做 push、pull —— 这样的话 main 总是最新的，始终与远程分支 (o/main) 保持一致。</p>\n<p>对于接下来这个工作流，我们集成了两个步骤：</p>\n<ul>\n<li>将特性分支集成到 <code>main</code> 上</li>\n<li>推送并更新远程分支</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242fc03cb835.png\"></p>\n<p>过程就是先 git pull –rebase 然后再rebase 合并分支</p>\n<hr>\n<h4 id=\"合并远端仓库\"><a href=\"#合并远端仓库\" class=\"headerlink\" title=\"合并远端仓库\"></a>合并远端仓库</h4><p>在开发社区里，有许多关于 merge 与 rebase 的讨论。以下是关于 rebase 的优缺点：</p>\n<p>优点:</p>\n<ul>\n<li>Rebase 使你的提交树变得很干净, 所有的提交都在一条线上</li>\n</ul>\n<p>缺点:</p>\n<ul>\n<li>Rebase 修改了提交树的历史</li>\n</ul>\n<p>比如, 提交 C1 可以被 rebase 到 C3 之后。这看起来 C1 中的工作是在 C3 之后进行的，但实际上是在 C3 之前。</p>\n<p>一些开发人员喜欢保留提交历史，因此更偏爱 merge。而其他人（比如我自己）可能更喜欢干净的提交树，于是偏爱 rebase。仁者见仁，智者见智。 </p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242fd476265d.png\"></p>\n<p>相对来说，更有细节，更能体现提交历史</p>\n<h4 id=\"远程追踪\"><a href=\"#远程追踪\" class=\"headerlink\" title=\"远程追踪\"></a>远程追踪</h4><p>Git 好像知道 <code>main</code> 与 <code>o/main</code> 是相关的。当然这些分支的名字是相似的，可能会让你觉得是依此将远程分支 main 和本地的 main 分支进行了关联。这种关联在以下两种情况下可以清楚地得到展示：</p>\n<ul>\n<li>pull 操作时, 提交记录会被先下载到 o/main 上，之后再合并到本地的 main 分支。隐含的合并目标由这个关联确定的。</li>\n<li>push 操作时, 我们把工作从 <code>main</code> 推到远程仓库中的 <code>main</code> 分支(同时会更新远程分支 <code>o/main</code>) 。这个推送的目的地也是由这种关联确定的！</li>\n</ul>\n<p>直接了当地讲，<code>main</code> 和 <code>o/main</code> 的关联关系就是由分支的“remote tracking”属性决定的。<code>main</code> 被设定为跟踪 <code>o/main</code> —— 这意味着为 <code>main</code> 分支指定了推送的目的地以及拉取后合并的目标。</p>\n<p>你可能想知道 <code>main</code> 分支上这个属性是怎么被设定的，你并没有用任何命令指定过这个属性呀！好吧, 当你克隆仓库的时候, Git 就自动帮你把这个属性设置好了。</p>\n<p>当你克隆时, Git 会为远程仓库中的每个分支在本地仓库中创建一个远程分支（比如 <code>o/main</code>）。然后再创建一个跟踪远程仓库中活动分支的本地分支，默认情况下这个本地分支会被命名为 <code>main</code>。</p>\n<p>克隆完成后，你会得到一个本地分支（如果没有这个本地分支的话，你的目录就是“空白”的），但是可以查看远程仓库中所有的分支（如果你好奇心很强的话）。这样做对于本地仓库和远程仓库来说，都是最佳选择。</p>\n<p>💯==<strong>git checkout -b totallyNotMain o/main</strong>==</p>\n<p>可以创建一个totallyNotMain来追踪远程分支o/main</p>\n<p>💯==<strong>git branch -u o/main foo</strong>==</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ff7627ed3.png\"></p>\n<hr>\n<h4 id=\"Git-Push的参数\"><a href=\"#Git-Push的参数\" class=\"headerlink\" title=\"Git Push的参数\"></a>Git Push的参数</h4><p>首先来看 <code>git push</code>。在远程跟踪课程中，你已经学到了 Git 是通过当前检出分支的属性来确定远程仓库以及要 push 的目的地的。这是未指定参数时的行为，我们可以为 push 指定参数，语法是：</p>\n<p>💯==<strong>git push &lt;remote&gt; &lt;place&gt;</strong>==</p>\n<p>把这个命令翻译过来就是：</p>\n<p><em>切到本地仓库中的“main”分支，获取所有的提交，再到远程仓库“origin”中找到“main”分支，将远程仓库中没有的提交记录都添加上去，搞定之后告诉我。</em></p>\n<p>我们通过“place”参数来告诉 Git 提交记录来自于 main, 要推送到远程仓库中的 main。它实际就是要同步的两个仓库的位置。</p>\n<p>需要注意的是，因为我们通过指定参数告诉了 Git 所有它需要的信息, 所以它就忽略了我们所检出的分支的属性！</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624300d69d378.png\"></p>\n<hr>\n<h4 id=\"Git-Push的参数2\"><a href=\"#Git-Push的参数2\" class=\"headerlink\" title=\"Git Push的参数2\"></a>Git Push的参数2</h4><p>，当为 git push 指定 place 参数为 <code>main</code> 时，我们同时指定了提交记录的来源和去向。</p>\n<p>你可能想问 —— 如果来源和去向分支的名称不同呢？比如你想把本地的 <code>foo</code> 分支推送到远程仓库中的 <code>bar</code> 分支。</p>\n<p>要同时为源和目的地指定 <code>&lt;place&gt;</code> 的话，只需要用冒号 <code>:</code> 将二者连起来就可以了：</p>\n<p>💯==<strong>git push origin &lt;source&gt;:&lt;destination&gt;</strong>==</p>\n<p>这个参数实际的值是个 refspec，“refspec” 是一个自造的词，意思是 Git 能识别的位置（比如分支 <code>foo</code> 或者 <code>HEAD~1</code>）</p>\n<p>一旦你指定了独立的来源和目的地，就可以组织出言简意赅的远程操作命令了.</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624301c9cddfe.png\"></p>\n<hr>\n<h4 id=\"Git-Fetch的参数\"><a href=\"#Git-Fetch的参数\" class=\"headerlink\" title=\"Git Fetch的参数\"></a>Git Fetch的参数</h4><p><code>git fetch</code> 的参数和 <code>git push</code> 极其相似。他们的概念是相同的，只是方向相反罢了（因为现在你是下载，而非上传）</p>\n<p>💯==<strong>git fetch &lt;remote&gt; &lt;place&gt;</strong>==</p>\n<p>Git 会到远程仓库的分支上，然后获取所有本地不存在的提交，放到本地的相应分支上。</p>\n<p>💯==<strong>git fetch origin &lt;source&gt;:&lt;destination&gt;</strong>==</p>\n<p>但是命令很不常用就是了</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624301c9cddfe.png\"></p>\n<hr>\n<h4 id=\"没有source的source\"><a href=\"#没有source的source\" class=\"headerlink\" title=\"没有source的source\"></a>没有source的source</h4><p>Git 有两种关于 <code>&lt;source&gt;</code> 的用法是比较诡异的，即你可以在 git push 或 git fetch 时不指定任何 <code>source</code>，方法就是仅保留冒号和 destination 部分，source 部分留空。</p>\n<ul>\n<li><code>git push origin :side</code></li>\n<li><code>git fetch origin :bugFix</code></li>\n</ul>\n<p>我们分别来看一下这两条命令的作用……</p>\n<p>如果 push 空 到远程仓库会如何呢？它会删除远程仓库中的分支！</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624313c20ceea.png\" style=\"zoom:50%;\" />\n\n<p>如果 fetch 空 到本地，会在本地创建一个新分支。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624314368592a.png\" style=\"zoom:50%;\" />\n\n\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6243147a70f05.png\"></p>\n<hr>\n<h4 id=\"Git-Pull的参数\"><a href=\"#Git-Pull的参数\" class=\"headerlink\" title=\"Git Pull的参数\"></a>Git Pull的参数</h4><p> git pull 到头来就是 fetch 后跟 merge 的缩写。你可以理解为用同样的参数执行 git fetch，然后再 merge 你所抓取到的提交记录。</p>\n<p><code>git pull origin foo</code> 相当于：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch origin foo; git merge o&#x2F;foo</span><br></pre></td></tr></table></figure>\n<p>还有…</p>\n<p><code>git pull origin bar~1:bugFix</code> 相当于：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch origin bar~1:bugFix; git merge bugFix</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624316d49f61c.png\"></p>\n<hr>\n<h2 id=\"Git操作实例\"><a href=\"#Git操作实例\" class=\"headerlink\" title=\"Git操作实例\"></a>Git操作实例</h2><blockquote>\n<p>在这一个月多的工作里，我也遇到了需要用到git的一些操作，在此总结如下情景：</p>\n</blockquote>\n<h3 id=\"先暂存当前工作而去完成另一个工作\"><a href=\"#先暂存当前工作而去完成另一个工作\" class=\"headerlink\" title=\"先暂存当前工作而去完成另一个工作\"></a>先暂存当前工作而去完成另一个工作</h3><blockquote>\n<p>遇到过这种情况：在做某个工作到一半还没完成的时候，突然被提醒先去做另外一个工作。这种情况下，现在没做完的工作咋办？</p>\n</blockquote>\n<p>首先，在看了上面的内容之后，不管如果我们一定要先进行 <code>git commit</code> 操作。</p>\n<p>因为只有在commit之后，当前工作才会成为一个结点。</p>\n<p>同时，为了唯一标识当前结点，我们可以采用新建分支或者新建tag的方式标记当前结点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag tag_name HEAD</span><br></pre></td></tr></table></figure>\n<p>在完成该操作后，我们就回到上一个结点，也就是远端所在结点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout HEAD^</span><br><span class=\"line\"></span><br><span class=\"line\">git branch -f master HEAD</span><br><span class=\"line\"></span><br><span class=\"line\">git checkout master</span><br></pre></td></tr></table></figure>\n<p>此后，我们便可以开始新的工作，以正常的方式进行新的操作（commit啊，push啊都可以）。</p>\n<p>当前工作完成之后，我们就可以通过 <code>git checkout tag_name</code> 回到之前没有完成的工作中去了！</p>\n<h3 id=\"更改两次提交的顺序\"><a href=\"#更改两次提交的顺序\" class=\"headerlink\" title=\"更改两次提交的顺序\"></a>更改两次提交的顺序</h3><blockquote>\n<p>这是今天遇到的一个情况：先完成了一个提交，之后去做另一个工作提交了一次。但这时被提示之前的提交有问题，需要修改。</p>\n<p>这个时候，后一次的提交没有问题，可以被点进主分支中。但由于它的父结点是前一次的提交，因此点不进去，怎么办呢？</p>\n</blockquote>\n<p>这个时候，我们就要考虑切换两个分支的顺序了。</p>\n<p>首先最重要的是，我们还是要加一个标签标记当前的位置，否则以后就找不到了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag tag_name HEAD</span><br></pre></td></tr></table></figure>\n<p>然后，我们回到上上一次的位置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout HEAD~2</span><br><span class=\"line\"></span><br><span class=\"line\">git branch -f master HEAD</span><br><span class=\"line\"></span><br><span class=\"line\">git checkout master</span><br></pre></td></tr></table></figure>\n<p>这个时候，我们只要通过 <code>cherry-pick</code> 操作把刚刚的两个操作反过来串联在一起就行了。</p>\n<p>当然，通过前面的学习，我们知道  <code>git rebase -i</code>也是可行的，在这里不再赘述。</p>\n"},{"title":"数位DP解题思路","date":"2024-01-16T05:04:31.000Z","_content":"## 参考链接\n\nhttps://oi-wiki.org/dp/number/\n\nhttps://blog.csdn.net/JKdd123456/article/details/81383012\n\n### demo\n\n> 题目大意：多组数据，每次给定区间  [n,m]  ，求在n到m中没有  “62“ （连续）或 “4“ 的数的个数。\n> 如62315包含62，88914包含4，这两个数都是不合法的。\n> 0 < n<=m < 1000000\n\n\n\n试想：我们如果能有一个函数count(int x)，可以返回[0,x]之间符合题意的数的个数。\n\n那么是不是直接输出count(m)-count(n-1)就是答案？\n\n设一个数组dp[i][j]表示i位数，最高位是j 的符合题意的个数\n\n\n\n### 模板\n\nhttps://leetcode.cn/problems/count-special-integers/solutions/1746956/shu-wei-dp-mo-ban-by-endlesscheng-xtgx/\n","source":"_posts/数位DP解题思路.md","raw":"---\ntitle: 数位DP解题思路\ndate: 2024-01-16 13:04:31\ntags:\n---\n## 参考链接\n\nhttps://oi-wiki.org/dp/number/\n\nhttps://blog.csdn.net/JKdd123456/article/details/81383012\n\n### demo\n\n> 题目大意：多组数据，每次给定区间  [n,m]  ，求在n到m中没有  “62“ （连续）或 “4“ 的数的个数。\n> 如62315包含62，88914包含4，这两个数都是不合法的。\n> 0 < n<=m < 1000000\n\n\n\n试想：我们如果能有一个函数count(int x)，可以返回[0,x]之间符合题意的数的个数。\n\n那么是不是直接输出count(m)-count(n-1)就是答案？\n\n设一个数组dp[i][j]表示i位数，最高位是j 的符合题意的个数\n\n\n\n### 模板\n\nhttps://leetcode.cn/problems/count-special-integers/solutions/1746956/shu-wei-dp-mo-ban-by-endlesscheng-xtgx/\n","slug":"数位DP解题思路","published":1,"updated":"2024-01-21T09:12:59.135Z","_id":"clrg98wet000087fafu1q2dvs","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://oi-wiki.org/dp/number/\">https://oi-wiki.org/dp/number/</a></p>\n<p><a href=\"https://blog.csdn.net/JKdd123456/article/details/81383012\">https://blog.csdn.net/JKdd123456/article/details/81383012</a></p>\n<h3 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h3><blockquote>\n<p>题目大意：多组数据，每次给定区间  [n,m]  ，求在n到m中没有  “62“ （连续）或 “4“ 的数的个数。<br>如62315包含62，88914包含4，这两个数都是不合法的。<br>0 &lt; n&lt;=m &lt; 1000000</p>\n</blockquote>\n<p>试想：我们如果能有一个函数count(int x)，可以返回[0,x]之间符合题意的数的个数。</p>\n<p>那么是不是直接输出count(m)-count(n-1)就是答案？</p>\n<p>设一个数组dp[i][j]表示i位数，最高位是j 的符合题意的个数</p>\n<h3 id=\"模板\"><a href=\"#模板\" class=\"headerlink\" title=\"模板\"></a>模板</h3><p><a href=\"https://leetcode.cn/problems/count-special-integers/solutions/1746956/shu-wei-dp-mo-ban-by-endlesscheng-xtgx/\">https://leetcode.cn/problems/count-special-integers/solutions/1746956/shu-wei-dp-mo-ban-by-endlesscheng-xtgx/</a></p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://oi-wiki.org/dp/number/\">https://oi-wiki.org/dp/number/</a></p>\n<p><a href=\"https://blog.csdn.net/JKdd123456/article/details/81383012\">https://blog.csdn.net/JKdd123456/article/details/81383012</a></p>\n<h3 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h3><blockquote>\n<p>题目大意：多组数据，每次给定区间  [n,m]  ，求在n到m中没有  “62“ （连续）或 “4“ 的数的个数。<br>如62315包含62，88914包含4，这两个数都是不合法的。<br>0 &lt; n&lt;=m &lt; 1000000</p>\n</blockquote>\n<p>试想：我们如果能有一个函数count(int x)，可以返回[0,x]之间符合题意的数的个数。</p>\n<p>那么是不是直接输出count(m)-count(n-1)就是答案？</p>\n<p>设一个数组dp[i][j]表示i位数，最高位是j 的符合题意的个数</p>\n<h3 id=\"模板\"><a href=\"#模板\" class=\"headerlink\" title=\"模板\"></a>模板</h3><p><a href=\"https://leetcode.cn/problems/count-special-integers/solutions/1746956/shu-wei-dp-mo-ban-by-endlesscheng-xtgx/\">https://leetcode.cn/problems/count-special-integers/solutions/1746956/shu-wei-dp-mo-ban-by-endlesscheng-xtgx/</a></p>\n"},{"title":"需要深入理解的一些算法","date":"2024-01-20T06:51:26.000Z","_content":"\n## 算法\n\nKMP算法：https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string\n","source":"_posts/需要深入理解的一些算法.md","raw":"---\ntitle: 需要深入理解的一些算法\ndate: 2024-01-20 14:51:26\ntags: 算法\n---\n\n## 算法\n\nKMP算法：https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string\n","slug":"需要深入理解的一些算法","published":1,"updated":"2024-01-21T09:12:59.132Z","_id":"clrlpownu0000696sa5ev93xe","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><p>KMP算法：<a href=\"https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string\">https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string</a></p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><p>KMP算法：<a href=\"https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string\">https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string</a></p>\n"},{"title":"parse_from_mail_attachment","date":"2024-07-04T16:39:17.000Z","_content":"\n## 如何提取邮件`.eml`文件的全部附件呢？\n\n可以使用下面这段`python`代码：\n\n```python\n\nimport os\nimport email\nfrom email import policy\nfrom email.parser import BytesParser\n\ndef save_attachments_from_eml(eml_file_path, output_dir, file_name):\n    # 读取 .eml 文件内容\n    with open(eml_file_path, 'rb') as f:\n        eml_content = f.read()\n\n    # 解析 .eml 文件\n    msg = BytesParser(policy=policy.default).parsebytes(eml_content)\n    \n    # 检查并保存附件\n    for part in msg.iter_attachments():\n        filename = part.get_filename()\n        if filename:\n            file_data = part.get_payload(decode=True)\n            \n            # 创建输出文件路径\n            output_file_path = os.path.join(output_dir, file_name + '-' + filename)\n            \n            # 将附件数据写入文件\n            with open(output_file_path, 'wb') as f:\n                f.write(file_data)\n            \n            print(f\"Saved attachment: {output_file_path}\")\n\neml_file_path = '/Users/wangmingjie/Desktop/NET'\noutput_dir = '/Users/wangmingjie/Desktop/NET-attachment'\nos.makedirs(output_dir, exist_ok=True)\n\n# 获取该路径下全部文件\nfiles = os.listdir(eml_file_path)\n\nfor file in files:\n    if file.endswith('.eml'):\n        # 将邮件名称作为file_name\n        file_name = file.split('.')[0]\n        save_attachments_from_eml(os.path.join(eml_file_path, file), output_dir, file_name)\n\n\nprint('存储完成，共存储了{}个文件'.format(len(files)))\n\n```","source":"_posts/parse-from-mail-attachment.md","raw":"---\ntitle: parse_from_mail_attachment\ndate: 2024-07-05 00:39:17\ntags:\n---\n\n## 如何提取邮件`.eml`文件的全部附件呢？\n\n可以使用下面这段`python`代码：\n\n```python\n\nimport os\nimport email\nfrom email import policy\nfrom email.parser import BytesParser\n\ndef save_attachments_from_eml(eml_file_path, output_dir, file_name):\n    # 读取 .eml 文件内容\n    with open(eml_file_path, 'rb') as f:\n        eml_content = f.read()\n\n    # 解析 .eml 文件\n    msg = BytesParser(policy=policy.default).parsebytes(eml_content)\n    \n    # 检查并保存附件\n    for part in msg.iter_attachments():\n        filename = part.get_filename()\n        if filename:\n            file_data = part.get_payload(decode=True)\n            \n            # 创建输出文件路径\n            output_file_path = os.path.join(output_dir, file_name + '-' + filename)\n            \n            # 将附件数据写入文件\n            with open(output_file_path, 'wb') as f:\n                f.write(file_data)\n            \n            print(f\"Saved attachment: {output_file_path}\")\n\neml_file_path = '/Users/wangmingjie/Desktop/NET'\noutput_dir = '/Users/wangmingjie/Desktop/NET-attachment'\nos.makedirs(output_dir, exist_ok=True)\n\n# 获取该路径下全部文件\nfiles = os.listdir(eml_file_path)\n\nfor file in files:\n    if file.endswith('.eml'):\n        # 将邮件名称作为file_name\n        file_name = file.split('.')[0]\n        save_attachments_from_eml(os.path.join(eml_file_path, file), output_dir, file_name)\n\n\nprint('存储完成，共存储了{}个文件'.format(len(files)))\n\n```","slug":"parse-from-mail-attachment","published":1,"updated":"2024-07-04T16:39:59.155Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cly7hsxnf0000bnfa45yv2hsy","content":"<h2 id=\"如何提取邮件-eml文件的全部附件呢？\"><a href=\"#如何提取邮件-eml文件的全部附件呢？\" class=\"headerlink\" title=\"如何提取邮件.eml文件的全部附件呢？\"></a>如何提取邮件<code>.eml</code>文件的全部附件呢？</h2><p>可以使用下面这段<code>python</code>代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> email</span><br><span class=\"line\"><span class=\"keyword\">from</span> email <span class=\"keyword\">import</span> policy</span><br><span class=\"line\"><span class=\"keyword\">from</span> email.parser <span class=\"keyword\">import</span> BytesParser</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">save_attachments_from_eml</span>(<span class=\"params\">eml_file_path, output_dir, file_name</span>):</span></span><br><span class=\"line\">    <span class=\"comment\"># 读取 .eml 文件内容</span></span><br><span class=\"line\">    <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(eml_file_path, <span class=\"string\">&#x27;rb&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">        eml_content = f.read()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 解析 .eml 文件</span></span><br><span class=\"line\">    msg = BytesParser(policy=policy.default).parsebytes(eml_content)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 检查并保存附件</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> part <span class=\"keyword\">in</span> msg.iter_attachments():</span><br><span class=\"line\">        filename = part.get_filename()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> filename:</span><br><span class=\"line\">            file_data = part.get_payload(decode=<span class=\"literal\">True</span>)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># 创建输出文件路径</span></span><br><span class=\"line\">            output_file_path = os.path.join(output_dir, file_name + <span class=\"string\">&#x27;-&#x27;</span> + filename)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># 将附件数据写入文件</span></span><br><span class=\"line\">            <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(output_file_path, <span class=\"string\">&#x27;wb&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">                f.write(file_data)</span><br><span class=\"line\">            </span><br><span class=\"line\">            print(<span class=\"string\">f&quot;Saved attachment: <span class=\"subst\">&#123;output_file_path&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">eml_file_path = <span class=\"string\">&#x27;/Users/wangmingjie/Desktop/NET&#x27;</span></span><br><span class=\"line\">output_dir = <span class=\"string\">&#x27;/Users/wangmingjie/Desktop/NET-attachment&#x27;</span></span><br><span class=\"line\">os.makedirs(output_dir, exist_ok=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取该路径下全部文件</span></span><br><span class=\"line\">files = os.listdir(eml_file_path)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> file <span class=\"keyword\">in</span> files:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> file.endswith(<span class=\"string\">&#x27;.eml&#x27;</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 将邮件名称作为file_name</span></span><br><span class=\"line\">        file_name = file.split(<span class=\"string\">&#x27;.&#x27;</span>)[<span class=\"number\">0</span>]</span><br><span class=\"line\">        save_attachments_from_eml(os.path.join(eml_file_path, file), output_dir, file_name)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">&#x27;存储完成，共存储了&#123;&#125;个文件&#x27;</span>.<span class=\"built_in\">format</span>(<span class=\"built_in\">len</span>(files)))</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h2 id=\"如何提取邮件-eml文件的全部附件呢？\"><a href=\"#如何提取邮件-eml文件的全部附件呢？\" class=\"headerlink\" title=\"如何提取邮件.eml文件的全部附件呢？\"></a>如何提取邮件<code>.eml</code>文件的全部附件呢？</h2><p>可以使用下面这段<code>python</code>代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> email</span><br><span class=\"line\"><span class=\"keyword\">from</span> email <span class=\"keyword\">import</span> policy</span><br><span class=\"line\"><span class=\"keyword\">from</span> email.parser <span class=\"keyword\">import</span> BytesParser</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">save_attachments_from_eml</span>(<span class=\"params\">eml_file_path, output_dir, file_name</span>):</span></span><br><span class=\"line\">    <span class=\"comment\"># 读取 .eml 文件内容</span></span><br><span class=\"line\">    <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(eml_file_path, <span class=\"string\">&#x27;rb&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">        eml_content = f.read()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 解析 .eml 文件</span></span><br><span class=\"line\">    msg = BytesParser(policy=policy.default).parsebytes(eml_content)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 检查并保存附件</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> part <span class=\"keyword\">in</span> msg.iter_attachments():</span><br><span class=\"line\">        filename = part.get_filename()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> filename:</span><br><span class=\"line\">            file_data = part.get_payload(decode=<span class=\"literal\">True</span>)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># 创建输出文件路径</span></span><br><span class=\"line\">            output_file_path = os.path.join(output_dir, file_name + <span class=\"string\">&#x27;-&#x27;</span> + filename)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># 将附件数据写入文件</span></span><br><span class=\"line\">            <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(output_file_path, <span class=\"string\">&#x27;wb&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">                f.write(file_data)</span><br><span class=\"line\">            </span><br><span class=\"line\">            print(<span class=\"string\">f&quot;Saved attachment: <span class=\"subst\">&#123;output_file_path&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">eml_file_path = <span class=\"string\">&#x27;/Users/wangmingjie/Desktop/NET&#x27;</span></span><br><span class=\"line\">output_dir = <span class=\"string\">&#x27;/Users/wangmingjie/Desktop/NET-attachment&#x27;</span></span><br><span class=\"line\">os.makedirs(output_dir, exist_ok=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取该路径下全部文件</span></span><br><span class=\"line\">files = os.listdir(eml_file_path)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> file <span class=\"keyword\">in</span> files:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> file.endswith(<span class=\"string\">&#x27;.eml&#x27;</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 将邮件名称作为file_name</span></span><br><span class=\"line\">        file_name = file.split(<span class=\"string\">&#x27;.&#x27;</span>)[<span class=\"number\">0</span>]</span><br><span class=\"line\">        save_attachments_from_eml(os.path.join(eml_file_path, file), output_dir, file_name)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">&#x27;存储完成，共存储了&#123;&#125;个文件&#x27;</span>.<span class=\"built_in\">format</span>(<span class=\"built_in\">len</span>(files)))</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"二分查找注意的点","date":"2024-10-02T05:30:00.000Z","cover":"https://s3.ax1x.com/2020/12/29/rbaWHf.jpg","_content":"\n\n\n二分查找的默认写法都是left <= right 最后跳出条件就是right, left\n\n```java\nif (nums[mid] == target) {\n    // break\n} else if (nums[mid] > target) {\n    right = mid - 1;\n} else {\n    left = mid + 1;\n}\n```\n\n如果只需要单边查找（也就是不特殊处理==target，通常是找小于或者大于某一个值的情况），就用left < right\n\n此时的跳出条件是left = right\n\n```java\nif (nums[mid] < target) {\n  left = mid + 1;\n} else {\n  right = mid; \n}\n// 单边查找，找到 == target的第一个value\n```\n\n\n\n这种情况下，如果是left变更，mid的计算就是left + (right - left + 1) / 2\n\n这是因为下取整，left可能不会变，所以需要+1来上取整\n\n否则，直接left + (right - left) / 2 即可\n\n这一题：https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/\n\n就是典型的单边查找的情况\n","source":"_posts/二分查找.md","raw":"---\ntitle: 二分查找注意的点\ndate: 2024-10-02 13:30:00\ncover: https://s3.ax1x.com/2020/12/29/rbaWHf.jpg\n---\n\n\n\n二分查找的默认写法都是left <= right 最后跳出条件就是right, left\n\n```java\nif (nums[mid] == target) {\n    // break\n} else if (nums[mid] > target) {\n    right = mid - 1;\n} else {\n    left = mid + 1;\n}\n```\n\n如果只需要单边查找（也就是不特殊处理==target，通常是找小于或者大于某一个值的情况），就用left < right\n\n此时的跳出条件是left = right\n\n```java\nif (nums[mid] < target) {\n  left = mid + 1;\n} else {\n  right = mid; \n}\n// 单边查找，找到 == target的第一个value\n```\n\n\n\n这种情况下，如果是left变更，mid的计算就是left + (right - left + 1) / 2\n\n这是因为下取整，left可能不会变，所以需要+1来上取整\n\n否则，直接left + (right - left) / 2 即可\n\n这一题：https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/\n\n就是典型的单边查找的情况\n","slug":"二分查找","published":1,"updated":"2024-10-02T05:24:53.250Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm1rfb9700000swfa6550fmn3","content":"<p>二分查找的默认写法都是left &lt;= right 最后跳出条件就是right, left</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (nums[mid] == target) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// break</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &gt; target) &#123;</span><br><span class=\"line\">    right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果只需要单边查找（也就是不特殊处理==target，通常是找小于或者大于某一个值的情况），就用left &lt; right</p>\n<p>此时的跳出条件是left = right</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (nums[mid] &lt; target) &#123;</span><br><span class=\"line\">  left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  right = mid; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 单边查找，找到 == target的第一个value</span></span><br></pre></td></tr></table></figure>\n\n\n<p>这种情况下，如果是left变更，mid的计算就是left + (right - left + 1) / 2</p>\n<p>这是因为下取整，left可能不会变，所以需要+1来上取整</p>\n<p>否则，直接left + (right - left) / 2 即可</p>\n<p>这一题：<a href=\"https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/\">https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/</a></p>\n<p>就是典型的单边查找的情况</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<p>二分查找的默认写法都是left &lt;= right 最后跳出条件就是right, left</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (nums[mid] == target) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// break</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &gt; target) &#123;</span><br><span class=\"line\">    right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果只需要单边查找（也就是不特殊处理==target，通常是找小于或者大于某一个值的情况），就用left &lt; right</p>\n<p>此时的跳出条件是left = right</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (nums[mid] &lt; target) &#123;</span><br><span class=\"line\">  left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  right = mid; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 单边查找，找到 == target的第一个value</span></span><br></pre></td></tr></table></figure>\n\n\n<p>这种情况下，如果是left变更，mid的计算就是left + (right - left + 1) / 2</p>\n<p>这是因为下取整，left可能不会变，所以需要+1来上取整</p>\n<p>否则，直接left + (right - left) / 2 即可</p>\n<p>这一题：<a href=\"https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/\">https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/</a></p>\n<p>就是典型的单边查找的情况</p>\n"},{"title":"贪心算法--加油站问题","date":"2024-09-08T04:59:43.000Z","_content":"\n\n\n## 问题\n\n有一条环形道路，沿着这条道路分布着 n 个加油站。每个加油站 i 提供的汽油量为 gas_i ，从加油站 i 到加油站 i+1 需要消耗的汽油量为 cost_i 。现在你要从某一个加油站出发，沿顺时针方向开车，绕着整个环形道路行驶一圈并返回到起点。你起步时油箱是空的。\n\n你需要找到一个起点加油站，使得从该加油站出发，经过每个加油站时，汽油量始终不小于0，并能顺利返回出发点。\n\n如果存在这样的起点，加油站编号是唯一的。如果不存在这样的起点，则说明无论从哪个加油站出发，都无法完成一圈。\n\n\n\n## 示例\n\n输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]\n\n输出: 3\n\n解释:\n\n从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油\n\n开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油\n\n开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油\n\n开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油\n\n开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油\n\n开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。\n\n因此，3 可为出发点。\n\n\n\n## 解答\n\n贪心算法\n\n如果i开不到j，那么从i里面的任何一个作为起点都开不到j\n\n所以下一次直接从j+1开始判断就行了\n","source":"_posts/贪心算法-加油站问题.md","raw":"---\ntitle: 贪心算法--加油站问题\ndate: 2024-09-08 12:59:43\ntags:\n---\n\n\n\n## 问题\n\n有一条环形道路，沿着这条道路分布着 n 个加油站。每个加油站 i 提供的汽油量为 gas_i ，从加油站 i 到加油站 i+1 需要消耗的汽油量为 cost_i 。现在你要从某一个加油站出发，沿顺时针方向开车，绕着整个环形道路行驶一圈并返回到起点。你起步时油箱是空的。\n\n你需要找到一个起点加油站，使得从该加油站出发，经过每个加油站时，汽油量始终不小于0，并能顺利返回出发点。\n\n如果存在这样的起点，加油站编号是唯一的。如果不存在这样的起点，则说明无论从哪个加油站出发，都无法完成一圈。\n\n\n\n## 示例\n\n输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]\n\n输出: 3\n\n解释:\n\n从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油\n\n开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油\n\n开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油\n\n开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油\n\n开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油\n\n开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。\n\n因此，3 可为出发点。\n\n\n\n## 解答\n\n贪心算法\n\n如果i开不到j，那么从i里面的任何一个作为起点都开不到j\n\n所以下一次直接从j+1开始判断就行了\n","slug":"贪心算法-加油站问题","published":1,"updated":"2024-10-02T05:25:18.748Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm1rfbt2i0000u2fahhwt9ng5","content":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>有一条环形道路，沿着这条道路分布着 n 个加油站。每个加油站 i 提供的汽油量为 gas_i ，从加油站 i 到加油站 i+1 需要消耗的汽油量为 cost_i 。现在你要从某一个加油站出发，沿顺时针方向开车，绕着整个环形道路行驶一圈并返回到起点。你起步时油箱是空的。</p>\n<p>你需要找到一个起点加油站，使得从该加油站出发，经过每个加油站时，汽油量始终不小于0，并能顺利返回出发点。</p>\n<p>如果存在这样的起点，加油站编号是唯一的。如果不存在这样的起点，则说明无论从哪个加油站出发，都无法完成一圈。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]</p>\n<p>输出: 3</p>\n<p>解释:</p>\n<p>从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油</p>\n<p>开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油</p>\n<p>开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油</p>\n<p>开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油</p>\n<p>开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油</p>\n<p>开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</p>\n<p>因此，3 可为出发点。</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>贪心算法</p>\n<p>如果i开不到j，那么从i里面的任何一个作为起点都开不到j</p>\n<p>所以下一次直接从j+1开始判断就行了</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>有一条环形道路，沿着这条道路分布着 n 个加油站。每个加油站 i 提供的汽油量为 gas_i ，从加油站 i 到加油站 i+1 需要消耗的汽油量为 cost_i 。现在你要从某一个加油站出发，沿顺时针方向开车，绕着整个环形道路行驶一圈并返回到起点。你起步时油箱是空的。</p>\n<p>你需要找到一个起点加油站，使得从该加油站出发，经过每个加油站时，汽油量始终不小于0，并能顺利返回出发点。</p>\n<p>如果存在这样的起点，加油站编号是唯一的。如果不存在这样的起点，则说明无论从哪个加油站出发，都无法完成一圈。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]</p>\n<p>输出: 3</p>\n<p>解释:</p>\n<p>从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油</p>\n<p>开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油</p>\n<p>开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油</p>\n<p>开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油</p>\n<p>开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油</p>\n<p>开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</p>\n<p>因此，3 可为出发点。</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>贪心算法</p>\n<p>如果i开不到j，那么从i里面的任何一个作为起点都开不到j</p>\n<p>所以下一次直接从j+1开始判断就行了</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"clrlpownu0000696sa5ev93xe","tag_id":"clrlpowo00001696s8s7v050j","_id":"clrlpowo50002696sfpzhhg20"}],"Tag":[{"name":"算法","_id":"clrlpowo00001696s8s7v050j"}]}}