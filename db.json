{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/ZONE/os/test.html","path":"ZONE/os/test.html","modified":0,"renderable":0},{"_id":"source/ZONE/test/bg.jpg","path":"ZONE/test/bg.jpg","modified":0,"renderable":0},{"_id":"source/ZONE/test/find.jpg","path":"ZONE/test/find.jpg","modified":0,"renderable":0},{"_id":"source/ZONE/test/love.jpg","path":"ZONE/test/love.jpg","modified":0,"renderable":0},{"_id":"source/ZONE/test/test.html","path":"ZONE/test/test.html","modified":0,"renderable":0},{"_id":"source/ZONE/test/wechat.jpg","path":"ZONE/test/wechat.jpg","modified":0,"renderable":0},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/error-page.png","path":"img/error-page.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/butterfly-icon.png","path":"img/butterfly-icon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.ico","path":"img/favicon.ico","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/.DS_Store","hash":"4e9f3542009df2015abb24ea231c1d11326756ae","modified":1761991032585},{"_id":"source/.DS_Store","hash":"c8b98cf7f288bb63973808bdbd504e3dfb2bcdec","modified":1733839098061},{"_id":"source/CNAME","hash":"89b86650a749b0a37945be60cf90d84df927c124","modified":1609217754000},{"_id":"source/_data/link.yml","hash":"74f729e79a657a4c0cbb591c892c4eef5176c896","modified":1609235384000},{"_id":"source/_posts/ElementUI2-开发.md","hash":"94aa90b3e72f4fe7ff147e36c7723d6237d6269e","modified":1682395678000},{"_id":"source/_posts/2020年.md","hash":"e5d558605efc4ca7ff9d773da6a1b61f465bc6be","modified":1609415418000},{"_id":"source/_posts/JS-原型链.md","hash":"f81f6be9056a6c56480a44e8b8c7495086214ccc","modified":1648990112000},{"_id":"source/_posts/React-native开发.md","hash":"7cd4bced45b39b8bbc874657fbe866fd137ab0b0","modified":1682433828000},{"_id":"source/_posts/Mac的常用操作.md","hash":"b5fcc9a66962682994cff00b6d9243c5dc815b22","modified":1682434302000},{"_id":"source/_posts/Ubuntu系统中的常用操作.md","hash":"d33104ab2aea46c044e15d7df8f67d3e049bae1d","modified":1682341048000},{"_id":"source/_posts/parse-from-mail-attachment.md","hash":"4e4dcfaf3a5bb8212d8a5fce0525a6f3f030c795","modified":1761875924674},{"_id":"source/_posts/二分查找.md","hash":"f250fb8f94dd8f9d1eb749e90ac156bef1411ac8","modified":1734769191886},{"_id":"source/_posts/git基本操作整理.md","hash":"facdaed88be710156f9bc195230482253501c872","modified":1648988348000},{"_id":"source/_posts/leetcode刷题.md","hash":"f2985703667b30c8cf41d92aae5e388afd39214b","modified":1647670480000},{"_id":"source/_posts/五子棋联机游戏介绍.md","hash":"715020e62fed77e6ef988f3015b0a2bb77d9b8c9","modified":1610357066000},{"_id":"source/_posts/前端——节流与防抖.md","hash":"c54057d3a2958c6d7006f0ba73cf73e69dbd9e51","modified":1647672312000},{"_id":"source/_posts/单调栈的应用.md","hash":"8e0bb17a12607e46a0de9e95e36d177a11784d76","modified":1648792740000},{"_id":"source/_posts/数位DP解题思路.md","hash":"479f2887bec59c6fa6a24e4186d1bac6a50220d5","modified":1705828379000},{"_id":"source/_posts/归海记忆的生日策划案.md","hash":"e0f283e432c18fa5ddb2fbe1330d2dd2486d0fb6","modified":1761875320791},{"_id":"source/_posts/数据结构论文.md","hash":"a709b36680abd38bb279c87f8661fb143009f3bc","modified":1609944002000},{"_id":"source/_posts/离散数学-复习.md","hash":"55527f28cbbb73c2b9197c3548e2bcbf94e8f7c8","modified":1610355680000},{"_id":"source/_posts/数据结构复习.md","hash":"8d97dc4164218e94bdc8d36269fae27e889baaee","modified":1609836836000},{"_id":"source/_posts/第一篇博客.md","hash":"b48c386cfaea1c670e393382f03d13e35a8f5da9","modified":1609343304000},{"_id":"source/_posts/高等讲堂.md","hash":"33e59c40128be86c34ba68a9764f947180dde838","modified":1705381411000},{"_id":"source/_posts/需要深入理解的一些算法.md","hash":"b5405ca6b38ee4cd5f2749edfa1ff39d5e131678","modified":1705828379000},{"_id":"source/_posts/贪心算法-加油站问题.md","hash":"cb35be01bcab192415126264450e68cd85ab00d2","modified":1727846718000},{"_id":"source/_posts/计算机组成原理实验.md","hash":"4a16712b9cd4068ad16831afe12f4194b00630bd","modified":1609343246000},{"_id":"source/ZONE/test/find.jpg","hash":"b46c4fcdba70c808a916c7952176d318531d8adf","modified":1608727418000},{"_id":"source/ZONE/test/love.jpg","hash":"844a3fd668c1c1e23b7df07f8042a43b356a3862","modified":1608727558000},{"_id":"source/ZONE/os/test.html","hash":"7f6813ad83dd7db5a314112bd640e336e77b4c3e","modified":1614672182000},{"_id":"source/ZONE/test/test.html","hash":"7e386cf68e5e25793c44e7c264d5fd8e86433882","modified":1608790876000},{"_id":"source/_posts/2025/暑期实习-字节面试.md","hash":"6f8d986ec94eb9f571ebd52b86bf1f5500df093f","modified":1761877611491},{"_id":"source/_posts/2025/暑期实习-京东面试.md","hash":"5a9d0c9a2fc937a10fd547f506a5aeea61311dd4","modified":1761875889269},{"_id":"source/ZONE/test/wechat.jpg","hash":"8985aa7d57c212bcd1472c75f08be8294ea7be25","modified":1608788204000},{"_id":"source/_posts/2025/暑期实习-携程面试.md","hash":"a3827e54444b21eb95e32c6d75537abc10351433","modified":1761877109657},{"_id":"source/_posts/2025/暑期实习-淘天面试.md","hash":"4c180055cad20f188ac71fac888a87e0eb3c0480","modified":1761877133237},{"_id":"source/_posts/2025/暑期实习-笔试记录.md","hash":"5dd37802e0fd8a00a773fbb2f91d8f67001d60b2","modified":1761877418413},{"_id":"source/_posts/2025/暑期实习-腾讯面试.md","hash":"feb0cc7ddd6c68d60318c486a4d3e1fd44f9f7a3","modified":1761875553223},{"_id":"source/_posts/2025/暑期实习-美团面试.md","hash":"926ca36888b7b699ccfa4508ef53f61efb05e1e1","modified":1761877095375},{"_id":"source/_posts/2025/暑期实习-蚂蚁面试.md","hash":"edb5624dc05c666d4acb3bec01e96e535d26953e","modified":1761877263850},{"_id":"source/_posts/2025/暑期实习-腾讯音乐面试.md","hash":"e2b606be51d448f427f4817c7509c90d8471da6c","modified":1761876243030},{"_id":"source/_posts/2025/秋招面试-小米.md","hash":"0be0484d3e51b7f303227503468770481ea3f160","modified":1761991415756},{"_id":"source/_posts/2025/秋招面试-虾皮.md","hash":"9a3ad0a36bb96b9e450a5e4a736e713a80e1cacb","modified":1761992071255},{"_id":"source/_posts/2025/面试-知识储备.md","hash":"4daaba31ae70b73954188951e8d01073ca1b8bde","modified":1761990902328},{"_id":"source/_posts/image/React-native开发/1682428818056.png","hash":"a798486e695a17c1e9ae874848c9aa2b43fd7422","modified":1682428818000},{"_id":"source/ZONE/test/bg.jpg","hash":"13e563306df2c9bed893856fb234416dbf5475af","modified":1608726088000},{"_id":"themes/butterfly/.gitignore","hash":"a1373164627c9a3e36c8eec1ad71b4b269800682","modified":1761880500469},{"_id":"themes/butterfly/LICENSE","hash":"c8bc7df08db9dd3b39c2c2259a163a36cf2f6808","modified":1761880500470},{"_id":"themes/butterfly/package.json","hash":"19442f97e7e5ccd6e70af89c14dd3dbf02767302","modified":1761880500488},{"_id":"themes/butterfly/README_CN.md","hash":"5595df16d0b28133a232cb5f45bbcf60798073e9","modified":1761880500470},{"_id":"themes/butterfly/README.md","hash":"d67b31fceac787d415a441f7eafc1832e8be7869","modified":1761880500470},{"_id":"themes/butterfly/_config.yml","hash":"fce270e7375c7d7fdd4a29f332bc4502958afedf","modified":1761880559875},{"_id":"themes/butterfly/.github/FUNDING.yml","hash":"bcc350ceddc464e64439af66d99a1c3bc7676130","modified":1761880500469},{"_id":"themes/butterfly/languages/default.yml","hash":"97e89708bea9740e7e156b53304d7f4697f6332d","modified":1761880500471},{"_id":"themes/butterfly/plugins.yml","hash":"285f5da900103a0289b1e484578df08795a28b94","modified":1761880500488},{"_id":"themes/butterfly/languages/en.yml","hash":"6d2a5795862abc121a164e8519e7587bb57af7c7","modified":1761880500471},{"_id":"themes/butterfly/languages/ja.yml","hash":"d97b97ebb8a1c8754373b450d4e81341b5dcd208","modified":1761880500471},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"25e717994a3eab37ccb9cf3ae5fec5647b525ced","modified":1761880500471},{"_id":"themes/butterfly/languages/ko.yml","hash":"4a959730509b211484b20d9fcabc80a9c7e8cc1f","modified":1761880500471},{"_id":"themes/butterfly/languages/zh-HK.yml","hash":"e2958e5b72fd2cb33b6706bc1588de6b8d9dde8f","modified":1761880500471},{"_id":"themes/butterfly/layout/archive.pug","hash":"bc77220dfc269b8faad0930e1a4142ebf68165e5","modified":1761880500471},{"_id":"themes/butterfly/layout/category.pug","hash":"a7e9805a781e34e38d27462e6ce2a5821c34bb9f","modified":1761880500472},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"af38319aa58cab193f90ef8caecdb9a26cdd165a","modified":1761880500471},{"_id":"themes/butterfly/layout/page.pug","hash":"7ce2a49c6c41847de4ccea377ade116339984434","modified":1761880500487},{"_id":"themes/butterfly/layout/post.pug","hash":"65c4a49c65c3fc4d9dc88b9791a75710c698c3a1","modified":1761880500487},{"_id":"themes/butterfly/.github/workflows/stale.yml","hash":"4040c76547e270aaf184e9b219a44ca41bbb1b9f","modified":1761880500469},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"e320b40c051bae1549156cd5ea4a51383cf78598","modified":1761880500469},{"_id":"themes/butterfly/layout/tag.pug","hash":"ca5333bd262cb58c195c844b593a0eed0c721766","modified":1761880500487},{"_id":"themes/butterfly/layout/index.pug","hash":"a93004cc8ec8050df603d32a6e6e02cd96fd9875","modified":1761880500487},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"10ce05c8dbde09f53bdabe40b5388de9ccc71a31","modified":1761880500469},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"63ad2249ad09fb3fe21bd5ff9adefb304a7ab24a","modified":1761880500469},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"e1611a30df80cbe7ecf60be2e0cdd816ecabdd03","modified":1761880500472},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"6e0f9470b18bd37d4891282ac73d61676b040e8c","modified":1761880500469},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"1d11e334b22dbbedcb0f751f9ee9789d4416605e","modified":1761880500472},{"_id":"themes/butterfly/scripts/common/postDesc.js","hash":"ba98361b9d469076bfb045e5ff42eaf764a38fb1","modified":1761880500488},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"da95d64f44e1e6b516d1f96f57b4b0a537c29c19","modified":1761880500472},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"e5e6c05a621483b3542f2884e8ba45e84b1e973a","modified":1761880500474},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"062137cb4d078b27680da1ae28d524a9c963eebc","modified":1761880500476},{"_id":"themes/butterfly/scripts/events/404.js","hash":"039fc75f363d79669b0b2177d929cdff6f2ef7a4","modified":1761880500488},{"_id":"themes/butterfly/scripts/events/cdn.js","hash":"7864ba45716c51aef8d8b04fd4bc212e0008ce3b","modified":1761880500489},{"_id":"themes/butterfly/scripts/events/init.js","hash":"19d0832078201746afb2508a1f463d7cae26dae0","modified":1761880500489},{"_id":"themes/butterfly/scripts/common/default_config.js","hash":"6ca5a7588e49a96103e206db12683fc3b8f3822b","modified":1761880500488},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"3617840416f26078117f760579fb544dce07e1bc","modified":1761880500476},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"bac639c404588ea62e601ef0bcd368c3bd0119af","modified":1761880500489},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"f59e10305fef59ea3e62a7395106c0927582879d","modified":1761880500489},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"d2878483c160999240e969a34e3ddc51a780821b","modified":1761880500489},{"_id":"themes/butterfly/scripts/helpers/getArchiveLength.js","hash":"bf77635e920eaf52bceebc95f87c7c87a7ca8038","modified":1761880500490},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"00c5742ad1c75b3c5684d02ffc6a1921399e5376","modified":1761880500490},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"25f7a5ce29fdab3b71a78788416e19276b6e2ac7","modified":1761880500490},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"0cdf781a8c14d7b50d309e69f282ec7b178804bb","modified":1761880500490},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"3e65b7bf6bccccbba7e15349f0a44f15c64c5b5e","modified":1761880500477},{"_id":"themes/butterfly/scripts/helpers/series.js","hash":"45367c4ce827329867dbcc750ec125da9ccb2cfd","modified":1761880500490},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"950b7d0966429bf0f9e6c5e1161e50e545e320b4","modified":1761880500490},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"2f44e1b3ccd170b256eae178299d6fa933a8d490","modified":1761880500490},{"_id":"themes/butterfly/scripts/tag/chartjs.js","hash":"195ba802d7e8406c155124a9c939a2318f82938b","modified":1761880500491},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"25eefe10189caf3910a0e5d5b2f2043ae9255531","modified":1761880500491},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"fa3d0a64f7fce4aff7928d4ddd95548978ba001c","modified":1761880500491},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"1ebe936e202c1baee8f6b7862a431e43db807229","modified":1761880500491},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"89c6c78d2db43b190055d5690741a79bab4f3e7e","modified":1761880500491},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"cf0bc17d0180231167cc6aa8a00fc64f198cb9f9","modified":1761880500491},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"50d8d8fac5c5b6e26317028895d7d82a2cf46606","modified":1761880500491},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"e68d8d21f3a86e3646907a3685550ee20e8d4a9f","modified":1761880500491},{"_id":"themes/butterfly/scripts/tag/score.js","hash":"f2f8a789967cda9559778b1936233dfb46a1f3a3","modified":1761880500492},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"176804f07567aa80f1ed95897a968a996b155dec","modified":1761880500492},{"_id":"themes/butterfly/scripts/tag/series.js","hash":"40bc9a065e3a1423e0e66f4911e00713ca9f5e9e","modified":1761880500492},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"3c486b149e28edd1a06843f05a5c355000991b82","modified":1761880500492},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"f96ccb349501dd2a268f1b64861600e3dc15e4e8","modified":1761880500489},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"20a6ebf63439501a4b3fc81e7a2a2ea5d103bace","modified":1761880500489},{"_id":"themes/butterfly/source/js/utils.js","hash":"f32e69a6e624ab224729b446f096da96ec263934","modified":1761880500504},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1761880500500},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"0561cc5c3d252d9b9b0d04a553028e9450965b6b","modified":1761880500503},{"_id":"themes/butterfly/source/js/main.js","hash":"1b6109e354afddbde858a30a6733e898993e9cac","modified":1761880500503},{"_id":"themes/butterfly/source/img/favicon.ico","hash":"455ac256580bf31a45813dbbdb87219bfc8bfb04","modified":1761880500502},{"_id":"themes/butterfly/source/img/error-page.png","hash":"d2519710498a871ca3e913c57e2ba20a805b6430","modified":1761880500502},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1761880500502},{"_id":"themes/butterfly/source/css/index.styl","hash":"b13d96924a5534bff91d75566b196ac87b4fac22","modified":1761880500499},{"_id":"themes/butterfly/layout/includes/loading/fullpage-loading.pug","hash":"d4d266eced4b9167bed86bcc5addc327f78cbdcc","modified":1761880500474},{"_id":"themes/butterfly/layout/includes/loading/index.pug","hash":"d76ce71ba106e350670c021a3dcae57547d01830","modified":1761880500474},{"_id":"themes/butterfly/layout/includes/loading/pace.pug","hash":"9d2d539555bab495959b9df734ed5c43a9f9e5a9","modified":1761880500474},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"ef7afe0df7a3746744ac8185da7163b7406120ca","modified":1761880500475},{"_id":"themes/butterfly/source/css/var.styl","hash":"41e5eb8c62fdf6ba12c98d026d6f26f08a4380e2","modified":1761880500500},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"c2156c77a011b20fafd34f03ca073397c21b099f","modified":1761880500472},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"e93a36d3c29b5a02c7f26a23f96e1f84b063cbe8","modified":1761880500472},{"_id":"themes/butterfly/layout/includes/mixins/indexPostUI.pug","hash":"f3389fa9ae4fa32e3c16573286583bc3023e57ad","modified":1761880500475},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"56a3c32de1a15627ff38c67f1131cdd6ec5ac924","modified":1761880500473},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1761880500473},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"1e1a69aa2cbda2e621c741b3802093244b3cc04e","modified":1761880500473},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"83ed05ef1e39f2ee70c3fba2cf96e488d8ffec66","modified":1761880500473},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"5168caadc4cf541f5d6676a9c5e8ae47a948f9ad","modified":1761880500473},{"_id":"themes/butterfly/layout/includes/head/structured_data.pug","hash":"49db40e9d3edcf6323e6fe7c074ab09e41453c82","modified":1761880500473},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"733184f88e3a586a5fcc9d193ad500556b6c8eed","modified":1761880500473},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"f1d3552f7cebe1e9e89804b0c0fed47d3f6969ca","modified":1761880500472},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"44331c9db74b281b5c5c41439d3407a9076df1a1","modified":1761880500473},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"f478a82ba4c15d4f6a5db38eca5c61f7054fa71d","modified":1761880500474},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"e2d31e0f450ad42c47f7ee96375799342bf2f19b","modified":1761880500474},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"7d799c4694adb6e265e3f4b975d7f7f6a7021a17","modified":1761880500474},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"ed79fef5b5025415ea12eaed970f3fe7f6ef9596","modified":1761880500477},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"43014bfc63583d3ee8808d526dd165848c0ed52f","modified":1761880500480},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"dc2d36c6ccf5ad1b5f115c443772764f58a87fd6","modified":1761880500484},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"88f979a0b1a19eeb0db229247833bf9c6865c3b9","modified":1761880500484},{"_id":"themes/butterfly/layout/includes/third-party/umami_analytics.pug","hash":"c912959307b5e968df9b96fdef560ba8f3da19c5","modified":1761880500485},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"236c3ce26dd76e80b04d457789475c42da5ac0c8","modified":1761880500485},{"_id":"themes/butterfly/layout/includes/post/outdate-notice.pug","hash":"b7ce9484bc5c97ea6154f0b78fb9b8951fafedbd","modified":1761880500476},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"b96c232e5178d927987791d9ae386dd83679535a","modified":1761880500476},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"db92f25ff3fd061882f81bf74ca560ff66983a0c","modified":1761880500476},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1761880500486},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"21e019bdc3b1e796bb00976bb29af2d51f873624","modified":1761880500486},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"73d33b6930e7944187a4b3403daf25d27077a2dd","modified":1761880500486},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"1dba77d250eeebfb6e293d504352c7e9ea31980b","modified":1761880500486},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"1aba8aa7cd767dc96879d13a13b4c8ceb9023233","modified":1761880500486},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"d8753772889b5d0f4d15639ed6af5e91e53b1d03","modified":1761880500486},{"_id":"themes/butterfly/layout/includes/widget/card_post_series.pug","hash":"e0bb72fa0ce15964b11b8fe421cae3432394e35f","modified":1761880500486},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"66e383b4ef374951eb87dd1bf4cdb7a667193fb5","modified":1761880500486},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"1dd19a564320d248dbcee7f118a5b96c6466da65","modified":1761880500487},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"f7e69cb0cb8dfe9445a15854604a6f9189338615","modified":1761880500487},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"bb842d2aa6469d65bf06af1372f0a19a9e4ef44c","modified":1761880500487},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"7b5ae404a1205546b7de4be42291315cf918f2b3","modified":1761880500487},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"fcddd80cdeb6aa81f342cd9f0102302f6ba087a8","modified":1761880500487},{"_id":"themes/butterfly/layout/includes/page/404.pug","hash":"15d32c511e4875066fcbe9cb84c3ada07b5a7c41","modified":1761880500475},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1761880500475},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"45f620cd87b9ef2aa9d1e024e697ed6b4eecff34","modified":1761880500487},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"efb40388e37cca0b5e7c3c66e811a42f8d32c910","modified":1761880500475},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"6b0fa5f048aca8e9cbe56978301af918cf7ac34a","modified":1761880500475},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"79ad31eb72a9e14007770b18a426406a25315b38","modified":1761880500476},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"9a7d1427cdf2f9fb7031eafcc651f63ac3eac7b0","modified":1761880500492},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"9426ab6c6fe84a76582dcb4e7762385c7c0a47f4","modified":1761880500493},{"_id":"themes/butterfly/layout/includes/page/shuoshuo.pug","hash":"2461305d85c329dc2d77b126dfd5c66853925697","modified":1761880500476},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"67062d597408068e4a59e95851e98fed34b745da","modified":1761880500493},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"a51edfd3e499e7d38c32241c40e8e4d371efca73","modified":1761880500494},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"4cc02bcbaa4a1933a82a9ea57a603fe2d059fc77","modified":1761880500494},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"fbfce4d67cacd1df22fb73d89d008693f59d9d91","modified":1761880500494},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"13f37791badfb942f639cc25092ee32d43de31bf","modified":1761880500503},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"5692bcf8929f7ef12b10d860da6cb90ca55752c0","modified":1761880500495},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"4adfe4087d8350a1188135a32a3bf76c6b305787","modified":1761880500503},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"f0b01bbf321c2c24fdccaee367dd9fd448031a72","modified":1761880500495},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"7d7554573c005399bc8c2264a85896d2d51be1e1","modified":1761880500495},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"543eaf9c7df7e0db841e5946ee5f9082c3c46290","modified":1761880500495},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"ef8e8549fe7ad4b99793844a93b4a89f77f417d5","modified":1761880500495},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"d4e8a938ef2a1f4bf895d187e4fa529c7476e238","modified":1761880500495},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"dcf24780ec6f1a3bf4a277d79d6287b9e65dbbe4","modified":1761880500495},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"e22bc88ab369c362905b29514d585b1d6bbfc5f3","modified":1761880500496},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"0af7c8754f04bdd9a02a14d880774753bd2e35ee","modified":1761880500496},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"d33d4af89231f4b0f1300bf2e9725344b4fab969","modified":1761880500498},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"1cb1c5fcdefc55aab674d7d84d057151f8f76577","modified":1761880500494},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"5abe5480d83ff8b452a780a484d50a44091475bf","modified":1761880500496},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"7536c44e78115559a996d0384adec38b78d8dc25","modified":1761880500495},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"205ccc7d0ec6ce1193b46bc0c9ce0385594581fb","modified":1761880500496},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"f6d0cfb510a0e351ec20b043d3d3784d0f6c96a4","modified":1761880500497},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"c4cda7b0c99015df29ce00fdfddd2f7679653754","modified":1761880500496},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"1a1766f8ea6a6576ec6129887e55221f540b9358","modified":1761880500497},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"1f8d715faf3b91b53426e38195c0920afb3bfa1c","modified":1761880500497},{"_id":"themes/butterfly/source/css/_page/shuoshuo.styl","hash":"a764c44ce1f17f966b2f439762f038570af00b1b","modified":1761880500497},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"4681a9d93a20b8de9f58cdbc794702f76f35192b","modified":1761880500497},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"5a8a181324a2f6b7d8240ea871971444403fa554","modified":1761880500497},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"f3fd3c43f16606a7b956fcb94b0d975b2d705fff","modified":1761880500498},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"fc26e980fedde31644ebf878967f66ef9ba32be2","modified":1761880500497},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"77cdcf374761800e638d7d39205a0becb1052011","modified":1761880500498},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"985b183db7b7bfd8f9bdb60494549fb7f850348b","modified":1761880500498},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"3be8d0a75e7cc96548667cae0cb6a474279bd0b5","modified":1761880500499},{"_id":"themes/butterfly/source/css/_tags/series.styl","hash":"0657169849bc4bf4d93b5492ade040c8f58c1901","modified":1761880500499},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"e84f1de06b818557cc4c45f9958121952ae268b8","modified":1761880500499},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"db2e94a2dd24a2777c9a74b35f98c11d71488003","modified":1761880500499},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"3a88eedcb694da79e92581ce50cb1a430b1fb615","modified":1761880500499},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"e846ddaef494d46cdfa2379deacfe74fa1cc5264","modified":1761880500499},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"446cb0cebe2e4d0bbf055a57caaed0125f4b78e7","modified":1761880500496},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"30d1f809efd252ed0233d96d4374efd2b01d2292","modified":1761880500498},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"8549829fb7d3c21cd9e119884962e8c463a4a267","modified":1761880500499},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"ad66212554468b7067590308ed4cf40524fea662","modified":1761880500496},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"7df4d27cf9e576c6b9c1e4f76a100a41749ca8bb","modified":1761880500477},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/index.pug","hash":"f0a90d8e39915a74b16ef22e851f179415cd7eaa","modified":1761880500477},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d6fff5a7f84c8b09f282f9ddc0020a68a8aac9ea","modified":1761880500477},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"b03ee8625149191f9d5d057bbc9824b68d8dd0c4","modified":1761880500477},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"846cabae287ae31b3bbfac3da022475713dd5ecc","modified":1761880500478},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"cbfbcf34a24d21ba2b21cf9eedb76f4c3c563c5a","modified":1761880500478},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"716dc463fe4ef5112e7018ed60804125fdfa5cad","modified":1761880500478},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"be45b522286bbc64724341f23a5056ad24d3f796","modified":1761880500478},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"7884883ec15792f7e54daacb3c62b851dde2b66a","modified":1761880500478},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"fd2320ee25507bb8ef49f932c2d170586b44ea4d","modified":1761880500478},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"5b29badecbbe828112c001156023fc0566045cf6","modified":1761880500478},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"24d094fd917947c0ca7492fa094328b1a183b873","modified":1761880500478},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"62466b251052cae609b6369d4cb4b6a85320757d","modified":1761880500479},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"f2ea5249b3e6670f6c8c77868f4f42c502e43830","modified":1761880500479},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"e8438941085def0591a72fc9b0d705dbf107f54f","modified":1761880500479},{"_id":"themes/butterfly/layout/includes/third-party/comments/artalk.pug","hash":"89c63a5f0c0ab6314de7158fbc8fcbc84997fc55","modified":1761880500479},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"c81fa7d8a5cb96d1ae07bfa8c46b84a58161add1","modified":1761880500479},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"8af585e6d6f73ee57114eefad574dc6e8ea9f570","modified":1761880500479},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"58914c58a190e3bc0aa37cb581e77e442b563501","modified":1761880500479},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"592b2251db6c1abeb8b0eebe3b2e6d9aa0dec445","modified":1761880500479},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"332b532bafbaf369fde840883b77e5a23d050a39","modified":1761880500479},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"3abbaaa4ea575c45b3cebffd40bad1acc6ffce84","modified":1761880500480},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"9d84a681289175dec75a85f301d2fc9ce1b2bb7a","modified":1761880500480},{"_id":"themes/butterfly/layout/includes/third-party/comments/remark42.pug","hash":"ea9766439b6b1936306916a8b08d2681afbc8ea9","modified":1761880500480},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"30a7d157890de69deab28baa47fb7bb28b040efd","modified":1761880500480},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"24f18b0c67803210d53abbf9c1d454c000b06eee","modified":1761880500480},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"53d99831f29aeb2e336ed1407d79590041f77002","modified":1761880500480},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"e2bf15357485cd502414b3b20f5b1f762a2fd014","modified":1761880500480},{"_id":"themes/butterfly/layout/includes/third-party/math/chartjs.pug","hash":"732eb1118ea1a73aa5c164d639097c614f8e9953","modified":1761880500481},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"af66d13204030d47537b9e31a6173e63589ce7ff","modified":1761880500481},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"b83db9fa64d42a0bfd97efb660e09be3f166a144","modified":1761880500481},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"cb5c8b0f2ac19a732ab78e26020dd5c8c70c0642","modified":1761880500483},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"ca2fc5928ca292f29fd8333c73733344994096fb","modified":1761880500483},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"187302dbc916852ff2fdf47061e272c061611dda","modified":1761880500483},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/common.pug","hash":"27fa75affebc6e84a487c62bceff783bde595256","modified":1761880500483},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"a7c07dbc1e970a5b247091458e1ee9b144a3366d","modified":1761880500483},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"72e2970b23570e308f8af5d8ba8e5e3321d01bbf","modified":1761880500483},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"fa4b4194749d05f7249f365f2b89c0281057ce54","modified":1761880500483},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"34edfebf0cace0852806be774910ccb0e0914650","modified":1761880500484},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"d2e12a9fc302a4efe52c90d44896fbd73e193a1f","modified":1761880500484},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"d376ec17fb19fcdcf0d2ad71330190146d3af879","modified":1761880500484},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"ec6c685080634ac46ffbea1b8f10313388888f43","modified":1761880500484},{"_id":"themes/butterfly/layout/includes/third-party/search/docsearch.pug","hash":"013756ff3363344987cc00fc9bd833baf193c341","modified":1761880500484},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"70364f4a9d9f13d713533a0fe0a9798707f1c1b3","modified":1761880500485},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"f8557548d2ad8dd149c562193991c6c6cda02415","modified":1761880500485},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"f5ee1c9c8ffa4bca972d30f4de69268b8d47f052","modified":1761880500485},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"e51e896ccb13900de38dc81cf44dc789e2418a12","modified":1761880500485},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"efef352c1d122409575386bf3894dce8e87032e2","modified":1761880500485},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"ef52ebf1e8e751a412f9456fdaeee7d88afd9a72","modified":1761880500493},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"9f02598b5e4296aec6470639d4bac4c9ac46392e","modified":1761880500493},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"1883c91d43bff10aae55122a21e0b064b6f5c9dd","modified":1761880500494},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"de4bb5fc2dfca368b35e4c1109c92f7abc9e2245","modified":1761880500494},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"c34c1b19b3cfe24ca11c5edfb34613507a9a00c7","modified":1761880500484},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"077ec530831be1d80e93da380406b9f5abd0918a","modified":1761880500493},{"_id":"source/_posts/2025/场景题.pdf","hash":"46d450325fae216cb127d54f70aa77b2e55824c3","modified":1761878493279},{"_id":"themes/butterfly/source/img/butterfly-icon.png","hash":"f5dd732fed5c3bcd4aa76bac3441bac8485fb432","modified":1761880500501},{"_id":"public/2020/12/29/第一篇博客/index.html","hash":"77f702163a22f189d673aab1a16a40d1c056bb42","modified":1761992337326},{"_id":"public/2020/12/30/计算机组成原理实验/index.html","hash":"37a14e586446a4589f010f6cfe2196217205c542","modified":1761992337326},{"_id":"public/2020/12/31/2020年/index.html","hash":"97b473b71e29165296e46dd31c619ec39f76d4da","modified":1761992337326},{"_id":"public/2021/01/11/五子棋联机游戏介绍/index.html","hash":"b404c5fecba861b2d8797e84a4eebd3714045e8b","modified":1761992337326},{"_id":"public/2021/01/06/数据结构论文/index.html","hash":"9a456c97576a3dbc7de4b90eaee457b56948393a","modified":1761992337326},{"_id":"public/2021/01/05/数据结构复习/index.html","hash":"7a54a47cdce71ad43b13aed46df4557ced2dba0d","modified":1761992337326},{"_id":"public/2021/01/11/离散数学-复习/index.html","hash":"cd250a9430e66d817b89ab2816f0861d14a6599b","modified":1761992337326},{"_id":"public/2021/01/26/leetcode刷题/index.html","hash":"8bf48978222c63e2a68fb866973e33880be2bfd5","modified":1761992337326},{"_id":"public/2022/03/19/前端——节流与防抖/index.html","hash":"328b58b6e1cdfd23a102a37b10d85ce5c8aca2dd","modified":1761992337326},{"_id":"public/2022/03/29/git基本操作整理/index.html","hash":"6835e23fdb7aca6143b535ff312f99228d9cc89e","modified":1761992337326},{"_id":"public/2022/03/31/单调栈的应用/index.html","hash":"e84dd5458b91deda3e53020e1504fe6f1ddddce3","modified":1761992337326},{"_id":"public/2022/04/03/JS-原型链/index.html","hash":"00974d7603861800906a4b33dee427a3bd4ab9b2","modified":1761992337326},{"_id":"public/2023/04/24/Ubuntu系统中的常用操作/index.html","hash":"ce0bc17cf4a35d835f5e428663ffc9cb4dd8faed","modified":1761992337326},{"_id":"public/2023/04/25/ElementUI2-开发/index.html","hash":"3aad037ab3ffe810f075056588dedf2ca9491cd4","modified":1761992337326},{"_id":"public/2023/04/25/React-native开发/index.html","hash":"55f7de8a0adcbab8cd7d86af6f6a48ba368e9891","modified":1761992337326},{"_id":"public/2023/04/25/Mac的常用操作/index.html","hash":"029a0594e073290ed14a1299d0d0664d298f41e3","modified":1761992337326},{"_id":"public/2023/12/29/高等讲堂/index.html","hash":"107463a568bc4e9125efe49cd692f21ef982c472","modified":1761992337326},{"_id":"public/2024/01/16/数位DP解题思路/index.html","hash":"c725395eaf8f664e53d5ad262a02a258904e4b70","modified":1761992337326},{"_id":"public/2024/01/20/需要深入理解的一些算法/index.html","hash":"f357fd90564b89d4edbb7cb17cd8390906c05239","modified":1761992337326},{"_id":"public/2024/07/05/parse-from-mail-attachment/index.html","hash":"7d3bb6d9dd563d30eab5fb4ea65ca00e4ac08695","modified":1761992337326},{"_id":"public/2024/09/08/贪心算法-加油站问题/index.html","hash":"a6ff3872f516b59795ae2a666cc53d553dfdeef3","modified":1761992337326},{"_id":"public/2024/10/02/二分查找/index.html","hash":"0942d5440f93004ac58f4b055ebf2ddb6e270cbd","modified":1761992337326},{"_id":"public/2025/10/23/归海记忆的生日策划案/index.html","hash":"8510db3c18c3db0f888b2c247a2805a3839e1847","modified":1761992337326},{"_id":"public/2025/10/31/2025/暑期实习-腾讯面试/index.html","hash":"9ef7d43f44591535aa438de71c06da2e1c070742","modified":1761992337326},{"_id":"public/2025/10/31/2025/暑期实习-淘天面试/index.html","hash":"468452a4c4c479816905da28d870c334fa48f95f","modified":1761992337326},{"_id":"public/2025/10/31/2025/暑期实习-京东面试/index.html","hash":"4e3f80fec0b38ebc2d2914bdef1019a4b073b6e7","modified":1761992337326},{"_id":"public/2025/10/31/2025/暑期实习-腾讯音乐面试/index.html","hash":"35a0c0652064a89417bf8604c51dd65aefcdb213","modified":1761992337326},{"_id":"public/2025/10/31/2025/暑期实习-携程面试/index.html","hash":"3796b1b8aa749f0734f486ed81752d719d928670","modified":1761992337326},{"_id":"public/2025/10/31/2025/暑期实习-蚂蚁面试/index.html","hash":"63f529fedc13f9ab356eca5c8269389551dabade","modified":1761992337326},{"_id":"public/2025/10/31/2025/暑期实习-美团面试/index.html","hash":"58cfa8356dffac6e0b3445594276ac2653aeea8f","modified":1761992337326},{"_id":"public/2025/10/31/2025/暑期实习-笔试记录/index.html","hash":"fa2968cc92bf205df3bcf5aa4a82784f4449277c","modified":1761992337326},{"_id":"public/2025/10/31/2025/暑期实习-字节面试/index.html","hash":"adbc93896bcbb3c3f51e7806da9ef8fe488f79c8","modified":1761992337326},{"_id":"public/2025/10/31/2025/面试-知识储备/index.html","hash":"dddf65a638588fb6390c10e59067867f6c42e7d2","modified":1761992337326},{"_id":"public/2025/11/01/2025/秋招面试-虾皮/index.html","hash":"b20e0d3a9e147a9c4d742d9590b8e6b22df36d7c","modified":1761992337326},{"_id":"public/2025/11/01/2025/秋招面试-小米/index.html","hash":"8b8dfef4854f174e6da6c655be2c5fbc02ab4fad","modified":1761992337326},{"_id":"public/archives/index.html","hash":"2f9338398e6dc46e72728068f614d2c5b04bbbce","modified":1761992337326},{"_id":"public/archives/page/2/index.html","hash":"d444faeccabd71c18afafa0e2a44ab035cabe44e","modified":1761992337326},{"_id":"public/archives/page/3/index.html","hash":"34a658542ddc01cac87326ce3a23d23901954572","modified":1761992337326},{"_id":"public/archives/page/4/index.html","hash":"f1ad1a1efc6be244b81cd8567547ba5663c58ca0","modified":1761992337326},{"_id":"public/archives/2020/index.html","hash":"2047d059c737d25d2fb6febfe2dcd250cab3c376","modified":1761992337326},{"_id":"public/archives/2020/12/index.html","hash":"edbc0a455dd64853d5cd35b180d2eda8807bb4a0","modified":1761992337326},{"_id":"public/archives/2021/index.html","hash":"7f62d653efd21208930f9cf20806fbd7d7c39dfc","modified":1761992337326},{"_id":"public/archives/2021/01/index.html","hash":"8c3e300fc0bfadef459bc16e73362fbdcf99cabf","modified":1761992337326},{"_id":"public/archives/2022/index.html","hash":"b24a86e0a89b13b8fbe13710829f41b51934fb64","modified":1761992337326},{"_id":"public/archives/2022/03/index.html","hash":"a4fafc2188f0af047e93e3c3a8b84fe4608d74c3","modified":1761992337326},{"_id":"public/archives/2022/04/index.html","hash":"654d99a73ace47916133c1689f4f6637f3565f0e","modified":1761992337326},{"_id":"public/archives/2023/index.html","hash":"752e5cfd2890b79232c42ba69f8694676088d5d7","modified":1761992337326},{"_id":"public/archives/2023/04/index.html","hash":"1435829a661f4b6c2613fbeb72f2dbca02d74b69","modified":1761992337326},{"_id":"public/archives/2023/12/index.html","hash":"c61d63e5cd5eb75009a1cdfa3b704f2efb0658ac","modified":1761992337326},{"_id":"public/archives/2024/index.html","hash":"7f5de15d829b8f07f5a236053c16526af07b45bb","modified":1761992337326},{"_id":"public/archives/2024/01/index.html","hash":"d558cb5ad1e0f0b21fb53bf1facf957026989f91","modified":1761992337326},{"_id":"public/archives/2024/07/index.html","hash":"3c6babd33b76be9170615de87c48c49f8b80ec6d","modified":1761992337326},{"_id":"public/archives/2024/09/index.html","hash":"cf27af47dc41afce0601710fa84791f428586561","modified":1761992337326},{"_id":"public/archives/2024/10/index.html","hash":"bc415931b76aac337e9e2906d88e7b260c763865","modified":1761992337326},{"_id":"public/archives/2025/index.html","hash":"d615625799e13bf886ec63a3a38e42ca174c4e24","modified":1761992337326},{"_id":"public/archives/2025/page/2/index.html","hash":"fd7aa7964ed77e2ca39d37192d43ba4ff1ad9bcf","modified":1761992337326},{"_id":"public/archives/2025/10/index.html","hash":"e74c9ba870b35bbe8492b3e8904e42650a633e84","modified":1761992337326},{"_id":"public/archives/2025/10/page/2/index.html","hash":"3f8264caeb0cb78711d718810f6cb3eeecade641","modified":1761992337326},{"_id":"public/archives/2025/11/index.html","hash":"05010a345bc89b73d8a35f783700d38ac11de1fc","modified":1761992337326},{"_id":"public/index.html","hash":"b1fda7072723bb946541d5f36d3787929e47835e","modified":1761992337326},{"_id":"public/page/2/index.html","hash":"86be363dc38ac2431ef5736d1312994d8befbab9","modified":1761992337326},{"_id":"public/page/3/index.html","hash":"3060e458df15e5b5c64fe4bab68453e5ed03a7b9","modified":1761992337326},{"_id":"public/page/4/index.html","hash":"61603cb3080c7617c7faad52d38dd72144685091","modified":1761992337326},{"_id":"public/tags/技术/index.html","hash":"44e574e71c3ff2d61b2bb471fe0009fbd5e5c817","modified":1761992337326},{"_id":"public/tags/算法/index.html","hash":"aee99702ed2a79bf0b54ae26f17e57085b34fbe6","modified":1761992337326},{"_id":"public/tags/生日/index.html","hash":"8ad28ffeda488b70090c3af6c49771c800f25931","modified":1761992337326},{"_id":"public/tags/暑期实习/index.html","hash":"5c79cf1b5459ca716384a8db24028627d54099d0","modified":1761992337326},{"_id":"public/tags/秋招/index.html","hash":"394401f2c4817a4ce407a0a7f0c45afc9df57190","modified":1761992337326},{"_id":"public/CNAME","hash":"89b86650a749b0a37945be60cf90d84df927c124","modified":1761992337326},{"_id":"public/ZONE/os/test.html","hash":"7f6813ad83dd7db5a314112bd640e336e77b4c3e","modified":1761992337326},{"_id":"public/ZONE/test/find.jpg","hash":"b46c4fcdba70c808a916c7952176d318531d8adf","modified":1761992337326},{"_id":"public/ZONE/test/love.jpg","hash":"844a3fd668c1c1e23b7df07f8042a43b356a3862","modified":1761992337326},{"_id":"public/ZONE/test/test.html","hash":"7e386cf68e5e25793c44e7c264d5fd8e86433882","modified":1761992337326},{"_id":"public/ZONE/test/wechat.jpg","hash":"8985aa7d57c212bcd1472c75f08be8294ea7be25","modified":1761992337326},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1761992337326},{"_id":"public/img/error-page.png","hash":"d2519710498a871ca3e913c57e2ba20a805b6430","modified":1761992337326},{"_id":"public/img/favicon.ico","hash":"455ac256580bf31a45813dbbdb87219bfc8bfb04","modified":1761992337326},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1761992337326},{"_id":"public/js/utils.js","hash":"e3b4a5e1ef72c3ebab85542da11d9addfbfce42a","modified":1761992337326},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1761992337326},{"_id":"public/css/index.css","hash":"2164dca38fddcdda179197b1b45357825871079f","modified":1761992337326},{"_id":"public/ZONE/test/bg.jpg","hash":"13e563306df2c9bed893856fb234416dbf5475af","modified":1761992337326},{"_id":"public/js/main.js","hash":"d46f5e46e6e78ee08ce791059a788b0d7ba1d70c","modified":1761992337326},{"_id":"public/js/tw_cn.js","hash":"337c417a6e37dfabc920463fa13f65cc3d02f164","modified":1761992337326},{"_id":"public/js/search/algolia.js","hash":"02491d2798f07f820962cafaceb07a2f8c97bc41","modified":1761992337326},{"_id":"public/js/search/local-search.js","hash":"50ab53c2b11c7c4cc1d9240b749af124ad38bfdc","modified":1761992337326},{"_id":"public/img/butterfly-icon.png","hash":"f5dd732fed5c3bcd4aa76bac3441bac8485fb432","modified":1761992337326}],"Category":[],"Data":[{"_id":"link","data":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}],"Page":[],"Post":[{"title":"2020年结束了啦~","date":"2020-12-30T16:00:00.000Z","description":"2020年年度总结","cover":"https://s3.ax1x.com/2020/12/31/rvEA3T.jpg","_content":"\n> 2020年结束的好快，感觉这一年还没反应过来就已经要一晃而过了。\n>\n> 现在是2020年12月31日，在数据科学这堂课上，写下了这篇博客，就当做是对这一年的一个回顾。\n>\n> \n\n2020年开始于大一上学期的考试周，前一天是在图书馆复习着即将到来的大物考试\n\n[![rvAkOH.jpg](https://s3.ax1x.com/2020/12/31/rvAkOH.jpg)](https://imgchr.com/i/rvAkOH)\n\n在2020年开始的时候，发生了让自己心态发生了一些变化的事情。不过幸好，自己还是做到了每天去图书馆，复习着那几门科目。\n\n大物、线代、高程……一门一门的考试，每一门考前都是从焦虑到放松，以及考完后的解放。\n\n最后一门考的是线代，那天中午去北苑吃了叉烧饭（自己当时没有想到也是大一最后一顿叉烧饭\n\n[![rvAG0s.jpg](https://s3.ax1x.com/2020/12/31/rvAG0s.jpg)](https://imgchr.com/i/rvAG0s)\n\n在线代考完后，自己便立马带着手拉箱奔向高铁站，准备去坐即将发车的高铁了。\n\n1月9号便迎来了我的寒假的开始。寒假一开始我还试着好好学习Stl，但是学着学着感觉没意思就放弃了。感觉我可能还是需要做一些有意思的项目才能够坚持下去吧，求大佬带我做点有意思的东西QAQ\n\n同时，寒假里也迎来了认真复习的好结果，自己好多课都拿到了理想的成绩了啦~\n\n[![rvEpHs.jpg](https://s3.ax1x.com/2020/12/31/rvEpHs.jpg)](https://imgchr.com/i/rvEpHs)\n\n疫情到来之前，放寒假每天就很无聊，就是想着吃啥、玩啥，然后发一些乱七八糟的动态：\n\n> 以前走楼梯最喜欢数台阶数 \n>\n> 所以每次走的时候都害怕会多出来或者少掉一个台阶 \n>\n> 如果走完数量正确就算成功逃生\n\n很快，疫情来了。刚开始那段时间真的还是蛮焦虑的，特别担心这种“未知的病毒”到自己的身边。然后响应国家政策不出门，在家里就玩游戏：QQ飞车、植物大战僵尸、逆转裁判什么的。\n\n> 在原本的世界线里 \n>\n> 我于六小时前到达同济大学 \n>\n> 并将在明天开始电路理论课程 而现在的现实却是要放暑假了\n\n很快也迎来了延迟开学的消息，在推迟了一周开学后，便迎来了印象深刻的网课时期。\n\n网课时期每天干的事情就是好好上课，然后晚上会玩会儿游戏，点名表扬qjy同学。\n\n这个学期也玩到了两个我特别喜欢的游戏：\n\n一个是奇异人生（Life Is Strange）：\n\n[![rvEA3T.jpg](https://s3.ax1x.com/2020/12/31/rvEA3T.jpg)](https://imgchr.com/i/rvEA3T)\n\n还有一个则是消逝的光芒（Dying Light），画面相对比较血腥这里就不放图了。\n\n然后就迎来了软件工程的大项目——元气骑士（Vigor Knight），和另外三个小伙伴一起做了个实际上非常垃圾的游戏（我自己反正是玩不下去），也认识了wly,mjy和ljj\n\n[![rvENbd.md.jpg](https://s3.ax1x.com/2020/12/31/rvENbd.md.jpg)](https://imgchr.com/i/rvENbd)\n\n同时，网课这学期也发生了件比较让我高兴的事情。\n\n我和lyf（春雨支教社团老大姐）强行凑成了数学建模小组，报名参加了学校的建模校赛，并且在比赛前三个人都没有看过任何建模相关的知识。就是五一建模强行冲，最后一天熬夜到了凌晨四点，最后迎来了一个让我们大家都不敢相信的事情，收到了答辩邮件。大家都不敢相信我们能拿奖，毕竟所有人最开始的目标是成功参赛奖。贼兴奋\n\n[![rvEYKe.md.jpg](https://s3.ax1x.com/2020/12/31/rvEYKe.md.jpg)](https://imgchr.com/i/rvEYKe)\n[![rvEGvD.md.jpg](https://s3.ax1x.com/2020/12/31/rvEGvD.md.jpg)](https://imgchr.com/i/rvEGvD)\n[![rvE8gO.md.jpg](https://s3.ax1x.com/2020/12/31/rvE8gO.md.jpg)](https://imgchr.com/i/rvE8gO)\n[![rvEtDH.md.jpg](https://s3.ax1x.com/2020/12/31/rvEtDH.md.jpg)](https://imgchr.com/i/rvEtDH)\n\n然后这学期还和wly合作做了数据库的大作业，因为我和他害怕经管的同学会卷，所以我们就越做越复杂。结果最后发现：\n\n**内卷人竟是我自己**\n\n不过这个项目做的过程中真的效率超高，垃圾代码产出量也非常多，还是真的有挺多收获的。\n\n[![rvE6Kg.png](https://s3.ax1x.com/2020/12/31/rvE6Kg.png)](https://imgchr.com/i/rvE6Kg)\n\n最后再次分享大一下学期，这个非常可惜通过网课度过的一个学期，所做的事情：\n\n> 1.建模写了好看论文，并且结果不错 \n>\n> 2.做了精美扫雷游戏，玩起来不会崩\n>\n>  3.设计了厉害的数据库，得到了孙丽君的认可\n>\n>  4.做了比较菜的元气骑士，勉强能跑了 \n>\n> 5.网课都基本认真听了，没怎么划水 \n>\n> 6.期末认真复习了，四场考试都用一半时间就做完了 \n>\n> 7.学会了C#新语言，可以开搞unity了\n>\n> 8.认识了牛逼的新同学 \n>\n> 9.没和老同学失去联系 \n>\n> 10.飞车上荣耀钻石啦 \n>\n> 11.跑步坚持一个月了 \n>\n> 12.c++会用stl啦 \n>\n> 13.坚持上完了机器学习，期中没退课！ \n>\n> 14.电路理论做了精美笔记！可以卖钱了！ \n>\n> 15.还没忘记你们长啥样 \n>\n> 16.被软件开发基础老师夸了 \n>\n> 17.终于会用github了... \n>\n> 18.考试周坚持了一个半月没玩游戏 \n>\n> 19.芒果tv充了年费会员 \n>\n> 20.积极帮别人解决问题了\n\n是主要搞学习的一个学期，赞！\n\n然后就放暑假了，暑假里让我印象深刻的主要就三件事情：\n\n1.lyh（真·大一就认识的hxd）来金寨了，一起去天堂寨玩了，然后我发誓再也不要去天堂寨\n\n2.开始学车，每天顶着大太阳去科目二的地方练车，等一两个小时练一把车\n\n3.和wly打QQ飞车\n\n再然后就开学了，开学就是先军训。不过因为我暑假面试过了政治部，所以避免了太阳：\n\n[![rvEWan.jpg](https://s3.ax1x.com/2020/12/31/rvEWan.jpg)](https://imgchr.com/i/rvEWan)但是说实话，政治部那七天的生活绝对不轻松。甚至可以说，我的绝大多数宣传能力都是在期间学习到的\n\n我和其他宣传组的小伙伴共同每天艰难的生活着（下图拍于12月份）\n\n[![rvEHr4.jpg](https://s3.ax1x.com/2020/12/31/rvEHr4.jpg)](https://imgchr.com/i/rvEHr4)\n\n那段时间，说实话，我个人过得挺自闭的。\n\n因为感觉有非常多的事情没有做完（剪可视化、外拍、推送等），还感觉自己的成绩可能不是很理想。中间甚至一度想要退课明年再选军训，总而言之：很庆幸熬了过去。\n\n下图是在其他组还没起来，卑微宣传人已经开始工作的一天\n\n[![rvEzRK.jpg](https://s3.ax1x.com/2020/12/31/rvEzRK.jpg)](https://imgchr.com/i/rvEzRK)\n\n军训之后，这一学期就正式开始了。\n\n来嘉定的第一个学期，体验一般。\n\n每天的生活就是去上课，去自习，思考中午吃什么，思考晚上吃什么，睡觉。\n\n比较有意思的事情是评上了果酱和社奖、参加了软院晚会、支书达理活动、玩密室等。\n\n这里就不再总结了，不要问我为什么，因为我打字打累了。这段经历应该在这学期结束的时候还会复习一下吧。\n\n直接进入最终总结环节吧。\n\n\n\n## 2020年收获\n\n> 1.认识了wly、mjy、sbq、ckx、lxy、zlh、lmx、xhz、hzj、syk、dtw、wjh、wmb、znf、lrj、lrz、chs、yxb、zkf、dgg、jch、whz、xmx、hmz、sr等很多同学\n>\n> 2.之前朋友还在\n>\n> 3.会用服务器了，然后懂了一些Linux操作\n>\n> 4.会做简单网页了\n>\n> 5.拥有自己的博客了，也就是这个网站\n>\n> 6.Steam库++\n>\n> 7.真的学会数据结构了\n>\n> 8.拿了一次果酱\n>\n> 9.数学建模拿奖了\n>\n> 10.还是在愿意帮助别人","source":"_posts/2020年.md","raw":"---\ntitle: 2020年结束了啦~\ndate: 2020-12-31 00:00:00\ndescription: 2020年年度总结\ncover: https://s3.ax1x.com/2020/12/31/rvEA3T.jpg\n---\n\n> 2020年结束的好快，感觉这一年还没反应过来就已经要一晃而过了。\n>\n> 现在是2020年12月31日，在数据科学这堂课上，写下了这篇博客，就当做是对这一年的一个回顾。\n>\n> \n\n2020年开始于大一上学期的考试周，前一天是在图书馆复习着即将到来的大物考试\n\n[![rvAkOH.jpg](https://s3.ax1x.com/2020/12/31/rvAkOH.jpg)](https://imgchr.com/i/rvAkOH)\n\n在2020年开始的时候，发生了让自己心态发生了一些变化的事情。不过幸好，自己还是做到了每天去图书馆，复习着那几门科目。\n\n大物、线代、高程……一门一门的考试，每一门考前都是从焦虑到放松，以及考完后的解放。\n\n最后一门考的是线代，那天中午去北苑吃了叉烧饭（自己当时没有想到也是大一最后一顿叉烧饭\n\n[![rvAG0s.jpg](https://s3.ax1x.com/2020/12/31/rvAG0s.jpg)](https://imgchr.com/i/rvAG0s)\n\n在线代考完后，自己便立马带着手拉箱奔向高铁站，准备去坐即将发车的高铁了。\n\n1月9号便迎来了我的寒假的开始。寒假一开始我还试着好好学习Stl，但是学着学着感觉没意思就放弃了。感觉我可能还是需要做一些有意思的项目才能够坚持下去吧，求大佬带我做点有意思的东西QAQ\n\n同时，寒假里也迎来了认真复习的好结果，自己好多课都拿到了理想的成绩了啦~\n\n[![rvEpHs.jpg](https://s3.ax1x.com/2020/12/31/rvEpHs.jpg)](https://imgchr.com/i/rvEpHs)\n\n疫情到来之前，放寒假每天就很无聊，就是想着吃啥、玩啥，然后发一些乱七八糟的动态：\n\n> 以前走楼梯最喜欢数台阶数 \n>\n> 所以每次走的时候都害怕会多出来或者少掉一个台阶 \n>\n> 如果走完数量正确就算成功逃生\n\n很快，疫情来了。刚开始那段时间真的还是蛮焦虑的，特别担心这种“未知的病毒”到自己的身边。然后响应国家政策不出门，在家里就玩游戏：QQ飞车、植物大战僵尸、逆转裁判什么的。\n\n> 在原本的世界线里 \n>\n> 我于六小时前到达同济大学 \n>\n> 并将在明天开始电路理论课程 而现在的现实却是要放暑假了\n\n很快也迎来了延迟开学的消息，在推迟了一周开学后，便迎来了印象深刻的网课时期。\n\n网课时期每天干的事情就是好好上课，然后晚上会玩会儿游戏，点名表扬qjy同学。\n\n这个学期也玩到了两个我特别喜欢的游戏：\n\n一个是奇异人生（Life Is Strange）：\n\n[![rvEA3T.jpg](https://s3.ax1x.com/2020/12/31/rvEA3T.jpg)](https://imgchr.com/i/rvEA3T)\n\n还有一个则是消逝的光芒（Dying Light），画面相对比较血腥这里就不放图了。\n\n然后就迎来了软件工程的大项目——元气骑士（Vigor Knight），和另外三个小伙伴一起做了个实际上非常垃圾的游戏（我自己反正是玩不下去），也认识了wly,mjy和ljj\n\n[![rvENbd.md.jpg](https://s3.ax1x.com/2020/12/31/rvENbd.md.jpg)](https://imgchr.com/i/rvENbd)\n\n同时，网课这学期也发生了件比较让我高兴的事情。\n\n我和lyf（春雨支教社团老大姐）强行凑成了数学建模小组，报名参加了学校的建模校赛，并且在比赛前三个人都没有看过任何建模相关的知识。就是五一建模强行冲，最后一天熬夜到了凌晨四点，最后迎来了一个让我们大家都不敢相信的事情，收到了答辩邮件。大家都不敢相信我们能拿奖，毕竟所有人最开始的目标是成功参赛奖。贼兴奋\n\n[![rvEYKe.md.jpg](https://s3.ax1x.com/2020/12/31/rvEYKe.md.jpg)](https://imgchr.com/i/rvEYKe)\n[![rvEGvD.md.jpg](https://s3.ax1x.com/2020/12/31/rvEGvD.md.jpg)](https://imgchr.com/i/rvEGvD)\n[![rvE8gO.md.jpg](https://s3.ax1x.com/2020/12/31/rvE8gO.md.jpg)](https://imgchr.com/i/rvE8gO)\n[![rvEtDH.md.jpg](https://s3.ax1x.com/2020/12/31/rvEtDH.md.jpg)](https://imgchr.com/i/rvEtDH)\n\n然后这学期还和wly合作做了数据库的大作业，因为我和他害怕经管的同学会卷，所以我们就越做越复杂。结果最后发现：\n\n**内卷人竟是我自己**\n\n不过这个项目做的过程中真的效率超高，垃圾代码产出量也非常多，还是真的有挺多收获的。\n\n[![rvE6Kg.png](https://s3.ax1x.com/2020/12/31/rvE6Kg.png)](https://imgchr.com/i/rvE6Kg)\n\n最后再次分享大一下学期，这个非常可惜通过网课度过的一个学期，所做的事情：\n\n> 1.建模写了好看论文，并且结果不错 \n>\n> 2.做了精美扫雷游戏，玩起来不会崩\n>\n>  3.设计了厉害的数据库，得到了孙丽君的认可\n>\n>  4.做了比较菜的元气骑士，勉强能跑了 \n>\n> 5.网课都基本认真听了，没怎么划水 \n>\n> 6.期末认真复习了，四场考试都用一半时间就做完了 \n>\n> 7.学会了C#新语言，可以开搞unity了\n>\n> 8.认识了牛逼的新同学 \n>\n> 9.没和老同学失去联系 \n>\n> 10.飞车上荣耀钻石啦 \n>\n> 11.跑步坚持一个月了 \n>\n> 12.c++会用stl啦 \n>\n> 13.坚持上完了机器学习，期中没退课！ \n>\n> 14.电路理论做了精美笔记！可以卖钱了！ \n>\n> 15.还没忘记你们长啥样 \n>\n> 16.被软件开发基础老师夸了 \n>\n> 17.终于会用github了... \n>\n> 18.考试周坚持了一个半月没玩游戏 \n>\n> 19.芒果tv充了年费会员 \n>\n> 20.积极帮别人解决问题了\n\n是主要搞学习的一个学期，赞！\n\n然后就放暑假了，暑假里让我印象深刻的主要就三件事情：\n\n1.lyh（真·大一就认识的hxd）来金寨了，一起去天堂寨玩了，然后我发誓再也不要去天堂寨\n\n2.开始学车，每天顶着大太阳去科目二的地方练车，等一两个小时练一把车\n\n3.和wly打QQ飞车\n\n再然后就开学了，开学就是先军训。不过因为我暑假面试过了政治部，所以避免了太阳：\n\n[![rvEWan.jpg](https://s3.ax1x.com/2020/12/31/rvEWan.jpg)](https://imgchr.com/i/rvEWan)但是说实话，政治部那七天的生活绝对不轻松。甚至可以说，我的绝大多数宣传能力都是在期间学习到的\n\n我和其他宣传组的小伙伴共同每天艰难的生活着（下图拍于12月份）\n\n[![rvEHr4.jpg](https://s3.ax1x.com/2020/12/31/rvEHr4.jpg)](https://imgchr.com/i/rvEHr4)\n\n那段时间，说实话，我个人过得挺自闭的。\n\n因为感觉有非常多的事情没有做完（剪可视化、外拍、推送等），还感觉自己的成绩可能不是很理想。中间甚至一度想要退课明年再选军训，总而言之：很庆幸熬了过去。\n\n下图是在其他组还没起来，卑微宣传人已经开始工作的一天\n\n[![rvEzRK.jpg](https://s3.ax1x.com/2020/12/31/rvEzRK.jpg)](https://imgchr.com/i/rvEzRK)\n\n军训之后，这一学期就正式开始了。\n\n来嘉定的第一个学期，体验一般。\n\n每天的生活就是去上课，去自习，思考中午吃什么，思考晚上吃什么，睡觉。\n\n比较有意思的事情是评上了果酱和社奖、参加了软院晚会、支书达理活动、玩密室等。\n\n这里就不再总结了，不要问我为什么，因为我打字打累了。这段经历应该在这学期结束的时候还会复习一下吧。\n\n直接进入最终总结环节吧。\n\n\n\n## 2020年收获\n\n> 1.认识了wly、mjy、sbq、ckx、lxy、zlh、lmx、xhz、hzj、syk、dtw、wjh、wmb、znf、lrj、lrz、chs、yxb、zkf、dgg、jch、whz、xmx、hmz、sr等很多同学\n>\n> 2.之前朋友还在\n>\n> 3.会用服务器了，然后懂了一些Linux操作\n>\n> 4.会做简单网页了\n>\n> 5.拥有自己的博客了，也就是这个网站\n>\n> 6.Steam库++\n>\n> 7.真的学会数据结构了\n>\n> 8.拿了一次果酱\n>\n> 9.数学建模拿奖了\n>\n> 10.还是在愿意帮助别人","slug":"2020年","published":1,"updated":"2020-12-31T11:50:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmhg4qt3n0000f5fag62k2n45","content":"<blockquote>\n<p>2020年结束的好快，感觉这一年还没反应过来就已经要一晃而过了。</p>\n<p>现在是2020年12月31日，在数据科学这堂课上，写下了这篇博客，就当做是对这一年的一个回顾。</p>\n</blockquote>\n<p>2020年开始于大一上学期的考试周，前一天是在图书馆复习着即将到来的大物考试</p>\n<p><a href=\"https://imgchr.com/i/rvAkOH\"><img src=\"https://s3.ax1x.com/2020/12/31/rvAkOH.jpg\" alt=\"rvAkOH.jpg\"></a></p>\n<p>在2020年开始的时候，发生了让自己心态发生了一些变化的事情。不过幸好，自己还是做到了每天去图书馆，复习着那几门科目。</p>\n<p>大物、线代、高程……一门一门的考试，每一门考前都是从焦虑到放松，以及考完后的解放。</p>\n<p>最后一门考的是线代，那天中午去北苑吃了叉烧饭（自己当时没有想到也是大一最后一顿叉烧饭</p>\n<p><a href=\"https://imgchr.com/i/rvAG0s\"><img src=\"https://s3.ax1x.com/2020/12/31/rvAG0s.jpg\" alt=\"rvAG0s.jpg\"></a></p>\n<p>在线代考完后，自己便立马带着手拉箱奔向高铁站，准备去坐即将发车的高铁了。</p>\n<p>1月9号便迎来了我的寒假的开始。寒假一开始我还试着好好学习Stl，但是学着学着感觉没意思就放弃了。感觉我可能还是需要做一些有意思的项目才能够坚持下去吧，求大佬带我做点有意思的东西QAQ</p>\n<p>同时，寒假里也迎来了认真复习的好结果，自己好多课都拿到了理想的成绩了啦~</p>\n<p><a href=\"https://imgchr.com/i/rvEpHs\"><img src=\"https://s3.ax1x.com/2020/12/31/rvEpHs.jpg\" alt=\"rvEpHs.jpg\"></a></p>\n<p>疫情到来之前，放寒假每天就很无聊，就是想着吃啥、玩啥，然后发一些乱七八糟的动态：</p>\n<blockquote>\n<p>以前走楼梯最喜欢数台阶数 </p>\n<p>所以每次走的时候都害怕会多出来或者少掉一个台阶 </p>\n<p>如果走完数量正确就算成功逃生</p>\n</blockquote>\n<p>很快，疫情来了。刚开始那段时间真的还是蛮焦虑的，特别担心这种“未知的病毒”到自己的身边。然后响应国家政策不出门，在家里就玩游戏：QQ飞车、植物大战僵尸、逆转裁判什么的。</p>\n<blockquote>\n<p>在原本的世界线里 </p>\n<p>我于六小时前到达同济大学 </p>\n<p>并将在明天开始电路理论课程 而现在的现实却是要放暑假了</p>\n</blockquote>\n<p>很快也迎来了延迟开学的消息，在推迟了一周开学后，便迎来了印象深刻的网课时期。</p>\n<p>网课时期每天干的事情就是好好上课，然后晚上会玩会儿游戏，点名表扬qjy同学。</p>\n<p>这个学期也玩到了两个我特别喜欢的游戏：</p>\n<p>一个是奇异人生（Life Is Strange）：</p>\n<p><a href=\"https://imgchr.com/i/rvEA3T\"><img src=\"https://s3.ax1x.com/2020/12/31/rvEA3T.jpg\" alt=\"rvEA3T.jpg\"></a></p>\n<p>还有一个则是消逝的光芒（Dying Light），画面相对比较血腥这里就不放图了。</p>\n<p>然后就迎来了软件工程的大项目——元气骑士（Vigor Knight），和另外三个小伙伴一起做了个实际上非常垃圾的游戏（我自己反正是玩不下去），也认识了wly,mjy和ljj</p>\n<p><a href=\"https://imgchr.com/i/rvENbd\"><img src=\"https://s3.ax1x.com/2020/12/31/rvENbd.md.jpg\" alt=\"rvENbd.md.jpg\"></a></p>\n<p>同时，网课这学期也发生了件比较让我高兴的事情。</p>\n<p>我和lyf（春雨支教社团老大姐）强行凑成了数学建模小组，报名参加了学校的建模校赛，并且在比赛前三个人都没有看过任何建模相关的知识。就是五一建模强行冲，最后一天熬夜到了凌晨四点，最后迎来了一个让我们大家都不敢相信的事情，收到了答辩邮件。大家都不敢相信我们能拿奖，毕竟所有人最开始的目标是成功参赛奖。贼兴奋</p>\n<p><a href=\"https://imgchr.com/i/rvEYKe\"><img src=\"https://s3.ax1x.com/2020/12/31/rvEYKe.md.jpg\" alt=\"rvEYKe.md.jpg\"></a><br><a href=\"https://imgchr.com/i/rvEGvD\"><img src=\"https://s3.ax1x.com/2020/12/31/rvEGvD.md.jpg\" alt=\"rvEGvD.md.jpg\"></a><br><a href=\"https://imgchr.com/i/rvE8gO\"><img src=\"https://s3.ax1x.com/2020/12/31/rvE8gO.md.jpg\" alt=\"rvE8gO.md.jpg\"></a><br><a href=\"https://imgchr.com/i/rvEtDH\"><img src=\"https://s3.ax1x.com/2020/12/31/rvEtDH.md.jpg\" alt=\"rvEtDH.md.jpg\"></a></p>\n<p>然后这学期还和wly合作做了数据库的大作业，因为我和他害怕经管的同学会卷，所以我们就越做越复杂。结果最后发现：</p>\n<p><strong>内卷人竟是我自己</strong></p>\n<p>不过这个项目做的过程中真的效率超高，垃圾代码产出量也非常多，还是真的有挺多收获的。</p>\n<p><a href=\"https://imgchr.com/i/rvE6Kg\"><img src=\"https://s3.ax1x.com/2020/12/31/rvE6Kg.png\" alt=\"rvE6Kg.png\"></a></p>\n<p>最后再次分享大一下学期，这个非常可惜通过网课度过的一个学期，所做的事情：</p>\n<blockquote>\n<p>1.建模写了好看论文，并且结果不错 </p>\n<p>2.做了精美扫雷游戏，玩起来不会崩</p>\n<p> 3.设计了厉害的数据库，得到了孙丽君的认可</p>\n<p> 4.做了比较菜的元气骑士，勉强能跑了 </p>\n<p>5.网课都基本认真听了，没怎么划水 </p>\n<p>6.期末认真复习了，四场考试都用一半时间就做完了 </p>\n<p>7.学会了C#新语言，可以开搞unity了</p>\n<p>8.认识了牛逼的新同学 </p>\n<p>9.没和老同学失去联系 </p>\n<p>10.飞车上荣耀钻石啦 </p>\n<p>11.跑步坚持一个月了 </p>\n<p>12.c++会用stl啦 </p>\n<p>13.坚持上完了机器学习，期中没退课！ </p>\n<p>14.电路理论做了精美笔记！可以卖钱了！ </p>\n<p>15.还没忘记你们长啥样 </p>\n<p>16.被软件开发基础老师夸了 </p>\n<p>17.终于会用github了… </p>\n<p>18.考试周坚持了一个半月没玩游戏 </p>\n<p>19.芒果tv充了年费会员 </p>\n<p>20.积极帮别人解决问题了</p>\n</blockquote>\n<p>是主要搞学习的一个学期，赞！</p>\n<p>然后就放暑假了，暑假里让我印象深刻的主要就三件事情：</p>\n<p>1.lyh（真·大一就认识的hxd）来金寨了，一起去天堂寨玩了，然后我发誓再也不要去天堂寨</p>\n<p>2.开始学车，每天顶着大太阳去科目二的地方练车，等一两个小时练一把车</p>\n<p>3.和wly打QQ飞车</p>\n<p>再然后就开学了，开学就是先军训。不过因为我暑假面试过了政治部，所以避免了太阳：</p>\n<p><a href=\"https://imgchr.com/i/rvEWan\"><img src=\"https://s3.ax1x.com/2020/12/31/rvEWan.jpg\" alt=\"rvEWan.jpg\"></a>但是说实话，政治部那七天的生活绝对不轻松。甚至可以说，我的绝大多数宣传能力都是在期间学习到的</p>\n<p>我和其他宣传组的小伙伴共同每天艰难的生活着（下图拍于12月份）</p>\n<p><a href=\"https://imgchr.com/i/rvEHr4\"><img src=\"https://s3.ax1x.com/2020/12/31/rvEHr4.jpg\" alt=\"rvEHr4.jpg\"></a></p>\n<p>那段时间，说实话，我个人过得挺自闭的。</p>\n<p>因为感觉有非常多的事情没有做完（剪可视化、外拍、推送等），还感觉自己的成绩可能不是很理想。中间甚至一度想要退课明年再选军训，总而言之：很庆幸熬了过去。</p>\n<p>下图是在其他组还没起来，卑微宣传人已经开始工作的一天</p>\n<p><a href=\"https://imgchr.com/i/rvEzRK\"><img src=\"https://s3.ax1x.com/2020/12/31/rvEzRK.jpg\" alt=\"rvEzRK.jpg\"></a></p>\n<p>军训之后，这一学期就正式开始了。</p>\n<p>来嘉定的第一个学期，体验一般。</p>\n<p>每天的生活就是去上课，去自习，思考中午吃什么，思考晚上吃什么，睡觉。</p>\n<p>比较有意思的事情是评上了果酱和社奖、参加了软院晚会、支书达理活动、玩密室等。</p>\n<p>这里就不再总结了，不要问我为什么，因为我打字打累了。这段经历应该在这学期结束的时候还会复习一下吧。</p>\n<p>直接进入最终总结环节吧。</p>\n<h2 id=\"2020年收获\"><a href=\"#2020年收获\" class=\"headerlink\" title=\"2020年收获\"></a>2020年收获</h2><blockquote>\n<p>1.认识了wly、mjy、sbq、ckx、lxy、zlh、lmx、xhz、hzj、syk、dtw、wjh、wmb、znf、lrj、lrz、chs、yxb、zkf、dgg、jch、whz、xmx、hmz、sr等很多同学</p>\n<p>2.之前朋友还在</p>\n<p>3.会用服务器了，然后懂了一些Linux操作</p>\n<p>4.会做简单网页了</p>\n<p>5.拥有自己的博客了，也就是这个网站</p>\n<p>6.Steam库++</p>\n<p>7.真的学会数据结构了</p>\n<p>8.拿了一次果酱</p>\n<p>9.数学建模拿奖了</p>\n<p>10.还是在愿意帮助别人</p>\n</blockquote>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<blockquote>\n<p>2020年结束的好快，感觉这一年还没反应过来就已经要一晃而过了。</p>\n<p>现在是2020年12月31日，在数据科学这堂课上，写下了这篇博客，就当做是对这一年的一个回顾。</p>\n</blockquote>\n<p>2020年开始于大一上学期的考试周，前一天是在图书馆复习着即将到来的大物考试</p>\n<p><a href=\"https://imgchr.com/i/rvAkOH\"><img src=\"https://s3.ax1x.com/2020/12/31/rvAkOH.jpg\" alt=\"rvAkOH.jpg\"></a></p>\n<p>在2020年开始的时候，发生了让自己心态发生了一些变化的事情。不过幸好，自己还是做到了每天去图书馆，复习着那几门科目。</p>\n<p>大物、线代、高程……一门一门的考试，每一门考前都是从焦虑到放松，以及考完后的解放。</p>\n<p>最后一门考的是线代，那天中午去北苑吃了叉烧饭（自己当时没有想到也是大一最后一顿叉烧饭</p>\n<p><a href=\"https://imgchr.com/i/rvAG0s\"><img src=\"https://s3.ax1x.com/2020/12/31/rvAG0s.jpg\" alt=\"rvAG0s.jpg\"></a></p>\n<p>在线代考完后，自己便立马带着手拉箱奔向高铁站，准备去坐即将发车的高铁了。</p>\n<p>1月9号便迎来了我的寒假的开始。寒假一开始我还试着好好学习Stl，但是学着学着感觉没意思就放弃了。感觉我可能还是需要做一些有意思的项目才能够坚持下去吧，求大佬带我做点有意思的东西QAQ</p>\n<p>同时，寒假里也迎来了认真复习的好结果，自己好多课都拿到了理想的成绩了啦~</p>\n<p><a href=\"https://imgchr.com/i/rvEpHs\"><img src=\"https://s3.ax1x.com/2020/12/31/rvEpHs.jpg\" alt=\"rvEpHs.jpg\"></a></p>\n<p>疫情到来之前，放寒假每天就很无聊，就是想着吃啥、玩啥，然后发一些乱七八糟的动态：</p>\n<blockquote>\n<p>以前走楼梯最喜欢数台阶数 </p>\n<p>所以每次走的时候都害怕会多出来或者少掉一个台阶 </p>\n<p>如果走完数量正确就算成功逃生</p>\n</blockquote>\n<p>很快，疫情来了。刚开始那段时间真的还是蛮焦虑的，特别担心这种“未知的病毒”到自己的身边。然后响应国家政策不出门，在家里就玩游戏：QQ飞车、植物大战僵尸、逆转裁判什么的。</p>\n<blockquote>\n<p>在原本的世界线里 </p>\n<p>我于六小时前到达同济大学 </p>\n<p>并将在明天开始电路理论课程 而现在的现实却是要放暑假了</p>\n</blockquote>\n<p>很快也迎来了延迟开学的消息，在推迟了一周开学后，便迎来了印象深刻的网课时期。</p>\n<p>网课时期每天干的事情就是好好上课，然后晚上会玩会儿游戏，点名表扬qjy同学。</p>\n<p>这个学期也玩到了两个我特别喜欢的游戏：</p>\n<p>一个是奇异人生（Life Is Strange）：</p>\n<p><a href=\"https://imgchr.com/i/rvEA3T\"><img src=\"https://s3.ax1x.com/2020/12/31/rvEA3T.jpg\" alt=\"rvEA3T.jpg\"></a></p>\n<p>还有一个则是消逝的光芒（Dying Light），画面相对比较血腥这里就不放图了。</p>\n<p>然后就迎来了软件工程的大项目——元气骑士（Vigor Knight），和另外三个小伙伴一起做了个实际上非常垃圾的游戏（我自己反正是玩不下去），也认识了wly,mjy和ljj</p>\n<p><a href=\"https://imgchr.com/i/rvENbd\"><img src=\"https://s3.ax1x.com/2020/12/31/rvENbd.md.jpg\" alt=\"rvENbd.md.jpg\"></a></p>\n<p>同时，网课这学期也发生了件比较让我高兴的事情。</p>\n<p>我和lyf（春雨支教社团老大姐）强行凑成了数学建模小组，报名参加了学校的建模校赛，并且在比赛前三个人都没有看过任何建模相关的知识。就是五一建模强行冲，最后一天熬夜到了凌晨四点，最后迎来了一个让我们大家都不敢相信的事情，收到了答辩邮件。大家都不敢相信我们能拿奖，毕竟所有人最开始的目标是成功参赛奖。贼兴奋</p>\n<p><a href=\"https://imgchr.com/i/rvEYKe\"><img src=\"https://s3.ax1x.com/2020/12/31/rvEYKe.md.jpg\" alt=\"rvEYKe.md.jpg\"></a><br><a href=\"https://imgchr.com/i/rvEGvD\"><img src=\"https://s3.ax1x.com/2020/12/31/rvEGvD.md.jpg\" alt=\"rvEGvD.md.jpg\"></a><br><a href=\"https://imgchr.com/i/rvE8gO\"><img src=\"https://s3.ax1x.com/2020/12/31/rvE8gO.md.jpg\" alt=\"rvE8gO.md.jpg\"></a><br><a href=\"https://imgchr.com/i/rvEtDH\"><img src=\"https://s3.ax1x.com/2020/12/31/rvEtDH.md.jpg\" alt=\"rvEtDH.md.jpg\"></a></p>\n<p>然后这学期还和wly合作做了数据库的大作业，因为我和他害怕经管的同学会卷，所以我们就越做越复杂。结果最后发现：</p>\n<p><strong>内卷人竟是我自己</strong></p>\n<p>不过这个项目做的过程中真的效率超高，垃圾代码产出量也非常多，还是真的有挺多收获的。</p>\n<p><a href=\"https://imgchr.com/i/rvE6Kg\"><img src=\"https://s3.ax1x.com/2020/12/31/rvE6Kg.png\" alt=\"rvE6Kg.png\"></a></p>\n<p>最后再次分享大一下学期，这个非常可惜通过网课度过的一个学期，所做的事情：</p>\n<blockquote>\n<p>1.建模写了好看论文，并且结果不错 </p>\n<p>2.做了精美扫雷游戏，玩起来不会崩</p>\n<p> 3.设计了厉害的数据库，得到了孙丽君的认可</p>\n<p> 4.做了比较菜的元气骑士，勉强能跑了 </p>\n<p>5.网课都基本认真听了，没怎么划水 </p>\n<p>6.期末认真复习了，四场考试都用一半时间就做完了 </p>\n<p>7.学会了C#新语言，可以开搞unity了</p>\n<p>8.认识了牛逼的新同学 </p>\n<p>9.没和老同学失去联系 </p>\n<p>10.飞车上荣耀钻石啦 </p>\n<p>11.跑步坚持一个月了 </p>\n<p>12.c++会用stl啦 </p>\n<p>13.坚持上完了机器学习，期中没退课！ </p>\n<p>14.电路理论做了精美笔记！可以卖钱了！ </p>\n<p>15.还没忘记你们长啥样 </p>\n<p>16.被软件开发基础老师夸了 </p>\n<p>17.终于会用github了… </p>\n<p>18.考试周坚持了一个半月没玩游戏 </p>\n<p>19.芒果tv充了年费会员 </p>\n<p>20.积极帮别人解决问题了</p>\n</blockquote>\n<p>是主要搞学习的一个学期，赞！</p>\n<p>然后就放暑假了，暑假里让我印象深刻的主要就三件事情：</p>\n<p>1.lyh（真·大一就认识的hxd）来金寨了，一起去天堂寨玩了，然后我发誓再也不要去天堂寨</p>\n<p>2.开始学车，每天顶着大太阳去科目二的地方练车，等一两个小时练一把车</p>\n<p>3.和wly打QQ飞车</p>\n<p>再然后就开学了，开学就是先军训。不过因为我暑假面试过了政治部，所以避免了太阳：</p>\n<p><a href=\"https://imgchr.com/i/rvEWan\"><img src=\"https://s3.ax1x.com/2020/12/31/rvEWan.jpg\" alt=\"rvEWan.jpg\"></a>但是说实话，政治部那七天的生活绝对不轻松。甚至可以说，我的绝大多数宣传能力都是在期间学习到的</p>\n<p>我和其他宣传组的小伙伴共同每天艰难的生活着（下图拍于12月份）</p>\n<p><a href=\"https://imgchr.com/i/rvEHr4\"><img src=\"https://s3.ax1x.com/2020/12/31/rvEHr4.jpg\" alt=\"rvEHr4.jpg\"></a></p>\n<p>那段时间，说实话，我个人过得挺自闭的。</p>\n<p>因为感觉有非常多的事情没有做完（剪可视化、外拍、推送等），还感觉自己的成绩可能不是很理想。中间甚至一度想要退课明年再选军训，总而言之：很庆幸熬了过去。</p>\n<p>下图是在其他组还没起来，卑微宣传人已经开始工作的一天</p>\n<p><a href=\"https://imgchr.com/i/rvEzRK\"><img src=\"https://s3.ax1x.com/2020/12/31/rvEzRK.jpg\" alt=\"rvEzRK.jpg\"></a></p>\n<p>军训之后，这一学期就正式开始了。</p>\n<p>来嘉定的第一个学期，体验一般。</p>\n<p>每天的生活就是去上课，去自习，思考中午吃什么，思考晚上吃什么，睡觉。</p>\n<p>比较有意思的事情是评上了果酱和社奖、参加了软院晚会、支书达理活动、玩密室等。</p>\n<p>这里就不再总结了，不要问我为什么，因为我打字打累了。这段经历应该在这学期结束的时候还会复习一下吧。</p>\n<p>直接进入最终总结环节吧。</p>\n<h2 id=\"2020年收获\"><a href=\"#2020年收获\" class=\"headerlink\" title=\"2020年收获\"></a>2020年收获</h2><blockquote>\n<p>1.认识了wly、mjy、sbq、ckx、lxy、zlh、lmx、xhz、hzj、syk、dtw、wjh、wmb、znf、lrj、lrz、chs、yxb、zkf、dgg、jch、whz、xmx、hmz、sr等很多同学</p>\n<p>2.之前朋友还在</p>\n<p>3.会用服务器了，然后懂了一些Linux操作</p>\n<p>4.会做简单网页了</p>\n<p>5.拥有自己的博客了，也就是这个网站</p>\n<p>6.Steam库++</p>\n<p>7.真的学会数据结构了</p>\n<p>8.拿了一次果酱</p>\n<p>9.数学建模拿奖了</p>\n<p>10.还是在愿意帮助别人</p>\n</blockquote>\n"},{"title":"ElementUI2 开发","date":"2023-04-25T04:06:16.000Z","_content":"需要python2环境\n\nhttps://www.wyr.me/post/658\n\n```she\nbrew install pyenv\npyenv install 2.7.18\nexport PATH=\"$(pyenv root)/shims:${PATH}\"\npyenv global 2.7.18\npython --version\n```\n\n\n\n需要注意node-sass版本的对应关系\n\n如，默认的node-sass是4.11.0，而这个版本对node有要求：\n\n| OS           | Architecture | Node                                                   |\n| ------------ | ------------ | ------------------------------------------------------ |\n| Windows      | x86 & x64    | 0.10, 0.12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11          |\n| OSX          | x64          | 0.10, 0.12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11          |\n| Linux*       | x86 & x64    | 0.10, 0.12, 1, 2, 3, 4, 5, 6, 7, 8**, 9**, 10**^, 11** |\n| Alpine Linux | x64          | 6, 8, 10, 11                                           |\n\n所以使用nvm install 11，先下载11版本的node\n","source":"_posts/ElementUI2-开发.md","raw":"---\ntitle: ElementUI2 开发\ndate: 2023-04-25 12:06:16\ntags:\n---\n需要python2环境\n\nhttps://www.wyr.me/post/658\n\n```she\nbrew install pyenv\npyenv install 2.7.18\nexport PATH=\"$(pyenv root)/shims:${PATH}\"\npyenv global 2.7.18\npython --version\n```\n\n\n\n需要注意node-sass版本的对应关系\n\n如，默认的node-sass是4.11.0，而这个版本对node有要求：\n\n| OS           | Architecture | Node                                                   |\n| ------------ | ------------ | ------------------------------------------------------ |\n| Windows      | x86 & x64    | 0.10, 0.12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11          |\n| OSX          | x64          | 0.10, 0.12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11          |\n| Linux*       | x86 & x64    | 0.10, 0.12, 1, 2, 3, 4, 5, 6, 7, 8**, 9**, 10**^, 11** |\n| Alpine Linux | x64          | 6, 8, 10, 11                                           |\n\n所以使用nvm install 11，先下载11版本的node\n","slug":"ElementUI2-开发","published":1,"updated":"2023-04-25T04:07:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmhg4qt3v0001f5fa1rdl1wwe","content":"<p>需要python2环境</p>\n<p><a href=\"https://www.wyr.me/post/658\">https://www.wyr.me/post/658</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install pyenv</span><br><span class=\"line\">pyenv install 2.7.18</span><br><span class=\"line\">export PATH&#x3D;&quot;$(pyenv root)&#x2F;shims:$&#123;PATH&#125;&quot;</span><br><span class=\"line\">pyenv global 2.7.18</span><br><span class=\"line\">python --version</span><br></pre></td></tr></table></figure>\n\n\n<p>需要注意node-sass版本的对应关系</p>\n<p>如，默认的node-sass是4.11.0，而这个版本对node有要求：</p>\n<table>\n<thead>\n<tr>\n<th>OS</th>\n<th>Architecture</th>\n<th>Node</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Windows</td>\n<td>x86 &amp; x64</td>\n<td>0.10, 0.12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11</td>\n</tr>\n<tr>\n<td>OSX</td>\n<td>x64</td>\n<td>0.10, 0.12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11</td>\n</tr>\n<tr>\n<td>Linux*</td>\n<td>x86 &amp; x64</td>\n<td>0.10, 0.12, 1, 2, 3, 4, 5, 6, 7, 8**, 9**, 10<strong>^, 11</strong></td>\n</tr>\n<tr>\n<td>Alpine Linux</td>\n<td>x64</td>\n<td>6, 8, 10, 11</td>\n</tr>\n</tbody></table>\n<p>所以使用nvm install 11，先下载11版本的node</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<p>需要python2环境</p>\n<p><a href=\"https://www.wyr.me/post/658\">https://www.wyr.me/post/658</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install pyenv</span><br><span class=\"line\">pyenv install 2.7.18</span><br><span class=\"line\">export PATH&#x3D;&quot;$(pyenv root)&#x2F;shims:$&#123;PATH&#125;&quot;</span><br><span class=\"line\">pyenv global 2.7.18</span><br><span class=\"line\">python --version</span><br></pre></td></tr></table></figure>\n\n\n<p>需要注意node-sass版本的对应关系</p>\n<p>如，默认的node-sass是4.11.0，而这个版本对node有要求：</p>\n<table>\n<thead>\n<tr>\n<th>OS</th>\n<th>Architecture</th>\n<th>Node</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Windows</td>\n<td>x86 &amp; x64</td>\n<td>0.10, 0.12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11</td>\n</tr>\n<tr>\n<td>OSX</td>\n<td>x64</td>\n<td>0.10, 0.12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11</td>\n</tr>\n<tr>\n<td>Linux*</td>\n<td>x86 &amp; x64</td>\n<td>0.10, 0.12, 1, 2, 3, 4, 5, 6, 7, 8**, 9**, 10<strong>^, 11</strong></td>\n</tr>\n<tr>\n<td>Alpine Linux</td>\n<td>x64</td>\n<td>6, 8, 10, 11</td>\n</tr>\n</tbody></table>\n<p>所以使用nvm install 11，先下载11版本的node</p>\n"},{"title":"JS——原型链","date":"2022-04-03T10:00:00.000Z","description":"有关Js原型链的一些知识。","cover":"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403162850136.png","_content":"\n\n\n## 前言\n\n在学习JS中的原型，原型链，继承这些知识之前，我们先学习下基础知识：**函数和对象的关系**。\n\n我们一直都知道，函数也是对象的一种，因为通过` instanceof `就可以判断出来。但是函数和对象的关系并不是简单的包含和被包含的关系，这两者之间的关系还是有点复杂的。接下来我们就来捋一捋。\n\n首先，阐述一点，**对象都是通过函数创建的**。\n对于下面这种类型的代码，一般叫做“语法糖”：\n\n```javascript\nvar obj = {a:10,b:20};\nvar arr = [5, 'x', true];\n```\n\n但是，其实上面这段代码的实质是下面这样的：\n\n```javascript\nvar obj = new Object();\nobj.a = 10;\nobj.b = 20;\n\nvar arr = new Array();\narr[0] = 5;\narr[1] = 'x';\narr[2] = true;\n```\n\n而`Object`和`Array`都是函数，可以自己用`typeof`函数进行验证。\n\n所以，可以得出：**对象都是通过函数创建的**。\n\n那么下面就进入正题。\n\n## 原型prototype\n\n在前言中，我们说了函数也是一种对象，所以函数也是属性的集合，同时，也可以对函数进行自定义属性。\n**每个函数都有一个属性——prototype。这个prototype的属性值是一个对象（属性的集合），默认只有一个叫做constructor的属性，指向这个函数本身。** 如下图所示：\n\n![image-20220403154221307](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403154221307.png)\n\n上图中，`SuperType`是一个函数，右侧的方框就是**它的原型**。\n\n原型既然作为对象（属性的集合），除了`constructor`外，还可以自定义许多属性，比如下面这样的：\n\n![image-20220403154324885](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403154324885.png)\n\n当然了，我们也可以在自己定义的方法的`prototype`中增加我们自己的属性，比如像下面这样的：\n\n```javascript\nfunction Fn() { }\nFn.prototype.name = '张三';\nFn.prototype.getAge = function () {\n    return 12;\n};\nvar a = new Fn();\n```\n\n![image-20220403154612542](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403154612542.png)\n\nFn就是下面这样：\n\n![image-20220403154633724](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403154633724.png)\n\n那么问题来了：函数的`prototype`到底有何用呢？\n\n在解决这个问题之前，我们还是先来看下另一个让人迷糊的属性：`__proto__`\n\n## 隐式原型  _ proto_\n\n先看一段非常常见的代码：\n\n```javascript\nfunction Fn() { }\nFn.prototype.name = '张三';\nFn.prototype.getAge = function () {\n    return 12;\n};\nvar fn = new Fn();\nconsole.log(fn.name);\nconsole.log(fn.getAge());\n```\n\n即，Fn是一个函数，fn对象是从Fn函数new出来的，这样fn对象就可以调用Fn.prototype中的属性。\n\n但是，因为每个对象都有一个隐藏的属性——` __proto__`，这个属性引用了**创建这个对象的函数的prototype**。即：` fn._proto_ === Fn.prototype `\n那么，这里的`__proto__`到底是什么呢？\n\n其实，这个`__proto__`是一个隐藏的属性，javascript不希望开发者用到这个属性值，有的低版本浏览器甚至不支持这个属性值。\n\n```javascript\nvar obj = {};\nconsole.log(obj.__proto__);\n```\n\n![image-20220403160024050](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403160024050.png)\n\n\n\n\n```javascript\nconsole.log(Object.prototype);\n```\n\n![image-20220403160148483](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403160148483.png)\n\n\n\n从上面来看，`obj.__proto__`和`Object.prototype`的属性一样！为什么呢？\n\n原因是：obj这个对象本质上是被Object函数创建的，因此obj.**\\_\\_proto__**=== Object.prototype。我们可以用一个图来表示。\n\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403160408070.png' width=\"50%\">\n\n即，**每个对象都有一个\\_\\_proto__属性，指向创建该对象的函数的prototype。**\n\n> **说一下自定义函数的prototype：**\n> 自定义函数的`prototype`本质上就是和 `var obj = {}` 是一样的，都是被`Object`创建，所以它的`__proto__`指向的就是`Object.prototype`。\n\n但是，**`Object.prototype`确实一个特例——它的`__proto__`指向的是`null`**。\n\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403161118789.png' width=\"50%\">\n\n另外一个问题：函数也是一种对象，函数也有`__proto__`吗？\n答：当然也不例外啦！\n下面用一段代码和一张图来说明这个问题，看完相信就有个比较直观的理解啦！\n\n```javascript\nfunction fn(x, y) {\n    return x+y;\n}\nconsole.log(fn(10,20));\n\n// 以下只是为了演示函数被Function创建的\nvar fn1 = new Function(\"x\",\"y\",\"return x+y;\");\nconsole.log(fn1(5,6));\n```\n\n用图表示就是：\n\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403161731562.png' width=\"60%\">\n\n从上图可以看出：自定义函数`Foo.__proto__`指向`Function.prototype`，`Object.__proto__`指向`Function.prototype`。\n\n但是，为什么有`Function.__proto__`指向`Function.prototype`呢？\n\n其实原因很简单：**`Function`也是一个函数，函数是一种对象，也有`__proto__`属性。既然是函数，那么它一定是被`Function`创建。所以`Function`是被自身创建的。所以它的`__proto__`指向了自身的`Prototype`**\n\n最后一个问题：`Function.prototype`指向的对象，它的`__proto__`是不是也指向`Object.prototype`？\n\n答案是肯定的。因为`Function.prototype`指向的对象也是一个普通的被`Object`创建的对象，所以也遵循基本的规则。如下图：\n\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403162506341.png' width=\"50%\">\n\n说了这么多，我们将上面这些图片整合到一整个图片，便于整体理解，图片如下：\n\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403162639383.png' width=\"50%\">\n\n## instanceof\n\n主要是说明下`instanceof`的判断规则是如何进行的。先看如下代码和图片：\n\n```javascript\nfunction Foo() {\n}\nvar f1 = new Foo();\n\nconsole.log(f1 instanceof Foo);//true\nconsole.log(f1 instanceof Object);// true\n```\n\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403162850136.png' width=\"50%\">\n\n`instanceof`的判断规则为：\n假设`instanceof`运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为B。\n\n`instanceof`的判断规则是：沿着A的`__proto__`这条线来找，同时沿着B的`prototype`这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回`true`。如果找到终点还未重合，则返回`false`。\n\n结合这个判断规则，上面的代码和图示相信很容易看懂了。\n\n## 原型继承\n\n首先说一下什么是原型链：\n**访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着\\_proto_这条链向上找，这就是原型链**。\n\n举一个例子说明下吧：\n在实际应用中如何区分一个属性到底是基本的还是从原型中找到的呢？\n答案就是：`hasOwnProperty`这个函数，特别是在for…in…循环中，一定要注意。\n\n![image-20220403174502374](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403174502374.png)\n\n但是，`f1`本身并没有`hasOwnProperty`这个方法，那是从哪里来的呢？答案很简单，是从`Object.prototype`中来的。看下图：\n\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403174630283.png' width='70%'>\n\n对象的原型链是沿着`__proto__`这条线走的，因此在查找`f1.hasOwnProperty`属性时，就会顺着原型链一直查找到`Object.prototype`。\n\n由于所有对象的原型链都会找到`Object.prototype`，因此所有对象都会有`Object.prototype`的方法。这就是所谓的“继承”。\n\n## 示例\n\n> 下面这段代码的输出：\n>\n> ```javascript\n> function Setcount(count){\n> \tthis.count=count\n> }\n> \n> Setcount.prototype.printCount=function(){\n> \tconsole.log(this.count)\n> }\n> \n> let a = new Setcount(100)\n> a.count =200\n> a.__proto__.count=300\n> a.__proto__.printCount()\n> a.printCount()\n> ```\n>\n> 结果为300和200。\n\n\n\n> 下面这段代码的输出：\n>\n> ```javascript\n> Object.prototype.foo = 'Object';\n> Function.prototype.foo = 'Function';\n> function Animal () {};\n> var cat = new Animal();\n> console.log(cat.foo);\n> console.log(Animal.foo);\n> ```\n>\n> 输出为Object 和 Function\n","source":"_posts/JS-原型链.md","raw":"---\ntitle: JS——原型链\ndate: 2022-4-03 18:00:00\ndescription: 有关Js原型链的一些知识。\ncover: https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403162850136.png\n---\n\n\n\n## 前言\n\n在学习JS中的原型，原型链，继承这些知识之前，我们先学习下基础知识：**函数和对象的关系**。\n\n我们一直都知道，函数也是对象的一种，因为通过` instanceof `就可以判断出来。但是函数和对象的关系并不是简单的包含和被包含的关系，这两者之间的关系还是有点复杂的。接下来我们就来捋一捋。\n\n首先，阐述一点，**对象都是通过函数创建的**。\n对于下面这种类型的代码，一般叫做“语法糖”：\n\n```javascript\nvar obj = {a:10,b:20};\nvar arr = [5, 'x', true];\n```\n\n但是，其实上面这段代码的实质是下面这样的：\n\n```javascript\nvar obj = new Object();\nobj.a = 10;\nobj.b = 20;\n\nvar arr = new Array();\narr[0] = 5;\narr[1] = 'x';\narr[2] = true;\n```\n\n而`Object`和`Array`都是函数，可以自己用`typeof`函数进行验证。\n\n所以，可以得出：**对象都是通过函数创建的**。\n\n那么下面就进入正题。\n\n## 原型prototype\n\n在前言中，我们说了函数也是一种对象，所以函数也是属性的集合，同时，也可以对函数进行自定义属性。\n**每个函数都有一个属性——prototype。这个prototype的属性值是一个对象（属性的集合），默认只有一个叫做constructor的属性，指向这个函数本身。** 如下图所示：\n\n![image-20220403154221307](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403154221307.png)\n\n上图中，`SuperType`是一个函数，右侧的方框就是**它的原型**。\n\n原型既然作为对象（属性的集合），除了`constructor`外，还可以自定义许多属性，比如下面这样的：\n\n![image-20220403154324885](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403154324885.png)\n\n当然了，我们也可以在自己定义的方法的`prototype`中增加我们自己的属性，比如像下面这样的：\n\n```javascript\nfunction Fn() { }\nFn.prototype.name = '张三';\nFn.prototype.getAge = function () {\n    return 12;\n};\nvar a = new Fn();\n```\n\n![image-20220403154612542](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403154612542.png)\n\nFn就是下面这样：\n\n![image-20220403154633724](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403154633724.png)\n\n那么问题来了：函数的`prototype`到底有何用呢？\n\n在解决这个问题之前，我们还是先来看下另一个让人迷糊的属性：`__proto__`\n\n## 隐式原型  _ proto_\n\n先看一段非常常见的代码：\n\n```javascript\nfunction Fn() { }\nFn.prototype.name = '张三';\nFn.prototype.getAge = function () {\n    return 12;\n};\nvar fn = new Fn();\nconsole.log(fn.name);\nconsole.log(fn.getAge());\n```\n\n即，Fn是一个函数，fn对象是从Fn函数new出来的，这样fn对象就可以调用Fn.prototype中的属性。\n\n但是，因为每个对象都有一个隐藏的属性——` __proto__`，这个属性引用了**创建这个对象的函数的prototype**。即：` fn._proto_ === Fn.prototype `\n那么，这里的`__proto__`到底是什么呢？\n\n其实，这个`__proto__`是一个隐藏的属性，javascript不希望开发者用到这个属性值，有的低版本浏览器甚至不支持这个属性值。\n\n```javascript\nvar obj = {};\nconsole.log(obj.__proto__);\n```\n\n![image-20220403160024050](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403160024050.png)\n\n\n\n\n```javascript\nconsole.log(Object.prototype);\n```\n\n![image-20220403160148483](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403160148483.png)\n\n\n\n从上面来看，`obj.__proto__`和`Object.prototype`的属性一样！为什么呢？\n\n原因是：obj这个对象本质上是被Object函数创建的，因此obj.**\\_\\_proto__**=== Object.prototype。我们可以用一个图来表示。\n\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403160408070.png' width=\"50%\">\n\n即，**每个对象都有一个\\_\\_proto__属性，指向创建该对象的函数的prototype。**\n\n> **说一下自定义函数的prototype：**\n> 自定义函数的`prototype`本质上就是和 `var obj = {}` 是一样的，都是被`Object`创建，所以它的`__proto__`指向的就是`Object.prototype`。\n\n但是，**`Object.prototype`确实一个特例——它的`__proto__`指向的是`null`**。\n\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403161118789.png' width=\"50%\">\n\n另外一个问题：函数也是一种对象，函数也有`__proto__`吗？\n答：当然也不例外啦！\n下面用一段代码和一张图来说明这个问题，看完相信就有个比较直观的理解啦！\n\n```javascript\nfunction fn(x, y) {\n    return x+y;\n}\nconsole.log(fn(10,20));\n\n// 以下只是为了演示函数被Function创建的\nvar fn1 = new Function(\"x\",\"y\",\"return x+y;\");\nconsole.log(fn1(5,6));\n```\n\n用图表示就是：\n\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403161731562.png' width=\"60%\">\n\n从上图可以看出：自定义函数`Foo.__proto__`指向`Function.prototype`，`Object.__proto__`指向`Function.prototype`。\n\n但是，为什么有`Function.__proto__`指向`Function.prototype`呢？\n\n其实原因很简单：**`Function`也是一个函数，函数是一种对象，也有`__proto__`属性。既然是函数，那么它一定是被`Function`创建。所以`Function`是被自身创建的。所以它的`__proto__`指向了自身的`Prototype`**\n\n最后一个问题：`Function.prototype`指向的对象，它的`__proto__`是不是也指向`Object.prototype`？\n\n答案是肯定的。因为`Function.prototype`指向的对象也是一个普通的被`Object`创建的对象，所以也遵循基本的规则。如下图：\n\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403162506341.png' width=\"50%\">\n\n说了这么多，我们将上面这些图片整合到一整个图片，便于整体理解，图片如下：\n\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403162639383.png' width=\"50%\">\n\n## instanceof\n\n主要是说明下`instanceof`的判断规则是如何进行的。先看如下代码和图片：\n\n```javascript\nfunction Foo() {\n}\nvar f1 = new Foo();\n\nconsole.log(f1 instanceof Foo);//true\nconsole.log(f1 instanceof Object);// true\n```\n\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403162850136.png' width=\"50%\">\n\n`instanceof`的判断规则为：\n假设`instanceof`运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为B。\n\n`instanceof`的判断规则是：沿着A的`__proto__`这条线来找，同时沿着B的`prototype`这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回`true`。如果找到终点还未重合，则返回`false`。\n\n结合这个判断规则，上面的代码和图示相信很容易看懂了。\n\n## 原型继承\n\n首先说一下什么是原型链：\n**访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着\\_proto_这条链向上找，这就是原型链**。\n\n举一个例子说明下吧：\n在实际应用中如何区分一个属性到底是基本的还是从原型中找到的呢？\n答案就是：`hasOwnProperty`这个函数，特别是在for…in…循环中，一定要注意。\n\n![image-20220403174502374](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403174502374.png)\n\n但是，`f1`本身并没有`hasOwnProperty`这个方法，那是从哪里来的呢？答案很简单，是从`Object.prototype`中来的。看下图：\n\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403174630283.png' width='70%'>\n\n对象的原型链是沿着`__proto__`这条线走的，因此在查找`f1.hasOwnProperty`属性时，就会顺着原型链一直查找到`Object.prototype`。\n\n由于所有对象的原型链都会找到`Object.prototype`，因此所有对象都会有`Object.prototype`的方法。这就是所谓的“继承”。\n\n## 示例\n\n> 下面这段代码的输出：\n>\n> ```javascript\n> function Setcount(count){\n> \tthis.count=count\n> }\n> \n> Setcount.prototype.printCount=function(){\n> \tconsole.log(this.count)\n> }\n> \n> let a = new Setcount(100)\n> a.count =200\n> a.__proto__.count=300\n> a.__proto__.printCount()\n> a.printCount()\n> ```\n>\n> 结果为300和200。\n\n\n\n> 下面这段代码的输出：\n>\n> ```javascript\n> Object.prototype.foo = 'Object';\n> Function.prototype.foo = 'Function';\n> function Animal () {};\n> var cat = new Animal();\n> console.log(cat.foo);\n> console.log(Animal.foo);\n> ```\n>\n> 输出为Object 和 Function\n","slug":"JS-原型链","published":1,"updated":"2022-04-03T12:48:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmhg4qt3z0002f5fa5xfm4omo","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在学习JS中的原型，原型链，继承这些知识之前，我们先学习下基础知识：<strong>函数和对象的关系</strong>。</p>\n<p>我们一直都知道，函数也是对象的一种，因为通过<code>instanceof</code>就可以判断出来。但是函数和对象的关系并不是简单的包含和被包含的关系，这两者之间的关系还是有点复杂的。接下来我们就来捋一捋。</p>\n<p>首先，阐述一点，<strong>对象都是通过函数创建的</strong>。<br>对于下面这种类型的代码，一般叫做“语法糖”：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;<span class=\"attr\">a</span>:<span class=\"number\">10</span>,<span class=\"attr\">b</span>:<span class=\"number\">20</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">5</span>, <span class=\"string\">&#x27;x&#x27;</span>, <span class=\"literal\">true</span>];</span><br></pre></td></tr></table></figure>\n<p>但是，其实上面这段代码的实质是下面这样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">obj.a = <span class=\"number\">10</span>;</span><br><span class=\"line\">obj.b = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\">arr[<span class=\"number\">0</span>] = <span class=\"number\">5</span>;</span><br><span class=\"line\">arr[<span class=\"number\">1</span>] = <span class=\"string\">&#x27;x&#x27;</span>;</span><br><span class=\"line\">arr[<span class=\"number\">2</span>] = <span class=\"literal\">true</span>;</span><br></pre></td></tr></table></figure>\n<p>而<code>Object</code>和<code>Array</code>都是函数，可以自己用<code>typeof</code>函数进行验证。</p>\n<p>所以，可以得出：<strong>对象都是通过函数创建的</strong>。</p>\n<p>那么下面就进入正题。</p>\n<h2 id=\"原型prototype\"><a href=\"#原型prototype\" class=\"headerlink\" title=\"原型prototype\"></a>原型prototype</h2><p>在前言中，我们说了函数也是一种对象，所以函数也是属性的集合，同时，也可以对函数进行自定义属性。<br><strong>每个函数都有一个属性——prototype。这个prototype的属性值是一个对象（属性的集合），默认只有一个叫做constructor的属性，指向这个函数本身。</strong> 如下图所示：</p>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403154221307.png\" alt=\"image-20220403154221307\"></p>\n<p>上图中，<code>SuperType</code>是一个函数，右侧的方框就是<strong>它的原型</strong>。</p>\n<p>原型既然作为对象（属性的集合），除了<code>constructor</code>外，还可以自定义许多属性，比如下面这样的：</p>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403154324885.png\" alt=\"image-20220403154324885\"></p>\n<p>当然了，我们也可以在自己定义的方法的<code>prototype</code>中增加我们自己的属性，比如像下面这样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Fn</span>(<span class=\"params\"></span>) </span>&#123; &#125;</span><br><span class=\"line\">Fn.prototype.name = <span class=\"string\">&#x27;张三&#x27;</span>;</span><br><span class=\"line\">Fn.prototype.getAge = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">12</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> Fn();</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403154612542.png\" alt=\"image-20220403154612542\"></p>\n<p>Fn就是下面这样：</p>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403154633724.png\" alt=\"image-20220403154633724\"></p>\n<p>那么问题来了：函数的<code>prototype</code>到底有何用呢？</p>\n<p>在解决这个问题之前，我们还是先来看下另一个让人迷糊的属性：<code>__proto__</code></p>\n<h2 id=\"隐式原型-proto\"><a href=\"#隐式原型-proto\" class=\"headerlink\" title=\"隐式原型  _ proto_\"></a>隐式原型  _ proto_</h2><p>先看一段非常常见的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Fn</span>(<span class=\"params\"></span>) </span>&#123; &#125;</span><br><span class=\"line\">Fn.prototype.name = <span class=\"string\">&#x27;张三&#x27;</span>;</span><br><span class=\"line\">Fn.prototype.getAge = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">12</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"keyword\">new</span> Fn();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(fn.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(fn.getAge());</span><br></pre></td></tr></table></figure>\n<p>即，Fn是一个函数，fn对象是从Fn函数new出来的，这样fn对象就可以调用Fn.prototype中的属性。</p>\n<p>但是，因为每个对象都有一个隐藏的属性——<code> __proto__</code>，这个属性引用了<strong>创建这个对象的函数的prototype</strong>。即：<code>fn._proto_ === Fn.prototype</code><br>那么，这里的<code>__proto__</code>到底是什么呢？</p>\n<p>其实，这个<code>__proto__</code>是一个隐藏的属性，javascript不希望开发者用到这个属性值，有的低版本浏览器甚至不支持这个属性值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.__proto__);</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403160024050.png\" alt=\"image-20220403160024050\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.prototype);</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403160148483.png\" alt=\"image-20220403160148483\"></p>\n<p>从上面来看，<code>obj.__proto__</code>和<code>Object.prototype</code>的属性一样！为什么呢？</p>\n<p>原因是：obj这个对象本质上是被Object函数创建的，因此obj.<strong>__proto__</strong>=== Object.prototype。我们可以用一个图来表示。</p>\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403160408070.png' width=\"50%\">\n\n<p>即，<strong>每个对象都有一个__proto__属性，指向创建该对象的函数的prototype。</strong></p>\n<blockquote>\n<p><strong>说一下自定义函数的prototype：</strong><br>自定义函数的<code>prototype</code>本质上就是和 <code>var obj = &#123;&#125;</code> 是一样的，都是被<code>Object</code>创建，所以它的<code>__proto__</code>指向的就是<code>Object.prototype</code>。</p>\n</blockquote>\n<p>但是，**<code>Object.prototype</code>确实一个特例——它的<code>__proto__</code>指向的是<code>null</code>**。</p>\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403161118789.png' width=\"50%\">\n\n<p>另外一个问题：函数也是一种对象，函数也有<code>__proto__</code>吗？<br>答：当然也不例外啦！<br>下面用一段代码和一张图来说明这个问题，看完相信就有个比较直观的理解啦！</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x+y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(fn(<span class=\"number\">10</span>,<span class=\"number\">20</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以下只是为了演示函数被Function创建的</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>(<span class=\"string\">&quot;x&quot;</span>,<span class=\"string\">&quot;y&quot;</span>,<span class=\"string\">&quot;return x+y;&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(fn1(<span class=\"number\">5</span>,<span class=\"number\">6</span>));</span><br></pre></td></tr></table></figure>\n<p>用图表示就是：</p>\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403161731562.png' width=\"60%\">\n\n<p>从上图可以看出：自定义函数<code>Foo.__proto__</code>指向<code>Function.prototype</code>，<code>Object.__proto__</code>指向<code>Function.prototype</code>。</p>\n<p>但是，为什么有<code>Function.__proto__</code>指向<code>Function.prototype</code>呢？</p>\n<p>其实原因很简单：**<code>Function</code>也是一个函数，函数是一种对象，也有<code>__proto__</code>属性。既然是函数，那么它一定是被<code>Function</code>创建。所以<code>Function</code>是被自身创建的。所以它的<code>__proto__</code>指向了自身的<code>Prototype</code>**</p>\n<p>最后一个问题：<code>Function.prototype</code>指向的对象，它的<code>__proto__</code>是不是也指向<code>Object.prototype</code>？</p>\n<p>答案是肯定的。因为<code>Function.prototype</code>指向的对象也是一个普通的被<code>Object</code>创建的对象，所以也遵循基本的规则。如下图：</p>\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403162506341.png' width=\"50%\">\n\n<p>说了这么多，我们将上面这些图片整合到一整个图片，便于整体理解，图片如下：</p>\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403162639383.png' width=\"50%\">\n\n<h2 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h2><p>主要是说明下<code>instanceof</code>的判断规则是如何进行的。先看如下代码和图片：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> f1 = <span class=\"keyword\">new</span> Foo();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(f1 <span class=\"keyword\">instanceof</span> Foo);<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(f1 <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>);<span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403162850136.png' width=\"50%\">\n\n<p><code>instanceof</code>的判断规则为：<br>假设<code>instanceof</code>运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为B。</p>\n<p><code>instanceof</code>的判断规则是：沿着A的<code>__proto__</code>这条线来找，同时沿着B的<code>prototype</code>这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回<code>true</code>。如果找到终点还未重合，则返回<code>false</code>。</p>\n<p>结合这个判断规则，上面的代码和图示相信很容易看懂了。</p>\n<h2 id=\"原型继承\"><a href=\"#原型继承\" class=\"headerlink\" title=\"原型继承\"></a>原型继承</h2><p>首先说一下什么是原型链：<br><strong>访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着_proto_这条链向上找，这就是原型链</strong>。</p>\n<p>举一个例子说明下吧：<br>在实际应用中如何区分一个属性到底是基本的还是从原型中找到的呢？<br>答案就是：<code>hasOwnProperty</code>这个函数，特别是在for…in…循环中，一定要注意。</p>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403174502374.png\" alt=\"image-20220403174502374\"></p>\n<p>但是，<code>f1</code>本身并没有<code>hasOwnProperty</code>这个方法，那是从哪里来的呢？答案很简单，是从<code>Object.prototype</code>中来的。看下图：</p>\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403174630283.png' width='70%'>\n\n<p>对象的原型链是沿着<code>__proto__</code>这条线走的，因此在查找<code>f1.hasOwnProperty</code>属性时，就会顺着原型链一直查找到<code>Object.prototype</code>。</p>\n<p>由于所有对象的原型链都会找到<code>Object.prototype</code>，因此所有对象都会有<code>Object.prototype</code>的方法。这就是所谓的“继承”。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><blockquote>\n<p>下面这段代码的输出：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Setcount</span>(<span class=\"params\">count</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.count=count</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Setcount.prototype.printCount=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.count)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"keyword\">new</span> Setcount(<span class=\"number\">100</span>)</span><br><span class=\"line\">a.count =<span class=\"number\">200</span></span><br><span class=\"line\">a.__proto__.count=<span class=\"number\">300</span></span><br><span class=\"line\">a.__proto__.printCount()</span><br><span class=\"line\">a.printCount()</span><br></pre></td></tr></table></figure>\n\n<p>结果为300和200。</p>\n</blockquote>\n<blockquote>\n<p>下面这段代码的输出：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.foo = <span class=\"string\">&#x27;Object&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.foo = <span class=\"string\">&#x27;Function&#x27;</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.foo);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Animal.foo);</span><br></pre></td></tr></table></figure>\n\n<p>输出为Object 和 Function</p>\n</blockquote>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在学习JS中的原型，原型链，继承这些知识之前，我们先学习下基础知识：<strong>函数和对象的关系</strong>。</p>\n<p>我们一直都知道，函数也是对象的一种，因为通过<code>instanceof</code>就可以判断出来。但是函数和对象的关系并不是简单的包含和被包含的关系，这两者之间的关系还是有点复杂的。接下来我们就来捋一捋。</p>\n<p>首先，阐述一点，<strong>对象都是通过函数创建的</strong>。<br>对于下面这种类型的代码，一般叫做“语法糖”：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;<span class=\"attr\">a</span>:<span class=\"number\">10</span>,<span class=\"attr\">b</span>:<span class=\"number\">20</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">5</span>, <span class=\"string\">&#x27;x&#x27;</span>, <span class=\"literal\">true</span>];</span><br></pre></td></tr></table></figure>\n<p>但是，其实上面这段代码的实质是下面这样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">obj.a = <span class=\"number\">10</span>;</span><br><span class=\"line\">obj.b = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\">arr[<span class=\"number\">0</span>] = <span class=\"number\">5</span>;</span><br><span class=\"line\">arr[<span class=\"number\">1</span>] = <span class=\"string\">&#x27;x&#x27;</span>;</span><br><span class=\"line\">arr[<span class=\"number\">2</span>] = <span class=\"literal\">true</span>;</span><br></pre></td></tr></table></figure>\n<p>而<code>Object</code>和<code>Array</code>都是函数，可以自己用<code>typeof</code>函数进行验证。</p>\n<p>所以，可以得出：<strong>对象都是通过函数创建的</strong>。</p>\n<p>那么下面就进入正题。</p>\n<h2 id=\"原型prototype\"><a href=\"#原型prototype\" class=\"headerlink\" title=\"原型prototype\"></a>原型prototype</h2><p>在前言中，我们说了函数也是一种对象，所以函数也是属性的集合，同时，也可以对函数进行自定义属性。<br><strong>每个函数都有一个属性——prototype。这个prototype的属性值是一个对象（属性的集合），默认只有一个叫做constructor的属性，指向这个函数本身。</strong> 如下图所示：</p>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403154221307.png\" alt=\"image-20220403154221307\"></p>\n<p>上图中，<code>SuperType</code>是一个函数，右侧的方框就是<strong>它的原型</strong>。</p>\n<p>原型既然作为对象（属性的集合），除了<code>constructor</code>外，还可以自定义许多属性，比如下面这样的：</p>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403154324885.png\" alt=\"image-20220403154324885\"></p>\n<p>当然了，我们也可以在自己定义的方法的<code>prototype</code>中增加我们自己的属性，比如像下面这样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Fn</span>(<span class=\"params\"></span>) </span>&#123; &#125;</span><br><span class=\"line\">Fn.prototype.name = <span class=\"string\">&#x27;张三&#x27;</span>;</span><br><span class=\"line\">Fn.prototype.getAge = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">12</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> Fn();</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403154612542.png\" alt=\"image-20220403154612542\"></p>\n<p>Fn就是下面这样：</p>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403154633724.png\" alt=\"image-20220403154633724\"></p>\n<p>那么问题来了：函数的<code>prototype</code>到底有何用呢？</p>\n<p>在解决这个问题之前，我们还是先来看下另一个让人迷糊的属性：<code>__proto__</code></p>\n<h2 id=\"隐式原型-proto\"><a href=\"#隐式原型-proto\" class=\"headerlink\" title=\"隐式原型  _ proto_\"></a>隐式原型  _ proto_</h2><p>先看一段非常常见的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Fn</span>(<span class=\"params\"></span>) </span>&#123; &#125;</span><br><span class=\"line\">Fn.prototype.name = <span class=\"string\">&#x27;张三&#x27;</span>;</span><br><span class=\"line\">Fn.prototype.getAge = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">12</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"keyword\">new</span> Fn();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(fn.name);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(fn.getAge());</span><br></pre></td></tr></table></figure>\n<p>即，Fn是一个函数，fn对象是从Fn函数new出来的，这样fn对象就可以调用Fn.prototype中的属性。</p>\n<p>但是，因为每个对象都有一个隐藏的属性——<code> __proto__</code>，这个属性引用了<strong>创建这个对象的函数的prototype</strong>。即：<code>fn._proto_ === Fn.prototype</code><br>那么，这里的<code>__proto__</code>到底是什么呢？</p>\n<p>其实，这个<code>__proto__</code>是一个隐藏的属性，javascript不希望开发者用到这个属性值，有的低版本浏览器甚至不支持这个属性值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.__proto__);</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403160024050.png\" alt=\"image-20220403160024050\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.prototype);</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403160148483.png\" alt=\"image-20220403160148483\"></p>\n<p>从上面来看，<code>obj.__proto__</code>和<code>Object.prototype</code>的属性一样！为什么呢？</p>\n<p>原因是：obj这个对象本质上是被Object函数创建的，因此obj.<strong>__proto__</strong>=== Object.prototype。我们可以用一个图来表示。</p>\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403160408070.png' width=\"50%\">\n\n<p>即，<strong>每个对象都有一个__proto__属性，指向创建该对象的函数的prototype。</strong></p>\n<blockquote>\n<p><strong>说一下自定义函数的prototype：</strong><br>自定义函数的<code>prototype</code>本质上就是和 <code>var obj = &#123;&#125;</code> 是一样的，都是被<code>Object</code>创建，所以它的<code>__proto__</code>指向的就是<code>Object.prototype</code>。</p>\n</blockquote>\n<p>但是，**<code>Object.prototype</code>确实一个特例——它的<code>__proto__</code>指向的是<code>null</code>**。</p>\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403161118789.png' width=\"50%\">\n\n<p>另外一个问题：函数也是一种对象，函数也有<code>__proto__</code>吗？<br>答：当然也不例外啦！<br>下面用一段代码和一张图来说明这个问题，看完相信就有个比较直观的理解啦！</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x+y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(fn(<span class=\"number\">10</span>,<span class=\"number\">20</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以下只是为了演示函数被Function创建的</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>(<span class=\"string\">&quot;x&quot;</span>,<span class=\"string\">&quot;y&quot;</span>,<span class=\"string\">&quot;return x+y;&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(fn1(<span class=\"number\">5</span>,<span class=\"number\">6</span>));</span><br></pre></td></tr></table></figure>\n<p>用图表示就是：</p>\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403161731562.png' width=\"60%\">\n\n<p>从上图可以看出：自定义函数<code>Foo.__proto__</code>指向<code>Function.prototype</code>，<code>Object.__proto__</code>指向<code>Function.prototype</code>。</p>\n<p>但是，为什么有<code>Function.__proto__</code>指向<code>Function.prototype</code>呢？</p>\n<p>其实原因很简单：**<code>Function</code>也是一个函数，函数是一种对象，也有<code>__proto__</code>属性。既然是函数，那么它一定是被<code>Function</code>创建。所以<code>Function</code>是被自身创建的。所以它的<code>__proto__</code>指向了自身的<code>Prototype</code>**</p>\n<p>最后一个问题：<code>Function.prototype</code>指向的对象，它的<code>__proto__</code>是不是也指向<code>Object.prototype</code>？</p>\n<p>答案是肯定的。因为<code>Function.prototype</code>指向的对象也是一个普通的被<code>Object</code>创建的对象，所以也遵循基本的规则。如下图：</p>\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403162506341.png' width=\"50%\">\n\n<p>说了这么多，我们将上面这些图片整合到一整个图片，便于整体理解，图片如下：</p>\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403162639383.png' width=\"50%\">\n\n<h2 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h2><p>主要是说明下<code>instanceof</code>的判断规则是如何进行的。先看如下代码和图片：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> f1 = <span class=\"keyword\">new</span> Foo();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(f1 <span class=\"keyword\">instanceof</span> Foo);<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(f1 <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>);<span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403162850136.png' width=\"50%\">\n\n<p><code>instanceof</code>的判断规则为：<br>假设<code>instanceof</code>运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为B。</p>\n<p><code>instanceof</code>的判断规则是：沿着A的<code>__proto__</code>这条线来找，同时沿着B的<code>prototype</code>这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回<code>true</code>。如果找到终点还未重合，则返回<code>false</code>。</p>\n<p>结合这个判断规则，上面的代码和图示相信很容易看懂了。</p>\n<h2 id=\"原型继承\"><a href=\"#原型继承\" class=\"headerlink\" title=\"原型继承\"></a>原型继承</h2><p>首先说一下什么是原型链：<br><strong>访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着_proto_这条链向上找，这就是原型链</strong>。</p>\n<p>举一个例子说明下吧：<br>在实际应用中如何区分一个属性到底是基本的还是从原型中找到的呢？<br>答案就是：<code>hasOwnProperty</code>这个函数，特别是在for…in…循环中，一定要注意。</p>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403174502374.png\" alt=\"image-20220403174502374\"></p>\n<p>但是，<code>f1</code>本身并没有<code>hasOwnProperty</code>这个方法，那是从哪里来的呢？答案很简单，是从<code>Object.prototype</code>中来的。看下图：</p>\n<img src='https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220403174630283.png' width='70%'>\n\n<p>对象的原型链是沿着<code>__proto__</code>这条线走的，因此在查找<code>f1.hasOwnProperty</code>属性时，就会顺着原型链一直查找到<code>Object.prototype</code>。</p>\n<p>由于所有对象的原型链都会找到<code>Object.prototype</code>，因此所有对象都会有<code>Object.prototype</code>的方法。这就是所谓的“继承”。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><blockquote>\n<p>下面这段代码的输出：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Setcount</span>(<span class=\"params\">count</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">this</span>.count=count</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Setcount.prototype.printCount=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.count)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"keyword\">new</span> Setcount(<span class=\"number\">100</span>)</span><br><span class=\"line\">a.count =<span class=\"number\">200</span></span><br><span class=\"line\">a.__proto__.count=<span class=\"number\">300</span></span><br><span class=\"line\">a.__proto__.printCount()</span><br><span class=\"line\">a.printCount()</span><br></pre></td></tr></table></figure>\n\n<p>结果为300和200。</p>\n</blockquote>\n<blockquote>\n<p>下面这段代码的输出：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.foo = <span class=\"string\">&#x27;Object&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.foo = <span class=\"string\">&#x27;Function&#x27;</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Animal();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cat.foo);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Animal.foo);</span><br></pre></td></tr></table></figure>\n\n<p>输出为Object 和 Function</p>\n</blockquote>\n"},{"title":"Mac的常用操作","date":"2023-04-25T14:50:56.000Z","_content":"## 环境变量配置\n\n打开文件进行编辑\n\n```shell\nopen -e .zshrc\n```\n\n配置变量，然后Command + S 保存退出\n\n输入：\n\n```shell\nsource .zshrc\n```\n","source":"_posts/Mac的常用操作.md","raw":"---\ntitle: Mac的常用操作\ndate: 2023-04-25 22:50:56\ntags:\n---\n## 环境变量配置\n\n打开文件进行编辑\n\n```shell\nopen -e .zshrc\n```\n\n配置变量，然后Command + S 保存退出\n\n输入：\n\n```shell\nsource .zshrc\n```\n","slug":"Mac的常用操作","published":1,"updated":"2023-04-25T14:51:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmhg4qt400003f5fah6clgs70","content":"<h2 id=\"环境变量配置\"><a href=\"#环境变量配置\" class=\"headerlink\" title=\"环境变量配置\"></a>环境变量配置</h2><p>打开文件进行编辑</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open -e .zshrc</span><br></pre></td></tr></table></figure>\n<p>配置变量，然后Command + S 保存退出</p>\n<p>输入：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source .zshrc</span><br></pre></td></tr></table></figure>","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<h2 id=\"环境变量配置\"><a href=\"#环境变量配置\" class=\"headerlink\" title=\"环境变量配置\"></a>环境变量配置</h2><p>打开文件进行编辑</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open -e .zshrc</span><br></pre></td></tr></table></figure>\n<p>配置变量，然后Command + S 保存退出</p>\n<p>输入：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source .zshrc</span><br></pre></td></tr></table></figure>"},{"title":"React native开发","date":"2023-04-25T13:19:03.000Z","_content":"\n配置android环境\n\n```shell\nexport ANDROID_HOME=$HOME/Library/Android/sdk\nexport PATH=$PATH:$ANDROID_HOME/emulator\nexport PATH=$PATH:$ANDROID_HOME/tools\nexport PATH=$PATH:$ANDROID_HOME/tools/bin\nexport PATH=$PATH:$ANDROID_HOME/platform-tools\n```\n\n![1682428818056](image/React-native开发/1682428818056.png)\n","source":"_posts/React-native开发.md","raw":"---\ntitle: React native开发\ndate: 2023-04-25 21:19:03\ntags:\n---\n\n配置android环境\n\n```shell\nexport ANDROID_HOME=$HOME/Library/Android/sdk\nexport PATH=$PATH:$ANDROID_HOME/emulator\nexport PATH=$PATH:$ANDROID_HOME/tools\nexport PATH=$PATH:$ANDROID_HOME/tools/bin\nexport PATH=$PATH:$ANDROID_HOME/platform-tools\n```\n\n![1682428818056](image/React-native开发/1682428818056.png)\n","slug":"React-native开发","published":1,"updated":"2023-04-25T14:43:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmhg4qt400004f5facicu52c4","content":"<p>配置android环境</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export ANDROID_HOME=$HOME/Library/Android/sdk</span><br><span class=\"line\">export PATH=$PATH:$ANDROID_HOME/emulator</span><br><span class=\"line\">export PATH=$PATH:$ANDROID_HOME/tools</span><br><span class=\"line\">export PATH=$PATH:$ANDROID_HOME/tools/bin</span><br><span class=\"line\">export PATH=$PATH:$ANDROID_HOME/platform-tools</span><br></pre></td></tr></table></figure>\n<p><img src=\"image/React-native%E5%BC%80%E5%8F%91/1682428818056.png\" alt=\"1682428818056\"></p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<p>配置android环境</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export ANDROID_HOME=$HOME/Library/Android/sdk</span><br><span class=\"line\">export PATH=$PATH:$ANDROID_HOME/emulator</span><br><span class=\"line\">export PATH=$PATH:$ANDROID_HOME/tools</span><br><span class=\"line\">export PATH=$PATH:$ANDROID_HOME/tools/bin</span><br><span class=\"line\">export PATH=$PATH:$ANDROID_HOME/platform-tools</span><br></pre></td></tr></table></figure>\n<p><img src=\"image/React-native%E5%BC%80%E5%8F%91/1682428818056.png\" alt=\"1682428818056\"></p>\n"},{"title":"Ubuntu系统中的常用操作","date":"2023-04-24T12:37:11.000Z","_content":"\n## jenkins的配置\n\n安装jenkins：\n\nhttps://blog.csdn.net/wf908164152/article/details/125716221\n\n```shell\nsudo apt-get install maven\n```\n\n设置权限：\n\n```shell\nvim /etc/default/jenkins\n```\n\n![image-20230409210155014](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230409210155014.png)\n\n```shell\n# 把jenkins目录文件交给ubuntu用户\nchown -R ubuntu:ubuntu /var/lib/jenkins\n```\n\n安装gitee、maven、nodejs插件\n\n```shell\ncurl -sL https://deb.nodesource.com/setup_14.x | sudo bash -\nsudo apt -y install nodejs\n```\n\n![image-20230409201414802](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230409201414802.png)\n\n设置jenkins令牌（https://blog.csdn.net/weixin_44931933/article/details/127704724）\n\n新建项目：web hooks配置\n\n配置maven\n\n![image-20230409202701088](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230409202701088.png)\n\n## screen的使用\n\n参考文章：https://blog.csdn.net/qq_34131701/article/details/124353270\n\n\n## 防火墙的使用\n\nhttps://blog.csdn.net/yt_php/article/details/104233920/\n","source":"_posts/Ubuntu系统中的常用操作.md","raw":"---\ntitle: Ubuntu系统中的常用操作\ndate: 2023-04-24 20:37:11\ntags:\n---\n\n## jenkins的配置\n\n安装jenkins：\n\nhttps://blog.csdn.net/wf908164152/article/details/125716221\n\n```shell\nsudo apt-get install maven\n```\n\n设置权限：\n\n```shell\nvim /etc/default/jenkins\n```\n\n![image-20230409210155014](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230409210155014.png)\n\n```shell\n# 把jenkins目录文件交给ubuntu用户\nchown -R ubuntu:ubuntu /var/lib/jenkins\n```\n\n安装gitee、maven、nodejs插件\n\n```shell\ncurl -sL https://deb.nodesource.com/setup_14.x | sudo bash -\nsudo apt -y install nodejs\n```\n\n![image-20230409201414802](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230409201414802.png)\n\n设置jenkins令牌（https://blog.csdn.net/weixin_44931933/article/details/127704724）\n\n新建项目：web hooks配置\n\n配置maven\n\n![image-20230409202701088](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230409202701088.png)\n\n## screen的使用\n\n参考文章：https://blog.csdn.net/qq_34131701/article/details/124353270\n\n\n## 防火墙的使用\n\nhttps://blog.csdn.net/yt_php/article/details/104233920/\n","slug":"Ubuntu系统中的常用操作","published":1,"updated":"2023-04-24T12:57:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmhg4qt410005f5faalin8eim","content":"<h2 id=\"jenkins的配置\"><a href=\"#jenkins的配置\" class=\"headerlink\" title=\"jenkins的配置\"></a>jenkins的配置</h2><p>安装jenkins：</p>\n<p><a href=\"https://blog.csdn.net/wf908164152/article/details/125716221\">https://blog.csdn.net/wf908164152/article/details/125716221</a></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install maven</span><br></pre></td></tr></table></figure>\n<p>设置权限：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /etc/default/jenkins</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230409210155014.png\" alt=\"image-20230409210155014\"></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 把jenkins目录文件交给ubuntu用户</span></span><br><span class=\"line\">chown -R ubuntu:ubuntu /var/lib/jenkins</span><br></pre></td></tr></table></figure>\n<p>安装gitee、maven、nodejs插件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -sL https://deb.nodesource.com/setup_14.x | sudo bash -</span><br><span class=\"line\">sudo apt -y install nodejs</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230409201414802.png\" alt=\"image-20230409201414802\"></p>\n<p>设置jenkins令牌（<a href=\"https://blog.csdn.net/weixin_44931933/article/details/127704724%EF%BC%89\">https://blog.csdn.net/weixin_44931933/article/details/127704724）</a></p>\n<p>新建项目：web hooks配置</p>\n<p>配置maven</p>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230409202701088.png\" alt=\"image-20230409202701088\"></p>\n<h2 id=\"screen的使用\"><a href=\"#screen的使用\" class=\"headerlink\" title=\"screen的使用\"></a>screen的使用</h2><p>参考文章：<a href=\"https://blog.csdn.net/qq_34131701/article/details/124353270\">https://blog.csdn.net/qq_34131701/article/details/124353270</a></p>\n<h2 id=\"防火墙的使用\"><a href=\"#防火墙的使用\" class=\"headerlink\" title=\"防火墙的使用\"></a>防火墙的使用</h2><p><a href=\"https://blog.csdn.net/yt_php/article/details/104233920/\">https://blog.csdn.net/yt_php/article/details/104233920/</a></p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<h2 id=\"jenkins的配置\"><a href=\"#jenkins的配置\" class=\"headerlink\" title=\"jenkins的配置\"></a>jenkins的配置</h2><p>安装jenkins：</p>\n<p><a href=\"https://blog.csdn.net/wf908164152/article/details/125716221\">https://blog.csdn.net/wf908164152/article/details/125716221</a></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install maven</span><br></pre></td></tr></table></figure>\n<p>设置权限：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /etc/default/jenkins</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230409210155014.png\" alt=\"image-20230409210155014\"></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 把jenkins目录文件交给ubuntu用户</span></span><br><span class=\"line\">chown -R ubuntu:ubuntu /var/lib/jenkins</span><br></pre></td></tr></table></figure>\n<p>安装gitee、maven、nodejs插件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -sL https://deb.nodesource.com/setup_14.x | sudo bash -</span><br><span class=\"line\">sudo apt -y install nodejs</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230409201414802.png\" alt=\"image-20230409201414802\"></p>\n<p>设置jenkins令牌（<a href=\"https://blog.csdn.net/weixin_44931933/article/details/127704724%EF%BC%89\">https://blog.csdn.net/weixin_44931933/article/details/127704724）</a></p>\n<p>新建项目：web hooks配置</p>\n<p>配置maven</p>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/uPic/image-20230409202701088.png\" alt=\"image-20230409202701088\"></p>\n<h2 id=\"screen的使用\"><a href=\"#screen的使用\" class=\"headerlink\" title=\"screen的使用\"></a>screen的使用</h2><p>参考文章：<a href=\"https://blog.csdn.net/qq_34131701/article/details/124353270\">https://blog.csdn.net/qq_34131701/article/details/124353270</a></p>\n<h2 id=\"防火墙的使用\"><a href=\"#防火墙的使用\" class=\"headerlink\" title=\"防火墙的使用\"></a>防火墙的使用</h2><p><a href=\"https://blog.csdn.net/yt_php/article/details/104233920/\">https://blog.csdn.net/yt_php/article/details/104233920/</a></p>\n"},{"title":"提取邮件文件的全部附件的Python代码","date":"2024-07-04T16:39:17.000Z","_content":"\n## 如何提取邮件`.eml`文件的全部附件呢？\n\n可以使用下面这段`python`代码：\n\n```python\n\nimport os\nimport email\nfrom email import policy\nfrom email.parser import BytesParser\n\ndef save_attachments_from_eml(eml_file_path, output_dir, file_name):\n    # 读取 .eml 文件内容\n    with open(eml_file_path, 'rb') as f:\n        eml_content = f.read()\n\n    # 解析 .eml 文件\n    msg = BytesParser(policy=policy.default).parsebytes(eml_content)\n    \n    # 检查并保存附件\n    for part in msg.iter_attachments():\n        filename = part.get_filename()\n        if filename:\n            file_data = part.get_payload(decode=True)\n            \n            # 创建输出文件路径\n            output_file_path = os.path.join(output_dir, file_name + '-' + filename)\n            \n            # 将附件数据写入文件\n            with open(output_file_path, 'wb') as f:\n                f.write(file_data)\n            \n            print(f\"Saved attachment: {output_file_path}\")\n\neml_file_path = '/Users/wangmingjie/Desktop/NET'\noutput_dir = '/Users/wangmingjie/Desktop/NET-attachment'\nos.makedirs(output_dir, exist_ok=True)\n\n# 获取该路径下全部文件\nfiles = os.listdir(eml_file_path)\n\nfor file in files:\n    if file.endswith('.eml'):\n        # 将邮件名称作为file_name\n        file_name = file.split('.')[0]\n        save_attachments_from_eml(os.path.join(eml_file_path, file), output_dir, file_name)\n\n\nprint('存储完成，共存储了{}个文件'.format(len(files)))\n\n```","source":"_posts/parse-from-mail-attachment.md","raw":"---\ntitle: 提取邮件文件的全部附件的Python代码\ndate: 2024-07-05 00:39:17\ntags: 技术\n---\n\n## 如何提取邮件`.eml`文件的全部附件呢？\n\n可以使用下面这段`python`代码：\n\n```python\n\nimport os\nimport email\nfrom email import policy\nfrom email.parser import BytesParser\n\ndef save_attachments_from_eml(eml_file_path, output_dir, file_name):\n    # 读取 .eml 文件内容\n    with open(eml_file_path, 'rb') as f:\n        eml_content = f.read()\n\n    # 解析 .eml 文件\n    msg = BytesParser(policy=policy.default).parsebytes(eml_content)\n    \n    # 检查并保存附件\n    for part in msg.iter_attachments():\n        filename = part.get_filename()\n        if filename:\n            file_data = part.get_payload(decode=True)\n            \n            # 创建输出文件路径\n            output_file_path = os.path.join(output_dir, file_name + '-' + filename)\n            \n            # 将附件数据写入文件\n            with open(output_file_path, 'wb') as f:\n                f.write(file_data)\n            \n            print(f\"Saved attachment: {output_file_path}\")\n\neml_file_path = '/Users/wangmingjie/Desktop/NET'\noutput_dir = '/Users/wangmingjie/Desktop/NET-attachment'\nos.makedirs(output_dir, exist_ok=True)\n\n# 获取该路径下全部文件\nfiles = os.listdir(eml_file_path)\n\nfor file in files:\n    if file.endswith('.eml'):\n        # 将邮件名称作为file_name\n        file_name = file.split('.')[0]\n        save_attachments_from_eml(os.path.join(eml_file_path, file), output_dir, file_name)\n\n\nprint('存储完成，共存储了{}个文件'.format(len(files)))\n\n```","slug":"parse-from-mail-attachment","published":1,"updated":"2025-10-31T01:58:44.674Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmhg4qt410006f5fa2o51ep3q","content":"<h2 id=\"如何提取邮件-eml文件的全部附件呢？\"><a href=\"#如何提取邮件-eml文件的全部附件呢？\" class=\"headerlink\" title=\"如何提取邮件.eml文件的全部附件呢？\"></a>如何提取邮件<code>.eml</code>文件的全部附件呢？</h2><p>可以使用下面这段<code>python</code>代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> email</span><br><span class=\"line\"><span class=\"keyword\">from</span> email <span class=\"keyword\">import</span> policy</span><br><span class=\"line\"><span class=\"keyword\">from</span> email.parser <span class=\"keyword\">import</span> BytesParser</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">save_attachments_from_eml</span>(<span class=\"params\">eml_file_path, output_dir, file_name</span>):</span></span><br><span class=\"line\">    <span class=\"comment\"># 读取 .eml 文件内容</span></span><br><span class=\"line\">    <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(eml_file_path, <span class=\"string\">&#x27;rb&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">        eml_content = f.read()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 解析 .eml 文件</span></span><br><span class=\"line\">    msg = BytesParser(policy=policy.default).parsebytes(eml_content)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 检查并保存附件</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> part <span class=\"keyword\">in</span> msg.iter_attachments():</span><br><span class=\"line\">        filename = part.get_filename()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> filename:</span><br><span class=\"line\">            file_data = part.get_payload(decode=<span class=\"literal\">True</span>)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># 创建输出文件路径</span></span><br><span class=\"line\">            output_file_path = os.path.join(output_dir, file_name + <span class=\"string\">&#x27;-&#x27;</span> + filename)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># 将附件数据写入文件</span></span><br><span class=\"line\">            <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(output_file_path, <span class=\"string\">&#x27;wb&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">                f.write(file_data)</span><br><span class=\"line\">            </span><br><span class=\"line\">            print(<span class=\"string\">f&quot;Saved attachment: <span class=\"subst\">&#123;output_file_path&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">eml_file_path = <span class=\"string\">&#x27;/Users/wangmingjie/Desktop/NET&#x27;</span></span><br><span class=\"line\">output_dir = <span class=\"string\">&#x27;/Users/wangmingjie/Desktop/NET-attachment&#x27;</span></span><br><span class=\"line\">os.makedirs(output_dir, exist_ok=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取该路径下全部文件</span></span><br><span class=\"line\">files = os.listdir(eml_file_path)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> file <span class=\"keyword\">in</span> files:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> file.endswith(<span class=\"string\">&#x27;.eml&#x27;</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 将邮件名称作为file_name</span></span><br><span class=\"line\">        file_name = file.split(<span class=\"string\">&#x27;.&#x27;</span>)[<span class=\"number\">0</span>]</span><br><span class=\"line\">        save_attachments_from_eml(os.path.join(eml_file_path, file), output_dir, file_name)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">&#x27;存储完成，共存储了&#123;&#125;个文件&#x27;</span>.<span class=\"built_in\">format</span>(<span class=\"built_in\">len</span>(files)))</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<h2 id=\"如何提取邮件-eml文件的全部附件呢？\"><a href=\"#如何提取邮件-eml文件的全部附件呢？\" class=\"headerlink\" title=\"如何提取邮件.eml文件的全部附件呢？\"></a>如何提取邮件<code>.eml</code>文件的全部附件呢？</h2><p>可以使用下面这段<code>python</code>代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> email</span><br><span class=\"line\"><span class=\"keyword\">from</span> email <span class=\"keyword\">import</span> policy</span><br><span class=\"line\"><span class=\"keyword\">from</span> email.parser <span class=\"keyword\">import</span> BytesParser</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">save_attachments_from_eml</span>(<span class=\"params\">eml_file_path, output_dir, file_name</span>):</span></span><br><span class=\"line\">    <span class=\"comment\"># 读取 .eml 文件内容</span></span><br><span class=\"line\">    <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(eml_file_path, <span class=\"string\">&#x27;rb&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">        eml_content = f.read()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 解析 .eml 文件</span></span><br><span class=\"line\">    msg = BytesParser(policy=policy.default).parsebytes(eml_content)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 检查并保存附件</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> part <span class=\"keyword\">in</span> msg.iter_attachments():</span><br><span class=\"line\">        filename = part.get_filename()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> filename:</span><br><span class=\"line\">            file_data = part.get_payload(decode=<span class=\"literal\">True</span>)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># 创建输出文件路径</span></span><br><span class=\"line\">            output_file_path = os.path.join(output_dir, file_name + <span class=\"string\">&#x27;-&#x27;</span> + filename)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\"># 将附件数据写入文件</span></span><br><span class=\"line\">            <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(output_file_path, <span class=\"string\">&#x27;wb&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">                f.write(file_data)</span><br><span class=\"line\">            </span><br><span class=\"line\">            print(<span class=\"string\">f&quot;Saved attachment: <span class=\"subst\">&#123;output_file_path&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">eml_file_path = <span class=\"string\">&#x27;/Users/wangmingjie/Desktop/NET&#x27;</span></span><br><span class=\"line\">output_dir = <span class=\"string\">&#x27;/Users/wangmingjie/Desktop/NET-attachment&#x27;</span></span><br><span class=\"line\">os.makedirs(output_dir, exist_ok=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取该路径下全部文件</span></span><br><span class=\"line\">files = os.listdir(eml_file_path)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> file <span class=\"keyword\">in</span> files:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> file.endswith(<span class=\"string\">&#x27;.eml&#x27;</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 将邮件名称作为file_name</span></span><br><span class=\"line\">        file_name = file.split(<span class=\"string\">&#x27;.&#x27;</span>)[<span class=\"number\">0</span>]</span><br><span class=\"line\">        save_attachments_from_eml(os.path.join(eml_file_path, file), output_dir, file_name)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">&#x27;存储完成，共存储了&#123;&#125;个文件&#x27;</span>.<span class=\"built_in\">format</span>(<span class=\"built_in\">len</span>(files)))</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"leetcode-数组题","date":"2021-01-25T16:00:00.000Z","description":"leetcode上有关数组的题目","cover":"https://s3.ax1x.com/2020/12/31/rvEA3T.jpg","_content":"\n\n\n### 4 寻找两个正序数组的中位数\n\n1.遍历数组，使用类似于归并排序的两个指针一一比较大小\n\n时间复杂度：O(N)\n\n空间复杂度：O(1)\n\n执行用时：48 ms, 在所有 C++ 提交中击败了83.73%的用户\n\n内存消耗：86.9 MB, 在所有 C++ 提交中击败了95.52%的用户\n\n```c++\ndouble findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n\t//O(N)\n\tint i = -1, j = -1;\n\tint size1 = nums1.size(), size2 = nums2.size();\n\tif ((size1 + size2) % 2 == 0)\n\t{\n\t\t//even\n\t\tint a;\n\t\tfor (int k = 0; k < (size1 + size2) / 2 - 1; ++k)\n\t\t{\n\t\t\tif (i == size1 - 1)\n\t\t\t\t++j;\n\t\t\telse if (j == size2 - 1)\n\t\t\t\t++i;\n\t\t\telse if (nums1[i + 1] > nums2[j + 1])\n\t\t\t{\n\t\t\t\t++j;\n\t\t\t}\n\t\t\telse\n\t\t\t\t++i;\n\t\t}\n\t\t//choose two num;\n\t\tif (i == size1 - 1)\n\t\t\ta = nums2[++j];\n\t\telse if (j == size2 - 1)\n\t\t\ta = nums1[++i];\n\t\telse if (nums1[i + 1] > nums2[j + 1])\n\t\t{\n\t\t\ta = nums2[++j];\n\t\t}\n\t\telse\n\t\t\ta = nums1[++i];\n\t\tif (i == size1 - 1)\n\t\t\ta += nums2[++j];\n\t\telse if (j == size2 - 1)\n\t\t\ta += nums1[++i];\n\t\telse if (nums1[i + 1] > nums2[j + 1])\n\t\t{\n\t\t\ta += nums2[++j];\n\t\t}\n\t\telse\n\t\t\ta += nums1[++i];\n\t\treturn a / 2.0;\n\t}\n\telse\n\t{\n\t\tfor (int k = 0; k < (size1 + size2) / 2 ; ++k)\n\t\t{\n\t\t\tif (i == size1 - 1)\n\t\t\t\t++j;\n\t\t\telse if (j == size2 - 1)\n\t\t\t\t++i;\n\t\t\telse if (nums1[i + 1] > nums2[j + 1])\n\t\t\t{\n\t\t\t\t++j;\n\t\t\t}\n\t\t\telse\n\t\t\t\t++i;\n\t\t}\n\t\tif (i == size1 - 1)\n\t\t\treturn nums2[++j];\n\t\telse if (j == size2 - 1)\n\t\t\treturn nums1[++i];\n\t\telse if (nums1[i + 1] > nums2[j + 1])\n\t\t{\n\t\t\treturn nums2[++j];\n\t\t}\n\t\telse\n\t\t\treturn nums1[++i];\n\t}\n}\n```\n\n\n\n### 5 最长回文子串\n\n1.递推，利用状态转移方程dp[i] [j]表示字符串的i到j是否为回文串\n\n初始条件：\n\n- dp[i] [i]=true\n- dp[i] [i+1]= s[i]==s[i+1]\n\n转移条件：\n\n- dp[i] [j]= true if dp[i+1] [j-1] and s[i]==s[j]\n\n时间复杂度:O(N)\n\n空间复杂度:O(N)\n\n执行用时：456 ms, 在所有 C++ 提交中击败了41.14%的用户\n\n内存消耗：7.9 MB, 在所有 C++ 提交中击败了77.31%的用户\n\n```c++\nstring longestPalindrome(string s) {\n\tbool dp[1000][1000];\n\tint strLength = s.length();\n\tint maxS = -1, maxE = -1;\n\tfor (int i = 0; i < strLength; ++i)\n\t\tfor (int j = 0; j < strLength; ++j)\n\t\t\tdp[i][j] = false;\n\t//边界条件\n\tfor (int i = 0; i < strLength; ++i)\n\t{\n\t\tdp[i][i] = true;\n\t\tmaxS = i;\n\t\tmaxE = i;\n\t}\n\tfor (int i = 0; i < strLength - 1; ++i)\n\t\tif (s[i] == s[i + 1])\n\t\t{\n\t\t\tdp[i][i + 1] = true;\n\t\t\tmaxS = i;\n\t\t\tmaxE = i + 1;\n\t\t}\n\t//奇数转移方程\n\tfor (int i = 0; i < strLength; ++i)\n\t{\n\t\tfor (int j = 1; j <= i && j <= strLength - i - 1; ++j)\n\t\t{\n\t\t\tif (dp[i - j + 1][i + j - 1] && s[i - j] == s[i + j])\n\t\t\t{\n\t\t\t\tdp[i - j][i + j] = true;\n\t\t\t}\n\t\t\tif (dp[i - j][i + j] && 2 * j + 1 > maxE - maxS + 1)\n\t\t\t{\n\t\t\t\tmaxS = i - j;\n\t\t\t\tmaxE = i + j;\n\t\t\t}\n\t\t}\n\t}\n\t//偶数转移方程\n\tfor (int i = 0; i < strLength - 1; ++i)\n\t{\n\t\tfor (int j = 1; j <= i && j <= strLength - i - 2; ++j)\n\t\t{\n\t\t\tif (dp[i - j + 1][i + j ] && s[i - j] == s[i + j+1])\n\t\t\t{\n\t\t\t\tdp[i - j][i + j+1] = true;\n\t\t\t}\n\t\t\tif (dp[i - j][i + j+1] && 2 * j + 2 > maxE - maxS + 1)\n\t\t\t{\n\t\t\t\tmaxS = i - j;\n\t\t\t\tmaxE = i + j+1;\n\t\t\t}\n\t\t}\n\t}\n\tif (maxS == -1)\n\t\treturn \"\";\n\telse\n\t\treturn s.substr(maxS, maxE - maxS + 1);\n}\n```\n\n\n\n\n\n### 6.Z字形变换\n\n1.利用一个二维数组存储绘制出的Z字形，完成绘制后遍历二维数组每一个顺序输出\n\n时间复杂度：O(N²)\n\n空间复杂度：O(N²)\n\n执行用时：1288 ms, 在所有 C++ 提交中击败了5.08%的用户\n\n内存消耗：9.1 MB, 在所有 C++ 提交中击败了62.58%的用户\n\n```c++\nstring convert(string s, int numRows) {\n\tchar word[1000][1000] = { 0 };\n\tint row = 0, col = 0;\n\tbool shu = true;\n\tif (numRows == 1)\n\t\treturn s;\n\tfor (int i = 0; i < s.length(); ++i)\n\t{\n\t\tword[row][col] = s[i];\n\t\tif (shu)\n\t\t{\n\t\t\tif (row == numRows - 1)\n\t\t\t{\n\t\t\t\tshu = false;\n\t\t\t\t--row;\n\t\t\t\t++col;\n\t\t\t}\n\t\t\telse\n\t\t\t\t++row;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (row == 0)\n\t\t\t{\n\t\t\t\tshu = true;\n\t\t\t\t++row;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t--row;\n\t\t\t\t++col;\n\t\t\t}\n\t\t}\n\t}\n\t//顺序读取\n\tstring ans;\n\tfor (int i = 0; i < 1000; ++i)\n\t\tfor (int j = 0; j < 1000; ++j)\n\t\t\tif (word[i][j] != 0)\n\t\t\t\tans.push_back(word[i][j]);\n\treturn ans;\n}\n```\n\n2.思路类似于1，不过不再采用1中二维数组的方式存取数据\n\n而是借鉴稀疏矩阵的方法，定义一个Node，将其存储在vector< Node >中。在绘制完毕后，重载比较运算符来进行排序。\n\n时间复杂度：O(NlogN)\n\n空间复杂度：O(N)\n\n执行用时：36 ms, 在所有 C++ 提交中击败了20.65%的用户\n\n内存消耗：12.6 MB, 在所有 C++ 提交中击败了17.63%的用户\n\n```c++\nstruct Node\n{\n\tint row;\n\tint col;\n\tchar data;\n\tNode(int r, int c, char d)\n\t{\n\t\trow = r;\n\t\tcol = c;\n\t\tdata = d;\n\t}\n\tbool operator<(const Node& p2)\n\t{\n\t\tif (this->row < p2.row)\n\t\t\treturn true;\n\t\telse return (this->row == p2.row&&this->col < p2.col);\n\t\t\t\n\t}\n};\n\n\n\nstring convert(string s, int numRows) {\n\tvector<Node> result;//类似于稀疏矩阵\n\tint row = 0, col = 0;\n\tbool shu = true;\n\tif (numRows == 1)\n\t\treturn s;\n\tfor (int i = 0; i < s.length(); ++i)\n\t{\n\t\tresult.push_back(Node(row, col, s[i]));\n\t\tif (shu)\n\t\t{\n\t\t\tif (row == numRows - 1)\n\t\t\t{\n\t\t\t\tshu = false;\n\t\t\t\t--row;\n\t\t\t\t++col;\n\t\t\t}\n\t\t\telse\n\t\t\t\t++row;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (row == 0)\n\t\t\t{\n\t\t\t\tshu = true;\n\t\t\t\t++row;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t--row;\n\t\t\t\t++col;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//对内部进行排序，先比较行，行小的在前，紧接着比较列\n\t//时间复杂度为O(NlogN)\n\tsort(result.begin(), result.end());\n\tstring ans;\n\n\tfor (auto i = result.begin(); i != result.end(); ++i)\n\t{\n\t\tans.push_back(i->data);\n\t}\n\treturn ans;\n}\n```\n\n\n\n3.利用1的方法，不过不再采用二维数组存储，而是使用一个vector存储每一行的字符串。到每一行直接加入尾端即可。这样字符串总长度实际上只有N。\n\n时间复杂度：O（N）\n\n空间复杂度：O（N）\n\n执行用时：8 ms, 在所有 C++ 提交中击败了93.23%的用户\n\n内存消耗：10.5 MB, 在所有 C++ 提交中击败了57.73%的用户\n\n```c++\nstring convert(string s, int numRows) {\n\tvector<string> result(numRows);\n\tint row = 0, col = 0;\n\tbool shu = true;\n\tif (numRows == 1)\n\t\treturn s;\n\tfor (int i = 0; i < s.length(); ++i)\n\t{\n\t\tresult[row].push_back(s[i]);\n\t\tif (shu)\n\t\t{\n\t\t\tif (row == numRows - 1)\n\t\t\t{\n\t\t\t\tshu = false;\n\t\t\t\t--row;\n\t\t\t\t++col;\n\t\t\t}\n\t\t\telse\n\t\t\t\t++row;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (row == 0)\n\t\t\t{\n\t\t\t\tshu = true;\n\t\t\t\t++row;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t--row;\n\t\t\t\t++col;\n\t\t\t}\n\t\t}\n\t}\n\t//顺序读取\n\tstring ans;\n\tfor (int i = 0; i < numRows; ++i)\n\t\tans += result[i];\n\treturn ans;\n}\n```\n\n\n\n### 23 合并K组升序链表\n\n1.采用K路归并的思路\n\n时间复杂度：O（nk)\n\n执行用时：756 ms, 在所有 C++ 提交中击败了7.77%的用户\n\n内存消耗：12.6 MB, 在所有 C++ 提交中击败了98.43%的用户\n\n```c++\nListNode* mergeKLists(vector<ListNode*>& lists) {\n        int n = lists.size();\n        bool allZero = false;\n        //N路归并\n        ListNode* head = new ListNode();\n        ListNode* ptr = head;\n        while (!allZero)\n        {\n            int minNum = 99999;\n            int index = -1;\n            for (int i = 0; i < n; ++i)\n            {\n                if (lists[i] != nullptr&&lists[i]->val < minNum)\n                {\n                    index = i;\n                    minNum = lists[i]->val;\n                }\n            }\n            //找到最小的了\n            if (index == -1)\n                allZero = true;\n            else\n            {\n                ptr->next = lists[index];\n                ptr = ptr->next;\n                lists[index] = lists[index]->next;\n            }\n        }\n        return head->next;\n    }\n```\n\n\n\n2.采用二路归并的思路\n\n时间复杂度：O（NlogK)\n\n执行用时：20 ms, 在所有 C++ 提交中击败了99.49%的用户\n\n内存消耗：22.2 MB, 在所有 C++ 提交中击败了13.34%的用户\n\n```c++\n//归并从下标start开始的n个链表\nListNode* merge2Lists(vector<ListNode*>& lists, int start,int n) {\n\tif (n == 0)\n\t\treturn nullptr;\n\tif (n == 1)\n\t\treturn lists[start];\n\tListNode* p1 = merge2Lists(lists, start, n / 2);\n\tListNode* p2 = merge2Lists(lists, start + n / 2, n - (n / 2));\n\t//对p1和p2进行归并\n\tListNode* head = new ListNode();\n\tListNode* ptr = head;\n\twhile (p1 != nullptr&&p2 != nullptr) {\n\t\tif (p1->val < p2->val) {\n\t\t\tptr->next = p1;\n\t\t\tp1 = p1->next;\n\t\t\tptr = ptr->next;\n\t\t}\n\t\telse {\n\t\t\tptr->next = p2;\n\t\t\tp2 = p2->next;\n\t\t\tptr = ptr->next;\n\t\t}\n\t}\n\twhile (p1 != nullptr) {\n\t\tptr->next = p1;\n\t\tp1 = p1->next;\n\t\tptr = ptr->next;\n\t}\n\twhile (p2 != nullptr) {\n\t\tptr->next = p2;\n\t\tp2 = p2->next;\n\t\tptr = ptr->next;\n\t}\n\treturn head->next;\n}\n\nListNode* mergeKLists(vector<ListNode*>& lists) {\n\treturn merge2Lists(lists, 0, lists.size());\n}\n```\n\n\n\n### 最小水位\n\n类似于最小生成树，使用优先级队列存储\n\n时间复杂度：O（N²logK)\n\n```c++\nstruct GridNode {\n\tint row;\n\tint col;\n\tint index;\n\t//const很重要!\n\tbool operator<(const GridNode& node)const {\n\t\treturn this->index < node.index;\n\t}\n\tbool operator>(const GridNode& node)const {\n\t\treturn this->index > node.index;\n\t}\n\n\tGridNode(int r, int c, int i) :row(r), col(c), index(i) {};\n\tGridNode() {};\n};\n\nint swimInWater(vector<vector<int>>& grid) {\n\tpriority_queue<GridNode,vector<GridNode>,greater<GridNode>> q;\n\tint n = grid.size();\n\n\t//初始化\n\tint minshuiwei = grid[0][0];\n\tgrid[0][0] = -1;\n\tq.push(GridNode(0, 1, grid[0][1]));\n\tq.push(GridNode(1, 0, grid[1][0]));\n\twhile (grid[n - 1][n - 1] != -1) {\n\t\t//找出当前最小的水位\n\t\tGridNode temp = q.top();\n\t\tq.pop();\n\t\tgrid[temp.row][temp.col] = -1;\n\t\tif (temp.index > minshuiwei) {\n\t\t\tminshuiwei = temp.index;\n\t\t}\n\t\t//加入其上下左右\n\t\tif (temp.row != 0 && grid[temp.row - 1][temp.col] != -1) {\n\t\t\tq.push(GridNode(temp.row - 1, temp.col, grid[temp.row - 1][temp.col]));\n\t\t}\n\t\tif (temp.col != 0 && grid[temp.row][temp.col - 1] != -1) {\n\t\t\tq.push(GridNode(temp.row, temp.col - 1, grid[temp.row][temp.col - 1]));\n\t\t}\n\t\tif (temp.row != n - 1 && grid[temp.row + 1][temp.col] != -1) {\n\t\t\tq.push(GridNode(temp.row + 1, temp.col, grid[temp.row + 1][temp.col]));\n\t\t}\n\t\tif (temp.col != n - 1 && grid[temp.row][temp.col + 1] != -1) {\n\t\t\tq.push(GridNode(temp.row, temp.col + 1, grid[temp.row][temp.col + 1]));\n\t\t}\n\n\t}\n\treturn minshuiwei;\n}\n```\n\n","source":"_posts/leetcode刷题.md","raw":"---\ntitle: leetcode-数组题\ndate: 2021-1-26 00:00:00\ndescription: leetcode上有关数组的题目\ncover: https://s3.ax1x.com/2020/12/31/rvEA3T.jpg\n---\n\n\n\n### 4 寻找两个正序数组的中位数\n\n1.遍历数组，使用类似于归并排序的两个指针一一比较大小\n\n时间复杂度：O(N)\n\n空间复杂度：O(1)\n\n执行用时：48 ms, 在所有 C++ 提交中击败了83.73%的用户\n\n内存消耗：86.9 MB, 在所有 C++ 提交中击败了95.52%的用户\n\n```c++\ndouble findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n\t//O(N)\n\tint i = -1, j = -1;\n\tint size1 = nums1.size(), size2 = nums2.size();\n\tif ((size1 + size2) % 2 == 0)\n\t{\n\t\t//even\n\t\tint a;\n\t\tfor (int k = 0; k < (size1 + size2) / 2 - 1; ++k)\n\t\t{\n\t\t\tif (i == size1 - 1)\n\t\t\t\t++j;\n\t\t\telse if (j == size2 - 1)\n\t\t\t\t++i;\n\t\t\telse if (nums1[i + 1] > nums2[j + 1])\n\t\t\t{\n\t\t\t\t++j;\n\t\t\t}\n\t\t\telse\n\t\t\t\t++i;\n\t\t}\n\t\t//choose two num;\n\t\tif (i == size1 - 1)\n\t\t\ta = nums2[++j];\n\t\telse if (j == size2 - 1)\n\t\t\ta = nums1[++i];\n\t\telse if (nums1[i + 1] > nums2[j + 1])\n\t\t{\n\t\t\ta = nums2[++j];\n\t\t}\n\t\telse\n\t\t\ta = nums1[++i];\n\t\tif (i == size1 - 1)\n\t\t\ta += nums2[++j];\n\t\telse if (j == size2 - 1)\n\t\t\ta += nums1[++i];\n\t\telse if (nums1[i + 1] > nums2[j + 1])\n\t\t{\n\t\t\ta += nums2[++j];\n\t\t}\n\t\telse\n\t\t\ta += nums1[++i];\n\t\treturn a / 2.0;\n\t}\n\telse\n\t{\n\t\tfor (int k = 0; k < (size1 + size2) / 2 ; ++k)\n\t\t{\n\t\t\tif (i == size1 - 1)\n\t\t\t\t++j;\n\t\t\telse if (j == size2 - 1)\n\t\t\t\t++i;\n\t\t\telse if (nums1[i + 1] > nums2[j + 1])\n\t\t\t{\n\t\t\t\t++j;\n\t\t\t}\n\t\t\telse\n\t\t\t\t++i;\n\t\t}\n\t\tif (i == size1 - 1)\n\t\t\treturn nums2[++j];\n\t\telse if (j == size2 - 1)\n\t\t\treturn nums1[++i];\n\t\telse if (nums1[i + 1] > nums2[j + 1])\n\t\t{\n\t\t\treturn nums2[++j];\n\t\t}\n\t\telse\n\t\t\treturn nums1[++i];\n\t}\n}\n```\n\n\n\n### 5 最长回文子串\n\n1.递推，利用状态转移方程dp[i] [j]表示字符串的i到j是否为回文串\n\n初始条件：\n\n- dp[i] [i]=true\n- dp[i] [i+1]= s[i]==s[i+1]\n\n转移条件：\n\n- dp[i] [j]= true if dp[i+1] [j-1] and s[i]==s[j]\n\n时间复杂度:O(N)\n\n空间复杂度:O(N)\n\n执行用时：456 ms, 在所有 C++ 提交中击败了41.14%的用户\n\n内存消耗：7.9 MB, 在所有 C++ 提交中击败了77.31%的用户\n\n```c++\nstring longestPalindrome(string s) {\n\tbool dp[1000][1000];\n\tint strLength = s.length();\n\tint maxS = -1, maxE = -1;\n\tfor (int i = 0; i < strLength; ++i)\n\t\tfor (int j = 0; j < strLength; ++j)\n\t\t\tdp[i][j] = false;\n\t//边界条件\n\tfor (int i = 0; i < strLength; ++i)\n\t{\n\t\tdp[i][i] = true;\n\t\tmaxS = i;\n\t\tmaxE = i;\n\t}\n\tfor (int i = 0; i < strLength - 1; ++i)\n\t\tif (s[i] == s[i + 1])\n\t\t{\n\t\t\tdp[i][i + 1] = true;\n\t\t\tmaxS = i;\n\t\t\tmaxE = i + 1;\n\t\t}\n\t//奇数转移方程\n\tfor (int i = 0; i < strLength; ++i)\n\t{\n\t\tfor (int j = 1; j <= i && j <= strLength - i - 1; ++j)\n\t\t{\n\t\t\tif (dp[i - j + 1][i + j - 1] && s[i - j] == s[i + j])\n\t\t\t{\n\t\t\t\tdp[i - j][i + j] = true;\n\t\t\t}\n\t\t\tif (dp[i - j][i + j] && 2 * j + 1 > maxE - maxS + 1)\n\t\t\t{\n\t\t\t\tmaxS = i - j;\n\t\t\t\tmaxE = i + j;\n\t\t\t}\n\t\t}\n\t}\n\t//偶数转移方程\n\tfor (int i = 0; i < strLength - 1; ++i)\n\t{\n\t\tfor (int j = 1; j <= i && j <= strLength - i - 2; ++j)\n\t\t{\n\t\t\tif (dp[i - j + 1][i + j ] && s[i - j] == s[i + j+1])\n\t\t\t{\n\t\t\t\tdp[i - j][i + j+1] = true;\n\t\t\t}\n\t\t\tif (dp[i - j][i + j+1] && 2 * j + 2 > maxE - maxS + 1)\n\t\t\t{\n\t\t\t\tmaxS = i - j;\n\t\t\t\tmaxE = i + j+1;\n\t\t\t}\n\t\t}\n\t}\n\tif (maxS == -1)\n\t\treturn \"\";\n\telse\n\t\treturn s.substr(maxS, maxE - maxS + 1);\n}\n```\n\n\n\n\n\n### 6.Z字形变换\n\n1.利用一个二维数组存储绘制出的Z字形，完成绘制后遍历二维数组每一个顺序输出\n\n时间复杂度：O(N²)\n\n空间复杂度：O(N²)\n\n执行用时：1288 ms, 在所有 C++ 提交中击败了5.08%的用户\n\n内存消耗：9.1 MB, 在所有 C++ 提交中击败了62.58%的用户\n\n```c++\nstring convert(string s, int numRows) {\n\tchar word[1000][1000] = { 0 };\n\tint row = 0, col = 0;\n\tbool shu = true;\n\tif (numRows == 1)\n\t\treturn s;\n\tfor (int i = 0; i < s.length(); ++i)\n\t{\n\t\tword[row][col] = s[i];\n\t\tif (shu)\n\t\t{\n\t\t\tif (row == numRows - 1)\n\t\t\t{\n\t\t\t\tshu = false;\n\t\t\t\t--row;\n\t\t\t\t++col;\n\t\t\t}\n\t\t\telse\n\t\t\t\t++row;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (row == 0)\n\t\t\t{\n\t\t\t\tshu = true;\n\t\t\t\t++row;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t--row;\n\t\t\t\t++col;\n\t\t\t}\n\t\t}\n\t}\n\t//顺序读取\n\tstring ans;\n\tfor (int i = 0; i < 1000; ++i)\n\t\tfor (int j = 0; j < 1000; ++j)\n\t\t\tif (word[i][j] != 0)\n\t\t\t\tans.push_back(word[i][j]);\n\treturn ans;\n}\n```\n\n2.思路类似于1，不过不再采用1中二维数组的方式存取数据\n\n而是借鉴稀疏矩阵的方法，定义一个Node，将其存储在vector< Node >中。在绘制完毕后，重载比较运算符来进行排序。\n\n时间复杂度：O(NlogN)\n\n空间复杂度：O(N)\n\n执行用时：36 ms, 在所有 C++ 提交中击败了20.65%的用户\n\n内存消耗：12.6 MB, 在所有 C++ 提交中击败了17.63%的用户\n\n```c++\nstruct Node\n{\n\tint row;\n\tint col;\n\tchar data;\n\tNode(int r, int c, char d)\n\t{\n\t\trow = r;\n\t\tcol = c;\n\t\tdata = d;\n\t}\n\tbool operator<(const Node& p2)\n\t{\n\t\tif (this->row < p2.row)\n\t\t\treturn true;\n\t\telse return (this->row == p2.row&&this->col < p2.col);\n\t\t\t\n\t}\n};\n\n\n\nstring convert(string s, int numRows) {\n\tvector<Node> result;//类似于稀疏矩阵\n\tint row = 0, col = 0;\n\tbool shu = true;\n\tif (numRows == 1)\n\t\treturn s;\n\tfor (int i = 0; i < s.length(); ++i)\n\t{\n\t\tresult.push_back(Node(row, col, s[i]));\n\t\tif (shu)\n\t\t{\n\t\t\tif (row == numRows - 1)\n\t\t\t{\n\t\t\t\tshu = false;\n\t\t\t\t--row;\n\t\t\t\t++col;\n\t\t\t}\n\t\t\telse\n\t\t\t\t++row;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (row == 0)\n\t\t\t{\n\t\t\t\tshu = true;\n\t\t\t\t++row;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t--row;\n\t\t\t\t++col;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//对内部进行排序，先比较行，行小的在前，紧接着比较列\n\t//时间复杂度为O(NlogN)\n\tsort(result.begin(), result.end());\n\tstring ans;\n\n\tfor (auto i = result.begin(); i != result.end(); ++i)\n\t{\n\t\tans.push_back(i->data);\n\t}\n\treturn ans;\n}\n```\n\n\n\n3.利用1的方法，不过不再采用二维数组存储，而是使用一个vector存储每一行的字符串。到每一行直接加入尾端即可。这样字符串总长度实际上只有N。\n\n时间复杂度：O（N）\n\n空间复杂度：O（N）\n\n执行用时：8 ms, 在所有 C++ 提交中击败了93.23%的用户\n\n内存消耗：10.5 MB, 在所有 C++ 提交中击败了57.73%的用户\n\n```c++\nstring convert(string s, int numRows) {\n\tvector<string> result(numRows);\n\tint row = 0, col = 0;\n\tbool shu = true;\n\tif (numRows == 1)\n\t\treturn s;\n\tfor (int i = 0; i < s.length(); ++i)\n\t{\n\t\tresult[row].push_back(s[i]);\n\t\tif (shu)\n\t\t{\n\t\t\tif (row == numRows - 1)\n\t\t\t{\n\t\t\t\tshu = false;\n\t\t\t\t--row;\n\t\t\t\t++col;\n\t\t\t}\n\t\t\telse\n\t\t\t\t++row;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (row == 0)\n\t\t\t{\n\t\t\t\tshu = true;\n\t\t\t\t++row;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t--row;\n\t\t\t\t++col;\n\t\t\t}\n\t\t}\n\t}\n\t//顺序读取\n\tstring ans;\n\tfor (int i = 0; i < numRows; ++i)\n\t\tans += result[i];\n\treturn ans;\n}\n```\n\n\n\n### 23 合并K组升序链表\n\n1.采用K路归并的思路\n\n时间复杂度：O（nk)\n\n执行用时：756 ms, 在所有 C++ 提交中击败了7.77%的用户\n\n内存消耗：12.6 MB, 在所有 C++ 提交中击败了98.43%的用户\n\n```c++\nListNode* mergeKLists(vector<ListNode*>& lists) {\n        int n = lists.size();\n        bool allZero = false;\n        //N路归并\n        ListNode* head = new ListNode();\n        ListNode* ptr = head;\n        while (!allZero)\n        {\n            int minNum = 99999;\n            int index = -1;\n            for (int i = 0; i < n; ++i)\n            {\n                if (lists[i] != nullptr&&lists[i]->val < minNum)\n                {\n                    index = i;\n                    minNum = lists[i]->val;\n                }\n            }\n            //找到最小的了\n            if (index == -1)\n                allZero = true;\n            else\n            {\n                ptr->next = lists[index];\n                ptr = ptr->next;\n                lists[index] = lists[index]->next;\n            }\n        }\n        return head->next;\n    }\n```\n\n\n\n2.采用二路归并的思路\n\n时间复杂度：O（NlogK)\n\n执行用时：20 ms, 在所有 C++ 提交中击败了99.49%的用户\n\n内存消耗：22.2 MB, 在所有 C++ 提交中击败了13.34%的用户\n\n```c++\n//归并从下标start开始的n个链表\nListNode* merge2Lists(vector<ListNode*>& lists, int start,int n) {\n\tif (n == 0)\n\t\treturn nullptr;\n\tif (n == 1)\n\t\treturn lists[start];\n\tListNode* p1 = merge2Lists(lists, start, n / 2);\n\tListNode* p2 = merge2Lists(lists, start + n / 2, n - (n / 2));\n\t//对p1和p2进行归并\n\tListNode* head = new ListNode();\n\tListNode* ptr = head;\n\twhile (p1 != nullptr&&p2 != nullptr) {\n\t\tif (p1->val < p2->val) {\n\t\t\tptr->next = p1;\n\t\t\tp1 = p1->next;\n\t\t\tptr = ptr->next;\n\t\t}\n\t\telse {\n\t\t\tptr->next = p2;\n\t\t\tp2 = p2->next;\n\t\t\tptr = ptr->next;\n\t\t}\n\t}\n\twhile (p1 != nullptr) {\n\t\tptr->next = p1;\n\t\tp1 = p1->next;\n\t\tptr = ptr->next;\n\t}\n\twhile (p2 != nullptr) {\n\t\tptr->next = p2;\n\t\tp2 = p2->next;\n\t\tptr = ptr->next;\n\t}\n\treturn head->next;\n}\n\nListNode* mergeKLists(vector<ListNode*>& lists) {\n\treturn merge2Lists(lists, 0, lists.size());\n}\n```\n\n\n\n### 最小水位\n\n类似于最小生成树，使用优先级队列存储\n\n时间复杂度：O（N²logK)\n\n```c++\nstruct GridNode {\n\tint row;\n\tint col;\n\tint index;\n\t//const很重要!\n\tbool operator<(const GridNode& node)const {\n\t\treturn this->index < node.index;\n\t}\n\tbool operator>(const GridNode& node)const {\n\t\treturn this->index > node.index;\n\t}\n\n\tGridNode(int r, int c, int i) :row(r), col(c), index(i) {};\n\tGridNode() {};\n};\n\nint swimInWater(vector<vector<int>>& grid) {\n\tpriority_queue<GridNode,vector<GridNode>,greater<GridNode>> q;\n\tint n = grid.size();\n\n\t//初始化\n\tint minshuiwei = grid[0][0];\n\tgrid[0][0] = -1;\n\tq.push(GridNode(0, 1, grid[0][1]));\n\tq.push(GridNode(1, 0, grid[1][0]));\n\twhile (grid[n - 1][n - 1] != -1) {\n\t\t//找出当前最小的水位\n\t\tGridNode temp = q.top();\n\t\tq.pop();\n\t\tgrid[temp.row][temp.col] = -1;\n\t\tif (temp.index > minshuiwei) {\n\t\t\tminshuiwei = temp.index;\n\t\t}\n\t\t//加入其上下左右\n\t\tif (temp.row != 0 && grid[temp.row - 1][temp.col] != -1) {\n\t\t\tq.push(GridNode(temp.row - 1, temp.col, grid[temp.row - 1][temp.col]));\n\t\t}\n\t\tif (temp.col != 0 && grid[temp.row][temp.col - 1] != -1) {\n\t\t\tq.push(GridNode(temp.row, temp.col - 1, grid[temp.row][temp.col - 1]));\n\t\t}\n\t\tif (temp.row != n - 1 && grid[temp.row + 1][temp.col] != -1) {\n\t\t\tq.push(GridNode(temp.row + 1, temp.col, grid[temp.row + 1][temp.col]));\n\t\t}\n\t\tif (temp.col != n - 1 && grid[temp.row][temp.col + 1] != -1) {\n\t\t\tq.push(GridNode(temp.row, temp.col + 1, grid[temp.row][temp.col + 1]));\n\t\t}\n\n\t}\n\treturn minshuiwei;\n}\n```\n\n","slug":"leetcode刷题","published":1,"updated":"2022-03-19T06:14:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmhg4qt410007f5fa1ptsdx88","content":"<h3 id=\"4-寻找两个正序数组的中位数\"><a href=\"#4-寻找两个正序数组的中位数\" class=\"headerlink\" title=\"4 寻找两个正序数组的中位数\"></a>4 寻找两个正序数组的中位数</h3><p>1.遍历数组，使用类似于归并排序的两个指针一一比较大小</p>\n<p>时间复杂度：O(N)</p>\n<p>空间复杂度：O(1)</p>\n<p>执行用时：48 ms, 在所有 C++ 提交中击败了83.73%的用户</p>\n<p>内存消耗：86.9 MB, 在所有 C++ 提交中击败了95.52%的用户</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">findMedianSortedArrays</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums1, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//O(N)</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = <span class=\"number\">-1</span>, j = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> size1 = nums1.size(), size2 = nums2.size();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((size1 + size2) % <span class=\"number\">2</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//even</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> a;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; (size1 + size2) / <span class=\"number\">2</span> - <span class=\"number\">1</span>; ++k)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i == size1 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t\t++j;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j == size2 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t\t++i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums1[i + <span class=\"number\">1</span>] &gt; nums2[j + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t++j;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t++i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//choose two num;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i == size1 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\ta = nums2[++j];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j == size2 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\ta = nums1[++i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums1[i + <span class=\"number\">1</span>] &gt; nums2[j + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ta = nums2[++j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\ta = nums1[++i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i == size1 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\ta += nums2[++j];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j == size2 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\ta += nums1[++i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums1[i + <span class=\"number\">1</span>] &gt; nums2[j + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ta += nums2[++j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\ta += nums1[++i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a / <span class=\"number\">2.0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; (size1 + size2) / <span class=\"number\">2</span> ; ++k)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i == size1 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t\t++j;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j == size2 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t\t++i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums1[i + <span class=\"number\">1</span>] &gt; nums2[j + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t++j;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t++i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i == size1 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> nums2[++j];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j == size2 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> nums1[++i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums1[i + <span class=\"number\">1</span>] &gt; nums2[j + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> nums2[++j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> nums1[++i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"5-最长回文子串\"><a href=\"#5-最长回文子串\" class=\"headerlink\" title=\"5 最长回文子串\"></a>5 最长回文子串</h3><p>1.递推，利用状态转移方程dp[i] [j]表示字符串的i到j是否为回文串</p>\n<p>初始条件：</p>\n<ul>\n<li>dp[i] [i]=true</li>\n<li>dp[i] [i+1]= s[i]==s[i+1]</li>\n</ul>\n<p>转移条件：</p>\n<ul>\n<li>dp[i] [j]= true if dp[i+1] [j-1] and s[i]==s[j]</li>\n</ul>\n<p>时间复杂度:O(N)</p>\n<p>空间复杂度:O(N)</p>\n<p>执行用时：456 ms, 在所有 C++ 提交中击败了41.14%的用户</p>\n<p>内存消耗：7.9 MB, 在所有 C++ 提交中击败了77.31%的用户</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> dp[<span class=\"number\">1000</span>][<span class=\"number\">1000</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> strLength = s.length();</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> maxS = <span class=\"number\">-1</span>, maxE = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; strLength; ++i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; strLength; ++j)</span><br><span class=\"line\">\t\t\tdp[i][j] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//边界条件</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; strLength; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tdp[i][i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\tmaxS = i;</span><br><span class=\"line\">\t\tmaxE = i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; strLength - <span class=\"number\">1</span>; ++i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (s[i] == s[i + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tdp[i][i + <span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\tmaxS = i;</span><br><span class=\"line\">\t\t\tmaxE = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//奇数转移方程</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; strLength; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= i &amp;&amp; j &lt;= strLength - i - <span class=\"number\">1</span>; ++j)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (dp[i - j + <span class=\"number\">1</span>][i + j - <span class=\"number\">1</span>] &amp;&amp; s[i - j] == s[i + j])</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tdp[i - j][i + j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (dp[i - j][i + j] &amp;&amp; <span class=\"number\">2</span> * j + <span class=\"number\">1</span> &gt; maxE - maxS + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tmaxS = i - j;</span><br><span class=\"line\">\t\t\t\tmaxE = i + j;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//偶数转移方程</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; strLength - <span class=\"number\">1</span>; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= i &amp;&amp; j &lt;= strLength - i - <span class=\"number\">2</span>; ++j)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (dp[i - j + <span class=\"number\">1</span>][i + j ] &amp;&amp; s[i - j] == s[i + j+<span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tdp[i - j][i + j+<span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (dp[i - j][i + j+<span class=\"number\">1</span>] &amp;&amp; <span class=\"number\">2</span> * j + <span class=\"number\">2</span> &gt; maxE - maxS + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tmaxS = i - j;</span><br><span class=\"line\">\t\t\t\tmaxE = i + j+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (maxS == <span class=\"number\">-1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> s.substr(maxS, maxE - maxS + <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h3 id=\"6-Z字形变换\"><a href=\"#6-Z字形变换\" class=\"headerlink\" title=\"6.Z字形变换\"></a>6.Z字形变换</h3><p>1.利用一个二维数组存储绘制出的Z字形，完成绘制后遍历二维数组每一个顺序输出</p>\n<p>时间复杂度：O(N²)</p>\n<p>空间复杂度：O(N²)</p>\n<p>执行用时：1288 ms, 在所有 C++ 提交中击败了5.08%的用户</p>\n<p>内存消耗：9.1 MB, 在所有 C++ 提交中击败了62.58%的用户</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">convert</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> numRows)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> word[<span class=\"number\">1000</span>][<span class=\"number\">1000</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> row = <span class=\"number\">0</span>, col = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> shu = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (numRows == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> s;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tword[row][col] = s[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (shu)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (row == numRows - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tshu = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t\t--row;</span><br><span class=\"line\">\t\t\t\t++col;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t++row;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (row == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tshu = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t\t++row;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t--row;</span><br><span class=\"line\">\t\t\t\t++col;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//顺序读取</span></span><br><span class=\"line\">\t<span class=\"built_in\">string</span> ans;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; ++i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">1000</span>; ++j)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (word[i][j] != <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\tans.push_back(word[i][j]);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2.思路类似于1，不过不再采用1中二维数组的方式存取数据</p>\n<p>而是借鉴稀疏矩阵的方法，定义一个Node，将其存储在vector&lt; Node &gt;中。在绘制完毕后，重载比较运算符来进行排序。</p>\n<p>时间复杂度：O(NlogN)</p>\n<p>空间复杂度：O(N)</p>\n<p>执行用时：36 ms, 在所有 C++ 提交中击败了20.65%的用户</p>\n<p>内存消耗：12.6 MB, 在所有 C++ 提交中击败了17.63%的用户</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> row;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> col;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> data;</span><br><span class=\"line\">\tNode(<span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> c, <span class=\"keyword\">char</span> d)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\trow = r;</span><br><span class=\"line\">\t\tcol = c;</span><br><span class=\"line\">\t\tdata = d;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"keyword\">const</span> Node&amp; p2)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;row &lt; p2.row)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span>-&gt;row == p2.row&amp;&amp;<span class=\"keyword\">this</span>-&gt;col &lt; p2.col);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">convert</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> numRows)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;Node&gt; result;<span class=\"comment\">//类似于稀疏矩阵</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> row = <span class=\"number\">0</span>, col = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> shu = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (numRows == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> s;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tresult.push_back(Node(row, col, s[i]));</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (shu)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (row == numRows - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tshu = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t\t--row;</span><br><span class=\"line\">\t\t\t\t++col;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t++row;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (row == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tshu = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t\t++row;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t--row;</span><br><span class=\"line\">\t\t\t\t++col;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//对内部进行排序，先比较行，行小的在前，紧接着比较列</span></span><br><span class=\"line\">\t<span class=\"comment\">//时间复杂度为O(NlogN)</span></span><br><span class=\"line\">\tsort(result.begin(), result.end());</span><br><span class=\"line\">\t<span class=\"built_in\">string</span> ans;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i = result.begin(); i != result.end(); ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tans.push_back(i-&gt;data);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>3.利用1的方法，不过不再采用二维数组存储，而是使用一个vector存储每一行的字符串。到每一行直接加入尾端即可。这样字符串总长度实际上只有N。</p>\n<p>时间复杂度：O（N）</p>\n<p>空间复杂度：O（N）</p>\n<p>执行用时：8 ms, 在所有 C++ 提交中击败了93.23%的用户</p>\n<p>内存消耗：10.5 MB, 在所有 C++ 提交中击败了57.73%的用户</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">convert</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> numRows)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">result</span><span class=\"params\">(numRows)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> row = <span class=\"number\">0</span>, col = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> shu = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (numRows == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> s;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tresult[row].push_back(s[i]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (shu)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (row == numRows - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tshu = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t\t--row;</span><br><span class=\"line\">\t\t\t\t++col;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t++row;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (row == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tshu = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t\t++row;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t--row;</span><br><span class=\"line\">\t\t\t\t++col;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//顺序读取</span></span><br><span class=\"line\">\t<span class=\"built_in\">string</span> ans;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numRows; ++i)</span><br><span class=\"line\">\t\tans += result[i];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"23-合并K组升序链表\"><a href=\"#23-合并K组升序链表\" class=\"headerlink\" title=\"23 合并K组升序链表\"></a>23 合并K组升序链表</h3><p>1.采用K路归并的思路</p>\n<p>时间复杂度：O（nk)</p>\n<p>执行用时：756 ms, 在所有 C++ 提交中击败了7.77%的用户</p>\n<p>内存消耗：12.6 MB, 在所有 C++ 提交中击败了98.43%的用户</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">mergeKLists</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = lists.size();</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> allZero = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">//N路归并</span></span><br><span class=\"line\">        ListNode* head = <span class=\"keyword\">new</span> ListNode();</span><br><span class=\"line\">        ListNode* ptr = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!allZero)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> minNum = <span class=\"number\">99999</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> index = <span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (lists[i] != <span class=\"literal\">nullptr</span>&amp;&amp;lists[i]-&gt;val &lt; minNum)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    index = i;</span><br><span class=\"line\">                    minNum = lists[i]-&gt;val;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//找到最小的了</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (index == <span class=\"number\">-1</span>)</span><br><span class=\"line\">                allZero = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ptr-&gt;next = lists[index];</span><br><span class=\"line\">                ptr = ptr-&gt;next;</span><br><span class=\"line\">                lists[index] = lists[index]-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head-&gt;next;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>2.采用二路归并的思路</p>\n<p>时间复杂度：O（NlogK)</p>\n<p>执行用时：20 ms, 在所有 C++ 提交中击败了99.49%的用户</p>\n<p>内存消耗：22.2 MB, 在所有 C++ 提交中击败了13.34%的用户</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//归并从下标start开始的n个链表</span></span><br><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">merge2Lists</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ListNode*&gt;&amp; lists, <span class=\"keyword\">int</span> start,<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> lists[start];</span><br><span class=\"line\">\tListNode* p1 = merge2Lists(lists, start, n / <span class=\"number\">2</span>);</span><br><span class=\"line\">\tListNode* p2 = merge2Lists(lists, start + n / <span class=\"number\">2</span>, n - (n / <span class=\"number\">2</span>));</span><br><span class=\"line\">\t<span class=\"comment\">//对p1和p2进行归并</span></span><br><span class=\"line\">\tListNode* head = <span class=\"keyword\">new</span> ListNode();</span><br><span class=\"line\">\tListNode* ptr = head;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (p1 != <span class=\"literal\">nullptr</span>&amp;&amp;p2 != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (p1-&gt;val &lt; p2-&gt;val) &#123;</span><br><span class=\"line\">\t\t\tptr-&gt;next = p1;</span><br><span class=\"line\">\t\t\tp1 = p1-&gt;next;</span><br><span class=\"line\">\t\t\tptr = ptr-&gt;next;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tptr-&gt;next = p2;</span><br><span class=\"line\">\t\t\tp2 = p2-&gt;next;</span><br><span class=\"line\">\t\t\tptr = ptr-&gt;next;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (p1 != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\tptr-&gt;next = p1;</span><br><span class=\"line\">\t\tp1 = p1-&gt;next;</span><br><span class=\"line\">\t\tptr = ptr-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (p2 != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\tptr-&gt;next = p2;</span><br><span class=\"line\">\t\tp2 = p2-&gt;next;</span><br><span class=\"line\">\t\tptr = ptr-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> head-&gt;next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">mergeKLists</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> merge2Lists(lists, <span class=\"number\">0</span>, lists.size());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"最小水位\"><a href=\"#最小水位\" class=\"headerlink\" title=\"最小水位\"></a>最小水位</h3><p>类似于最小生成树，使用优先级队列存储</p>\n<p>时间复杂度：O（N²logK)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GridNode</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> row;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> col;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index;</span><br><span class=\"line\">\t<span class=\"comment\">//const很重要!</span></span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"keyword\">const</span> GridNode&amp; node)<span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;index &lt; node.index;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&gt;(<span class=\"keyword\">const</span> GridNode&amp; node)<span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;index &gt; node.index;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tGridNode(<span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> c, <span class=\"keyword\">int</span> i) :row(r), col(c), index(i) &#123;&#125;;</span><br><span class=\"line\">\tGridNode() &#123;&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">swimInWater</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">priority_queue</span>&lt;GridNode,<span class=\"built_in\">vector</span>&lt;GridNode&gt;,greater&lt;GridNode&gt;&gt; q;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n = grid.size();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//初始化</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> minshuiwei = grid[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">\tgrid[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\tq.push(GridNode(<span class=\"number\">0</span>, <span class=\"number\">1</span>, grid[<span class=\"number\">0</span>][<span class=\"number\">1</span>]));</span><br><span class=\"line\">\tq.push(GridNode(<span class=\"number\">1</span>, <span class=\"number\">0</span>, grid[<span class=\"number\">1</span>][<span class=\"number\">0</span>]));</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (grid[n - <span class=\"number\">1</span>][n - <span class=\"number\">1</span>] != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//找出当前最小的水位</span></span><br><span class=\"line\">\t\tGridNode temp = q.top();</span><br><span class=\"line\">\t\tq.pop();</span><br><span class=\"line\">\t\tgrid[temp.row][temp.col] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (temp.index &gt; minshuiwei) &#123;</span><br><span class=\"line\">\t\t\tminshuiwei = temp.index;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//加入其上下左右</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (temp.row != <span class=\"number\">0</span> &amp;&amp; grid[temp.row - <span class=\"number\">1</span>][temp.col] != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">\t\t\tq.push(GridNode(temp.row - <span class=\"number\">1</span>, temp.col, grid[temp.row - <span class=\"number\">1</span>][temp.col]));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (temp.col != <span class=\"number\">0</span> &amp;&amp; grid[temp.row][temp.col - <span class=\"number\">1</span>] != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">\t\t\tq.push(GridNode(temp.row, temp.col - <span class=\"number\">1</span>, grid[temp.row][temp.col - <span class=\"number\">1</span>]));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (temp.row != n - <span class=\"number\">1</span> &amp;&amp; grid[temp.row + <span class=\"number\">1</span>][temp.col] != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">\t\t\tq.push(GridNode(temp.row + <span class=\"number\">1</span>, temp.col, grid[temp.row + <span class=\"number\">1</span>][temp.col]));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (temp.col != n - <span class=\"number\">1</span> &amp;&amp; grid[temp.row][temp.col + <span class=\"number\">1</span>] != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">\t\t\tq.push(GridNode(temp.row, temp.col + <span class=\"number\">1</span>, grid[temp.row][temp.col + <span class=\"number\">1</span>]));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> minshuiwei;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<h3 id=\"4-寻找两个正序数组的中位数\"><a href=\"#4-寻找两个正序数组的中位数\" class=\"headerlink\" title=\"4 寻找两个正序数组的中位数\"></a>4 寻找两个正序数组的中位数</h3><p>1.遍历数组，使用类似于归并排序的两个指针一一比较大小</p>\n<p>时间复杂度：O(N)</p>\n<p>空间复杂度：O(1)</p>\n<p>执行用时：48 ms, 在所有 C++ 提交中击败了83.73%的用户</p>\n<p>内存消耗：86.9 MB, 在所有 C++ 提交中击败了95.52%的用户</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">findMedianSortedArrays</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums1, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//O(N)</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = <span class=\"number\">-1</span>, j = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> size1 = nums1.size(), size2 = nums2.size();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((size1 + size2) % <span class=\"number\">2</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//even</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> a;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; (size1 + size2) / <span class=\"number\">2</span> - <span class=\"number\">1</span>; ++k)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i == size1 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t\t++j;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j == size2 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t\t++i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums1[i + <span class=\"number\">1</span>] &gt; nums2[j + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t++j;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t++i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//choose two num;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i == size1 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\ta = nums2[++j];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j == size2 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\ta = nums1[++i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums1[i + <span class=\"number\">1</span>] &gt; nums2[j + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ta = nums2[++j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\ta = nums1[++i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i == size1 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\ta += nums2[++j];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j == size2 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\ta += nums1[++i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums1[i + <span class=\"number\">1</span>] &gt; nums2[j + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ta += nums2[++j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\ta += nums1[++i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a / <span class=\"number\">2.0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; (size1 + size2) / <span class=\"number\">2</span> ; ++k)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i == size1 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t\t++j;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j == size2 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t\t++i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums1[i + <span class=\"number\">1</span>] &gt; nums2[j + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t++j;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t++i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i == size1 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> nums2[++j];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j == size2 - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> nums1[++i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums1[i + <span class=\"number\">1</span>] &gt; nums2[j + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> nums2[++j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> nums1[++i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"5-最长回文子串\"><a href=\"#5-最长回文子串\" class=\"headerlink\" title=\"5 最长回文子串\"></a>5 最长回文子串</h3><p>1.递推，利用状态转移方程dp[i] [j]表示字符串的i到j是否为回文串</p>\n<p>初始条件：</p>\n<ul>\n<li>dp[i] [i]=true</li>\n<li>dp[i] [i+1]= s[i]==s[i+1]</li>\n</ul>\n<p>转移条件：</p>\n<ul>\n<li>dp[i] [j]= true if dp[i+1] [j-1] and s[i]==s[j]</li>\n</ul>\n<p>时间复杂度:O(N)</p>\n<p>空间复杂度:O(N)</p>\n<p>执行用时：456 ms, 在所有 C++ 提交中击败了41.14%的用户</p>\n<p>内存消耗：7.9 MB, 在所有 C++ 提交中击败了77.31%的用户</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> dp[<span class=\"number\">1000</span>][<span class=\"number\">1000</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> strLength = s.length();</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> maxS = <span class=\"number\">-1</span>, maxE = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; strLength; ++i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; strLength; ++j)</span><br><span class=\"line\">\t\t\tdp[i][j] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//边界条件</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; strLength; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tdp[i][i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\tmaxS = i;</span><br><span class=\"line\">\t\tmaxE = i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; strLength - <span class=\"number\">1</span>; ++i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (s[i] == s[i + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tdp[i][i + <span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\tmaxS = i;</span><br><span class=\"line\">\t\t\tmaxE = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//奇数转移方程</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; strLength; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= i &amp;&amp; j &lt;= strLength - i - <span class=\"number\">1</span>; ++j)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (dp[i - j + <span class=\"number\">1</span>][i + j - <span class=\"number\">1</span>] &amp;&amp; s[i - j] == s[i + j])</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tdp[i - j][i + j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (dp[i - j][i + j] &amp;&amp; <span class=\"number\">2</span> * j + <span class=\"number\">1</span> &gt; maxE - maxS + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tmaxS = i - j;</span><br><span class=\"line\">\t\t\t\tmaxE = i + j;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//偶数转移方程</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; strLength - <span class=\"number\">1</span>; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt;= i &amp;&amp; j &lt;= strLength - i - <span class=\"number\">2</span>; ++j)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (dp[i - j + <span class=\"number\">1</span>][i + j ] &amp;&amp; s[i - j] == s[i + j+<span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tdp[i - j][i + j+<span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (dp[i - j][i + j+<span class=\"number\">1</span>] &amp;&amp; <span class=\"number\">2</span> * j + <span class=\"number\">2</span> &gt; maxE - maxS + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tmaxS = i - j;</span><br><span class=\"line\">\t\t\t\tmaxE = i + j+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (maxS == <span class=\"number\">-1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> s.substr(maxS, maxE - maxS + <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h3 id=\"6-Z字形变换\"><a href=\"#6-Z字形变换\" class=\"headerlink\" title=\"6.Z字形变换\"></a>6.Z字形变换</h3><p>1.利用一个二维数组存储绘制出的Z字形，完成绘制后遍历二维数组每一个顺序输出</p>\n<p>时间复杂度：O(N²)</p>\n<p>空间复杂度：O(N²)</p>\n<p>执行用时：1288 ms, 在所有 C++ 提交中击败了5.08%的用户</p>\n<p>内存消耗：9.1 MB, 在所有 C++ 提交中击败了62.58%的用户</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">convert</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> numRows)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> word[<span class=\"number\">1000</span>][<span class=\"number\">1000</span>] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> row = <span class=\"number\">0</span>, col = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> shu = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (numRows == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> s;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tword[row][col] = s[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (shu)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (row == numRows - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tshu = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t\t--row;</span><br><span class=\"line\">\t\t\t\t++col;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t++row;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (row == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tshu = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t\t++row;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t--row;</span><br><span class=\"line\">\t\t\t\t++col;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//顺序读取</span></span><br><span class=\"line\">\t<span class=\"built_in\">string</span> ans;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; ++i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">1000</span>; ++j)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (word[i][j] != <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\tans.push_back(word[i][j]);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2.思路类似于1，不过不再采用1中二维数组的方式存取数据</p>\n<p>而是借鉴稀疏矩阵的方法，定义一个Node，将其存储在vector&lt; Node &gt;中。在绘制完毕后，重载比较运算符来进行排序。</p>\n<p>时间复杂度：O(NlogN)</p>\n<p>空间复杂度：O(N)</p>\n<p>执行用时：36 ms, 在所有 C++ 提交中击败了20.65%的用户</p>\n<p>内存消耗：12.6 MB, 在所有 C++ 提交中击败了17.63%的用户</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> row;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> col;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> data;</span><br><span class=\"line\">\tNode(<span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> c, <span class=\"keyword\">char</span> d)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\trow = r;</span><br><span class=\"line\">\t\tcol = c;</span><br><span class=\"line\">\t\tdata = d;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"keyword\">const</span> Node&amp; p2)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;row &lt; p2.row)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span>-&gt;row == p2.row&amp;&amp;<span class=\"keyword\">this</span>-&gt;col &lt; p2.col);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">convert</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> numRows)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;Node&gt; result;<span class=\"comment\">//类似于稀疏矩阵</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> row = <span class=\"number\">0</span>, col = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> shu = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (numRows == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> s;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tresult.push_back(Node(row, col, s[i]));</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (shu)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (row == numRows - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tshu = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t\t--row;</span><br><span class=\"line\">\t\t\t\t++col;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t++row;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (row == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tshu = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t\t++row;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t--row;</span><br><span class=\"line\">\t\t\t\t++col;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//对内部进行排序，先比较行，行小的在前，紧接着比较列</span></span><br><span class=\"line\">\t<span class=\"comment\">//时间复杂度为O(NlogN)</span></span><br><span class=\"line\">\tsort(result.begin(), result.end());</span><br><span class=\"line\">\t<span class=\"built_in\">string</span> ans;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i = result.begin(); i != result.end(); ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tans.push_back(i-&gt;data);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>3.利用1的方法，不过不再采用二维数组存储，而是使用一个vector存储每一行的字符串。到每一行直接加入尾端即可。这样字符串总长度实际上只有N。</p>\n<p>时间复杂度：O（N）</p>\n<p>空间复杂度：O（N）</p>\n<p>执行用时：8 ms, 在所有 C++ 提交中击败了93.23%的用户</p>\n<p>内存消耗：10.5 MB, 在所有 C++ 提交中击败了57.73%的用户</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">convert</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> numRows)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">result</span><span class=\"params\">(numRows)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> row = <span class=\"number\">0</span>, col = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> shu = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (numRows == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> s;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tresult[row].push_back(s[i]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (shu)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (row == numRows - <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tshu = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t\t--row;</span><br><span class=\"line\">\t\t\t\t++col;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t++row;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (row == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tshu = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t\t++row;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t--row;</span><br><span class=\"line\">\t\t\t\t++col;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//顺序读取</span></span><br><span class=\"line\">\t<span class=\"built_in\">string</span> ans;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numRows; ++i)</span><br><span class=\"line\">\t\tans += result[i];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"23-合并K组升序链表\"><a href=\"#23-合并K组升序链表\" class=\"headerlink\" title=\"23 合并K组升序链表\"></a>23 合并K组升序链表</h3><p>1.采用K路归并的思路</p>\n<p>时间复杂度：O（nk)</p>\n<p>执行用时：756 ms, 在所有 C++ 提交中击败了7.77%的用户</p>\n<p>内存消耗：12.6 MB, 在所有 C++ 提交中击败了98.43%的用户</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">mergeKLists</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = lists.size();</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> allZero = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">//N路归并</span></span><br><span class=\"line\">        ListNode* head = <span class=\"keyword\">new</span> ListNode();</span><br><span class=\"line\">        ListNode* ptr = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!allZero)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> minNum = <span class=\"number\">99999</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> index = <span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (lists[i] != <span class=\"literal\">nullptr</span>&amp;&amp;lists[i]-&gt;val &lt; minNum)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    index = i;</span><br><span class=\"line\">                    minNum = lists[i]-&gt;val;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//找到最小的了</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (index == <span class=\"number\">-1</span>)</span><br><span class=\"line\">                allZero = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ptr-&gt;next = lists[index];</span><br><span class=\"line\">                ptr = ptr-&gt;next;</span><br><span class=\"line\">                lists[index] = lists[index]-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head-&gt;next;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>2.采用二路归并的思路</p>\n<p>时间复杂度：O（NlogK)</p>\n<p>执行用时：20 ms, 在所有 C++ 提交中击败了99.49%的用户</p>\n<p>内存消耗：22.2 MB, 在所有 C++ 提交中击败了13.34%的用户</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//归并从下标start开始的n个链表</span></span><br><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">merge2Lists</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ListNode*&gt;&amp; lists, <span class=\"keyword\">int</span> start,<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> lists[start];</span><br><span class=\"line\">\tListNode* p1 = merge2Lists(lists, start, n / <span class=\"number\">2</span>);</span><br><span class=\"line\">\tListNode* p2 = merge2Lists(lists, start + n / <span class=\"number\">2</span>, n - (n / <span class=\"number\">2</span>));</span><br><span class=\"line\">\t<span class=\"comment\">//对p1和p2进行归并</span></span><br><span class=\"line\">\tListNode* head = <span class=\"keyword\">new</span> ListNode();</span><br><span class=\"line\">\tListNode* ptr = head;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (p1 != <span class=\"literal\">nullptr</span>&amp;&amp;p2 != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (p1-&gt;val &lt; p2-&gt;val) &#123;</span><br><span class=\"line\">\t\t\tptr-&gt;next = p1;</span><br><span class=\"line\">\t\t\tp1 = p1-&gt;next;</span><br><span class=\"line\">\t\t\tptr = ptr-&gt;next;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tptr-&gt;next = p2;</span><br><span class=\"line\">\t\t\tp2 = p2-&gt;next;</span><br><span class=\"line\">\t\t\tptr = ptr-&gt;next;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (p1 != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\tptr-&gt;next = p1;</span><br><span class=\"line\">\t\tp1 = p1-&gt;next;</span><br><span class=\"line\">\t\tptr = ptr-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (p2 != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\tptr-&gt;next = p2;</span><br><span class=\"line\">\t\tp2 = p2-&gt;next;</span><br><span class=\"line\">\t\tptr = ptr-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> head-&gt;next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">mergeKLists</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> merge2Lists(lists, <span class=\"number\">0</span>, lists.size());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"最小水位\"><a href=\"#最小水位\" class=\"headerlink\" title=\"最小水位\"></a>最小水位</h3><p>类似于最小生成树，使用优先级队列存储</p>\n<p>时间复杂度：O（N²logK)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GridNode</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> row;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> col;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index;</span><br><span class=\"line\">\t<span class=\"comment\">//const很重要!</span></span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"keyword\">const</span> GridNode&amp; node)<span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;index &lt; node.index;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&gt;(<span class=\"keyword\">const</span> GridNode&amp; node)<span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;index &gt; node.index;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tGridNode(<span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> c, <span class=\"keyword\">int</span> i) :row(r), col(c), index(i) &#123;&#125;;</span><br><span class=\"line\">\tGridNode() &#123;&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">swimInWater</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">priority_queue</span>&lt;GridNode,<span class=\"built_in\">vector</span>&lt;GridNode&gt;,greater&lt;GridNode&gt;&gt; q;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n = grid.size();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//初始化</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> minshuiwei = grid[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">\tgrid[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\tq.push(GridNode(<span class=\"number\">0</span>, <span class=\"number\">1</span>, grid[<span class=\"number\">0</span>][<span class=\"number\">1</span>]));</span><br><span class=\"line\">\tq.push(GridNode(<span class=\"number\">1</span>, <span class=\"number\">0</span>, grid[<span class=\"number\">1</span>][<span class=\"number\">0</span>]));</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (grid[n - <span class=\"number\">1</span>][n - <span class=\"number\">1</span>] != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//找出当前最小的水位</span></span><br><span class=\"line\">\t\tGridNode temp = q.top();</span><br><span class=\"line\">\t\tq.pop();</span><br><span class=\"line\">\t\tgrid[temp.row][temp.col] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (temp.index &gt; minshuiwei) &#123;</span><br><span class=\"line\">\t\t\tminshuiwei = temp.index;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//加入其上下左右</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (temp.row != <span class=\"number\">0</span> &amp;&amp; grid[temp.row - <span class=\"number\">1</span>][temp.col] != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">\t\t\tq.push(GridNode(temp.row - <span class=\"number\">1</span>, temp.col, grid[temp.row - <span class=\"number\">1</span>][temp.col]));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (temp.col != <span class=\"number\">0</span> &amp;&amp; grid[temp.row][temp.col - <span class=\"number\">1</span>] != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">\t\t\tq.push(GridNode(temp.row, temp.col - <span class=\"number\">1</span>, grid[temp.row][temp.col - <span class=\"number\">1</span>]));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (temp.row != n - <span class=\"number\">1</span> &amp;&amp; grid[temp.row + <span class=\"number\">1</span>][temp.col] != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">\t\t\tq.push(GridNode(temp.row + <span class=\"number\">1</span>, temp.col, grid[temp.row + <span class=\"number\">1</span>][temp.col]));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (temp.col != n - <span class=\"number\">1</span> &amp;&amp; grid[temp.row][temp.col + <span class=\"number\">1</span>] != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">\t\t\tq.push(GridNode(temp.row, temp.col + <span class=\"number\">1</span>, grid[temp.row][temp.col + <span class=\"number\">1</span>]));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> minshuiwei;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"二分查找注意的点","date":"2024-10-02T05:30:00.000Z","cover":"https://s3.ax1x.com/2020/12/29/rbaWHf.jpg","_content":"\n\n\n二分查找的默认写法都是left <= right 最后跳出条件就是right, left\n\n```java\nif (nums[mid] == target) {\n    // break\n} else if (nums[mid] > target) {\n    right = mid - 1;\n} else {\n    left = mid + 1;\n}\n```\n\n如果只需要单边查找（也就是不特殊处理==target，通常是找最大的小于或者最小的大于某一个值的情况），就用left < right\n\n此时的跳出条件是left = right\n\n```java\nif (nums[mid] < target) {\n  left = mid + 1;\n} else {\n  right = mid; \n}\n// 单边查找，找到 == target的第一个value\n```\n\n\n\n这种情况下，如果是left变更（也就是left = mid），mid的计算就是left + (right - left + 1) / 2\n\n这是因为下取整，left可能不会变，所以需要+1来上取整\n\n否则（right = mid的情况），直接left + (right - left) / 2 即可\n\n这一题：https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/\n\n就是典型的单边查找的情况\n","source":"_posts/二分查找.md","raw":"---\ntitle: 二分查找注意的点\ndate: 2024-10-02 13:30:00\ncover: https://s3.ax1x.com/2020/12/29/rbaWHf.jpg\n---\n\n\n\n二分查找的默认写法都是left <= right 最后跳出条件就是right, left\n\n```java\nif (nums[mid] == target) {\n    // break\n} else if (nums[mid] > target) {\n    right = mid - 1;\n} else {\n    left = mid + 1;\n}\n```\n\n如果只需要单边查找（也就是不特殊处理==target，通常是找最大的小于或者最小的大于某一个值的情况），就用left < right\n\n此时的跳出条件是left = right\n\n```java\nif (nums[mid] < target) {\n  left = mid + 1;\n} else {\n  right = mid; \n}\n// 单边查找，找到 == target的第一个value\n```\n\n\n\n这种情况下，如果是left变更（也就是left = mid），mid的计算就是left + (right - left + 1) / 2\n\n这是因为下取整，left可能不会变，所以需要+1来上取整\n\n否则（right = mid的情况），直接left + (right - left) / 2 即可\n\n这一题：https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/\n\n就是典型的单边查找的情况\n","slug":"二分查找","published":1,"updated":"2024-12-21T08:19:51.886Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmhg4qt430009f5fa2yhqbakm","content":"<p>二分查找的默认写法都是left &lt;= right 最后跳出条件就是right, left</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (nums[mid] == target) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// break</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &gt; target) &#123;</span><br><span class=\"line\">    right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果只需要单边查找（也就是不特殊处理==target，通常是找最大的小于或者最小的大于某一个值的情况），就用left &lt; right</p>\n<p>此时的跳出条件是left = right</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (nums[mid] &lt; target) &#123;</span><br><span class=\"line\">  left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  right = mid; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 单边查找，找到 == target的第一个value</span></span><br></pre></td></tr></table></figure>\n\n\n<p>这种情况下，如果是left变更（也就是left = mid），mid的计算就是left + (right - left + 1) / 2</p>\n<p>这是因为下取整，left可能不会变，所以需要+1来上取整</p>\n<p>否则（right = mid的情况），直接left + (right - left) / 2 即可</p>\n<p>这一题：<a href=\"https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/\">https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/</a></p>\n<p>就是典型的单边查找的情况</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<p>二分查找的默认写法都是left &lt;= right 最后跳出条件就是right, left</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (nums[mid] == target) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// break</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &gt; target) &#123;</span><br><span class=\"line\">    right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果只需要单边查找（也就是不特殊处理==target，通常是找最大的小于或者最小的大于某一个值的情况），就用left &lt; right</p>\n<p>此时的跳出条件是left = right</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (nums[mid] &lt; target) &#123;</span><br><span class=\"line\">  left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  right = mid; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 单边查找，找到 == target的第一个value</span></span><br></pre></td></tr></table></figure>\n\n\n<p>这种情况下，如果是left变更（也就是left = mid），mid的计算就是left + (right - left + 1) / 2</p>\n<p>这是因为下取整，left可能不会变，所以需要+1来上取整</p>\n<p>否则（right = mid的情况），直接left + (right - left) / 2 即可</p>\n<p>这一题：<a href=\"https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/\">https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/</a></p>\n<p>就是典型的单边查找的情况</p>\n"},{"title":"游戏 | 联机版五子棋 v0.1","date":"2021-01-11T04:00:00.000Z","description":"菜鸡的第一次尝试","cover":"https://s3.ax1x.com/2021/01/11/s8aeKJ.jpg","_content":"\n## 项目简介\n\n版本：0.1\n\n项目地址：https://github.com/wangwangwang23333/Five-Son-s-Chess-Online\n\n介绍：\n\n一个可以支持联机进行五子棋的游戏\n\n目前支持功能：等待其他玩家加入、查看上一步下棋位置\n\n未来预期加入功能：悔棋、聊天、选择黑白方、积分功能\n\n\n\n## 代码环境\n\n编译器：vscode\n\n语言：python\n\n版本：3.7+\n\n库：pygame、socket等\n\n\n\n## 项目方法\n\n1.将server.py中ip地址更改为服务器的私网ip\n\n2.将playchess.py中ip地址更改为服务器的公网ip\n\n3.打开服务器\n\n4.两端即可同时开始游戏\n\n注：可以通过Pyinstall库部署为.exe文件\n\n\n\n## 项目截图\n\n开始游戏界面：\n\n[![s8ai5V.md.png](https://s3.ax1x.com/2021/01/11/s8ai5V.md.png)](https://imgchr.com/i/s8ai5V)\n\n等待其他玩家加入界面：\n\n[![s8aA8U.md.jpg](https://s3.ax1x.com/2021/01/11/s8aA8U.md.jpg)](https://imgchr.com/i/s8aA8U)\n\n游戏界面：\n\n[![s8aeKJ.md.jpg](https://s3.ax1x.com/2021/01/11/s8aeKJ.md.jpg)](https://imgchr.com/i/s8aeKJ)","source":"_posts/五子棋联机游戏介绍.md","raw":"---\ntitle: 游戏 | 联机版五子棋 v0.1\ndate: 2021-1-11 12:00:00\ndescription: 菜鸡的第一次尝试\ncover: https://s3.ax1x.com/2021/01/11/s8aeKJ.jpg\n---\n\n## 项目简介\n\n版本：0.1\n\n项目地址：https://github.com/wangwangwang23333/Five-Son-s-Chess-Online\n\n介绍：\n\n一个可以支持联机进行五子棋的游戏\n\n目前支持功能：等待其他玩家加入、查看上一步下棋位置\n\n未来预期加入功能：悔棋、聊天、选择黑白方、积分功能\n\n\n\n## 代码环境\n\n编译器：vscode\n\n语言：python\n\n版本：3.7+\n\n库：pygame、socket等\n\n\n\n## 项目方法\n\n1.将server.py中ip地址更改为服务器的私网ip\n\n2.将playchess.py中ip地址更改为服务器的公网ip\n\n3.打开服务器\n\n4.两端即可同时开始游戏\n\n注：可以通过Pyinstall库部署为.exe文件\n\n\n\n## 项目截图\n\n开始游戏界面：\n\n[![s8ai5V.md.png](https://s3.ax1x.com/2021/01/11/s8ai5V.md.png)](https://imgchr.com/i/s8ai5V)\n\n等待其他玩家加入界面：\n\n[![s8aA8U.md.jpg](https://s3.ax1x.com/2021/01/11/s8aA8U.md.jpg)](https://imgchr.com/i/s8aA8U)\n\n游戏界面：\n\n[![s8aeKJ.md.jpg](https://s3.ax1x.com/2021/01/11/s8aeKJ.md.jpg)](https://imgchr.com/i/s8aeKJ)","slug":"五子棋联机游戏介绍","published":1,"updated":"2021-01-11T09:24:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmhg4qt44000af5fa7m0562sp","content":"<h2 id=\"项目简介\"><a href=\"#项目简介\" class=\"headerlink\" title=\"项目简介\"></a>项目简介</h2><p>版本：0.1</p>\n<p>项目地址：<a href=\"https://github.com/wangwangwang23333/Five-Son-s-Chess-Online\">https://github.com/wangwangwang23333/Five-Son-s-Chess-Online</a></p>\n<p>介绍：</p>\n<p>一个可以支持联机进行五子棋的游戏</p>\n<p>目前支持功能：等待其他玩家加入、查看上一步下棋位置</p>\n<p>未来预期加入功能：悔棋、聊天、选择黑白方、积分功能</p>\n<h2 id=\"代码环境\"><a href=\"#代码环境\" class=\"headerlink\" title=\"代码环境\"></a>代码环境</h2><p>编译器：vscode</p>\n<p>语言：python</p>\n<p>版本：3.7+</p>\n<p>库：pygame、socket等</p>\n<h2 id=\"项目方法\"><a href=\"#项目方法\" class=\"headerlink\" title=\"项目方法\"></a>项目方法</h2><p>1.将server.py中ip地址更改为服务器的私网ip</p>\n<p>2.将playchess.py中ip地址更改为服务器的公网ip</p>\n<p>3.打开服务器</p>\n<p>4.两端即可同时开始游戏</p>\n<p>注：可以通过Pyinstall库部署为.exe文件</p>\n<h2 id=\"项目截图\"><a href=\"#项目截图\" class=\"headerlink\" title=\"项目截图\"></a>项目截图</h2><p>开始游戏界面：</p>\n<p><a href=\"https://imgchr.com/i/s8ai5V\"><img src=\"https://s3.ax1x.com/2021/01/11/s8ai5V.md.png\" alt=\"s8ai5V.md.png\"></a></p>\n<p>等待其他玩家加入界面：</p>\n<p><a href=\"https://imgchr.com/i/s8aA8U\"><img src=\"https://s3.ax1x.com/2021/01/11/s8aA8U.md.jpg\" alt=\"s8aA8U.md.jpg\"></a></p>\n<p>游戏界面：</p>\n<p><a href=\"https://imgchr.com/i/s8aeKJ\"><img src=\"https://s3.ax1x.com/2021/01/11/s8aeKJ.md.jpg\" alt=\"s8aeKJ.md.jpg\"></a></p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<h2 id=\"项目简介\"><a href=\"#项目简介\" class=\"headerlink\" title=\"项目简介\"></a>项目简介</h2><p>版本：0.1</p>\n<p>项目地址：<a href=\"https://github.com/wangwangwang23333/Five-Son-s-Chess-Online\">https://github.com/wangwangwang23333/Five-Son-s-Chess-Online</a></p>\n<p>介绍：</p>\n<p>一个可以支持联机进行五子棋的游戏</p>\n<p>目前支持功能：等待其他玩家加入、查看上一步下棋位置</p>\n<p>未来预期加入功能：悔棋、聊天、选择黑白方、积分功能</p>\n<h2 id=\"代码环境\"><a href=\"#代码环境\" class=\"headerlink\" title=\"代码环境\"></a>代码环境</h2><p>编译器：vscode</p>\n<p>语言：python</p>\n<p>版本：3.7+</p>\n<p>库：pygame、socket等</p>\n<h2 id=\"项目方法\"><a href=\"#项目方法\" class=\"headerlink\" title=\"项目方法\"></a>项目方法</h2><p>1.将server.py中ip地址更改为服务器的私网ip</p>\n<p>2.将playchess.py中ip地址更改为服务器的公网ip</p>\n<p>3.打开服务器</p>\n<p>4.两端即可同时开始游戏</p>\n<p>注：可以通过Pyinstall库部署为.exe文件</p>\n<h2 id=\"项目截图\"><a href=\"#项目截图\" class=\"headerlink\" title=\"项目截图\"></a>项目截图</h2><p>开始游戏界面：</p>\n<p><a href=\"https://imgchr.com/i/s8ai5V\"><img src=\"https://s3.ax1x.com/2021/01/11/s8ai5V.md.png\" alt=\"s8ai5V.md.png\"></a></p>\n<p>等待其他玩家加入界面：</p>\n<p><a href=\"https://imgchr.com/i/s8aA8U\"><img src=\"https://s3.ax1x.com/2021/01/11/s8aA8U.md.jpg\" alt=\"s8aA8U.md.jpg\"></a></p>\n<p>游戏界面：</p>\n<p><a href=\"https://imgchr.com/i/s8aeKJ\"><img src=\"https://s3.ax1x.com/2021/01/11/s8aeKJ.md.jpg\" alt=\"s8aeKJ.md.jpg\"></a></p>\n"},{"title":"前端--节流与防抖","date":"2022-03-18T16:00:00.000Z","description":"两个重要的概念","_content":"\n节流与防抖是前端中比较重要的两个概念。\n\n# 函数防抖\n\n当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。\n\n如下图，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。\n\n<img src='https://img-blog.csdnimg.cn/img_convert/525e0fb3b1b982c626003319f07de623.png'>\n\n下面的代码可以实现防抖的功能：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <style>\n        body{\n            height: 5000px;\n        }\n    </style>\n</head>\n<body>\n    <script>\n        function debounce(fn, wait) {\n            var timeout = null;\n            return function() {\n                if(timeout !== null)\n                    clearTimeout(timeout);\n                timeout = setTimeout(fn, wait);\n            }\n        }\n        // 处理函数\n        function handle() {\n            console.log(Math.random());\n        }\n        // 滚动事件\n        window.addEventListener('scroll', debounce(handle, 1000));\n    </script>\n</body>\n</html>\n```\n\n可以实现以下的效果：\n\n<img src='https://img-blog.csdn.net/20180917111553767?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDAwODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70'>\n\n# 函数节流\n\n当持续触发事件时，保证一定时间段内只调用一次事件处理函数。\n\n节流通俗解释就比如我们水龙头防水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。\n\n有以下的方案：\n\n## 时间戳方案\n\n```javascript\nvar throttle = function(func, delay) {\n    var prev = Date.now();\n    return function() {\n        var context = this;\n        var args = arguments;\n        var now = Date.now();\n        if (now - prev >= delay) {\n            func.apply(context, args);\n            prev = Date.now();\n        }\n    }\n}\nfunction handle() {\n    console.log(Math.random());\n}\nwindow.addEventListener('scroll', throttle(handle, 1000));\n```\n\n## 定时器方案\n\n```javascript\nvar throttle = function(func, delay) {\n    var timer = null;\n    return function() {\n        var context = this;\n        var args = arguments;\n        if (!timer) {\n            timer = setTimeout(function() {\n                func.apply(context, args);\n                timer = null;\n            }, delay);\n        }\n    }\n}\nfunction handle() {\n    console.log(Math.random());\n}\nwindow.addEventListener('scroll', throttle(handle, 1000));\n```\n\n## 时间戳+定时器\n\n```javascript\nvar throttle = function(func, delay) {\n    var timer = null;\n    var startTime = Date.now();\n    return function() {\n        var curTime = Date.now();\n        var remaining = delay - (curTime - startTime);\n        var context = this;\n        var args = arguments;\n        clearTimeout(timer);\n        if (remaining <= 0) {\n            func.apply(context, args);\n            startTime = Date.now();\n        } else {\n            timer = setTimeout(func, remaining);\n        }\n    }\n}\nfunction handle() {\n      console.log(Math.random());\n}\n window.addEventListener('scroll', throttle(handle, 1000));\n```\n\n效果如下所示：\n\n<img src='https://img-blog.csdn.net/20180917111627196?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDAwODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70'>\n\n# 总结\n\n**函数防抖**：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。\n\n**函数节流**：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。\n\n**区别**： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。","source":"_posts/前端——节流与防抖.md","raw":"---\ntitle: 前端--节流与防抖\ndate: 2022-3-19 00:00:00\ndescription: 两个重要的概念\n---\n\n节流与防抖是前端中比较重要的两个概念。\n\n# 函数防抖\n\n当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。\n\n如下图，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。\n\n<img src='https://img-blog.csdnimg.cn/img_convert/525e0fb3b1b982c626003319f07de623.png'>\n\n下面的代码可以实现防抖的功能：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <style>\n        body{\n            height: 5000px;\n        }\n    </style>\n</head>\n<body>\n    <script>\n        function debounce(fn, wait) {\n            var timeout = null;\n            return function() {\n                if(timeout !== null)\n                    clearTimeout(timeout);\n                timeout = setTimeout(fn, wait);\n            }\n        }\n        // 处理函数\n        function handle() {\n            console.log(Math.random());\n        }\n        // 滚动事件\n        window.addEventListener('scroll', debounce(handle, 1000));\n    </script>\n</body>\n</html>\n```\n\n可以实现以下的效果：\n\n<img src='https://img-blog.csdn.net/20180917111553767?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDAwODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70'>\n\n# 函数节流\n\n当持续触发事件时，保证一定时间段内只调用一次事件处理函数。\n\n节流通俗解释就比如我们水龙头防水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。\n\n有以下的方案：\n\n## 时间戳方案\n\n```javascript\nvar throttle = function(func, delay) {\n    var prev = Date.now();\n    return function() {\n        var context = this;\n        var args = arguments;\n        var now = Date.now();\n        if (now - prev >= delay) {\n            func.apply(context, args);\n            prev = Date.now();\n        }\n    }\n}\nfunction handle() {\n    console.log(Math.random());\n}\nwindow.addEventListener('scroll', throttle(handle, 1000));\n```\n\n## 定时器方案\n\n```javascript\nvar throttle = function(func, delay) {\n    var timer = null;\n    return function() {\n        var context = this;\n        var args = arguments;\n        if (!timer) {\n            timer = setTimeout(function() {\n                func.apply(context, args);\n                timer = null;\n            }, delay);\n        }\n    }\n}\nfunction handle() {\n    console.log(Math.random());\n}\nwindow.addEventListener('scroll', throttle(handle, 1000));\n```\n\n## 时间戳+定时器\n\n```javascript\nvar throttle = function(func, delay) {\n    var timer = null;\n    var startTime = Date.now();\n    return function() {\n        var curTime = Date.now();\n        var remaining = delay - (curTime - startTime);\n        var context = this;\n        var args = arguments;\n        clearTimeout(timer);\n        if (remaining <= 0) {\n            func.apply(context, args);\n            startTime = Date.now();\n        } else {\n            timer = setTimeout(func, remaining);\n        }\n    }\n}\nfunction handle() {\n      console.log(Math.random());\n}\n window.addEventListener('scroll', throttle(handle, 1000));\n```\n\n效果如下所示：\n\n<img src='https://img-blog.csdn.net/20180917111627196?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDAwODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70'>\n\n# 总结\n\n**函数防抖**：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。\n\n**函数节流**：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。\n\n**区别**： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。","slug":"前端——节流与防抖","published":1,"updated":"2022-03-19T06:45:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmhg4qt44000bf5faagzb4qtg","content":"<p>节流与防抖是前端中比较重要的两个概念。</p>\n<h1 id=\"函数防抖\"><a href=\"#函数防抖\" class=\"headerlink\" title=\"函数防抖\"></a>函数防抖</h1><p>当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。</p>\n<p>如下图，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。</p>\n<img src='https://img-blog.csdnimg.cn/img_convert/525e0fb3b1b982c626003319f07de623.png'>\n\n<p>下面的代码可以实现防抖的功能：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Title<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\">        body&#123;</span><br><span class=\"line\">            height: 5000px;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">fn, wait</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> timeout = <span class=\"literal\">null</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">if</span>(timeout !== <span class=\"literal\">null</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">                    <span class=\"built_in\">clearTimeout</span>(timeout);</span></span><br><span class=\"line\"><span class=\"javascript\">                timeout = <span class=\"built_in\">setTimeout</span>(fn, wait);</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 处理函数</span></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Math</span>.random());</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 滚动事件</span></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&#x27;scroll&#x27;</span>, debounce(handle, <span class=\"number\">1000</span>));</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>可以实现以下的效果：</p>\n<img src='https://img-blog.csdn.net/20180917111553767?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDAwODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70'>\n\n<h1 id=\"函数节流\"><a href=\"#函数节流\" class=\"headerlink\" title=\"函数节流\"></a>函数节流</h1><p>当持续触发事件时，保证一定时间段内只调用一次事件处理函数。</p>\n<p>节流通俗解释就比如我们水龙头防水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。</p>\n<p>有以下的方案：</p>\n<h2 id=\"时间戳方案\"><a href=\"#时间戳方案\" class=\"headerlink\" title=\"时间戳方案\"></a>时间戳方案</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> throttle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, delay</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> prev = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> context = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> now = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (now - prev &gt;= delay) &#123;</span><br><span class=\"line\">            func.apply(context, args);</span><br><span class=\"line\">            prev = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Math</span>.random());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&#x27;scroll&#x27;</span>, throttle(handle, <span class=\"number\">1000</span>));</span><br></pre></td></tr></table></figure>\n<h2 id=\"定时器方案\"><a href=\"#定时器方案\" class=\"headerlink\" title=\"定时器方案\"></a>定时器方案</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> throttle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, delay</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> context = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!timer) &#123;</span><br><span class=\"line\">            timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                func.apply(context, args);</span><br><span class=\"line\">                timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            &#125;, delay);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Math</span>.random());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&#x27;scroll&#x27;</span>, throttle(handle, <span class=\"number\">1000</span>));</span><br></pre></td></tr></table></figure>\n<h2 id=\"时间戳-定时器\"><a href=\"#时间戳-定时器\" class=\"headerlink\" title=\"时间戳+定时器\"></a>时间戳+定时器</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> throttle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, delay</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> startTime = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> curTime = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">        <span class=\"keyword\">var</span> remaining = delay - (curTime - startTime);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> context = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">        <span class=\"built_in\">clearTimeout</span>(timer);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (remaining &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            func.apply(context, args);</span><br><span class=\"line\">            startTime = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            timer = <span class=\"built_in\">setTimeout</span>(func, remaining);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Math</span>.random());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&#x27;scroll&#x27;</span>, throttle(handle, <span class=\"number\">1000</span>));</span><br></pre></td></tr></table></figure>\n<p>效果如下所示：</p>\n<img src='https://img-blog.csdn.net/20180917111627196?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDAwODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70'>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p><strong>函数防抖</strong>：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。</p>\n<p><strong>函数节流</strong>：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。</p>\n<p><strong>区别</strong>： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<p>节流与防抖是前端中比较重要的两个概念。</p>\n<h1 id=\"函数防抖\"><a href=\"#函数防抖\" class=\"headerlink\" title=\"函数防抖\"></a>函数防抖</h1><p>当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。</p>\n<p>如下图，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。</p>\n<img src='https://img-blog.csdnimg.cn/img_convert/525e0fb3b1b982c626003319f07de623.png'>\n\n<p>下面的代码可以实现防抖的功能：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Title<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\">        body&#123;</span><br><span class=\"line\">            height: 5000px;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">fn, wait</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> timeout = <span class=\"literal\">null</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">if</span>(timeout !== <span class=\"literal\">null</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">                    <span class=\"built_in\">clearTimeout</span>(timeout);</span></span><br><span class=\"line\"><span class=\"javascript\">                timeout = <span class=\"built_in\">setTimeout</span>(fn, wait);</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 处理函数</span></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Math</span>.random());</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// 滚动事件</span></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&#x27;scroll&#x27;</span>, debounce(handle, <span class=\"number\">1000</span>));</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>可以实现以下的效果：</p>\n<img src='https://img-blog.csdn.net/20180917111553767?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDAwODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70'>\n\n<h1 id=\"函数节流\"><a href=\"#函数节流\" class=\"headerlink\" title=\"函数节流\"></a>函数节流</h1><p>当持续触发事件时，保证一定时间段内只调用一次事件处理函数。</p>\n<p>节流通俗解释就比如我们水龙头防水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。</p>\n<p>有以下的方案：</p>\n<h2 id=\"时间戳方案\"><a href=\"#时间戳方案\" class=\"headerlink\" title=\"时间戳方案\"></a>时间戳方案</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> throttle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, delay</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> prev = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> context = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> now = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (now - prev &gt;= delay) &#123;</span><br><span class=\"line\">            func.apply(context, args);</span><br><span class=\"line\">            prev = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Math</span>.random());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&#x27;scroll&#x27;</span>, throttle(handle, <span class=\"number\">1000</span>));</span><br></pre></td></tr></table></figure>\n<h2 id=\"定时器方案\"><a href=\"#定时器方案\" class=\"headerlink\" title=\"定时器方案\"></a>定时器方案</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> throttle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, delay</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> context = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!timer) &#123;</span><br><span class=\"line\">            timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                func.apply(context, args);</span><br><span class=\"line\">                timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            &#125;, delay);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Math</span>.random());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&#x27;scroll&#x27;</span>, throttle(handle, <span class=\"number\">1000</span>));</span><br></pre></td></tr></table></figure>\n<h2 id=\"时间戳-定时器\"><a href=\"#时间戳-定时器\" class=\"headerlink\" title=\"时间戳+定时器\"></a>时间戳+定时器</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> throttle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, delay</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> startTime = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> curTime = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">        <span class=\"keyword\">var</span> remaining = delay - (curTime - startTime);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> context = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">        <span class=\"built_in\">clearTimeout</span>(timer);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (remaining &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            func.apply(context, args);</span><br><span class=\"line\">            startTime = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            timer = <span class=\"built_in\">setTimeout</span>(func, remaining);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Math</span>.random());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&#x27;scroll&#x27;</span>, throttle(handle, <span class=\"number\">1000</span>));</span><br></pre></td></tr></table></figure>\n<p>效果如下所示：</p>\n<img src='https://img-blog.csdn.net/20180917111627196?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDAwODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70'>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p><strong>函数防抖</strong>：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。</p>\n<p><strong>函数节流</strong>：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。</p>\n<p><strong>区别</strong>： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。</p>\n"},{"title":"单调栈的应用","date":"2022-03-31T12:00:00.000Z","description":"LeetCode中单调栈的一些应用","cover":"https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg","_content":"\n## 84 柱状图中最大的矩形\n\n> 题目链接：https://leetcode-cn.com/problems/largest-rectangle-in-histogram/\n>\n> 给定 `n `个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n>\n> 求在该柱状图中，能够勾勒出来的矩形的最大面积。\n\n<img src='https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg' width='50%'>\n\n### 思考\n\n我们可以反过来考虑针对于每一个元素，都可以求出**以它为高的最大矩形面积**。\n\n那么这样一个矩形，它的底应该是多少呢？\n\n自然而然，我们可以发现：这一个矩形的左侧就是左边比它小的元素的位置，右侧自然也是比它小的元素的位置。\n\n以下图的元素5为例，它的最左侧就应该是比它小的元素1的右边，它的最右侧就应该是比它小的元素2的左边。\n\n![image-20220331205119619](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220331205119619.png)\n\n因此，问题就转化成了：针对于每一个元素，我们都需要求出左边比它小的元素的位置以及右边比它小的元素的位置。\n\n### 单调栈\n\n那么在从左往右遍历一遍的过程中，如何找出比它小的元素呢？\n\n我们自然而然的想到了单调递增栈（严格单调递增）：每当一个元素到达时候，不断出栈直到栈为空或者栈顶元素小于该元素，那么这个元素就一定是比它小的最近的元素。\n\n### 代码\n\n```typescript\nfunction largestRectangleArea(heights: number[]): number {\n    // 元素个数\n    let n = heights.length;\n\n    let left = new Array(n).fill(-1);\n    let right = new Array(n).fill(n);\n\n    // 单调递增栈：严格单调递增，存储的是元素下标\n    let s = new Array();\n\n    // 从左往右遍历，计算left数组\n    for (let i = 0; i < n; ++i) {\n        // 出栈，直到栈空或者满足栈顶元素 < 当前元素\n        while (s.length != 0 && heights[s[s.length - 1]] >= heights[i]) {\n            s.pop();\n        }\n        if (s.length != 0) {\n            left[i] = s[s.length - 1];\n        }\n        // 入栈\n        s.push(i);\n    }\n    \n    s.splice(0, s.length);\n    // 从右往左遍历，计算right数组\n    for (let i = n - 1; i >= 0; --i) {\n        // 出栈，直到栈空或者满足栈顶元素 < 当前元素\n        while (s.length != 0 && heights[s[s.length - 1]] >= heights[i]) {\n            s.pop();\n        }\n        if (s.length != 0) {\n            right[i] = s[s.length - 1];\n        }\n        // 入栈\n        s.push(i);\n    }\n\n    let maxRes = 0;\n    for (let i = 0; i < n; ++i) {\n        maxRes = Math.max(maxRes, (right[i] - left[i] - 1) * heights[i]);\n    }\n\n    return maxRes;\n};\n```\n\n\n\n## 42 接雨水\n\n> 题目链接：https://leetcode-cn.com/problems/trapping-rain-water/\n>\n> 给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)\n\n### 思考\n\n我们可以考虑计算每一根柱子所能接的雨水的高度。\n\n这个高度应该是：左右两侧柱子的高度。其中这根柱子满足，它是这根柱子左边（或右边）比它高的那一根柱子所能接到雨水的高度。\n\n` 注意：不是左边（或）右边比它高的柱子的高度，因为可能还有更高的柱子。实际上应该是接到雨水的高度，因为比它高的雨水能借到的柱子，它自己也一定能接到。`\n\n这样问题实际上就转化成了，寻找左边（或右边）最近的比它大的元素。\n\n自然而然，我们应该使用单调递减栈（严格单调递减）：每遍历到一个元素的时候，不断出栈直到栈空或者栈顶元素大于该元素。\n\n### 代码\n\n```typescript\nfunction trap(height: number[]): number {\n    let n = height.length;\n    let left = new Array(n);\n    let right = new Array(n);\n\n    let s = [];\n\n    for (let i = 0; i < n; ++i) {\n        // 出栈，直到栈空或者栈顶元素>该元素\n        while (s.length != 0 && height[s[s.length - 1]] <= height[i]) {\n            s.pop();\n        }\n        if (s.length == 0) {\n            left[i] = height[i];\n        }\n        else {\n            left[i] = left[s[s.length - 1]];\n        }\n        s.push(i);\n    }\n    s.splice(0, s.length);\n    for (let i = n - 1; i >= 0; --i) {\n        // 出栈，直到栈空或者栈顶元素>该元素\n        while (s.length != 0 && height[s[s.length - 1]] <= height[i]) {\n            s.pop();\n        }\n        if (s.length == 0) {\n            right[i] = height[i];\n        }\n        else {\n            right[i] = right[s[s.length - 1]];\n        }\n        s.push(i);\n    }\n    let ans = 0;\n    for (let i = 0; i < n; ++i) {\n        ans += Math.min(left[i], right[i]) - height[i];\n    }\n\n    return ans;\n};\n```\n\n","source":"_posts/单调栈的应用.md","raw":"---\ntitle: 单调栈的应用\ndate: 2022-3-31 20:00:00\ndescription: LeetCode中单调栈的一些应用\ncover: https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg\n---\n\n## 84 柱状图中最大的矩形\n\n> 题目链接：https://leetcode-cn.com/problems/largest-rectangle-in-histogram/\n>\n> 给定 `n `个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n>\n> 求在该柱状图中，能够勾勒出来的矩形的最大面积。\n\n<img src='https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg' width='50%'>\n\n### 思考\n\n我们可以反过来考虑针对于每一个元素，都可以求出**以它为高的最大矩形面积**。\n\n那么这样一个矩形，它的底应该是多少呢？\n\n自然而然，我们可以发现：这一个矩形的左侧就是左边比它小的元素的位置，右侧自然也是比它小的元素的位置。\n\n以下图的元素5为例，它的最左侧就应该是比它小的元素1的右边，它的最右侧就应该是比它小的元素2的左边。\n\n![image-20220331205119619](https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220331205119619.png)\n\n因此，问题就转化成了：针对于每一个元素，我们都需要求出左边比它小的元素的位置以及右边比它小的元素的位置。\n\n### 单调栈\n\n那么在从左往右遍历一遍的过程中，如何找出比它小的元素呢？\n\n我们自然而然的想到了单调递增栈（严格单调递增）：每当一个元素到达时候，不断出栈直到栈为空或者栈顶元素小于该元素，那么这个元素就一定是比它小的最近的元素。\n\n### 代码\n\n```typescript\nfunction largestRectangleArea(heights: number[]): number {\n    // 元素个数\n    let n = heights.length;\n\n    let left = new Array(n).fill(-1);\n    let right = new Array(n).fill(n);\n\n    // 单调递增栈：严格单调递增，存储的是元素下标\n    let s = new Array();\n\n    // 从左往右遍历，计算left数组\n    for (let i = 0; i < n; ++i) {\n        // 出栈，直到栈空或者满足栈顶元素 < 当前元素\n        while (s.length != 0 && heights[s[s.length - 1]] >= heights[i]) {\n            s.pop();\n        }\n        if (s.length != 0) {\n            left[i] = s[s.length - 1];\n        }\n        // 入栈\n        s.push(i);\n    }\n    \n    s.splice(0, s.length);\n    // 从右往左遍历，计算right数组\n    for (let i = n - 1; i >= 0; --i) {\n        // 出栈，直到栈空或者满足栈顶元素 < 当前元素\n        while (s.length != 0 && heights[s[s.length - 1]] >= heights[i]) {\n            s.pop();\n        }\n        if (s.length != 0) {\n            right[i] = s[s.length - 1];\n        }\n        // 入栈\n        s.push(i);\n    }\n\n    let maxRes = 0;\n    for (let i = 0; i < n; ++i) {\n        maxRes = Math.max(maxRes, (right[i] - left[i] - 1) * heights[i]);\n    }\n\n    return maxRes;\n};\n```\n\n\n\n## 42 接雨水\n\n> 题目链接：https://leetcode-cn.com/problems/trapping-rain-water/\n>\n> 给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)\n\n### 思考\n\n我们可以考虑计算每一根柱子所能接的雨水的高度。\n\n这个高度应该是：左右两侧柱子的高度。其中这根柱子满足，它是这根柱子左边（或右边）比它高的那一根柱子所能接到雨水的高度。\n\n` 注意：不是左边（或）右边比它高的柱子的高度，因为可能还有更高的柱子。实际上应该是接到雨水的高度，因为比它高的雨水能借到的柱子，它自己也一定能接到。`\n\n这样问题实际上就转化成了，寻找左边（或右边）最近的比它大的元素。\n\n自然而然，我们应该使用单调递减栈（严格单调递减）：每遍历到一个元素的时候，不断出栈直到栈空或者栈顶元素大于该元素。\n\n### 代码\n\n```typescript\nfunction trap(height: number[]): number {\n    let n = height.length;\n    let left = new Array(n);\n    let right = new Array(n);\n\n    let s = [];\n\n    for (let i = 0; i < n; ++i) {\n        // 出栈，直到栈空或者栈顶元素>该元素\n        while (s.length != 0 && height[s[s.length - 1]] <= height[i]) {\n            s.pop();\n        }\n        if (s.length == 0) {\n            left[i] = height[i];\n        }\n        else {\n            left[i] = left[s[s.length - 1]];\n        }\n        s.push(i);\n    }\n    s.splice(0, s.length);\n    for (let i = n - 1; i >= 0; --i) {\n        // 出栈，直到栈空或者栈顶元素>该元素\n        while (s.length != 0 && height[s[s.length - 1]] <= height[i]) {\n            s.pop();\n        }\n        if (s.length == 0) {\n            right[i] = height[i];\n        }\n        else {\n            right[i] = right[s[s.length - 1]];\n        }\n        s.push(i);\n    }\n    let ans = 0;\n    for (let i = 0; i < n; ++i) {\n        ans += Math.min(left[i], right[i]) - height[i];\n    }\n\n    return ans;\n};\n```\n\n","slug":"单调栈的应用","published":1,"updated":"2022-04-01T05:59:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmhg4qt49000df5fa06cx6y7a","content":"<h2 id=\"84-柱状图中最大的矩形\"><a href=\"#84-柱状图中最大的矩形\" class=\"headerlink\" title=\"84 柱状图中最大的矩形\"></a>84 柱状图中最大的矩形</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode-cn.com/problems/largest-rectangle-in-histogram/\">https://leetcode-cn.com/problems/largest-rectangle-in-histogram/</a></p>\n<p>给定 <code>n </code>个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>\n<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>\n</blockquote>\n<img src='https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg' width='50%'>\n\n<h3 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h3><p>我们可以反过来考虑针对于每一个元素，都可以求出<strong>以它为高的最大矩形面积</strong>。</p>\n<p>那么这样一个矩形，它的底应该是多少呢？</p>\n<p>自然而然，我们可以发现：这一个矩形的左侧就是左边比它小的元素的位置，右侧自然也是比它小的元素的位置。</p>\n<p>以下图的元素5为例，它的最左侧就应该是比它小的元素1的右边，它的最右侧就应该是比它小的元素2的左边。</p>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220331205119619.png\" alt=\"image-20220331205119619\"></p>\n<p>因此，问题就转化成了：针对于每一个元素，我们都需要求出左边比它小的元素的位置以及右边比它小的元素的位置。</p>\n<h3 id=\"单调栈\"><a href=\"#单调栈\" class=\"headerlink\" title=\"单调栈\"></a>单调栈</h3><p>那么在从左往右遍历一遍的过程中，如何找出比它小的元素呢？</p>\n<p>我们自然而然的想到了单调递增栈（严格单调递增）：每当一个元素到达时候，不断出栈直到栈为空或者栈顶元素小于该元素，那么这个元素就一定是比它小的最近的元素。</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">largestRectangleArea</span>(<span class=\"params\">heights: <span class=\"built_in\">number</span>[]</span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 元素个数</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> n = heights.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> left = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(n).fill(-<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> right = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(n).fill(n);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 单调递增栈：严格单调递增，存储的是元素下标</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从左往右遍历，计算left数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 出栈，直到栈空或者满足栈顶元素 &lt; 当前元素</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (s.length != <span class=\"number\">0</span> &amp;&amp; heights[s[s.length - <span class=\"number\">1</span>]] &gt;= heights[i]) &#123;</span><br><span class=\"line\">            s.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            left[i] = s[s.length - <span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 入栈</span></span><br><span class=\"line\">        s.push(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    s.splice(<span class=\"number\">0</span>, s.length);</span><br><span class=\"line\">    <span class=\"comment\">// 从右往左遍历，计算right数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 出栈，直到栈空或者满足栈顶元素 &lt; 当前元素</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (s.length != <span class=\"number\">0</span> &amp;&amp; heights[s[s.length - <span class=\"number\">1</span>]] &gt;= heights[i]) &#123;</span><br><span class=\"line\">            s.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            right[i] = s[s.length - <span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 入栈</span></span><br><span class=\"line\">        s.push(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> maxRes = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        maxRes = <span class=\"built_in\">Math</span>.max(maxRes, (right[i] - left[i] - <span class=\"number\">1</span>) * heights[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> maxRes;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"42-接雨水\"><a href=\"#42-接雨水\" class=\"headerlink\" title=\"42 接雨水\"></a>42 接雨水</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode-cn.com/problems/trapping-rain-water/\">https://leetcode-cn.com/problems/trapping-rain-water/</a></p>\n<p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>\n</blockquote>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png\" alt=\"img\"></p>\n<h3 id=\"思考-1\"><a href=\"#思考-1\" class=\"headerlink\" title=\"思考\"></a>思考</h3><p>我们可以考虑计算每一根柱子所能接的雨水的高度。</p>\n<p>这个高度应该是：左右两侧柱子的高度。其中这根柱子满足，它是这根柱子左边（或右边）比它高的那一根柱子所能接到雨水的高度。</p>\n<p><code> 注意：不是左边（或）右边比它高的柱子的高度，因为可能还有更高的柱子。实际上应该是接到雨水的高度，因为比它高的雨水能借到的柱子，它自己也一定能接到。</code></p>\n<p>这样问题实际上就转化成了，寻找左边（或右边）最近的比它大的元素。</p>\n<p>自然而然，我们应该使用单调递减栈（严格单调递减）：每遍历到一个元素的时候，不断出栈直到栈空或者栈顶元素大于该元素。</p>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">trap</span>(<span class=\"params\">height: <span class=\"built_in\">number</span>[]</span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> n = height.length;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> left = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(n);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> right = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(n);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> s = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 出栈，直到栈空或者栈顶元素&gt;该元素</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (s.length != <span class=\"number\">0</span> &amp;&amp; height[s[s.length - <span class=\"number\">1</span>]] &lt;= height[i]) &#123;</span><br><span class=\"line\">            s.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            left[i] = height[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            left[i] = left[s[s.length - <span class=\"number\">1</span>]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        s.push(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s.splice(<span class=\"number\">0</span>, s.length);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 出栈，直到栈空或者栈顶元素&gt;该元素</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (s.length != <span class=\"number\">0</span> &amp;&amp; height[s[s.length - <span class=\"number\">1</span>]] &lt;= height[i]) &#123;</span><br><span class=\"line\">            s.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            right[i] = height[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            right[i] = right[s[s.length - <span class=\"number\">1</span>]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        s.push(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        ans += <span class=\"built_in\">Math</span>.min(left[i], right[i]) - height[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<h2 id=\"84-柱状图中最大的矩形\"><a href=\"#84-柱状图中最大的矩形\" class=\"headerlink\" title=\"84 柱状图中最大的矩形\"></a>84 柱状图中最大的矩形</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode-cn.com/problems/largest-rectangle-in-histogram/\">https://leetcode-cn.com/problems/largest-rectangle-in-histogram/</a></p>\n<p>给定 <code>n </code>个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>\n<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>\n</blockquote>\n<img src='https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg' width='50%'>\n\n<h3 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h3><p>我们可以反过来考虑针对于每一个元素，都可以求出<strong>以它为高的最大矩形面积</strong>。</p>\n<p>那么这样一个矩形，它的底应该是多少呢？</p>\n<p>自然而然，我们可以发现：这一个矩形的左侧就是左边比它小的元素的位置，右侧自然也是比它小的元素的位置。</p>\n<p>以下图的元素5为例，它的最左侧就应该是比它小的元素1的右边，它的最右侧就应该是比它小的元素2的左边。</p>\n<p><img src=\"https://wwwtypora.oss-cn-shanghai.aliyuncs.com/image-20220331205119619.png\" alt=\"image-20220331205119619\"></p>\n<p>因此，问题就转化成了：针对于每一个元素，我们都需要求出左边比它小的元素的位置以及右边比它小的元素的位置。</p>\n<h3 id=\"单调栈\"><a href=\"#单调栈\" class=\"headerlink\" title=\"单调栈\"></a>单调栈</h3><p>那么在从左往右遍历一遍的过程中，如何找出比它小的元素呢？</p>\n<p>我们自然而然的想到了单调递增栈（严格单调递增）：每当一个元素到达时候，不断出栈直到栈为空或者栈顶元素小于该元素，那么这个元素就一定是比它小的最近的元素。</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">largestRectangleArea</span>(<span class=\"params\">heights: <span class=\"built_in\">number</span>[]</span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 元素个数</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> n = heights.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> left = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(n).fill(-<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> right = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(n).fill(n);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 单调递增栈：严格单调递增，存储的是元素下标</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> s = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从左往右遍历，计算left数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 出栈，直到栈空或者满足栈顶元素 &lt; 当前元素</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (s.length != <span class=\"number\">0</span> &amp;&amp; heights[s[s.length - <span class=\"number\">1</span>]] &gt;= heights[i]) &#123;</span><br><span class=\"line\">            s.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            left[i] = s[s.length - <span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 入栈</span></span><br><span class=\"line\">        s.push(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    s.splice(<span class=\"number\">0</span>, s.length);</span><br><span class=\"line\">    <span class=\"comment\">// 从右往左遍历，计算right数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 出栈，直到栈空或者满足栈顶元素 &lt; 当前元素</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (s.length != <span class=\"number\">0</span> &amp;&amp; heights[s[s.length - <span class=\"number\">1</span>]] &gt;= heights[i]) &#123;</span><br><span class=\"line\">            s.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            right[i] = s[s.length - <span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 入栈</span></span><br><span class=\"line\">        s.push(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> maxRes = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        maxRes = <span class=\"built_in\">Math</span>.max(maxRes, (right[i] - left[i] - <span class=\"number\">1</span>) * heights[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> maxRes;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"42-接雨水\"><a href=\"#42-接雨水\" class=\"headerlink\" title=\"42 接雨水\"></a>42 接雨水</h2><blockquote>\n<p>题目链接：<a href=\"https://leetcode-cn.com/problems/trapping-rain-water/\">https://leetcode-cn.com/problems/trapping-rain-water/</a></p>\n<p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>\n</blockquote>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png\" alt=\"img\"></p>\n<h3 id=\"思考-1\"><a href=\"#思考-1\" class=\"headerlink\" title=\"思考\"></a>思考</h3><p>我们可以考虑计算每一根柱子所能接的雨水的高度。</p>\n<p>这个高度应该是：左右两侧柱子的高度。其中这根柱子满足，它是这根柱子左边（或右边）比它高的那一根柱子所能接到雨水的高度。</p>\n<p><code> 注意：不是左边（或）右边比它高的柱子的高度，因为可能还有更高的柱子。实际上应该是接到雨水的高度，因为比它高的雨水能借到的柱子，它自己也一定能接到。</code></p>\n<p>这样问题实际上就转化成了，寻找左边（或右边）最近的比它大的元素。</p>\n<p>自然而然，我们应该使用单调递减栈（严格单调递减）：每遍历到一个元素的时候，不断出栈直到栈空或者栈顶元素大于该元素。</p>\n<h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">trap</span>(<span class=\"params\">height: <span class=\"built_in\">number</span>[]</span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> n = height.length;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> left = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(n);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> right = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(n);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> s = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 出栈，直到栈空或者栈顶元素&gt;该元素</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (s.length != <span class=\"number\">0</span> &amp;&amp; height[s[s.length - <span class=\"number\">1</span>]] &lt;= height[i]) &#123;</span><br><span class=\"line\">            s.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            left[i] = height[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            left[i] = left[s[s.length - <span class=\"number\">1</span>]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        s.push(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s.splice(<span class=\"number\">0</span>, s.length);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 出栈，直到栈空或者栈顶元素&gt;该元素</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (s.length != <span class=\"number\">0</span> &amp;&amp; height[s[s.length - <span class=\"number\">1</span>]] &lt;= height[i]) &#123;</span><br><span class=\"line\">            s.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            right[i] = height[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            right[i] = right[s[s.length - <span class=\"number\">1</span>]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        s.push(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        ans += <span class=\"built_in\">Math</span>.min(left[i], right[i]) - height[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"数位DP解题思路","date":"2024-01-16T05:04:31.000Z","_content":"## 参考链接\n\nhttps://oi-wiki.org/dp/number/\n\nhttps://blog.csdn.net/JKdd123456/article/details/81383012\n\n### demo\n\n> 题目大意：多组数据，每次给定区间  [n,m]  ，求在n到m中没有  “62“ （连续）或 “4“ 的数的个数。\n> 如62315包含62，88914包含4，这两个数都是不合法的。\n> 0 < n<=m < 1000000\n\n\n\n试想：我们如果能有一个函数count(int x)，可以返回[0,x]之间符合题意的数的个数。\n\n那么是不是直接输出count(m)-count(n-1)就是答案？\n\n设一个数组dp[i][j]表示i位数，最高位是j 的符合题意的个数\n\n\n\n### 模板\n\nhttps://leetcode.cn/problems/count-special-integers/solutions/1746956/shu-wei-dp-mo-ban-by-endlesscheng-xtgx/\n","source":"_posts/数位DP解题思路.md","raw":"---\ntitle: 数位DP解题思路\ndate: 2024-01-16 13:04:31\ntags:\n---\n## 参考链接\n\nhttps://oi-wiki.org/dp/number/\n\nhttps://blog.csdn.net/JKdd123456/article/details/81383012\n\n### demo\n\n> 题目大意：多组数据，每次给定区间  [n,m]  ，求在n到m中没有  “62“ （连续）或 “4“ 的数的个数。\n> 如62315包含62，88914包含4，这两个数都是不合法的。\n> 0 < n<=m < 1000000\n\n\n\n试想：我们如果能有一个函数count(int x)，可以返回[0,x]之间符合题意的数的个数。\n\n那么是不是直接输出count(m)-count(n-1)就是答案？\n\n设一个数组dp[i][j]表示i位数，最高位是j 的符合题意的个数\n\n\n\n### 模板\n\nhttps://leetcode.cn/problems/count-special-integers/solutions/1746956/shu-wei-dp-mo-ban-by-endlesscheng-xtgx/\n","slug":"数位DP解题思路","published":1,"updated":"2024-01-21T09:12:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmhg4qt49000ef5fa53if60i0","content":"<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://oi-wiki.org/dp/number/\">https://oi-wiki.org/dp/number/</a></p>\n<p><a href=\"https://blog.csdn.net/JKdd123456/article/details/81383012\">https://blog.csdn.net/JKdd123456/article/details/81383012</a></p>\n<h3 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h3><blockquote>\n<p>题目大意：多组数据，每次给定区间  [n,m]  ，求在n到m中没有  “62“ （连续）或 “4“ 的数的个数。<br>如62315包含62，88914包含4，这两个数都是不合法的。<br>0 &lt; n&lt;=m &lt; 1000000</p>\n</blockquote>\n<p>试想：我们如果能有一个函数count(int x)，可以返回[0,x]之间符合题意的数的个数。</p>\n<p>那么是不是直接输出count(m)-count(n-1)就是答案？</p>\n<p>设一个数组dp[i][j]表示i位数，最高位是j 的符合题意的个数</p>\n<h3 id=\"模板\"><a href=\"#模板\" class=\"headerlink\" title=\"模板\"></a>模板</h3><p><a href=\"https://leetcode.cn/problems/count-special-integers/solutions/1746956/shu-wei-dp-mo-ban-by-endlesscheng-xtgx/\">https://leetcode.cn/problems/count-special-integers/solutions/1746956/shu-wei-dp-mo-ban-by-endlesscheng-xtgx/</a></p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://oi-wiki.org/dp/number/\">https://oi-wiki.org/dp/number/</a></p>\n<p><a href=\"https://blog.csdn.net/JKdd123456/article/details/81383012\">https://blog.csdn.net/JKdd123456/article/details/81383012</a></p>\n<h3 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h3><blockquote>\n<p>题目大意：多组数据，每次给定区间  [n,m]  ，求在n到m中没有  “62“ （连续）或 “4“ 的数的个数。<br>如62315包含62，88914包含4，这两个数都是不合法的。<br>0 &lt; n&lt;=m &lt; 1000000</p>\n</blockquote>\n<p>试想：我们如果能有一个函数count(int x)，可以返回[0,x]之间符合题意的数的个数。</p>\n<p>那么是不是直接输出count(m)-count(n-1)就是答案？</p>\n<p>设一个数组dp[i][j]表示i位数，最高位是j 的符合题意的个数</p>\n<h3 id=\"模板\"><a href=\"#模板\" class=\"headerlink\" title=\"模板\"></a>模板</h3><p><a href=\"https://leetcode.cn/problems/count-special-integers/solutions/1746956/shu-wei-dp-mo-ban-by-endlesscheng-xtgx/\">https://leetcode.cn/problems/count-special-integers/solutions/1746956/shu-wei-dp-mo-ban-by-endlesscheng-xtgx/</a></p>\n"},{"title":"数据结构总复习（1）——数组、链表、队列、栈和稀疏矩阵","date":"2021-01-04T16:00:00.000Z","description":"复习专辑","cover":"https://s3.ax1x.com/2021/01/05/sk0Own.jpg","_content":"\n> 数据结构复习\n>\n> 由于复习比较个人向，因此主要记录的是我容易混淆的知识点以及自己一直记不住的一些题\n>\n> 另外题目基本全部来自某考研复习资料，因此建议辅助该书学习为佳\n\n\n\n# 数组和链表\n\n## 重要知识点\n\n略\n\n\n\n## 题目\n\n> 1.找出数组中出现次数最多的元素\n\n**时间复杂度：O(N)**\n\n**空间复杂度：O（1）**\n\n依次扫描所给数组中的每个整数，将第一个遇到的整数Num保存到c中，记录Num出现的次数为1；若遇到的下一个整数仍等于Num，则计数加1，否则计数减1；当计数减到0时，将遇到的下一个整数保存到c中，计数重新记为1，开始新一轮计数，即从当前位置开始重复上述过程，直到扫描全部数组元素。\n\n\n\n> 2.求两个等长升序序列合并后的中位数\n\n**时间复杂度：O（logN）**\n\n**空间复杂度：O（1）**\n\n分别求两个升序序列A、B的中位数，设为a和b，求序列A、B的中位数过程如下：\n\n（1）若a=b，则a或b即为所求中位数，算法结束；\n\n（2）若a<b，则舍弃序列A中较小的一半，同时舍弃序列B中较大的一半，要求两次舍弃的长度相等；\n\n（3）若a>b，则舍弃序列A中较大的一半，同时舍弃序列B中较小的一半，要求两次舍弃的长度相等；\n\n在保留的两个升序序列中，重复过程（1）~（3），直到两个序列中均只含一个元素时为止，较小者即为所求的中位数。\n\n\n\n> 3.从尾到头反向输出带头结点的单链表中每个结点的值\n\n**时间复杂度：O（N）**\n\n**空间复杂度：O（N）**\n\n利用递归函数，思路如下：\n\n```c++\nvoid R_Print(LinkList L)\n{\n    if (L->next != nullptr)\n        R_print(L->next);\n    if (L!=nullptr)\n        cout<<L->data<<\" \";\n}\n```\n\n\n\n> 4.将带头结点的单链表就地逆置。\n\n**时间复杂度：O（N）**\n\n**空间复杂度：O（1）**\n\n将头结点摘下，然后从第一个结点开始，依次插入到头结点之后（即头插法建立单链表）。\n\n\n\n> 5.给定两个单链表，找出两个链表的公共结点。\n\n**时间复杂度：O（len1+len2)**\n\n**空间复杂度：O（1）**\n\n由于两个链表有一个公共结点，则该公共结点之后的所有结点都是重合的。\n\n因此假设一个链表比另一个链表长k个结点，只需在较长的链表上先遍历k个结点，然后再同步遍历。接下来，一一比较即可找出公共结点。\n\n\n\n> 6.**遍历一遍**找出带头结点的单链表倒数第k个结点。\n\n定义两个指针变量p和q，初始时均指向头结点的下一个结点（链表的第一个结点），p指针沿链表移动；当p指针移动到第k个结点时，q指针开始与p指针同步移动；当p指针移动到最后一个结点时，q指针所指结点为倒数第k个结点。**关键：让一个结点先走一定距离。**\n\n\n\n> 7.将线性表L=(a1,a2,...,an-2,an-1,an)重新排列为L'=(a1,an,a2,an-1,a3,an-2...)。\n\n**时间复杂度：O（N）**\n\n**空间复杂度：O（1）**\n\n分为三个重要的步骤：\n\n（1）找出链表L的中间结点：与第6题思路相同，设置两个指针p和q，指针p每走一步，q走两步。当指针q到达链表尾的时候，p恰好在链表的中间结点位置；\n\n（2）原地逆置：参考第4题思路，利用头插法逆置；\n\n（3）从单链表前后两段各取一个结点，按要求重排。\n\n以上三步时间复杂度均为O（N），因此总的时间复杂度也为O（N)。\n\n\n\n# 栈和队列\n\n## 重要知识点\n\n1.n个不同元素进栈，出栈元素不同排列的个数为1/(n+1)*C(2n,n)\n\n2.顺序表存储的队列（**依照ppt**）：\n\nfront指向队头元素的前一个元素，rear指向队尾元素\n\n[![skAnH0.jpg](https://s3.ax1x.com/2021/01/05/skAnH0.jpg)](https://imgchr.com/i/skAnH0)\n\n3.循环队列：\n\n[![skVhcQ.jpg](https://s3.ax1x.com/2021/01/05/skVhcQ.jpg)](https://imgchr.com/i/skVhcQ)\n\n- 队头指针进1: front = (front + 1) % maxSize; \n- 队尾指针进1: rear = (rear + 1) % maxSize ; \n- 队列初始化：front = rear = 0; \n- 队空条件：front == rear; \n- 队满条件：(rear + 1) % maxSize\n\n4.队列中，注意入队只改变rear的值，出队只改变front的值。\n\n5.运算符优先级（中缀表达式转后缀表达式）：\n\n|     操作符      |  (   | *,/  | +,-  |  )   |\n| :-------------: | :--: | :--: | :--: | :--: |\n| isp(栈内优先级) |  1   |  5   |  3   |  6   |\n| icp(栈外优先级) |  6   |  4   |  2   |  1   |\n\n​\t读取字符ch：\n\n- 若ch是操作数，则直接输出，同时继续读取；\n- 若ch是操作符，则需要判断ch的优先级icp和当前位于栈顶的操作符op的优先级isp，执行下面的循环过程：\n  - 若icp(ch)>isp(op)，则ch进栈，继续读取；\n  - 若icp(ch)<isp(op)，则退栈并输出；\n  - 若icp(ch)==isp(op)，退栈但不输出，若退出的是'('则继续读取。\n\n\n\n## 题目\n\n> 1.若一个栈的输入序列是P1,P2,...Pn,输出序列是1,2,3,...n，若P3=1，则P1的值？\n\nP1可以取除了2以外的所有值。\n\nP2可以取除了n以外的所有值。\n\nP4可以取除了n-1,n以外的所有值。\n\n\n\n> 2.一个栈的入栈序列为1,2,3,...,n，出栈数列是P1,P2,P3,...,Pn。若P2=1,则P3的可能取值个数为多少？\n\nn-1个。\n\n很显然：3之后的4,5,...,n都是P3可取的数（持续进栈直到该数入栈后立即出栈）。\n\n接下来考虑1和2：当P1=1时，P3可取2；当P1=2时，P3可取1。\n\n\n\n> 3.若用数组A[0...5]来实现循环队列，且当前rear和front的值分别为1和5，当从队列中删除一个元素，再加入两个元素后，rear和front的值分别为？\n\n3和0。本题需要注意的是从循环队列中删除操作的方法是front=(front+1)%maxSize，注意不要反向。\n\n\n\n# 稀疏矩阵\n\n## 重要知识点\n\n1.稀疏矩阵中采用结构体存储数据：\n\n```c++\nstruct Trituple\n{\n    int row,col; //非零元素所在的行号、列号\n    Type value; //非零元素的值\n}\n```\n\n2.快速转置算法：\n\n> 建立辅助数组rowSize 和 rowStart，记录矩阵转置后各行**非零元素个数**和**各行元素在转置三元组表中开始存放位置**。\n>\n> 扫描矩阵三元组表，根据某项的列号，确定它转置后的行号，查 **rowStart**表，按查到的 位置直接将该项存入转置三元组表中。 ","source":"_posts/数据结构复习.md","raw":"---\ntitle: 数据结构总复习（1）——数组、链表、队列、栈和稀疏矩阵\ndate: 2021-1-5 00:00:00\ndescription: 复习专辑\ncover: https://s3.ax1x.com/2021/01/05/sk0Own.jpg\n---\n\n> 数据结构复习\n>\n> 由于复习比较个人向，因此主要记录的是我容易混淆的知识点以及自己一直记不住的一些题\n>\n> 另外题目基本全部来自某考研复习资料，因此建议辅助该书学习为佳\n\n\n\n# 数组和链表\n\n## 重要知识点\n\n略\n\n\n\n## 题目\n\n> 1.找出数组中出现次数最多的元素\n\n**时间复杂度：O(N)**\n\n**空间复杂度：O（1）**\n\n依次扫描所给数组中的每个整数，将第一个遇到的整数Num保存到c中，记录Num出现的次数为1；若遇到的下一个整数仍等于Num，则计数加1，否则计数减1；当计数减到0时，将遇到的下一个整数保存到c中，计数重新记为1，开始新一轮计数，即从当前位置开始重复上述过程，直到扫描全部数组元素。\n\n\n\n> 2.求两个等长升序序列合并后的中位数\n\n**时间复杂度：O（logN）**\n\n**空间复杂度：O（1）**\n\n分别求两个升序序列A、B的中位数，设为a和b，求序列A、B的中位数过程如下：\n\n（1）若a=b，则a或b即为所求中位数，算法结束；\n\n（2）若a<b，则舍弃序列A中较小的一半，同时舍弃序列B中较大的一半，要求两次舍弃的长度相等；\n\n（3）若a>b，则舍弃序列A中较大的一半，同时舍弃序列B中较小的一半，要求两次舍弃的长度相等；\n\n在保留的两个升序序列中，重复过程（1）~（3），直到两个序列中均只含一个元素时为止，较小者即为所求的中位数。\n\n\n\n> 3.从尾到头反向输出带头结点的单链表中每个结点的值\n\n**时间复杂度：O（N）**\n\n**空间复杂度：O（N）**\n\n利用递归函数，思路如下：\n\n```c++\nvoid R_Print(LinkList L)\n{\n    if (L->next != nullptr)\n        R_print(L->next);\n    if (L!=nullptr)\n        cout<<L->data<<\" \";\n}\n```\n\n\n\n> 4.将带头结点的单链表就地逆置。\n\n**时间复杂度：O（N）**\n\n**空间复杂度：O（1）**\n\n将头结点摘下，然后从第一个结点开始，依次插入到头结点之后（即头插法建立单链表）。\n\n\n\n> 5.给定两个单链表，找出两个链表的公共结点。\n\n**时间复杂度：O（len1+len2)**\n\n**空间复杂度：O（1）**\n\n由于两个链表有一个公共结点，则该公共结点之后的所有结点都是重合的。\n\n因此假设一个链表比另一个链表长k个结点，只需在较长的链表上先遍历k个结点，然后再同步遍历。接下来，一一比较即可找出公共结点。\n\n\n\n> 6.**遍历一遍**找出带头结点的单链表倒数第k个结点。\n\n定义两个指针变量p和q，初始时均指向头结点的下一个结点（链表的第一个结点），p指针沿链表移动；当p指针移动到第k个结点时，q指针开始与p指针同步移动；当p指针移动到最后一个结点时，q指针所指结点为倒数第k个结点。**关键：让一个结点先走一定距离。**\n\n\n\n> 7.将线性表L=(a1,a2,...,an-2,an-1,an)重新排列为L'=(a1,an,a2,an-1,a3,an-2...)。\n\n**时间复杂度：O（N）**\n\n**空间复杂度：O（1）**\n\n分为三个重要的步骤：\n\n（1）找出链表L的中间结点：与第6题思路相同，设置两个指针p和q，指针p每走一步，q走两步。当指针q到达链表尾的时候，p恰好在链表的中间结点位置；\n\n（2）原地逆置：参考第4题思路，利用头插法逆置；\n\n（3）从单链表前后两段各取一个结点，按要求重排。\n\n以上三步时间复杂度均为O（N），因此总的时间复杂度也为O（N)。\n\n\n\n# 栈和队列\n\n## 重要知识点\n\n1.n个不同元素进栈，出栈元素不同排列的个数为1/(n+1)*C(2n,n)\n\n2.顺序表存储的队列（**依照ppt**）：\n\nfront指向队头元素的前一个元素，rear指向队尾元素\n\n[![skAnH0.jpg](https://s3.ax1x.com/2021/01/05/skAnH0.jpg)](https://imgchr.com/i/skAnH0)\n\n3.循环队列：\n\n[![skVhcQ.jpg](https://s3.ax1x.com/2021/01/05/skVhcQ.jpg)](https://imgchr.com/i/skVhcQ)\n\n- 队头指针进1: front = (front + 1) % maxSize; \n- 队尾指针进1: rear = (rear + 1) % maxSize ; \n- 队列初始化：front = rear = 0; \n- 队空条件：front == rear; \n- 队满条件：(rear + 1) % maxSize\n\n4.队列中，注意入队只改变rear的值，出队只改变front的值。\n\n5.运算符优先级（中缀表达式转后缀表达式）：\n\n|     操作符      |  (   | *,/  | +,-  |  )   |\n| :-------------: | :--: | :--: | :--: | :--: |\n| isp(栈内优先级) |  1   |  5   |  3   |  6   |\n| icp(栈外优先级) |  6   |  4   |  2   |  1   |\n\n​\t读取字符ch：\n\n- 若ch是操作数，则直接输出，同时继续读取；\n- 若ch是操作符，则需要判断ch的优先级icp和当前位于栈顶的操作符op的优先级isp，执行下面的循环过程：\n  - 若icp(ch)>isp(op)，则ch进栈，继续读取；\n  - 若icp(ch)<isp(op)，则退栈并输出；\n  - 若icp(ch)==isp(op)，退栈但不输出，若退出的是'('则继续读取。\n\n\n\n## 题目\n\n> 1.若一个栈的输入序列是P1,P2,...Pn,输出序列是1,2,3,...n，若P3=1，则P1的值？\n\nP1可以取除了2以外的所有值。\n\nP2可以取除了n以外的所有值。\n\nP4可以取除了n-1,n以外的所有值。\n\n\n\n> 2.一个栈的入栈序列为1,2,3,...,n，出栈数列是P1,P2,P3,...,Pn。若P2=1,则P3的可能取值个数为多少？\n\nn-1个。\n\n很显然：3之后的4,5,...,n都是P3可取的数（持续进栈直到该数入栈后立即出栈）。\n\n接下来考虑1和2：当P1=1时，P3可取2；当P1=2时，P3可取1。\n\n\n\n> 3.若用数组A[0...5]来实现循环队列，且当前rear和front的值分别为1和5，当从队列中删除一个元素，再加入两个元素后，rear和front的值分别为？\n\n3和0。本题需要注意的是从循环队列中删除操作的方法是front=(front+1)%maxSize，注意不要反向。\n\n\n\n# 稀疏矩阵\n\n## 重要知识点\n\n1.稀疏矩阵中采用结构体存储数据：\n\n```c++\nstruct Trituple\n{\n    int row,col; //非零元素所在的行号、列号\n    Type value; //非零元素的值\n}\n```\n\n2.快速转置算法：\n\n> 建立辅助数组rowSize 和 rowStart，记录矩阵转置后各行**非零元素个数**和**各行元素在转置三元组表中开始存放位置**。\n>\n> 扫描矩阵三元组表，根据某项的列号，确定它转置后的行号，查 **rowStart**表，按查到的 位置直接将该项存入转置三元组表中。 ","slug":"数据结构复习","published":1,"updated":"2021-01-05T08:53:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmhg4qt4a000ff5fa0oxgh6mt","content":"<blockquote>\n<p>数据结构复习</p>\n<p>由于复习比较个人向，因此主要记录的是我容易混淆的知识点以及自己一直记不住的一些题</p>\n<p>另外题目基本全部来自某考研复习资料，因此建议辅助该书学习为佳</p>\n</blockquote>\n<h1 id=\"数组和链表\"><a href=\"#数组和链表\" class=\"headerlink\" title=\"数组和链表\"></a>数组和链表</h1><h2 id=\"重要知识点\"><a href=\"#重要知识点\" class=\"headerlink\" title=\"重要知识点\"></a>重要知识点</h2><p>略</p>\n<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><blockquote>\n<p>1.找出数组中出现次数最多的元素</p>\n</blockquote>\n<p><strong>时间复杂度：O(N)</strong></p>\n<p><strong>空间复杂度：O（1）</strong></p>\n<p>依次扫描所给数组中的每个整数，将第一个遇到的整数Num保存到c中，记录Num出现的次数为1；若遇到的下一个整数仍等于Num，则计数加1，否则计数减1；当计数减到0时，将遇到的下一个整数保存到c中，计数重新记为1，开始新一轮计数，即从当前位置开始重复上述过程，直到扫描全部数组元素。</p>\n<blockquote>\n<p>2.求两个等长升序序列合并后的中位数</p>\n</blockquote>\n<p><strong>时间复杂度：O（logN）</strong></p>\n<p><strong>空间复杂度：O（1）</strong></p>\n<p>分别求两个升序序列A、B的中位数，设为a和b，求序列A、B的中位数过程如下：</p>\n<p>（1）若a=b，则a或b即为所求中位数，算法结束；</p>\n<p>（2）若a&lt;b，则舍弃序列A中较小的一半，同时舍弃序列B中较大的一半，要求两次舍弃的长度相等；</p>\n<p>（3）若a&gt;b，则舍弃序列A中较大的一半，同时舍弃序列B中较小的一半，要求两次舍弃的长度相等；</p>\n<p>在保留的两个升序序列中，重复过程（1）~（3），直到两个序列中均只含一个元素时为止，较小者即为所求的中位数。</p>\n<blockquote>\n<p>3.从尾到头反向输出带头结点的单链表中每个结点的值</p>\n</blockquote>\n<p><strong>时间复杂度：O（N）</strong></p>\n<p><strong>空间复杂度：O（N）</strong></p>\n<p>利用递归函数，思路如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">R_Print</span><span class=\"params\">(LinkList L)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (L-&gt;next != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        R_print(L-&gt;next);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (L!=<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;L-&gt;data&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<blockquote>\n<p>4.将带头结点的单链表就地逆置。</p>\n</blockquote>\n<p><strong>时间复杂度：O（N）</strong></p>\n<p><strong>空间复杂度：O（1）</strong></p>\n<p>将头结点摘下，然后从第一个结点开始，依次插入到头结点之后（即头插法建立单链表）。</p>\n<blockquote>\n<p>5.给定两个单链表，找出两个链表的公共结点。</p>\n</blockquote>\n<p><strong>时间复杂度：O（len1+len2)</strong></p>\n<p><strong>空间复杂度：O（1）</strong></p>\n<p>由于两个链表有一个公共结点，则该公共结点之后的所有结点都是重合的。</p>\n<p>因此假设一个链表比另一个链表长k个结点，只需在较长的链表上先遍历k个结点，然后再同步遍历。接下来，一一比较即可找出公共结点。</p>\n<blockquote>\n<p>6.<strong>遍历一遍</strong>找出带头结点的单链表倒数第k个结点。</p>\n</blockquote>\n<p>定义两个指针变量p和q，初始时均指向头结点的下一个结点（链表的第一个结点），p指针沿链表移动；当p指针移动到第k个结点时，q指针开始与p指针同步移动；当p指针移动到最后一个结点时，q指针所指结点为倒数第k个结点。<strong>关键：让一个结点先走一定距离。</strong></p>\n<blockquote>\n<p>7.将线性表L=(a1,a2,…,an-2,an-1,an)重新排列为L’=(a1,an,a2,an-1,a3,an-2…)。</p>\n</blockquote>\n<p><strong>时间复杂度：O（N）</strong></p>\n<p><strong>空间复杂度：O（1）</strong></p>\n<p>分为三个重要的步骤：</p>\n<p>（1）找出链表L的中间结点：与第6题思路相同，设置两个指针p和q，指针p每走一步，q走两步。当指针q到达链表尾的时候，p恰好在链表的中间结点位置；</p>\n<p>（2）原地逆置：参考第4题思路，利用头插法逆置；</p>\n<p>（3）从单链表前后两段各取一个结点，按要求重排。</p>\n<p>以上三步时间复杂度均为O（N），因此总的时间复杂度也为O（N)。</p>\n<h1 id=\"栈和队列\"><a href=\"#栈和队列\" class=\"headerlink\" title=\"栈和队列\"></a>栈和队列</h1><h2 id=\"重要知识点-1\"><a href=\"#重要知识点-1\" class=\"headerlink\" title=\"重要知识点\"></a>重要知识点</h2><p>1.n个不同元素进栈，出栈元素不同排列的个数为1/(n+1)*C(2n,n)</p>\n<p>2.顺序表存储的队列（<strong>依照ppt</strong>）：</p>\n<p>front指向队头元素的前一个元素，rear指向队尾元素</p>\n<p><a href=\"https://imgchr.com/i/skAnH0\"><img src=\"https://s3.ax1x.com/2021/01/05/skAnH0.jpg\" alt=\"skAnH0.jpg\"></a></p>\n<p>3.循环队列：</p>\n<p><a href=\"https://imgchr.com/i/skVhcQ\"><img src=\"https://s3.ax1x.com/2021/01/05/skVhcQ.jpg\" alt=\"skVhcQ.jpg\"></a></p>\n<ul>\n<li>队头指针进1: front = (front + 1) % maxSize; </li>\n<li>队尾指针进1: rear = (rear + 1) % maxSize ; </li>\n<li>队列初始化：front = rear = 0; </li>\n<li>队空条件：front == rear; </li>\n<li>队满条件：(rear + 1) % maxSize</li>\n</ul>\n<p>4.队列中，注意入队只改变rear的值，出队只改变front的值。</p>\n<p>5.运算符优先级（中缀表达式转后缀表达式）：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">操作符</th>\n<th align=\"center\">(</th>\n<th align=\"center\">*,/</th>\n<th align=\"center\">+,-</th>\n<th align=\"center\">)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">isp(栈内优先级)</td>\n<td align=\"center\">1</td>\n<td align=\"center\">5</td>\n<td align=\"center\">3</td>\n<td align=\"center\">6</td>\n</tr>\n<tr>\n<td align=\"center\">icp(栈外优先级)</td>\n<td align=\"center\">6</td>\n<td align=\"center\">4</td>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n</tr>\n</tbody></table>\n<p>​    读取字符ch：</p>\n<ul>\n<li>若ch是操作数，则直接输出，同时继续读取；</li>\n<li>若ch是操作符，则需要判断ch的优先级icp和当前位于栈顶的操作符op的优先级isp，执行下面的循环过程：<ul>\n<li>若icp(ch)&gt;isp(op)，则ch进栈，继续读取；</li>\n<li>若icp(ch)&lt;isp(op)，则退栈并输出；</li>\n<li>若icp(ch)==isp(op)，退栈但不输出，若退出的是’(‘则继续读取。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"题目-1\"><a href=\"#题目-1\" class=\"headerlink\" title=\"题目\"></a>题目</h2><blockquote>\n<p>1.若一个栈的输入序列是P1,P2,…Pn,输出序列是1,2,3,…n，若P3=1，则P1的值？</p>\n</blockquote>\n<p>P1可以取除了2以外的所有值。</p>\n<p>P2可以取除了n以外的所有值。</p>\n<p>P4可以取除了n-1,n以外的所有值。</p>\n<blockquote>\n<p>2.一个栈的入栈序列为1,2,3,…,n，出栈数列是P1,P2,P3,…,Pn。若P2=1,则P3的可能取值个数为多少？</p>\n</blockquote>\n<p>n-1个。</p>\n<p>很显然：3之后的4,5,…,n都是P3可取的数（持续进栈直到该数入栈后立即出栈）。</p>\n<p>接下来考虑1和2：当P1=1时，P3可取2；当P1=2时，P3可取1。</p>\n<blockquote>\n<p>3.若用数组A[0…5]来实现循环队列，且当前rear和front的值分别为1和5，当从队列中删除一个元素，再加入两个元素后，rear和front的值分别为？</p>\n</blockquote>\n<p>3和0。本题需要注意的是从循环队列中删除操作的方法是front=(front+1)%maxSize，注意不要反向。</p>\n<h1 id=\"稀疏矩阵\"><a href=\"#稀疏矩阵\" class=\"headerlink\" title=\"稀疏矩阵\"></a>稀疏矩阵</h1><h2 id=\"重要知识点-2\"><a href=\"#重要知识点-2\" class=\"headerlink\" title=\"重要知识点\"></a>重要知识点</h2><p>1.稀疏矩阵中采用结构体存储数据：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Trituple</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> row,col; <span class=\"comment\">//非零元素所在的行号、列号</span></span><br><span class=\"line\">    Type value; <span class=\"comment\">//非零元素的值</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2.快速转置算法：</p>\n<blockquote>\n<p>建立辅助数组rowSize 和 rowStart，记录矩阵转置后各行<strong>非零元素个数</strong>和<strong>各行元素在转置三元组表中开始存放位置</strong>。</p>\n<p>扫描矩阵三元组表，根据某项的列号，确定它转置后的行号，查 <strong>rowStart</strong>表，按查到的 位置直接将该项存入转置三元组表中。 </p>\n</blockquote>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<blockquote>\n<p>数据结构复习</p>\n<p>由于复习比较个人向，因此主要记录的是我容易混淆的知识点以及自己一直记不住的一些题</p>\n<p>另外题目基本全部来自某考研复习资料，因此建议辅助该书学习为佳</p>\n</blockquote>\n<h1 id=\"数组和链表\"><a href=\"#数组和链表\" class=\"headerlink\" title=\"数组和链表\"></a>数组和链表</h1><h2 id=\"重要知识点\"><a href=\"#重要知识点\" class=\"headerlink\" title=\"重要知识点\"></a>重要知识点</h2><p>略</p>\n<h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><blockquote>\n<p>1.找出数组中出现次数最多的元素</p>\n</blockquote>\n<p><strong>时间复杂度：O(N)</strong></p>\n<p><strong>空间复杂度：O（1）</strong></p>\n<p>依次扫描所给数组中的每个整数，将第一个遇到的整数Num保存到c中，记录Num出现的次数为1；若遇到的下一个整数仍等于Num，则计数加1，否则计数减1；当计数减到0时，将遇到的下一个整数保存到c中，计数重新记为1，开始新一轮计数，即从当前位置开始重复上述过程，直到扫描全部数组元素。</p>\n<blockquote>\n<p>2.求两个等长升序序列合并后的中位数</p>\n</blockquote>\n<p><strong>时间复杂度：O（logN）</strong></p>\n<p><strong>空间复杂度：O（1）</strong></p>\n<p>分别求两个升序序列A、B的中位数，设为a和b，求序列A、B的中位数过程如下：</p>\n<p>（1）若a=b，则a或b即为所求中位数，算法结束；</p>\n<p>（2）若a&lt;b，则舍弃序列A中较小的一半，同时舍弃序列B中较大的一半，要求两次舍弃的长度相等；</p>\n<p>（3）若a&gt;b，则舍弃序列A中较大的一半，同时舍弃序列B中较小的一半，要求两次舍弃的长度相等；</p>\n<p>在保留的两个升序序列中，重复过程（1）~（3），直到两个序列中均只含一个元素时为止，较小者即为所求的中位数。</p>\n<blockquote>\n<p>3.从尾到头反向输出带头结点的单链表中每个结点的值</p>\n</blockquote>\n<p><strong>时间复杂度：O（N）</strong></p>\n<p><strong>空间复杂度：O（N）</strong></p>\n<p>利用递归函数，思路如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">R_Print</span><span class=\"params\">(LinkList L)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (L-&gt;next != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        R_print(L-&gt;next);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (L!=<span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;L-&gt;data&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<blockquote>\n<p>4.将带头结点的单链表就地逆置。</p>\n</blockquote>\n<p><strong>时间复杂度：O（N）</strong></p>\n<p><strong>空间复杂度：O（1）</strong></p>\n<p>将头结点摘下，然后从第一个结点开始，依次插入到头结点之后（即头插法建立单链表）。</p>\n<blockquote>\n<p>5.给定两个单链表，找出两个链表的公共结点。</p>\n</blockquote>\n<p><strong>时间复杂度：O（len1+len2)</strong></p>\n<p><strong>空间复杂度：O（1）</strong></p>\n<p>由于两个链表有一个公共结点，则该公共结点之后的所有结点都是重合的。</p>\n<p>因此假设一个链表比另一个链表长k个结点，只需在较长的链表上先遍历k个结点，然后再同步遍历。接下来，一一比较即可找出公共结点。</p>\n<blockquote>\n<p>6.<strong>遍历一遍</strong>找出带头结点的单链表倒数第k个结点。</p>\n</blockquote>\n<p>定义两个指针变量p和q，初始时均指向头结点的下一个结点（链表的第一个结点），p指针沿链表移动；当p指针移动到第k个结点时，q指针开始与p指针同步移动；当p指针移动到最后一个结点时，q指针所指结点为倒数第k个结点。<strong>关键：让一个结点先走一定距离。</strong></p>\n<blockquote>\n<p>7.将线性表L=(a1,a2,…,an-2,an-1,an)重新排列为L’=(a1,an,a2,an-1,a3,an-2…)。</p>\n</blockquote>\n<p><strong>时间复杂度：O（N）</strong></p>\n<p><strong>空间复杂度：O（1）</strong></p>\n<p>分为三个重要的步骤：</p>\n<p>（1）找出链表L的中间结点：与第6题思路相同，设置两个指针p和q，指针p每走一步，q走两步。当指针q到达链表尾的时候，p恰好在链表的中间结点位置；</p>\n<p>（2）原地逆置：参考第4题思路，利用头插法逆置；</p>\n<p>（3）从单链表前后两段各取一个结点，按要求重排。</p>\n<p>以上三步时间复杂度均为O（N），因此总的时间复杂度也为O（N)。</p>\n<h1 id=\"栈和队列\"><a href=\"#栈和队列\" class=\"headerlink\" title=\"栈和队列\"></a>栈和队列</h1><h2 id=\"重要知识点-1\"><a href=\"#重要知识点-1\" class=\"headerlink\" title=\"重要知识点\"></a>重要知识点</h2><p>1.n个不同元素进栈，出栈元素不同排列的个数为1/(n+1)*C(2n,n)</p>\n<p>2.顺序表存储的队列（<strong>依照ppt</strong>）：</p>\n<p>front指向队头元素的前一个元素，rear指向队尾元素</p>\n<p><a href=\"https://imgchr.com/i/skAnH0\"><img src=\"https://s3.ax1x.com/2021/01/05/skAnH0.jpg\" alt=\"skAnH0.jpg\"></a></p>\n<p>3.循环队列：</p>\n<p><a href=\"https://imgchr.com/i/skVhcQ\"><img src=\"https://s3.ax1x.com/2021/01/05/skVhcQ.jpg\" alt=\"skVhcQ.jpg\"></a></p>\n<ul>\n<li>队头指针进1: front = (front + 1) % maxSize; </li>\n<li>队尾指针进1: rear = (rear + 1) % maxSize ; </li>\n<li>队列初始化：front = rear = 0; </li>\n<li>队空条件：front == rear; </li>\n<li>队满条件：(rear + 1) % maxSize</li>\n</ul>\n<p>4.队列中，注意入队只改变rear的值，出队只改变front的值。</p>\n<p>5.运算符优先级（中缀表达式转后缀表达式）：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">操作符</th>\n<th align=\"center\">(</th>\n<th align=\"center\">*,/</th>\n<th align=\"center\">+,-</th>\n<th align=\"center\">)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">isp(栈内优先级)</td>\n<td align=\"center\">1</td>\n<td align=\"center\">5</td>\n<td align=\"center\">3</td>\n<td align=\"center\">6</td>\n</tr>\n<tr>\n<td align=\"center\">icp(栈外优先级)</td>\n<td align=\"center\">6</td>\n<td align=\"center\">4</td>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n</tr>\n</tbody></table>\n<p>​    读取字符ch：</p>\n<ul>\n<li>若ch是操作数，则直接输出，同时继续读取；</li>\n<li>若ch是操作符，则需要判断ch的优先级icp和当前位于栈顶的操作符op的优先级isp，执行下面的循环过程：<ul>\n<li>若icp(ch)&gt;isp(op)，则ch进栈，继续读取；</li>\n<li>若icp(ch)&lt;isp(op)，则退栈并输出；</li>\n<li>若icp(ch)==isp(op)，退栈但不输出，若退出的是’(‘则继续读取。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"题目-1\"><a href=\"#题目-1\" class=\"headerlink\" title=\"题目\"></a>题目</h2><blockquote>\n<p>1.若一个栈的输入序列是P1,P2,…Pn,输出序列是1,2,3,…n，若P3=1，则P1的值？</p>\n</blockquote>\n<p>P1可以取除了2以外的所有值。</p>\n<p>P2可以取除了n以外的所有值。</p>\n<p>P4可以取除了n-1,n以外的所有值。</p>\n<blockquote>\n<p>2.一个栈的入栈序列为1,2,3,…,n，出栈数列是P1,P2,P3,…,Pn。若P2=1,则P3的可能取值个数为多少？</p>\n</blockquote>\n<p>n-1个。</p>\n<p>很显然：3之后的4,5,…,n都是P3可取的数（持续进栈直到该数入栈后立即出栈）。</p>\n<p>接下来考虑1和2：当P1=1时，P3可取2；当P1=2时，P3可取1。</p>\n<blockquote>\n<p>3.若用数组A[0…5]来实现循环队列，且当前rear和front的值分别为1和5，当从队列中删除一个元素，再加入两个元素后，rear和front的值分别为？</p>\n</blockquote>\n<p>3和0。本题需要注意的是从循环队列中删除操作的方法是front=(front+1)%maxSize，注意不要反向。</p>\n<h1 id=\"稀疏矩阵\"><a href=\"#稀疏矩阵\" class=\"headerlink\" title=\"稀疏矩阵\"></a>稀疏矩阵</h1><h2 id=\"重要知识点-2\"><a href=\"#重要知识点-2\" class=\"headerlink\" title=\"重要知识点\"></a>重要知识点</h2><p>1.稀疏矩阵中采用结构体存储数据：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Trituple</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> row,col; <span class=\"comment\">//非零元素所在的行号、列号</span></span><br><span class=\"line\">    Type value; <span class=\"comment\">//非零元素的值</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2.快速转置算法：</p>\n<blockquote>\n<p>建立辅助数组rowSize 和 rowStart，记录矩阵转置后各行<strong>非零元素个数</strong>和<strong>各行元素在转置三元组表中开始存放位置</strong>。</p>\n<p>扫描矩阵三元组表，根据某项的列号，确定它转置后的行号，查 <strong>rowStart</strong>表，按查到的 位置直接将该项存入转置三元组表中。 </p>\n</blockquote>\n"},{"title":"四种平衡二叉树","date":"2021-01-06T14:00:00.000Z","description":"速来学习","cover":"https://s3.ax1x.com/2021/01/06/sZE6yD.png","_content":"\n二叉树（Binary Tree）指的是树中结点的度不大于2的有序树，其递归定义是：二叉树是一棵空树，或者是一棵由一个根节点和两棵互不相交的，分别称作根的左子树和右子树组成的非空树；左子树和右子树同样也是二叉树。\n\n二叉树是树形结构的一个重要类型，许多实际问题抽象出来的数据结构往往都是二叉树的类型。即使是一般的树也可以转化为二叉树，并且二叉树的存储结构和算法相对而言都比较简单。因此研究二叉树对于研究数据结构有着重要的意义。\n\n基于二叉树在数据结构中的重要作用，本篇文章中将探讨二叉树的一个重要应用，即作为二叉搜索树时能够发挥的作用。同时，本文也进一步探讨研究了较常使用的平衡二叉树和六种不同的平衡二叉树的性能并对其做了对比分析，为未来计算机应用提供了可供参考的意见。\n\n# **1**  **二叉搜索树**\n\n## **1.1**  二叉搜索树（BST）\n\n二叉搜索树（Binary Search Tree）又称二叉查找树或二叉排序树。作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势。\n\n二叉搜索树的定义也是递归的。它是一棵空树，或者是满足下列性质的二叉树：\n\n1. 每个结点都有一个作为搜索依据的关键码（key），所有节点的关键码互不相同；\n2. 左子树（如果存在）上所有结点的关键码都小于根；\n3. 右子树（如果存在）上所有结点的关键码都大于根；\n4. 左子树和右子树也是一棵二叉搜索树。\n\n如下图所示，就是一棵标准的二叉搜索树：\n\n[![sZAigU.png](https://s3.ax1x.com/2021/01/06/sZAigU.png)](https://imgchr.com/i/sZAigU)\n\n### 1.1.1 搜索\n\n二叉树的搜索是一个递归的过程，流程图如下所示：\n\n[![sZAeER.png](https://s3.ax1x.com/2021/01/06/sZAeER.png)](https://imgchr.com/i/sZAeER)\n\n从树根出发，逐步的缩小查找范围，直到发现目标（成功）或者缩小至空结点（失败）。对于该过程而言，在二叉搜索树的每一层，查找算法至多访问一个结点，并且只需要常数时间。因此，总体所需时间应当线性正比于查找路径的长度，或最终返回结点的深度。对于规模为n的二叉搜索树，深度在最坏情况下可达(n)。\n\n### 1.1.2 插入\n\n 二叉搜索树的插入的流程图如下所示：\n\n[![sZAEDJ.png](https://s3.ax1x.com/2021/01/06/sZAEDJ.png)](https://imgchr.com/i/sZAEDJ)\n\n为了在二叉搜索树中插入一个结点，首先需要利用其搜索操作查找到插入的位置，然后再将新结点作为叶子结点插入（或者更新已存在结点的值）。由于该操作依赖于搜索操作，因此时间复杂度也为O(n)。\n\n### 1.1.3 删除\n\n二叉搜索树的删除的流程图如下所示：\n\n[![sZAVb9.png](https://s3.ax1x.com/2021/01/06/sZAVb9.png)](https://imgchr.com/i/sZAVb9)\n\n二叉搜索树的删除过程也依赖于其查找过程，故时间复杂度也为O(n)。\n\n## **1.2**  平衡二叉搜索树（BBST）\n\n由于二叉搜索树在最坏情况下可能退化为列表，此时的各种效率降至O(n)。因此如果不能有效的控制树高，二叉搜索树无法体现出明显的优势。因此，需要依照某种宽松的标准，重新定义二叉搜索树的平衡性。\n\n平衡二叉搜索树（Balanced Binary Search Tree）指的是在某种约束条件下，树高渐进地不超过O(logN)。在这一约束条件下，各种操作的时间复杂度即可降低为O(logN)。它为每一个结点v的平衡因子（balance factor）定义为左、右子树的高度差，即\n\n **balFac(v) = height(lc(v)) - height(rc(v))**\n\n下图即为定义了平衡因子的二叉搜索树：\n\n[![sZArrQ.png](https://s3.ax1x.com/2021/01/06/sZArrQ.png)](https://imgchr.com/i/sZArrQ)\n\n通过设定这种约束条件，即可达到搜索树的最佳性能。后续将介绍六种二叉搜索树。\n\n# **2** **六种平衡二叉搜索树**\n\n## **2.1** **高度平衡树（AVL**）\n\nAVL是最早发明自平衡二叉树，它被称作高度平衡树。在ALV树中，任意结点平衡因子的绝对值不超过1，即：\n\n **|balFac(v)|≤1**\n\n### 2.1.1 平衡性\n\n[![sZAhxU.png](https://s3.ax1x.com/2021/01/06/sZAhxU.png)](https://imgchr.com/i/sZAhxU)\n\n如上图所示，不妨设结点数最少的AVL树S的根结点为r，r的左、右子树分别为lc和rc，记规模为|lc|和|rc|，高度为h_l和h_r，则有：\n|S|=1+|lc|+|rc|\n由于S的子树lc和rc也是AVL树，并且高度不超过h-1。因此，不妨取：\nh_l=h-1, h_r=h-2,\n|S|=1+| S_(h-1) |+| S_(h-2) |,\n由归纳假设，可以获得如下关系：\n|S|=1+(fib(h+2)-1)+(fib(h+1)-1)\n而根据Fibonacci数列的定义，可以获得：\n|S|=fib(h+2)+fib(h+1)-1=fib(h+3)-1                          \n因此，可以知道：高度为h的AVL树至少包含fib(h+3)-1个结点。由于fib(h)和n次方正比，于是包含n个结点的AVL树的高度应为O(log⁡n )。\n综上可知，AVL树的确是平衡的。\n\n### 2.1.2 旋转\n\nAVL树的插入过程和一般二叉搜索树的过程相同，即：从树根出发，逐步的缩小查找范围，直到发现目标（成功）或者缩小至空结点（失败）。\n\n不同之处在于，二叉树在插入或者删除时，需要维持其平衡。而维持平衡这一过程，正是通过旋转（Rotate）操作来实现的。AVL树的旋转可以归纳为四种：LL单右旋、RR单左旋、LR先左旋再右旋和RL先右旋再左旋。\n\n- LL单右旋：当失衡位置发生在失衡结点左子树的左子树时，需要进行LL单右旋。\n\n[![sZAIr4.png](https://s3.ax1x.com/2021/01/06/sZAIr4.png)](https://imgchr.com/i/sZAIr4)\n\n- RR单左旋：当失衡位置发生在失衡结点右子树的右子树时，需要进行RR单左旋。\n\n[![sZAjxO.png](https://s3.ax1x.com/2021/01/06/sZAjxO.png)](https://imgchr.com/i/sZAjxO)\n\n- LR先左旋再右旋：当失衡位置发生在失衡结点左子树的右子树时，需要进行LR先左旋再右旋。\n\n[![sZESqH.png](https://s3.ax1x.com/2021/01/06/sZESqH.png)](https://imgchr.com/i/sZESqH)\n\n- RL先右旋再左旋：当失衡位置发生在失衡结点右子树的左子树时，需要进行RL先右旋再左旋。\n\n[![sZEFit.png](https://s3.ax1x.com/2021/01/06/sZEFit.png)](https://imgchr.com/i/sZEFit)\n\n### 2.1.3 性能分析\n\n通过2.1.2的旋转操作，AVL树可以满足其性质的定义，通过2.1.1证明可知：包含n个结点的AVL树的高度应为logn 。\n\n由于二叉搜索树的查找操作时间正比于树高，因此AVL树查找的时间复杂度为O(logN) 。同理，插入和删除的时间复杂度也为(logN)。\n\n## **2.2** **伸展树（ST**）\n\n伸展树（Splay Tree）也叫分裂树，相对于AVL树实现更为简捷。伸展树无需时刻都严格地保持全树的平衡，但却能够在任何足够长的真实操作序列中，保持分摊意义上的高效率。伸展树也不需要对基本的二叉树节点结构，做任何附加的要求或改动，更不需要记录平衡因子或高度之类的额外信息，故适用范围更广。\n\n每次查找节点之后对树进行重构，把被查找的节点搬移到树根。每次对伸展树进行操作后，它均会通过伸展（Splay）的方法使得被访问结点置于根结点的位置。\n\n### 2.2.1 伸展\n\n与普通的二叉搜索树的区别在于，伸展树通过伸展操作将元素调整至根结点的位置。这一调整根据结点所在位置的不同，采用不同的调整方法：\n\n| 情形  |     旋转方法     |\n| :---: | :--------------: |\n| 单R型 |      左旋转      |\n| 单L型 |      右旋转      |\n| RR型  |    两次左旋转    |\n| LL型  |    两次右旋转    |\n| RL型  | 先右旋转再左旋转 |\n| LR型  | 先左旋转再右旋转 |\n\n### 2.2.2 性能分析\n\n伸展树能够在O(log⁡n)内完成插入、查找和删除操作。它在不保证最坏情况下的时间复杂度是O(log⁡n)，其边界是均摊的。但是，它有一个最显著的缺点，即有可能变成一条链，这种情况下时间复杂度高达O(n)。\n\n## **2.3** **红黑树（RBT**）\n\n红黑树（Red Black Tree）是一种自平衡二叉搜索树，它等价于4阶B-树。它实际上是一种特化的AVL，均是在进行插入和删除操作时通过特定操作保持二叉搜索树的平衡，从而获得了较高的查找性能。\n\n红黑树保持适度平衡的关键在于：任一结点左、右子树的高度，相差不得超过两倍。为了保持这一平衡，红黑树为其内部的每一个结点定义了颜色属性黑色或者红色（本文章中红黑树黑底表示黑色结点，白底表示红色结点）。\n\n[![sZEliq.png](https://s3.ax1x.com/2021/01/06/sZEliq.png)](https://imgchr.com/i/sZEliq)\n\n与上述二叉搜索树不同，红黑树引入了外部结点作为叶结点（图11中的黑色矩形即为叶结点），它满足下述性质：\n\n1. 每个结点要么是黑色，要么是红色；\n2. 根结点是黑色的；\n3. 每个叶结点（NIL）是黑色的；\n4. 每个红色结点的两个子结点一定都是黑色的；\n5. 任意一个结点到每个叶结点的路径都包含相同数量的黑色结点。\n\n事实上，正是由于性质（5），红黑树的这种平衡被称作黑色完美平衡。红黑树维持平衡主要依靠三种方法：左旋、右旋和染色（结点的颜色由黑变红或者由红变黑）。\n\n### 2.3.1 平衡性\n\n略\n\n### 2.3.2 三种操作\n\n由于红黑树是一棵二叉搜索树，并且查找并不会破坏树的平衡，因此查找和二叉搜索树的查找无异，是一个递归的过程。\n\n红黑树的插入过程分为两步，第一步是查找到插入位置，第二步则是插入后的自平衡。因此，其插入过程可分为下述情况（如图11所示）：\n\n1. 红黑树为空树：将插入的结点作为根结点，并且染色为黑色；\n\n2. 插入结点的父结点为黑色结点：直接插入即可；\n\n3. 插入结点的父结点为红色结点：\n\n   若叔叔结点存在并且为红色结点，则只需将P和S设置为黑色，PP设置为红色，接下来递归的处理PP结点即可；\n\n   [![sZEJQU.png](https://s3.ax1x.com/2021/01/06/sZEJQU.png)](https://imgchr.com/i/sZEJQU)\n\n   若叔叔结点不存在或者为黑色结点，插入结点是父结点的左子结点，父结点是祖先结点的左子结点。该种情况需要将P设为黑色，PP设为红色，同时对PP进行右旋，如下图所示。其余情况实际为该种情况的对称形式，在此不再赘述。\n\n   [![sZEYyF.png](https://s3.ax1x.com/2021/01/06/sZEYyF.png)](https://imgchr.com/i/sZEYyF)\n\n红黑树的删除过程也是先查找到删除位置，然后通过旋转和染色来实现再次平衡。\n\n## **2.4** **替罪羊树（ST**）\n\n替罪羊树（Scapegoat Tree）不同于上述通过旋转来维持相对平衡的二叉搜索树，它是基于一种暴力重构的操作来保持相对平衡的。\n\n### 2.4.1 平衡因子\n\n替罪羊树中定义了一个平衡因子α的概念，范围在0.5到1之间。当某个结点的总结点数* α <它某个子树的总结点数，便会对该结点执行重构操作。\n对于α的取值，如果α越小，那么对平衡的要求越高，重构的次数会更多；α越大，树的平衡程度越低，重构的次数也会随之减少。一般而言，α取0.7左右比较合适。\n\n### 2.4.2 平衡性\n\n略\n\n### 2.4.3 重构\n\n[![sZEaw9.png](https://s3.ax1x.com/2021/01/06/sZEaw9.png)](https://imgchr.com/i/sZEaw9)\n\n如上图所示的替罪羊树，若平衡因子  ，则结点v已发生失衡。重构过程如下：\n\n1. 将这棵树压扁，存入向量中：\n\n[![sZEsSK.png](https://s3.ax1x.com/2021/01/06/sZEsSK.png)](https://imgchr.com/i/sZEsSK)\n\n​\t2.重新建树：每次取区间中点作为根结点，递归左右两边子树建树：\n\n[![sZE6yD.md.png](https://s3.ax1x.com/2021/01/06/sZE6yD.md.png)](https://imgchr.com/i/sZE6yD)\n\n通过上述操作，替罪羊树即完成了其重构操作。并且由2.4.2中结论可知，每次插入后的重构仍然能保证替罪羊树各种操作的时间复杂度达到  。\n\n# **3** **平衡搜索树的性能对比**\n\n根据上述介绍可以看出，AVL、伸展树、红黑树和替罪羊树分别采取了不同的方法实现了相对平衡，复杂度如表2所示。在实际使用时，应当根据工作情景选用：\n\n|  平衡树  |  时间复杂度  |     应用     |\n| :------: | :----------: | :----------: |\n|   AVL    |   O(log n)   | 最早的平衡树 |\n|  伸展树  | 均摊O(log n) |  对区间操作  |\n|  红黑树  |   O(log n)   | 综合效率最高 |\n| 替罪羊树 |   O(log n)   |   实现较易   |\n\n \n\n","source":"_posts/数据结构论文.md","raw":"---\ntitle: 四种平衡二叉树\ndate: 2021-1-6 22:00:00\ndescription: 速来学习\ncover: https://s3.ax1x.com/2021/01/06/sZE6yD.png\n---\n\n二叉树（Binary Tree）指的是树中结点的度不大于2的有序树，其递归定义是：二叉树是一棵空树，或者是一棵由一个根节点和两棵互不相交的，分别称作根的左子树和右子树组成的非空树；左子树和右子树同样也是二叉树。\n\n二叉树是树形结构的一个重要类型，许多实际问题抽象出来的数据结构往往都是二叉树的类型。即使是一般的树也可以转化为二叉树，并且二叉树的存储结构和算法相对而言都比较简单。因此研究二叉树对于研究数据结构有着重要的意义。\n\n基于二叉树在数据结构中的重要作用，本篇文章中将探讨二叉树的一个重要应用，即作为二叉搜索树时能够发挥的作用。同时，本文也进一步探讨研究了较常使用的平衡二叉树和六种不同的平衡二叉树的性能并对其做了对比分析，为未来计算机应用提供了可供参考的意见。\n\n# **1**  **二叉搜索树**\n\n## **1.1**  二叉搜索树（BST）\n\n二叉搜索树（Binary Search Tree）又称二叉查找树或二叉排序树。作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势。\n\n二叉搜索树的定义也是递归的。它是一棵空树，或者是满足下列性质的二叉树：\n\n1. 每个结点都有一个作为搜索依据的关键码（key），所有节点的关键码互不相同；\n2. 左子树（如果存在）上所有结点的关键码都小于根；\n3. 右子树（如果存在）上所有结点的关键码都大于根；\n4. 左子树和右子树也是一棵二叉搜索树。\n\n如下图所示，就是一棵标准的二叉搜索树：\n\n[![sZAigU.png](https://s3.ax1x.com/2021/01/06/sZAigU.png)](https://imgchr.com/i/sZAigU)\n\n### 1.1.1 搜索\n\n二叉树的搜索是一个递归的过程，流程图如下所示：\n\n[![sZAeER.png](https://s3.ax1x.com/2021/01/06/sZAeER.png)](https://imgchr.com/i/sZAeER)\n\n从树根出发，逐步的缩小查找范围，直到发现目标（成功）或者缩小至空结点（失败）。对于该过程而言，在二叉搜索树的每一层，查找算法至多访问一个结点，并且只需要常数时间。因此，总体所需时间应当线性正比于查找路径的长度，或最终返回结点的深度。对于规模为n的二叉搜索树，深度在最坏情况下可达(n)。\n\n### 1.1.2 插入\n\n 二叉搜索树的插入的流程图如下所示：\n\n[![sZAEDJ.png](https://s3.ax1x.com/2021/01/06/sZAEDJ.png)](https://imgchr.com/i/sZAEDJ)\n\n为了在二叉搜索树中插入一个结点，首先需要利用其搜索操作查找到插入的位置，然后再将新结点作为叶子结点插入（或者更新已存在结点的值）。由于该操作依赖于搜索操作，因此时间复杂度也为O(n)。\n\n### 1.1.3 删除\n\n二叉搜索树的删除的流程图如下所示：\n\n[![sZAVb9.png](https://s3.ax1x.com/2021/01/06/sZAVb9.png)](https://imgchr.com/i/sZAVb9)\n\n二叉搜索树的删除过程也依赖于其查找过程，故时间复杂度也为O(n)。\n\n## **1.2**  平衡二叉搜索树（BBST）\n\n由于二叉搜索树在最坏情况下可能退化为列表，此时的各种效率降至O(n)。因此如果不能有效的控制树高，二叉搜索树无法体现出明显的优势。因此，需要依照某种宽松的标准，重新定义二叉搜索树的平衡性。\n\n平衡二叉搜索树（Balanced Binary Search Tree）指的是在某种约束条件下，树高渐进地不超过O(logN)。在这一约束条件下，各种操作的时间复杂度即可降低为O(logN)。它为每一个结点v的平衡因子（balance factor）定义为左、右子树的高度差，即\n\n **balFac(v) = height(lc(v)) - height(rc(v))**\n\n下图即为定义了平衡因子的二叉搜索树：\n\n[![sZArrQ.png](https://s3.ax1x.com/2021/01/06/sZArrQ.png)](https://imgchr.com/i/sZArrQ)\n\n通过设定这种约束条件，即可达到搜索树的最佳性能。后续将介绍六种二叉搜索树。\n\n# **2** **六种平衡二叉搜索树**\n\n## **2.1** **高度平衡树（AVL**）\n\nAVL是最早发明自平衡二叉树，它被称作高度平衡树。在ALV树中，任意结点平衡因子的绝对值不超过1，即：\n\n **|balFac(v)|≤1**\n\n### 2.1.1 平衡性\n\n[![sZAhxU.png](https://s3.ax1x.com/2021/01/06/sZAhxU.png)](https://imgchr.com/i/sZAhxU)\n\n如上图所示，不妨设结点数最少的AVL树S的根结点为r，r的左、右子树分别为lc和rc，记规模为|lc|和|rc|，高度为h_l和h_r，则有：\n|S|=1+|lc|+|rc|\n由于S的子树lc和rc也是AVL树，并且高度不超过h-1。因此，不妨取：\nh_l=h-1, h_r=h-2,\n|S|=1+| S_(h-1) |+| S_(h-2) |,\n由归纳假设，可以获得如下关系：\n|S|=1+(fib(h+2)-1)+(fib(h+1)-1)\n而根据Fibonacci数列的定义，可以获得：\n|S|=fib(h+2)+fib(h+1)-1=fib(h+3)-1                          \n因此，可以知道：高度为h的AVL树至少包含fib(h+3)-1个结点。由于fib(h)和n次方正比，于是包含n个结点的AVL树的高度应为O(log⁡n )。\n综上可知，AVL树的确是平衡的。\n\n### 2.1.2 旋转\n\nAVL树的插入过程和一般二叉搜索树的过程相同，即：从树根出发，逐步的缩小查找范围，直到发现目标（成功）或者缩小至空结点（失败）。\n\n不同之处在于，二叉树在插入或者删除时，需要维持其平衡。而维持平衡这一过程，正是通过旋转（Rotate）操作来实现的。AVL树的旋转可以归纳为四种：LL单右旋、RR单左旋、LR先左旋再右旋和RL先右旋再左旋。\n\n- LL单右旋：当失衡位置发生在失衡结点左子树的左子树时，需要进行LL单右旋。\n\n[![sZAIr4.png](https://s3.ax1x.com/2021/01/06/sZAIr4.png)](https://imgchr.com/i/sZAIr4)\n\n- RR单左旋：当失衡位置发生在失衡结点右子树的右子树时，需要进行RR单左旋。\n\n[![sZAjxO.png](https://s3.ax1x.com/2021/01/06/sZAjxO.png)](https://imgchr.com/i/sZAjxO)\n\n- LR先左旋再右旋：当失衡位置发生在失衡结点左子树的右子树时，需要进行LR先左旋再右旋。\n\n[![sZESqH.png](https://s3.ax1x.com/2021/01/06/sZESqH.png)](https://imgchr.com/i/sZESqH)\n\n- RL先右旋再左旋：当失衡位置发生在失衡结点右子树的左子树时，需要进行RL先右旋再左旋。\n\n[![sZEFit.png](https://s3.ax1x.com/2021/01/06/sZEFit.png)](https://imgchr.com/i/sZEFit)\n\n### 2.1.3 性能分析\n\n通过2.1.2的旋转操作，AVL树可以满足其性质的定义，通过2.1.1证明可知：包含n个结点的AVL树的高度应为logn 。\n\n由于二叉搜索树的查找操作时间正比于树高，因此AVL树查找的时间复杂度为O(logN) 。同理，插入和删除的时间复杂度也为(logN)。\n\n## **2.2** **伸展树（ST**）\n\n伸展树（Splay Tree）也叫分裂树，相对于AVL树实现更为简捷。伸展树无需时刻都严格地保持全树的平衡，但却能够在任何足够长的真实操作序列中，保持分摊意义上的高效率。伸展树也不需要对基本的二叉树节点结构，做任何附加的要求或改动，更不需要记录平衡因子或高度之类的额外信息，故适用范围更广。\n\n每次查找节点之后对树进行重构，把被查找的节点搬移到树根。每次对伸展树进行操作后，它均会通过伸展（Splay）的方法使得被访问结点置于根结点的位置。\n\n### 2.2.1 伸展\n\n与普通的二叉搜索树的区别在于，伸展树通过伸展操作将元素调整至根结点的位置。这一调整根据结点所在位置的不同，采用不同的调整方法：\n\n| 情形  |     旋转方法     |\n| :---: | :--------------: |\n| 单R型 |      左旋转      |\n| 单L型 |      右旋转      |\n| RR型  |    两次左旋转    |\n| LL型  |    两次右旋转    |\n| RL型  | 先右旋转再左旋转 |\n| LR型  | 先左旋转再右旋转 |\n\n### 2.2.2 性能分析\n\n伸展树能够在O(log⁡n)内完成插入、查找和删除操作。它在不保证最坏情况下的时间复杂度是O(log⁡n)，其边界是均摊的。但是，它有一个最显著的缺点，即有可能变成一条链，这种情况下时间复杂度高达O(n)。\n\n## **2.3** **红黑树（RBT**）\n\n红黑树（Red Black Tree）是一种自平衡二叉搜索树，它等价于4阶B-树。它实际上是一种特化的AVL，均是在进行插入和删除操作时通过特定操作保持二叉搜索树的平衡，从而获得了较高的查找性能。\n\n红黑树保持适度平衡的关键在于：任一结点左、右子树的高度，相差不得超过两倍。为了保持这一平衡，红黑树为其内部的每一个结点定义了颜色属性黑色或者红色（本文章中红黑树黑底表示黑色结点，白底表示红色结点）。\n\n[![sZEliq.png](https://s3.ax1x.com/2021/01/06/sZEliq.png)](https://imgchr.com/i/sZEliq)\n\n与上述二叉搜索树不同，红黑树引入了外部结点作为叶结点（图11中的黑色矩形即为叶结点），它满足下述性质：\n\n1. 每个结点要么是黑色，要么是红色；\n2. 根结点是黑色的；\n3. 每个叶结点（NIL）是黑色的；\n4. 每个红色结点的两个子结点一定都是黑色的；\n5. 任意一个结点到每个叶结点的路径都包含相同数量的黑色结点。\n\n事实上，正是由于性质（5），红黑树的这种平衡被称作黑色完美平衡。红黑树维持平衡主要依靠三种方法：左旋、右旋和染色（结点的颜色由黑变红或者由红变黑）。\n\n### 2.3.1 平衡性\n\n略\n\n### 2.3.2 三种操作\n\n由于红黑树是一棵二叉搜索树，并且查找并不会破坏树的平衡，因此查找和二叉搜索树的查找无异，是一个递归的过程。\n\n红黑树的插入过程分为两步，第一步是查找到插入位置，第二步则是插入后的自平衡。因此，其插入过程可分为下述情况（如图11所示）：\n\n1. 红黑树为空树：将插入的结点作为根结点，并且染色为黑色；\n\n2. 插入结点的父结点为黑色结点：直接插入即可；\n\n3. 插入结点的父结点为红色结点：\n\n   若叔叔结点存在并且为红色结点，则只需将P和S设置为黑色，PP设置为红色，接下来递归的处理PP结点即可；\n\n   [![sZEJQU.png](https://s3.ax1x.com/2021/01/06/sZEJQU.png)](https://imgchr.com/i/sZEJQU)\n\n   若叔叔结点不存在或者为黑色结点，插入结点是父结点的左子结点，父结点是祖先结点的左子结点。该种情况需要将P设为黑色，PP设为红色，同时对PP进行右旋，如下图所示。其余情况实际为该种情况的对称形式，在此不再赘述。\n\n   [![sZEYyF.png](https://s3.ax1x.com/2021/01/06/sZEYyF.png)](https://imgchr.com/i/sZEYyF)\n\n红黑树的删除过程也是先查找到删除位置，然后通过旋转和染色来实现再次平衡。\n\n## **2.4** **替罪羊树（ST**）\n\n替罪羊树（Scapegoat Tree）不同于上述通过旋转来维持相对平衡的二叉搜索树，它是基于一种暴力重构的操作来保持相对平衡的。\n\n### 2.4.1 平衡因子\n\n替罪羊树中定义了一个平衡因子α的概念，范围在0.5到1之间。当某个结点的总结点数* α <它某个子树的总结点数，便会对该结点执行重构操作。\n对于α的取值，如果α越小，那么对平衡的要求越高，重构的次数会更多；α越大，树的平衡程度越低，重构的次数也会随之减少。一般而言，α取0.7左右比较合适。\n\n### 2.4.2 平衡性\n\n略\n\n### 2.4.3 重构\n\n[![sZEaw9.png](https://s3.ax1x.com/2021/01/06/sZEaw9.png)](https://imgchr.com/i/sZEaw9)\n\n如上图所示的替罪羊树，若平衡因子  ，则结点v已发生失衡。重构过程如下：\n\n1. 将这棵树压扁，存入向量中：\n\n[![sZEsSK.png](https://s3.ax1x.com/2021/01/06/sZEsSK.png)](https://imgchr.com/i/sZEsSK)\n\n​\t2.重新建树：每次取区间中点作为根结点，递归左右两边子树建树：\n\n[![sZE6yD.md.png](https://s3.ax1x.com/2021/01/06/sZE6yD.md.png)](https://imgchr.com/i/sZE6yD)\n\n通过上述操作，替罪羊树即完成了其重构操作。并且由2.4.2中结论可知，每次插入后的重构仍然能保证替罪羊树各种操作的时间复杂度达到  。\n\n# **3** **平衡搜索树的性能对比**\n\n根据上述介绍可以看出，AVL、伸展树、红黑树和替罪羊树分别采取了不同的方法实现了相对平衡，复杂度如表2所示。在实际使用时，应当根据工作情景选用：\n\n|  平衡树  |  时间复杂度  |     应用     |\n| :------: | :----------: | :----------: |\n|   AVL    |   O(log n)   | 最早的平衡树 |\n|  伸展树  | 均摊O(log n) |  对区间操作  |\n|  红黑树  |   O(log n)   | 综合效率最高 |\n| 替罪羊树 |   O(log n)   |   实现较易   |\n\n \n\n","slug":"数据结构论文","published":1,"updated":"2021-01-06T14:40:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmhg4qt4d000gf5fac1xsf8jw","content":"<p>二叉树（Binary Tree）指的是树中结点的度不大于2的有序树，其递归定义是：二叉树是一棵空树，或者是一棵由一个根节点和两棵互不相交的，分别称作根的左子树和右子树组成的非空树；左子树和右子树同样也是二叉树。</p>\n<p>二叉树是树形结构的一个重要类型，许多实际问题抽象出来的数据结构往往都是二叉树的类型。即使是一般的树也可以转化为二叉树，并且二叉树的存储结构和算法相对而言都比较简单。因此研究二叉树对于研究数据结构有着重要的意义。</p>\n<p>基于二叉树在数据结构中的重要作用，本篇文章中将探讨二叉树的一个重要应用，即作为二叉搜索树时能够发挥的作用。同时，本文也进一步探讨研究了较常使用的平衡二叉树和六种不同的平衡二叉树的性能并对其做了对比分析，为未来计算机应用提供了可供参考的意见。</p>\n<h1 id=\"1-二叉搜索树\"><a href=\"#1-二叉搜索树\" class=\"headerlink\" title=\"1  二叉搜索树\"></a><strong>1</strong>  <strong>二叉搜索树</strong></h1><h2 id=\"1-1-二叉搜索树（BST）\"><a href=\"#1-1-二叉搜索树（BST）\" class=\"headerlink\" title=\"1.1  二叉搜索树（BST）\"></a><strong>1.1</strong>  二叉搜索树（BST）</h2><p>二叉搜索树（Binary Search Tree）又称二叉查找树或二叉排序树。作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势。</p>\n<p>二叉搜索树的定义也是递归的。它是一棵空树，或者是满足下列性质的二叉树：</p>\n<ol>\n<li>每个结点都有一个作为搜索依据的关键码（key），所有节点的关键码互不相同；</li>\n<li>左子树（如果存在）上所有结点的关键码都小于根；</li>\n<li>右子树（如果存在）上所有结点的关键码都大于根；</li>\n<li>左子树和右子树也是一棵二叉搜索树。</li>\n</ol>\n<p>如下图所示，就是一棵标准的二叉搜索树：</p>\n<p><a href=\"https://imgchr.com/i/sZAigU\"><img src=\"https://s3.ax1x.com/2021/01/06/sZAigU.png\" alt=\"sZAigU.png\"></a></p>\n<h3 id=\"1-1-1-搜索\"><a href=\"#1-1-1-搜索\" class=\"headerlink\" title=\"1.1.1 搜索\"></a>1.1.1 搜索</h3><p>二叉树的搜索是一个递归的过程，流程图如下所示：</p>\n<p><a href=\"https://imgchr.com/i/sZAeER\"><img src=\"https://s3.ax1x.com/2021/01/06/sZAeER.png\" alt=\"sZAeER.png\"></a></p>\n<p>从树根出发，逐步的缩小查找范围，直到发现目标（成功）或者缩小至空结点（失败）。对于该过程而言，在二叉搜索树的每一层，查找算法至多访问一个结点，并且只需要常数时间。因此，总体所需时间应当线性正比于查找路径的长度，或最终返回结点的深度。对于规模为n的二叉搜索树，深度在最坏情况下可达(n)。</p>\n<h3 id=\"1-1-2-插入\"><a href=\"#1-1-2-插入\" class=\"headerlink\" title=\"1.1.2 插入\"></a>1.1.2 插入</h3><p> 二叉搜索树的插入的流程图如下所示：</p>\n<p><a href=\"https://imgchr.com/i/sZAEDJ\"><img src=\"https://s3.ax1x.com/2021/01/06/sZAEDJ.png\" alt=\"sZAEDJ.png\"></a></p>\n<p>为了在二叉搜索树中插入一个结点，首先需要利用其搜索操作查找到插入的位置，然后再将新结点作为叶子结点插入（或者更新已存在结点的值）。由于该操作依赖于搜索操作，因此时间复杂度也为O(n)。</p>\n<h3 id=\"1-1-3-删除\"><a href=\"#1-1-3-删除\" class=\"headerlink\" title=\"1.1.3 删除\"></a>1.1.3 删除</h3><p>二叉搜索树的删除的流程图如下所示：</p>\n<p><a href=\"https://imgchr.com/i/sZAVb9\"><img src=\"https://s3.ax1x.com/2021/01/06/sZAVb9.png\" alt=\"sZAVb9.png\"></a></p>\n<p>二叉搜索树的删除过程也依赖于其查找过程，故时间复杂度也为O(n)。</p>\n<h2 id=\"1-2-平衡二叉搜索树（BBST）\"><a href=\"#1-2-平衡二叉搜索树（BBST）\" class=\"headerlink\" title=\"1.2  平衡二叉搜索树（BBST）\"></a><strong>1.2</strong>  平衡二叉搜索树（BBST）</h2><p>由于二叉搜索树在最坏情况下可能退化为列表，此时的各种效率降至O(n)。因此如果不能有效的控制树高，二叉搜索树无法体现出明显的优势。因此，需要依照某种宽松的标准，重新定义二叉搜索树的平衡性。</p>\n<p>平衡二叉搜索树（Balanced Binary Search Tree）指的是在某种约束条件下，树高渐进地不超过O(logN)。在这一约束条件下，各种操作的时间复杂度即可降低为O(logN)。它为每一个结点v的平衡因子（balance factor）定义为左、右子树的高度差，即</p>\n<p> <strong>balFac(v) = height(lc(v)) - height(rc(v))</strong></p>\n<p>下图即为定义了平衡因子的二叉搜索树：</p>\n<p><a href=\"https://imgchr.com/i/sZArrQ\"><img src=\"https://s3.ax1x.com/2021/01/06/sZArrQ.png\" alt=\"sZArrQ.png\"></a></p>\n<p>通过设定这种约束条件，即可达到搜索树的最佳性能。后续将介绍六种二叉搜索树。</p>\n<h1 id=\"2-六种平衡二叉搜索树\"><a href=\"#2-六种平衡二叉搜索树\" class=\"headerlink\" title=\"2 六种平衡二叉搜索树\"></a><strong>2</strong> <strong>六种平衡二叉搜索树</strong></h1><h2 id=\"2-1-高度平衡树（AVL）\"><a href=\"#2-1-高度平衡树（AVL）\" class=\"headerlink\" title=\"2.1 高度平衡树（AVL）\"></a><strong>2.1</strong> <strong>高度平衡树（AVL</strong>）</h2><p>AVL是最早发明自平衡二叉树，它被称作高度平衡树。在ALV树中，任意结点平衡因子的绝对值不超过1，即：</p>\n<p> <strong>|balFac(v)|≤1</strong></p>\n<h3 id=\"2-1-1-平衡性\"><a href=\"#2-1-1-平衡性\" class=\"headerlink\" title=\"2.1.1 平衡性\"></a>2.1.1 平衡性</h3><p><a href=\"https://imgchr.com/i/sZAhxU\"><img src=\"https://s3.ax1x.com/2021/01/06/sZAhxU.png\" alt=\"sZAhxU.png\"></a></p>\n<p>如上图所示，不妨设结点数最少的AVL树S的根结点为r，r的左、右子树分别为lc和rc，记规模为|lc|和|rc|，高度为h_l和h_r，则有：<br>|S|=1+|lc|+|rc|<br>由于S的子树lc和rc也是AVL树，并且高度不超过h-1。因此，不妨取：<br>h_l=h-1, h_r=h-2,<br>|S|=1+| S_(h-1) |+| S_(h-2) |,<br>由归纳假设，可以获得如下关系：<br>|S|=1+(fib(h+2)-1)+(fib(h+1)-1)<br>而根据Fibonacci数列的定义，可以获得：<br>|S|=fib(h+2)+fib(h+1)-1=fib(h+3)-1<br>因此，可以知道：高度为h的AVL树至少包含fib(h+3)-1个结点。由于fib(h)和n次方正比，于是包含n个结点的AVL树的高度应为O(log⁡n )。<br>综上可知，AVL树的确是平衡的。</p>\n<h3 id=\"2-1-2-旋转\"><a href=\"#2-1-2-旋转\" class=\"headerlink\" title=\"2.1.2 旋转\"></a>2.1.2 旋转</h3><p>AVL树的插入过程和一般二叉搜索树的过程相同，即：从树根出发，逐步的缩小查找范围，直到发现目标（成功）或者缩小至空结点（失败）。</p>\n<p>不同之处在于，二叉树在插入或者删除时，需要维持其平衡。而维持平衡这一过程，正是通过旋转（Rotate）操作来实现的。AVL树的旋转可以归纳为四种：LL单右旋、RR单左旋、LR先左旋再右旋和RL先右旋再左旋。</p>\n<ul>\n<li>LL单右旋：当失衡位置发生在失衡结点左子树的左子树时，需要进行LL单右旋。</li>\n</ul>\n<p><a href=\"https://imgchr.com/i/sZAIr4\"><img src=\"https://s3.ax1x.com/2021/01/06/sZAIr4.png\" alt=\"sZAIr4.png\"></a></p>\n<ul>\n<li>RR单左旋：当失衡位置发生在失衡结点右子树的右子树时，需要进行RR单左旋。</li>\n</ul>\n<p><a href=\"https://imgchr.com/i/sZAjxO\"><img src=\"https://s3.ax1x.com/2021/01/06/sZAjxO.png\" alt=\"sZAjxO.png\"></a></p>\n<ul>\n<li>LR先左旋再右旋：当失衡位置发生在失衡结点左子树的右子树时，需要进行LR先左旋再右旋。</li>\n</ul>\n<p><a href=\"https://imgchr.com/i/sZESqH\"><img src=\"https://s3.ax1x.com/2021/01/06/sZESqH.png\" alt=\"sZESqH.png\"></a></p>\n<ul>\n<li>RL先右旋再左旋：当失衡位置发生在失衡结点右子树的左子树时，需要进行RL先右旋再左旋。</li>\n</ul>\n<p><a href=\"https://imgchr.com/i/sZEFit\"><img src=\"https://s3.ax1x.com/2021/01/06/sZEFit.png\" alt=\"sZEFit.png\"></a></p>\n<h3 id=\"2-1-3-性能分析\"><a href=\"#2-1-3-性能分析\" class=\"headerlink\" title=\"2.1.3 性能分析\"></a>2.1.3 性能分析</h3><p>通过2.1.2的旋转操作，AVL树可以满足其性质的定义，通过2.1.1证明可知：包含n个结点的AVL树的高度应为logn 。</p>\n<p>由于二叉搜索树的查找操作时间正比于树高，因此AVL树查找的时间复杂度为O(logN) 。同理，插入和删除的时间复杂度也为(logN)。</p>\n<h2 id=\"2-2-伸展树（ST）\"><a href=\"#2-2-伸展树（ST）\" class=\"headerlink\" title=\"2.2 伸展树（ST）\"></a><strong>2.2</strong> <strong>伸展树（ST</strong>）</h2><p>伸展树（Splay Tree）也叫分裂树，相对于AVL树实现更为简捷。伸展树无需时刻都严格地保持全树的平衡，但却能够在任何足够长的真实操作序列中，保持分摊意义上的高效率。伸展树也不需要对基本的二叉树节点结构，做任何附加的要求或改动，更不需要记录平衡因子或高度之类的额外信息，故适用范围更广。</p>\n<p>每次查找节点之后对树进行重构，把被查找的节点搬移到树根。每次对伸展树进行操作后，它均会通过伸展（Splay）的方法使得被访问结点置于根结点的位置。</p>\n<h3 id=\"2-2-1-伸展\"><a href=\"#2-2-1-伸展\" class=\"headerlink\" title=\"2.2.1 伸展\"></a>2.2.1 伸展</h3><p>与普通的二叉搜索树的区别在于，伸展树通过伸展操作将元素调整至根结点的位置。这一调整根据结点所在位置的不同，采用不同的调整方法：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">情形</th>\n<th align=\"center\">旋转方法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">单R型</td>\n<td align=\"center\">左旋转</td>\n</tr>\n<tr>\n<td align=\"center\">单L型</td>\n<td align=\"center\">右旋转</td>\n</tr>\n<tr>\n<td align=\"center\">RR型</td>\n<td align=\"center\">两次左旋转</td>\n</tr>\n<tr>\n<td align=\"center\">LL型</td>\n<td align=\"center\">两次右旋转</td>\n</tr>\n<tr>\n<td align=\"center\">RL型</td>\n<td align=\"center\">先右旋转再左旋转</td>\n</tr>\n<tr>\n<td align=\"center\">LR型</td>\n<td align=\"center\">先左旋转再右旋转</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-2-2-性能分析\"><a href=\"#2-2-2-性能分析\" class=\"headerlink\" title=\"2.2.2 性能分析\"></a>2.2.2 性能分析</h3><p>伸展树能够在O(log⁡n)内完成插入、查找和删除操作。它在不保证最坏情况下的时间复杂度是O(log⁡n)，其边界是均摊的。但是，它有一个最显著的缺点，即有可能变成一条链，这种情况下时间复杂度高达O(n)。</p>\n<h2 id=\"2-3-红黑树（RBT）\"><a href=\"#2-3-红黑树（RBT）\" class=\"headerlink\" title=\"2.3 红黑树（RBT）\"></a><strong>2.3</strong> <strong>红黑树（RBT</strong>）</h2><p>红黑树（Red Black Tree）是一种自平衡二叉搜索树，它等价于4阶B-树。它实际上是一种特化的AVL，均是在进行插入和删除操作时通过特定操作保持二叉搜索树的平衡，从而获得了较高的查找性能。</p>\n<p>红黑树保持适度平衡的关键在于：任一结点左、右子树的高度，相差不得超过两倍。为了保持这一平衡，红黑树为其内部的每一个结点定义了颜色属性黑色或者红色（本文章中红黑树黑底表示黑色结点，白底表示红色结点）。</p>\n<p><a href=\"https://imgchr.com/i/sZEliq\"><img src=\"https://s3.ax1x.com/2021/01/06/sZEliq.png\" alt=\"sZEliq.png\"></a></p>\n<p>与上述二叉搜索树不同，红黑树引入了外部结点作为叶结点（图11中的黑色矩形即为叶结点），它满足下述性质：</p>\n<ol>\n<li>每个结点要么是黑色，要么是红色；</li>\n<li>根结点是黑色的；</li>\n<li>每个叶结点（NIL）是黑色的；</li>\n<li>每个红色结点的两个子结点一定都是黑色的；</li>\n<li>任意一个结点到每个叶结点的路径都包含相同数量的黑色结点。</li>\n</ol>\n<p>事实上，正是由于性质（5），红黑树的这种平衡被称作黑色完美平衡。红黑树维持平衡主要依靠三种方法：左旋、右旋和染色（结点的颜色由黑变红或者由红变黑）。</p>\n<h3 id=\"2-3-1-平衡性\"><a href=\"#2-3-1-平衡性\" class=\"headerlink\" title=\"2.3.1 平衡性\"></a>2.3.1 平衡性</h3><p>略</p>\n<h3 id=\"2-3-2-三种操作\"><a href=\"#2-3-2-三种操作\" class=\"headerlink\" title=\"2.3.2 三种操作\"></a>2.3.2 三种操作</h3><p>由于红黑树是一棵二叉搜索树，并且查找并不会破坏树的平衡，因此查找和二叉搜索树的查找无异，是一个递归的过程。</p>\n<p>红黑树的插入过程分为两步，第一步是查找到插入位置，第二步则是插入后的自平衡。因此，其插入过程可分为下述情况（如图11所示）：</p>\n<ol>\n<li><p>红黑树为空树：将插入的结点作为根结点，并且染色为黑色；</p>\n</li>\n<li><p>插入结点的父结点为黑色结点：直接插入即可；</p>\n</li>\n<li><p>插入结点的父结点为红色结点：</p>\n<p>若叔叔结点存在并且为红色结点，则只需将P和S设置为黑色，PP设置为红色，接下来递归的处理PP结点即可；</p>\n<p><a href=\"https://imgchr.com/i/sZEJQU\"><img src=\"https://s3.ax1x.com/2021/01/06/sZEJQU.png\" alt=\"sZEJQU.png\"></a></p>\n<p>若叔叔结点不存在或者为黑色结点，插入结点是父结点的左子结点，父结点是祖先结点的左子结点。该种情况需要将P设为黑色，PP设为红色，同时对PP进行右旋，如下图所示。其余情况实际为该种情况的对称形式，在此不再赘述。</p>\n<p><a href=\"https://imgchr.com/i/sZEYyF\"><img src=\"https://s3.ax1x.com/2021/01/06/sZEYyF.png\" alt=\"sZEYyF.png\"></a></p>\n</li>\n</ol>\n<p>红黑树的删除过程也是先查找到删除位置，然后通过旋转和染色来实现再次平衡。</p>\n<h2 id=\"2-4-替罪羊树（ST）\"><a href=\"#2-4-替罪羊树（ST）\" class=\"headerlink\" title=\"2.4 替罪羊树（ST）\"></a><strong>2.4</strong> <strong>替罪羊树（ST</strong>）</h2><p>替罪羊树（Scapegoat Tree）不同于上述通过旋转来维持相对平衡的二叉搜索树，它是基于一种暴力重构的操作来保持相对平衡的。</p>\n<h3 id=\"2-4-1-平衡因子\"><a href=\"#2-4-1-平衡因子\" class=\"headerlink\" title=\"2.4.1 平衡因子\"></a>2.4.1 平衡因子</h3><p>替罪羊树中定义了一个平衡因子α的概念，范围在0.5到1之间。当某个结点的总结点数* α &lt;它某个子树的总结点数，便会对该结点执行重构操作。<br>对于α的取值，如果α越小，那么对平衡的要求越高，重构的次数会更多；α越大，树的平衡程度越低，重构的次数也会随之减少。一般而言，α取0.7左右比较合适。</p>\n<h3 id=\"2-4-2-平衡性\"><a href=\"#2-4-2-平衡性\" class=\"headerlink\" title=\"2.4.2 平衡性\"></a>2.4.2 平衡性</h3><p>略</p>\n<h3 id=\"2-4-3-重构\"><a href=\"#2-4-3-重构\" class=\"headerlink\" title=\"2.4.3 重构\"></a>2.4.3 重构</h3><p><a href=\"https://imgchr.com/i/sZEaw9\"><img src=\"https://s3.ax1x.com/2021/01/06/sZEaw9.png\" alt=\"sZEaw9.png\"></a></p>\n<p>如上图所示的替罪羊树，若平衡因子  ，则结点v已发生失衡。重构过程如下：</p>\n<ol>\n<li>将这棵树压扁，存入向量中：</li>\n</ol>\n<p><a href=\"https://imgchr.com/i/sZEsSK\"><img src=\"https://s3.ax1x.com/2021/01/06/sZEsSK.png\" alt=\"sZEsSK.png\"></a></p>\n<p>​    2.重新建树：每次取区间中点作为根结点，递归左右两边子树建树：</p>\n<p><a href=\"https://imgchr.com/i/sZE6yD\"><img src=\"https://s3.ax1x.com/2021/01/06/sZE6yD.md.png\" alt=\"sZE6yD.md.png\"></a></p>\n<p>通过上述操作，替罪羊树即完成了其重构操作。并且由2.4.2中结论可知，每次插入后的重构仍然能保证替罪羊树各种操作的时间复杂度达到  。</p>\n<h1 id=\"3-平衡搜索树的性能对比\"><a href=\"#3-平衡搜索树的性能对比\" class=\"headerlink\" title=\"3 平衡搜索树的性能对比\"></a><strong>3</strong> <strong>平衡搜索树的性能对比</strong></h1><p>根据上述介绍可以看出，AVL、伸展树、红黑树和替罪羊树分别采取了不同的方法实现了相对平衡，复杂度如表2所示。在实际使用时，应当根据工作情景选用：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">平衡树</th>\n<th align=\"center\">时间复杂度</th>\n<th align=\"center\">应用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">AVL</td>\n<td align=\"center\">O(log n)</td>\n<td align=\"center\">最早的平衡树</td>\n</tr>\n<tr>\n<td align=\"center\">伸展树</td>\n<td align=\"center\">均摊O(log n)</td>\n<td align=\"center\">对区间操作</td>\n</tr>\n<tr>\n<td align=\"center\">红黑树</td>\n<td align=\"center\">O(log n)</td>\n<td align=\"center\">综合效率最高</td>\n</tr>\n<tr>\n<td align=\"center\">替罪羊树</td>\n<td align=\"center\">O(log n)</td>\n<td align=\"center\">实现较易</td>\n</tr>\n</tbody></table>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<p>二叉树（Binary Tree）指的是树中结点的度不大于2的有序树，其递归定义是：二叉树是一棵空树，或者是一棵由一个根节点和两棵互不相交的，分别称作根的左子树和右子树组成的非空树；左子树和右子树同样也是二叉树。</p>\n<p>二叉树是树形结构的一个重要类型，许多实际问题抽象出来的数据结构往往都是二叉树的类型。即使是一般的树也可以转化为二叉树，并且二叉树的存储结构和算法相对而言都比较简单。因此研究二叉树对于研究数据结构有着重要的意义。</p>\n<p>基于二叉树在数据结构中的重要作用，本篇文章中将探讨二叉树的一个重要应用，即作为二叉搜索树时能够发挥的作用。同时，本文也进一步探讨研究了较常使用的平衡二叉树和六种不同的平衡二叉树的性能并对其做了对比分析，为未来计算机应用提供了可供参考的意见。</p>\n<h1 id=\"1-二叉搜索树\"><a href=\"#1-二叉搜索树\" class=\"headerlink\" title=\"1  二叉搜索树\"></a><strong>1</strong>  <strong>二叉搜索树</strong></h1><h2 id=\"1-1-二叉搜索树（BST）\"><a href=\"#1-1-二叉搜索树（BST）\" class=\"headerlink\" title=\"1.1  二叉搜索树（BST）\"></a><strong>1.1</strong>  二叉搜索树（BST）</h2><p>二叉搜索树（Binary Search Tree）又称二叉查找树或二叉排序树。作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势。</p>\n<p>二叉搜索树的定义也是递归的。它是一棵空树，或者是满足下列性质的二叉树：</p>\n<ol>\n<li>每个结点都有一个作为搜索依据的关键码（key），所有节点的关键码互不相同；</li>\n<li>左子树（如果存在）上所有结点的关键码都小于根；</li>\n<li>右子树（如果存在）上所有结点的关键码都大于根；</li>\n<li>左子树和右子树也是一棵二叉搜索树。</li>\n</ol>\n<p>如下图所示，就是一棵标准的二叉搜索树：</p>\n<p><a href=\"https://imgchr.com/i/sZAigU\"><img src=\"https://s3.ax1x.com/2021/01/06/sZAigU.png\" alt=\"sZAigU.png\"></a></p>\n<h3 id=\"1-1-1-搜索\"><a href=\"#1-1-1-搜索\" class=\"headerlink\" title=\"1.1.1 搜索\"></a>1.1.1 搜索</h3><p>二叉树的搜索是一个递归的过程，流程图如下所示：</p>\n<p><a href=\"https://imgchr.com/i/sZAeER\"><img src=\"https://s3.ax1x.com/2021/01/06/sZAeER.png\" alt=\"sZAeER.png\"></a></p>\n<p>从树根出发，逐步的缩小查找范围，直到发现目标（成功）或者缩小至空结点（失败）。对于该过程而言，在二叉搜索树的每一层，查找算法至多访问一个结点，并且只需要常数时间。因此，总体所需时间应当线性正比于查找路径的长度，或最终返回结点的深度。对于规模为n的二叉搜索树，深度在最坏情况下可达(n)。</p>\n<h3 id=\"1-1-2-插入\"><a href=\"#1-1-2-插入\" class=\"headerlink\" title=\"1.1.2 插入\"></a>1.1.2 插入</h3><p> 二叉搜索树的插入的流程图如下所示：</p>\n<p><a href=\"https://imgchr.com/i/sZAEDJ\"><img src=\"https://s3.ax1x.com/2021/01/06/sZAEDJ.png\" alt=\"sZAEDJ.png\"></a></p>\n<p>为了在二叉搜索树中插入一个结点，首先需要利用其搜索操作查找到插入的位置，然后再将新结点作为叶子结点插入（或者更新已存在结点的值）。由于该操作依赖于搜索操作，因此时间复杂度也为O(n)。</p>\n<h3 id=\"1-1-3-删除\"><a href=\"#1-1-3-删除\" class=\"headerlink\" title=\"1.1.3 删除\"></a>1.1.3 删除</h3><p>二叉搜索树的删除的流程图如下所示：</p>\n<p><a href=\"https://imgchr.com/i/sZAVb9\"><img src=\"https://s3.ax1x.com/2021/01/06/sZAVb9.png\" alt=\"sZAVb9.png\"></a></p>\n<p>二叉搜索树的删除过程也依赖于其查找过程，故时间复杂度也为O(n)。</p>\n<h2 id=\"1-2-平衡二叉搜索树（BBST）\"><a href=\"#1-2-平衡二叉搜索树（BBST）\" class=\"headerlink\" title=\"1.2  平衡二叉搜索树（BBST）\"></a><strong>1.2</strong>  平衡二叉搜索树（BBST）</h2><p>由于二叉搜索树在最坏情况下可能退化为列表，此时的各种效率降至O(n)。因此如果不能有效的控制树高，二叉搜索树无法体现出明显的优势。因此，需要依照某种宽松的标准，重新定义二叉搜索树的平衡性。</p>\n<p>平衡二叉搜索树（Balanced Binary Search Tree）指的是在某种约束条件下，树高渐进地不超过O(logN)。在这一约束条件下，各种操作的时间复杂度即可降低为O(logN)。它为每一个结点v的平衡因子（balance factor）定义为左、右子树的高度差，即</p>\n<p> <strong>balFac(v) = height(lc(v)) - height(rc(v))</strong></p>\n<p>下图即为定义了平衡因子的二叉搜索树：</p>\n<p><a href=\"https://imgchr.com/i/sZArrQ\"><img src=\"https://s3.ax1x.com/2021/01/06/sZArrQ.png\" alt=\"sZArrQ.png\"></a></p>\n<p>通过设定这种约束条件，即可达到搜索树的最佳性能。后续将介绍六种二叉搜索树。</p>\n<h1 id=\"2-六种平衡二叉搜索树\"><a href=\"#2-六种平衡二叉搜索树\" class=\"headerlink\" title=\"2 六种平衡二叉搜索树\"></a><strong>2</strong> <strong>六种平衡二叉搜索树</strong></h1><h2 id=\"2-1-高度平衡树（AVL）\"><a href=\"#2-1-高度平衡树（AVL）\" class=\"headerlink\" title=\"2.1 高度平衡树（AVL）\"></a><strong>2.1</strong> <strong>高度平衡树（AVL</strong>）</h2><p>AVL是最早发明自平衡二叉树，它被称作高度平衡树。在ALV树中，任意结点平衡因子的绝对值不超过1，即：</p>\n<p> <strong>|balFac(v)|≤1</strong></p>\n<h3 id=\"2-1-1-平衡性\"><a href=\"#2-1-1-平衡性\" class=\"headerlink\" title=\"2.1.1 平衡性\"></a>2.1.1 平衡性</h3><p><a href=\"https://imgchr.com/i/sZAhxU\"><img src=\"https://s3.ax1x.com/2021/01/06/sZAhxU.png\" alt=\"sZAhxU.png\"></a></p>\n<p>如上图所示，不妨设结点数最少的AVL树S的根结点为r，r的左、右子树分别为lc和rc，记规模为|lc|和|rc|，高度为h_l和h_r，则有：<br>|S|=1+|lc|+|rc|<br>由于S的子树lc和rc也是AVL树，并且高度不超过h-1。因此，不妨取：<br>h_l=h-1, h_r=h-2,<br>|S|=1+| S_(h-1) |+| S_(h-2) |,<br>由归纳假设，可以获得如下关系：<br>|S|=1+(fib(h+2)-1)+(fib(h+1)-1)<br>而根据Fibonacci数列的定义，可以获得：<br>|S|=fib(h+2)+fib(h+1)-1=fib(h+3)-1<br>因此，可以知道：高度为h的AVL树至少包含fib(h+3)-1个结点。由于fib(h)和n次方正比，于是包含n个结点的AVL树的高度应为O(log⁡n )。<br>综上可知，AVL树的确是平衡的。</p>\n<h3 id=\"2-1-2-旋转\"><a href=\"#2-1-2-旋转\" class=\"headerlink\" title=\"2.1.2 旋转\"></a>2.1.2 旋转</h3><p>AVL树的插入过程和一般二叉搜索树的过程相同，即：从树根出发，逐步的缩小查找范围，直到发现目标（成功）或者缩小至空结点（失败）。</p>\n<p>不同之处在于，二叉树在插入或者删除时，需要维持其平衡。而维持平衡这一过程，正是通过旋转（Rotate）操作来实现的。AVL树的旋转可以归纳为四种：LL单右旋、RR单左旋、LR先左旋再右旋和RL先右旋再左旋。</p>\n<ul>\n<li>LL单右旋：当失衡位置发生在失衡结点左子树的左子树时，需要进行LL单右旋。</li>\n</ul>\n<p><a href=\"https://imgchr.com/i/sZAIr4\"><img src=\"https://s3.ax1x.com/2021/01/06/sZAIr4.png\" alt=\"sZAIr4.png\"></a></p>\n<ul>\n<li>RR单左旋：当失衡位置发生在失衡结点右子树的右子树时，需要进行RR单左旋。</li>\n</ul>\n<p><a href=\"https://imgchr.com/i/sZAjxO\"><img src=\"https://s3.ax1x.com/2021/01/06/sZAjxO.png\" alt=\"sZAjxO.png\"></a></p>\n<ul>\n<li>LR先左旋再右旋：当失衡位置发生在失衡结点左子树的右子树时，需要进行LR先左旋再右旋。</li>\n</ul>\n<p><a href=\"https://imgchr.com/i/sZESqH\"><img src=\"https://s3.ax1x.com/2021/01/06/sZESqH.png\" alt=\"sZESqH.png\"></a></p>\n<ul>\n<li>RL先右旋再左旋：当失衡位置发生在失衡结点右子树的左子树时，需要进行RL先右旋再左旋。</li>\n</ul>\n<p><a href=\"https://imgchr.com/i/sZEFit\"><img src=\"https://s3.ax1x.com/2021/01/06/sZEFit.png\" alt=\"sZEFit.png\"></a></p>\n<h3 id=\"2-1-3-性能分析\"><a href=\"#2-1-3-性能分析\" class=\"headerlink\" title=\"2.1.3 性能分析\"></a>2.1.3 性能分析</h3><p>通过2.1.2的旋转操作，AVL树可以满足其性质的定义，通过2.1.1证明可知：包含n个结点的AVL树的高度应为logn 。</p>\n<p>由于二叉搜索树的查找操作时间正比于树高，因此AVL树查找的时间复杂度为O(logN) 。同理，插入和删除的时间复杂度也为(logN)。</p>\n<h2 id=\"2-2-伸展树（ST）\"><a href=\"#2-2-伸展树（ST）\" class=\"headerlink\" title=\"2.2 伸展树（ST）\"></a><strong>2.2</strong> <strong>伸展树（ST</strong>）</h2><p>伸展树（Splay Tree）也叫分裂树，相对于AVL树实现更为简捷。伸展树无需时刻都严格地保持全树的平衡，但却能够在任何足够长的真实操作序列中，保持分摊意义上的高效率。伸展树也不需要对基本的二叉树节点结构，做任何附加的要求或改动，更不需要记录平衡因子或高度之类的额外信息，故适用范围更广。</p>\n<p>每次查找节点之后对树进行重构，把被查找的节点搬移到树根。每次对伸展树进行操作后，它均会通过伸展（Splay）的方法使得被访问结点置于根结点的位置。</p>\n<h3 id=\"2-2-1-伸展\"><a href=\"#2-2-1-伸展\" class=\"headerlink\" title=\"2.2.1 伸展\"></a>2.2.1 伸展</h3><p>与普通的二叉搜索树的区别在于，伸展树通过伸展操作将元素调整至根结点的位置。这一调整根据结点所在位置的不同，采用不同的调整方法：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">情形</th>\n<th align=\"center\">旋转方法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">单R型</td>\n<td align=\"center\">左旋转</td>\n</tr>\n<tr>\n<td align=\"center\">单L型</td>\n<td align=\"center\">右旋转</td>\n</tr>\n<tr>\n<td align=\"center\">RR型</td>\n<td align=\"center\">两次左旋转</td>\n</tr>\n<tr>\n<td align=\"center\">LL型</td>\n<td align=\"center\">两次右旋转</td>\n</tr>\n<tr>\n<td align=\"center\">RL型</td>\n<td align=\"center\">先右旋转再左旋转</td>\n</tr>\n<tr>\n<td align=\"center\">LR型</td>\n<td align=\"center\">先左旋转再右旋转</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-2-2-性能分析\"><a href=\"#2-2-2-性能分析\" class=\"headerlink\" title=\"2.2.2 性能分析\"></a>2.2.2 性能分析</h3><p>伸展树能够在O(log⁡n)内完成插入、查找和删除操作。它在不保证最坏情况下的时间复杂度是O(log⁡n)，其边界是均摊的。但是，它有一个最显著的缺点，即有可能变成一条链，这种情况下时间复杂度高达O(n)。</p>\n<h2 id=\"2-3-红黑树（RBT）\"><a href=\"#2-3-红黑树（RBT）\" class=\"headerlink\" title=\"2.3 红黑树（RBT）\"></a><strong>2.3</strong> <strong>红黑树（RBT</strong>）</h2><p>红黑树（Red Black Tree）是一种自平衡二叉搜索树，它等价于4阶B-树。它实际上是一种特化的AVL，均是在进行插入和删除操作时通过特定操作保持二叉搜索树的平衡，从而获得了较高的查找性能。</p>\n<p>红黑树保持适度平衡的关键在于：任一结点左、右子树的高度，相差不得超过两倍。为了保持这一平衡，红黑树为其内部的每一个结点定义了颜色属性黑色或者红色（本文章中红黑树黑底表示黑色结点，白底表示红色结点）。</p>\n<p><a href=\"https://imgchr.com/i/sZEliq\"><img src=\"https://s3.ax1x.com/2021/01/06/sZEliq.png\" alt=\"sZEliq.png\"></a></p>\n<p>与上述二叉搜索树不同，红黑树引入了外部结点作为叶结点（图11中的黑色矩形即为叶结点），它满足下述性质：</p>\n<ol>\n<li>每个结点要么是黑色，要么是红色；</li>\n<li>根结点是黑色的；</li>\n<li>每个叶结点（NIL）是黑色的；</li>\n<li>每个红色结点的两个子结点一定都是黑色的；</li>\n<li>任意一个结点到每个叶结点的路径都包含相同数量的黑色结点。</li>\n</ol>\n<p>事实上，正是由于性质（5），红黑树的这种平衡被称作黑色完美平衡。红黑树维持平衡主要依靠三种方法：左旋、右旋和染色（结点的颜色由黑变红或者由红变黑）。</p>\n<h3 id=\"2-3-1-平衡性\"><a href=\"#2-3-1-平衡性\" class=\"headerlink\" title=\"2.3.1 平衡性\"></a>2.3.1 平衡性</h3><p>略</p>\n<h3 id=\"2-3-2-三种操作\"><a href=\"#2-3-2-三种操作\" class=\"headerlink\" title=\"2.3.2 三种操作\"></a>2.3.2 三种操作</h3><p>由于红黑树是一棵二叉搜索树，并且查找并不会破坏树的平衡，因此查找和二叉搜索树的查找无异，是一个递归的过程。</p>\n<p>红黑树的插入过程分为两步，第一步是查找到插入位置，第二步则是插入后的自平衡。因此，其插入过程可分为下述情况（如图11所示）：</p>\n<ol>\n<li><p>红黑树为空树：将插入的结点作为根结点，并且染色为黑色；</p>\n</li>\n<li><p>插入结点的父结点为黑色结点：直接插入即可；</p>\n</li>\n<li><p>插入结点的父结点为红色结点：</p>\n<p>若叔叔结点存在并且为红色结点，则只需将P和S设置为黑色，PP设置为红色，接下来递归的处理PP结点即可；</p>\n<p><a href=\"https://imgchr.com/i/sZEJQU\"><img src=\"https://s3.ax1x.com/2021/01/06/sZEJQU.png\" alt=\"sZEJQU.png\"></a></p>\n<p>若叔叔结点不存在或者为黑色结点，插入结点是父结点的左子结点，父结点是祖先结点的左子结点。该种情况需要将P设为黑色，PP设为红色，同时对PP进行右旋，如下图所示。其余情况实际为该种情况的对称形式，在此不再赘述。</p>\n<p><a href=\"https://imgchr.com/i/sZEYyF\"><img src=\"https://s3.ax1x.com/2021/01/06/sZEYyF.png\" alt=\"sZEYyF.png\"></a></p>\n</li>\n</ol>\n<p>红黑树的删除过程也是先查找到删除位置，然后通过旋转和染色来实现再次平衡。</p>\n<h2 id=\"2-4-替罪羊树（ST）\"><a href=\"#2-4-替罪羊树（ST）\" class=\"headerlink\" title=\"2.4 替罪羊树（ST）\"></a><strong>2.4</strong> <strong>替罪羊树（ST</strong>）</h2><p>替罪羊树（Scapegoat Tree）不同于上述通过旋转来维持相对平衡的二叉搜索树，它是基于一种暴力重构的操作来保持相对平衡的。</p>\n<h3 id=\"2-4-1-平衡因子\"><a href=\"#2-4-1-平衡因子\" class=\"headerlink\" title=\"2.4.1 平衡因子\"></a>2.4.1 平衡因子</h3><p>替罪羊树中定义了一个平衡因子α的概念，范围在0.5到1之间。当某个结点的总结点数* α &lt;它某个子树的总结点数，便会对该结点执行重构操作。<br>对于α的取值，如果α越小，那么对平衡的要求越高，重构的次数会更多；α越大，树的平衡程度越低，重构的次数也会随之减少。一般而言，α取0.7左右比较合适。</p>\n<h3 id=\"2-4-2-平衡性\"><a href=\"#2-4-2-平衡性\" class=\"headerlink\" title=\"2.4.2 平衡性\"></a>2.4.2 平衡性</h3><p>略</p>\n<h3 id=\"2-4-3-重构\"><a href=\"#2-4-3-重构\" class=\"headerlink\" title=\"2.4.3 重构\"></a>2.4.3 重构</h3><p><a href=\"https://imgchr.com/i/sZEaw9\"><img src=\"https://s3.ax1x.com/2021/01/06/sZEaw9.png\" alt=\"sZEaw9.png\"></a></p>\n<p>如上图所示的替罪羊树，若平衡因子  ，则结点v已发生失衡。重构过程如下：</p>\n<ol>\n<li>将这棵树压扁，存入向量中：</li>\n</ol>\n<p><a href=\"https://imgchr.com/i/sZEsSK\"><img src=\"https://s3.ax1x.com/2021/01/06/sZEsSK.png\" alt=\"sZEsSK.png\"></a></p>\n<p>​    2.重新建树：每次取区间中点作为根结点，递归左右两边子树建树：</p>\n<p><a href=\"https://imgchr.com/i/sZE6yD\"><img src=\"https://s3.ax1x.com/2021/01/06/sZE6yD.md.png\" alt=\"sZE6yD.md.png\"></a></p>\n<p>通过上述操作，替罪羊树即完成了其重构操作。并且由2.4.2中结论可知，每次插入后的重构仍然能保证替罪羊树各种操作的时间复杂度达到  。</p>\n<h1 id=\"3-平衡搜索树的性能对比\"><a href=\"#3-平衡搜索树的性能对比\" class=\"headerlink\" title=\"3 平衡搜索树的性能对比\"></a><strong>3</strong> <strong>平衡搜索树的性能对比</strong></h1><p>根据上述介绍可以看出，AVL、伸展树、红黑树和替罪羊树分别采取了不同的方法实现了相对平衡，复杂度如表2所示。在实际使用时，应当根据工作情景选用：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">平衡树</th>\n<th align=\"center\">时间复杂度</th>\n<th align=\"center\">应用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">AVL</td>\n<td align=\"center\">O(log n)</td>\n<td align=\"center\">最早的平衡树</td>\n</tr>\n<tr>\n<td align=\"center\">伸展树</td>\n<td align=\"center\">均摊O(log n)</td>\n<td align=\"center\">对区间操作</td>\n</tr>\n<tr>\n<td align=\"center\">红黑树</td>\n<td align=\"center\">O(log n)</td>\n<td align=\"center\">综合效率最高</td>\n</tr>\n<tr>\n<td align=\"center\">替罪羊树</td>\n<td align=\"center\">O(log n)</td>\n<td align=\"center\">实现较易</td>\n</tr>\n</tbody></table>\n"},{"title":"离散数学复习","date":"2021-01-11T04:00:00.000Z","description":"比较水的复习","cover":"https://s3.ax1x.com/2021/01/11/s8GD8H.jpg","_content":"\n\n\n## 第一章 集合\n\n比较简单，就是高中知识\n\n\n\n## 第二章 命题逻辑\n\n- 命题判断：\n\n  - 下列句子中那些是命题？  \n    (1) 北京是中华人民共和国的首都.\n    (2)  2 + 5 ＝8.\n    (3)  x + 5 ＞ 3.\n    (4)  你会开车吗？\n    (5) 2050年元旦北京是晴天.\n    (6) 这只兔子跑得真快呀！\n    (7) 请关上门！\n    (8) 我正在说谎话.\n\n    (1),(2),(5)是命题, (3),(4),(6)~(8)都不是命题\n\n- 永真式、永假式\n\n- 等值式：\n\n  [![s3voPs.jpg](https://s3.ax1x.com/2021/01/11/s3voPs.jpg)](https://imgchr.com/i/s3voPs)\n\n  [![s3v72q.jpg](https://s3.ax1x.com/2021/01/11/s3v72q.jpg)](https://imgchr.com/i/s3v72q)\n\n  \n\n- 范式：析取是V，合取是∩\n\n  [![s3xNJs.md.jpg](https://s3.ax1x.com/2021/01/11/s3xNJs.md.jpg)](https://imgchr.com/i/s3xNJs)\n\n  p,q形成的极小项和极大项：\n\n  - 极小项：\n\n    | 公式     | 成真赋值 | 名称 |\n    | -------- | -------- | ---- |\n    | 非p且非q | 0 0      | m0   |\n    | 非p且q   | 0 1      | m1   |\n    | p且非q   | 1 0      | m2   |\n    | p且q     | 1 1      | m3   |\n\n  - 极大项：\n\n    | 公式     | 成假赋值 | 名称 |\n    | -------- | -------- | ---- |\n    | p或q     | 0 0      | M0   |\n    | p或非q   | 0 1      | M1   |\n    | 非p或q   | 1 0      | M2   |\n    | 非p或非q | 1 1      | M3   |\n\n  【题】\n\n  [![s8p8eK.md.jpg](https://s3.ax1x.com/2021/01/11/s8p8eK.md.jpg)](https://imgchr.com/i/s8p8eK)\n\n\n\n## 第三章 一阶逻辑\n\n1.**约束出现**和**自由出现**的概念\n\n2.前束范式：一个量词非否定出现在全式的开头，并且作用域延伸到公式末尾\n\n\n\n## 第四章 关系\n\n1.自反性、对称性、传递性（充要条件：RoR是R的子集）\n\n2.闭包：满足某一性质的最小关系\n\n3.等价关系：自反、对称、传递（记作x~y）\n\n​\t等价类：与x等价的y都是其等价类。比如模三同余的等价关系中，1的等价类是{ ...,-2,1,4,... }\n\n4.商集：设R 为非空集合A 上的等价关系, 以R 的所有等价类作为元素的集合称为A关于R 的商集, 记做 A/R\n\n​\t令A={ 1, 2, …, 8 }，A关于模 3 等价关系R 的商集为 A/R = {  { 1, 4,7 }, { 2, 5, 8 }, { 3, 6 }  }\n\n5.集合的划分：设A＝{ a, b, c, d }, 给定1,2,3,4,5,6如下：     \n     1= { { a, b, c } , { d } }，     \n\n​\t2={ { a, b }, { c },{ d } }\n\n​\t3={ { a } , { a, b, c, d } }\n\n​\t4={ { a, b } ,  { c } }\n\n​\t5={ ∅, { a, b }, { c, d } }\n\n​\t6={ { a, { a } }, { b, c, d } }\n\n​\t则1和2是A的划分, 其他都不是A的划分. \n\n6.偏序关系：自反、反对称、传递\n\n7.哈赛图：最大下界、最小上界（根据偏序来画就好了）\n\n\n\n\n\n","source":"_posts/离散数学-复习.md","raw":"---\ntitle: 离散数学复习\ndate: 2021-1-11 12:00:00\ndescription: 比较水的复习\ncover: https://s3.ax1x.com/2021/01/11/s8GD8H.jpg\n---\n\n\n\n## 第一章 集合\n\n比较简单，就是高中知识\n\n\n\n## 第二章 命题逻辑\n\n- 命题判断：\n\n  - 下列句子中那些是命题？  \n    (1) 北京是中华人民共和国的首都.\n    (2)  2 + 5 ＝8.\n    (3)  x + 5 ＞ 3.\n    (4)  你会开车吗？\n    (5) 2050年元旦北京是晴天.\n    (6) 这只兔子跑得真快呀！\n    (7) 请关上门！\n    (8) 我正在说谎话.\n\n    (1),(2),(5)是命题, (3),(4),(6)~(8)都不是命题\n\n- 永真式、永假式\n\n- 等值式：\n\n  [![s3voPs.jpg](https://s3.ax1x.com/2021/01/11/s3voPs.jpg)](https://imgchr.com/i/s3voPs)\n\n  [![s3v72q.jpg](https://s3.ax1x.com/2021/01/11/s3v72q.jpg)](https://imgchr.com/i/s3v72q)\n\n  \n\n- 范式：析取是V，合取是∩\n\n  [![s3xNJs.md.jpg](https://s3.ax1x.com/2021/01/11/s3xNJs.md.jpg)](https://imgchr.com/i/s3xNJs)\n\n  p,q形成的极小项和极大项：\n\n  - 极小项：\n\n    | 公式     | 成真赋值 | 名称 |\n    | -------- | -------- | ---- |\n    | 非p且非q | 0 0      | m0   |\n    | 非p且q   | 0 1      | m1   |\n    | p且非q   | 1 0      | m2   |\n    | p且q     | 1 1      | m3   |\n\n  - 极大项：\n\n    | 公式     | 成假赋值 | 名称 |\n    | -------- | -------- | ---- |\n    | p或q     | 0 0      | M0   |\n    | p或非q   | 0 1      | M1   |\n    | 非p或q   | 1 0      | M2   |\n    | 非p或非q | 1 1      | M3   |\n\n  【题】\n\n  [![s8p8eK.md.jpg](https://s3.ax1x.com/2021/01/11/s8p8eK.md.jpg)](https://imgchr.com/i/s8p8eK)\n\n\n\n## 第三章 一阶逻辑\n\n1.**约束出现**和**自由出现**的概念\n\n2.前束范式：一个量词非否定出现在全式的开头，并且作用域延伸到公式末尾\n\n\n\n## 第四章 关系\n\n1.自反性、对称性、传递性（充要条件：RoR是R的子集）\n\n2.闭包：满足某一性质的最小关系\n\n3.等价关系：自反、对称、传递（记作x~y）\n\n​\t等价类：与x等价的y都是其等价类。比如模三同余的等价关系中，1的等价类是{ ...,-2,1,4,... }\n\n4.商集：设R 为非空集合A 上的等价关系, 以R 的所有等价类作为元素的集合称为A关于R 的商集, 记做 A/R\n\n​\t令A={ 1, 2, …, 8 }，A关于模 3 等价关系R 的商集为 A/R = {  { 1, 4,7 }, { 2, 5, 8 }, { 3, 6 }  }\n\n5.集合的划分：设A＝{ a, b, c, d }, 给定1,2,3,4,5,6如下：     \n     1= { { a, b, c } , { d } }，     \n\n​\t2={ { a, b }, { c },{ d } }\n\n​\t3={ { a } , { a, b, c, d } }\n\n​\t4={ { a, b } ,  { c } }\n\n​\t5={ ∅, { a, b }, { c, d } }\n\n​\t6={ { a, { a } }, { b, c, d } }\n\n​\t则1和2是A的划分, 其他都不是A的划分. \n\n6.偏序关系：自反、反对称、传递\n\n7.哈赛图：最大下界、最小上界（根据偏序来画就好了）\n\n\n\n\n\n","slug":"离散数学-复习","published":1,"updated":"2021-01-11T09:01:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmhg4qt4d000hf5fa8lf3ce9n","content":"<h2 id=\"第一章-集合\"><a href=\"#第一章-集合\" class=\"headerlink\" title=\"第一章 集合\"></a>第一章 集合</h2><p>比较简单，就是高中知识</p>\n<h2 id=\"第二章-命题逻辑\"><a href=\"#第二章-命题逻辑\" class=\"headerlink\" title=\"第二章 命题逻辑\"></a>第二章 命题逻辑</h2><ul>\n<li><p>命题判断：</p>\n<ul>\n<li><p>下列句子中那些是命题？<br>(1) 北京是中华人民共和国的首都.<br>(2)  2 + 5 ＝8.<br>(3)  x + 5 ＞ 3.<br>(4)  你会开车吗？<br>(5) 2050年元旦北京是晴天.<br>(6) 这只兔子跑得真快呀！<br>(7) 请关上门！<br>(8) 我正在说谎话.</p>\n<p>(1),(2),(5)是命题, (3),(4),(6)~(8)都不是命题</p>\n</li>\n</ul>\n</li>\n<li><p>永真式、永假式</p>\n</li>\n<li><p>等值式：</p>\n<p><a href=\"https://imgchr.com/i/s3voPs\"><img src=\"https://s3.ax1x.com/2021/01/11/s3voPs.jpg\" alt=\"s3voPs.jpg\"></a></p>\n<p><a href=\"https://imgchr.com/i/s3v72q\"><img src=\"https://s3.ax1x.com/2021/01/11/s3v72q.jpg\" alt=\"s3v72q.jpg\"></a></p>\n</li>\n</ul>\n<ul>\n<li><p>范式：析取是V，合取是∩</p>\n<p><a href=\"https://imgchr.com/i/s3xNJs\"><img src=\"https://s3.ax1x.com/2021/01/11/s3xNJs.md.jpg\" alt=\"s3xNJs.md.jpg\"></a></p>\n<p>p,q形成的极小项和极大项：</p>\n<ul>\n<li><p>极小项：</p>\n<table>\n<thead>\n<tr>\n<th>公式</th>\n<th>成真赋值</th>\n<th>名称</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>非p且非q</td>\n<td>0 0</td>\n<td>m0</td>\n</tr>\n<tr>\n<td>非p且q</td>\n<td>0 1</td>\n<td>m1</td>\n</tr>\n<tr>\n<td>p且非q</td>\n<td>1 0</td>\n<td>m2</td>\n</tr>\n<tr>\n<td>p且q</td>\n<td>1 1</td>\n<td>m3</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>极大项：</p>\n<table>\n<thead>\n<tr>\n<th>公式</th>\n<th>成假赋值</th>\n<th>名称</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>p或q</td>\n<td>0 0</td>\n<td>M0</td>\n</tr>\n<tr>\n<td>p或非q</td>\n<td>0 1</td>\n<td>M1</td>\n</tr>\n<tr>\n<td>非p或q</td>\n<td>1 0</td>\n<td>M2</td>\n</tr>\n<tr>\n<td>非p或非q</td>\n<td>1 1</td>\n<td>M3</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<p>【题】</p>\n<p><a href=\"https://imgchr.com/i/s8p8eK\"><img src=\"https://s3.ax1x.com/2021/01/11/s8p8eK.md.jpg\" alt=\"s8p8eK.md.jpg\"></a></p>\n</li>\n</ul>\n<h2 id=\"第三章-一阶逻辑\"><a href=\"#第三章-一阶逻辑\" class=\"headerlink\" title=\"第三章 一阶逻辑\"></a>第三章 一阶逻辑</h2><p>1.<strong>约束出现</strong>和<strong>自由出现</strong>的概念</p>\n<p>2.前束范式：一个量词非否定出现在全式的开头，并且作用域延伸到公式末尾</p>\n<h2 id=\"第四章-关系\"><a href=\"#第四章-关系\" class=\"headerlink\" title=\"第四章 关系\"></a>第四章 关系</h2><p>1.自反性、对称性、传递性（充要条件：RoR是R的子集）</p>\n<p>2.闭包：满足某一性质的最小关系</p>\n<p>3.等价关系：自反、对称、传递（记作x~y）</p>\n<p>​    等价类：与x等价的y都是其等价类。比如模三同余的等价关系中，1的等价类是{ …,-2,1,4,… }</p>\n<p>4.商集：设R 为非空集合A 上的等价关系, 以R 的所有等价类作为元素的集合称为A关于R 的商集, 记做 A/R</p>\n<p>​    令A={ 1, 2, …, 8 }，A关于模 3 等价关系R 的商集为 A/R = {  { 1, 4,7 }, { 2, 5, 8 }, { 3, 6 }  }</p>\n<p>5.集合的划分：设A＝{ a, b, c, d }, 给定1,2,3,4,5,6如下：<br>     1= { { a, b, c } , { d } }，     </p>\n<p>​    2={ { a, b }, { c },{ d } }</p>\n<p>​    3={ { a } , { a, b, c, d } }</p>\n<p>​    4={ { a, b } ,  { c } }</p>\n<p>​    5={ ∅, { a, b }, { c, d } }</p>\n<p>​    6={ { a, { a } }, { b, c, d } }</p>\n<p>​    则1和2是A的划分, 其他都不是A的划分. </p>\n<p>6.偏序关系：自反、反对称、传递</p>\n<p>7.哈赛图：最大下界、最小上界（根据偏序来画就好了）</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<h2 id=\"第一章-集合\"><a href=\"#第一章-集合\" class=\"headerlink\" title=\"第一章 集合\"></a>第一章 集合</h2><p>比较简单，就是高中知识</p>\n<h2 id=\"第二章-命题逻辑\"><a href=\"#第二章-命题逻辑\" class=\"headerlink\" title=\"第二章 命题逻辑\"></a>第二章 命题逻辑</h2><ul>\n<li><p>命题判断：</p>\n<ul>\n<li><p>下列句子中那些是命题？<br>(1) 北京是中华人民共和国的首都.<br>(2)  2 + 5 ＝8.<br>(3)  x + 5 ＞ 3.<br>(4)  你会开车吗？<br>(5) 2050年元旦北京是晴天.<br>(6) 这只兔子跑得真快呀！<br>(7) 请关上门！<br>(8) 我正在说谎话.</p>\n<p>(1),(2),(5)是命题, (3),(4),(6)~(8)都不是命题</p>\n</li>\n</ul>\n</li>\n<li><p>永真式、永假式</p>\n</li>\n<li><p>等值式：</p>\n<p><a href=\"https://imgchr.com/i/s3voPs\"><img src=\"https://s3.ax1x.com/2021/01/11/s3voPs.jpg\" alt=\"s3voPs.jpg\"></a></p>\n<p><a href=\"https://imgchr.com/i/s3v72q\"><img src=\"https://s3.ax1x.com/2021/01/11/s3v72q.jpg\" alt=\"s3v72q.jpg\"></a></p>\n</li>\n</ul>\n<ul>\n<li><p>范式：析取是V，合取是∩</p>\n<p><a href=\"https://imgchr.com/i/s3xNJs\"><img src=\"https://s3.ax1x.com/2021/01/11/s3xNJs.md.jpg\" alt=\"s3xNJs.md.jpg\"></a></p>\n<p>p,q形成的极小项和极大项：</p>\n<ul>\n<li><p>极小项：</p>\n<table>\n<thead>\n<tr>\n<th>公式</th>\n<th>成真赋值</th>\n<th>名称</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>非p且非q</td>\n<td>0 0</td>\n<td>m0</td>\n</tr>\n<tr>\n<td>非p且q</td>\n<td>0 1</td>\n<td>m1</td>\n</tr>\n<tr>\n<td>p且非q</td>\n<td>1 0</td>\n<td>m2</td>\n</tr>\n<tr>\n<td>p且q</td>\n<td>1 1</td>\n<td>m3</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>极大项：</p>\n<table>\n<thead>\n<tr>\n<th>公式</th>\n<th>成假赋值</th>\n<th>名称</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>p或q</td>\n<td>0 0</td>\n<td>M0</td>\n</tr>\n<tr>\n<td>p或非q</td>\n<td>0 1</td>\n<td>M1</td>\n</tr>\n<tr>\n<td>非p或q</td>\n<td>1 0</td>\n<td>M2</td>\n</tr>\n<tr>\n<td>非p或非q</td>\n<td>1 1</td>\n<td>M3</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<p>【题】</p>\n<p><a href=\"https://imgchr.com/i/s8p8eK\"><img src=\"https://s3.ax1x.com/2021/01/11/s8p8eK.md.jpg\" alt=\"s8p8eK.md.jpg\"></a></p>\n</li>\n</ul>\n<h2 id=\"第三章-一阶逻辑\"><a href=\"#第三章-一阶逻辑\" class=\"headerlink\" title=\"第三章 一阶逻辑\"></a>第三章 一阶逻辑</h2><p>1.<strong>约束出现</strong>和<strong>自由出现</strong>的概念</p>\n<p>2.前束范式：一个量词非否定出现在全式的开头，并且作用域延伸到公式末尾</p>\n<h2 id=\"第四章-关系\"><a href=\"#第四章-关系\" class=\"headerlink\" title=\"第四章 关系\"></a>第四章 关系</h2><p>1.自反性、对称性、传递性（充要条件：RoR是R的子集）</p>\n<p>2.闭包：满足某一性质的最小关系</p>\n<p>3.等价关系：自反、对称、传递（记作x~y）</p>\n<p>​    等价类：与x等价的y都是其等价类。比如模三同余的等价关系中，1的等价类是{ …,-2,1,4,… }</p>\n<p>4.商集：设R 为非空集合A 上的等价关系, 以R 的所有等价类作为元素的集合称为A关于R 的商集, 记做 A/R</p>\n<p>​    令A={ 1, 2, …, 8 }，A关于模 3 等价关系R 的商集为 A/R = {  { 1, 4,7 }, { 2, 5, 8 }, { 3, 6 }  }</p>\n<p>5.集合的划分：设A＝{ a, b, c, d }, 给定1,2,3,4,5,6如下：<br>     1= { { a, b, c } , { d } }，     </p>\n<p>​    2={ { a, b }, { c },{ d } }</p>\n<p>​    3={ { a } , { a, b, c, d } }</p>\n<p>​    4={ { a, b } ,  { c } }</p>\n<p>​    5={ ∅, { a, b }, { c, d } }</p>\n<p>​    6={ { a, { a } }, { b, c, d } }</p>\n<p>​    则1和2是A的划分, 其他都不是A的划分. </p>\n<p>6.偏序关系：自反、反对称、传递</p>\n<p>7.哈赛图：最大下界、最小上界（根据偏序来画就好了）</p>\n"},{"title":"第一篇博客","date":"2020-12-28T16:00:00.000Z","cover":"https://s3.ax1x.com/2020/12/29/rbaWHf.jpg","_content":"\n\n\n# 第一篇博客\n\n2020年12月29日，在C楼教室写下了第一篇博客。\n\n[![rbaWHf.jpg](https://s3.ax1x.com/2020/12/29/rbaWHf.jpg)](https://imgchr.com/i/rbaWHf)\n\n天气灰蒙蒙的，因为正在下雨，并且今晚要大降温。\n\n**看到这条消息的你记得加件衣服哦**\n\n建立这个博客没什么特别大的意义，主要就是想一方面能整活一下，另一方面还可以熟悉一下git的使用。\n\n首先，感谢下**lltdl**（lltdl的博客见友链）在百忙之冲帮我解决了不少问题。\n\n捣鼓捣鼓了一下午，终于在16:10这个时间点成功的搞起来了。\n\n在用github的链接能登录上后，然后花了六块钱买了一年的域名（也就是这个啦：**http://wangwangwang.website**），终于能成功访问了。\n\n虽然现在还有一个奇怪的问题，就是为啥校园网不能访问，以后再解决吧。（**十分钟后我就发现域名能成功访问了**）\n\n记得收藏这个域名哦，可能会不定时和公众号同步更新一些奇奇怪怪的内容（公众号：**汪汪汪233**）。\n\n今天就讲到这里吧，现在我要准备去吃饭了，虽然不知道吃点什么。\n\n然后可能晚上会再美化一下网站什么的。\n\n拜拜！","source":"_posts/第一篇博客.md","raw":"---\ntitle: 第一篇博客\ndate: 2020-12-29 00:00:00\ncover: https://s3.ax1x.com/2020/12/29/rbaWHf.jpg\n---\n\n\n\n# 第一篇博客\n\n2020年12月29日，在C楼教室写下了第一篇博客。\n\n[![rbaWHf.jpg](https://s3.ax1x.com/2020/12/29/rbaWHf.jpg)](https://imgchr.com/i/rbaWHf)\n\n天气灰蒙蒙的，因为正在下雨，并且今晚要大降温。\n\n**看到这条消息的你记得加件衣服哦**\n\n建立这个博客没什么特别大的意义，主要就是想一方面能整活一下，另一方面还可以熟悉一下git的使用。\n\n首先，感谢下**lltdl**（lltdl的博客见友链）在百忙之冲帮我解决了不少问题。\n\n捣鼓捣鼓了一下午，终于在16:10这个时间点成功的搞起来了。\n\n在用github的链接能登录上后，然后花了六块钱买了一年的域名（也就是这个啦：**http://wangwangwang.website**），终于能成功访问了。\n\n虽然现在还有一个奇怪的问题，就是为啥校园网不能访问，以后再解决吧。（**十分钟后我就发现域名能成功访问了**）\n\n记得收藏这个域名哦，可能会不定时和公众号同步更新一些奇奇怪怪的内容（公众号：**汪汪汪233**）。\n\n今天就讲到这里吧，现在我要准备去吃饭了，虽然不知道吃点什么。\n\n然后可能晚上会再美化一下网站什么的。\n\n拜拜！","slug":"第一篇博客","published":1,"updated":"2020-12-30T15:48:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmhg4qt4d000if5faf78shzla","content":"<h1 id=\"第一篇博客\"><a href=\"#第一篇博客\" class=\"headerlink\" title=\"第一篇博客\"></a>第一篇博客</h1><p>2020年12月29日，在C楼教室写下了第一篇博客。</p>\n<p><a href=\"https://imgchr.com/i/rbaWHf\"><img src=\"https://s3.ax1x.com/2020/12/29/rbaWHf.jpg\" alt=\"rbaWHf.jpg\"></a></p>\n<p>天气灰蒙蒙的，因为正在下雨，并且今晚要大降温。</p>\n<p><strong>看到这条消息的你记得加件衣服哦</strong></p>\n<p>建立这个博客没什么特别大的意义，主要就是想一方面能整活一下，另一方面还可以熟悉一下git的使用。</p>\n<p>首先，感谢下<strong>lltdl</strong>（lltdl的博客见友链）在百忙之冲帮我解决了不少问题。</p>\n<p>捣鼓捣鼓了一下午，终于在16:10这个时间点成功的搞起来了。</p>\n<p>在用github的链接能登录上后，然后花了六块钱买了一年的域名（也就是这个啦：<strong><a href=\"http://wangwangwang.website/\">http://wangwangwang.website</a></strong>），终于能成功访问了。</p>\n<p>虽然现在还有一个奇怪的问题，就是为啥校园网不能访问，以后再解决吧。（<strong>十分钟后我就发现域名能成功访问了</strong>）</p>\n<p>记得收藏这个域名哦，可能会不定时和公众号同步更新一些奇奇怪怪的内容（公众号：<strong>汪汪汪233</strong>）。</p>\n<p>今天就讲到这里吧，现在我要准备去吃饭了，虽然不知道吃点什么。</p>\n<p>然后可能晚上会再美化一下网站什么的。</p>\n<p>拜拜！</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<h1 id=\"第一篇博客\"><a href=\"#第一篇博客\" class=\"headerlink\" title=\"第一篇博客\"></a>第一篇博客</h1><p>2020年12月29日，在C楼教室写下了第一篇博客。</p>\n<p><a href=\"https://imgchr.com/i/rbaWHf\"><img src=\"https://s3.ax1x.com/2020/12/29/rbaWHf.jpg\" alt=\"rbaWHf.jpg\"></a></p>\n<p>天气灰蒙蒙的，因为正在下雨，并且今晚要大降温。</p>\n<p><strong>看到这条消息的你记得加件衣服哦</strong></p>\n<p>建立这个博客没什么特别大的意义，主要就是想一方面能整活一下，另一方面还可以熟悉一下git的使用。</p>\n<p>首先，感谢下<strong>lltdl</strong>（lltdl的博客见友链）在百忙之冲帮我解决了不少问题。</p>\n<p>捣鼓捣鼓了一下午，终于在16:10这个时间点成功的搞起来了。</p>\n<p>在用github的链接能登录上后，然后花了六块钱买了一年的域名（也就是这个啦：<strong><a href=\"http://wangwangwang.website/\">http://wangwangwang.website</a></strong>），终于能成功访问了。</p>\n<p>虽然现在还有一个奇怪的问题，就是为啥校园网不能访问，以后再解决吧。（<strong>十分钟后我就发现域名能成功访问了</strong>）</p>\n<p>记得收藏这个域名哦，可能会不定时和公众号同步更新一些奇奇怪怪的内容（公众号：<strong>汪汪汪233</strong>）。</p>\n<p>今天就讲到这里吧，现在我要准备去吃饭了，虽然不知道吃点什么。</p>\n<p>然后可能晚上会再美化一下网站什么的。</p>\n<p>拜拜！</p>\n"},{"title":"计算机组成原理实验知识点总结","date":"2020-12-29T16:00:00.000Z","description":"软件工程专业计算机组成原理实验下半部分小结","top_img":"https://s3.ax1x.com/2020/12/30/rO9C4J.jpg","cover":"https://s3.ax1x.com/2020/12/30/rO9C4J.jpg","_content":"\n> 这学期的计算机组成原理课程终于结束了，明天就要去最后答辩了。大概可能就是要回答一些问题什么的吧，所以今天剩下的时间就用来总结一下这学期学过的比较重要的一些内容。\n\n\n\n# 组成原理实验\n\n> 由于似乎后半部分是考核的重点，因此主要需要复习的是后半部分知识。\n>\n> 后半部分包括了六个实验，其中比较重要的是：**微程序控制器实验**和**简单模型机设计实验**。此外，掌握各种信号的作用也是相对比较重要的。\n>\n> 在本文档中，所有标注***关键*** 为必须掌握内容\n\n\n\n## 计算机系统认识实验\n\n1.后半部分的实验主要建立在**TD-DMA实验箱**基础上；\n\n2.**（关键）**计算机系统组成的五大部件：\n\n[![rLI8oT.jpg](https://s3.ax1x.com/2020/12/30/rLI8oT.jpg)](https://imgchr.com/i/rLI8oT)\n\n- [x] 运算器\n- [x] 控制器\n- [x] 存储器\n- [x] 输入设备\n- [x] 输出设备\n\n3.计算机系统操作过程概括：\n\n（1）通过**输入设备**接受程序和数据信息，传送到**存储器**；\n\n（2）通过**控制器**分析存放在存储器中的程序，将其中的数据信息读取到**运算器**进行处理；\n\n（3）将处理结果送到计算机的**输出设备**或**存储器**\n\n4.冯诺依曼体系：\n\n（1）指令和数据由**二进制代码**表示，即0和1；\n\n（2）采用**存储程序**方式，程序存放在连续的存储器地址中；\n\n（3）以**控制信息流**为驱动，由控制器控制整个程序和数据的存取以及程序的执行；\n\n（4）以运算器为核心，**数据信息流**被调用处理，所有的数据处理执行都经过运算器；\n\n（5）通过**程序计数器PC**来存放下一次执行的指令单元地址，顺序加1或跳转\n\n\n\n## 基本运算器实验\n\n1.运算器是计算机进行数据处理的核心部件，其核心是**算术逻辑单元（ALU）**\n\n2.运算器组成：\n\n- 三个独立的运算部件：算数、逻辑、移位\n- 暂存器：A和B\n- 控制信号：S3-S0、CN\n- 进位标志：FC\n- 判零标志：FZ\n\n3.**（关键）**三个信号的作用：\n\n（1）ALU-B置低电平：运算器单元的运算结果进入总线\n\n（2）IN-B置低电平：输入单元的数据进入总线\n\n（3）LDA/LDB置高电平：两个暂存器可以接受数据\n\n4.运算器的控制信号作用（可以控制运算）：\n\n[![rLIRld.jpg](https://s3.ax1x.com/2020/12/30/rLIRld.jpg)](https://imgchr.com/i/rLIRld)\n\n\n\n## 静态随机存储器实验\n\n1.基本存储单元：\n\n（1）能够存储一位二进制信息；\n\n（2）是一个可控制的双稳态二进制触发器；\n\n（3）选择信号、读写信号、数据信号\n\n2.**（关键）**几个控制信号的作用（前三个信号在总线那一节还会讲到）：\n\n（1）IOM：决定对I/0设备还是对存储器进行读写操作，置低电平代表对存储器进行读写操作；\n\n（2）WR：置高电平进行写操作；\n\n（3）RD：置高电平进行读操作；\n\n（4）LDAR置高电平：对地址存储器AR写数据；\n\n（5）IOR：置低电平代表从输入单元获取数据\n\n\n\n## 微程序控制器实验\n\n1.微程序控制器的基本任务：\n\n（1）完成当前指令的翻译和执行；\n\n（2）将当前指令的功能转换为可控制的硬件逻辑部件工作\n\n2.**（关键）**重要概念：\n\n| 名称             | 定义                                                         |\n| ---------------- | ------------------------------------------------------------ |\n| 微命令（微信号） | 直接作用于控制电路的控制命令                                 |\n| 微操作           | 由微命令控制实现的最基本操作：<br />取指令地址、读指令、译码、取操作数地址、取操作数、运算、写回结果等都是微操作 |\n| 微指令           | 1.一个微周期所需的微命令集，用二进制编码表示；<br />2.同时发出的控制信号所执行的一组微操作<br />一个典型的加法指令的执行可分为：取指令、计算地址、取操作数和加法运算四步，每一步都由一组微操作实现 |\n| 微周期           | 读取一条微指令并完成相应微操作所用时间，通常为一个机器周期   |\n| 微程序           | 1.若干条微指令的有序序列；<br />2.每条机器指令对应一段微程序 |\n\n- 一段程序由一系列机器指令组成\n\n  比如：in、add、out、jump……\n\n- 每一条机器指令由一段微程序实现\n\n- 每一段微程序由一组微指令表示\n\n- 每一条微指令由一组微操作实现\n\n- 一个微操作对应一条微命令\n\n3.**（关键）**微程序控制器组成：\n\n- [x] 控制存储器CM：\n  - 用于存放微程序\n  - 每个单元存放一条微指令代码，只读\n- [x] 微指令寄存器uIR：\n  - 用于存放正在指令的微指令\n  - 包括微命令控制字段和顺序控制字段两部分\n- [x] 微地址寄存器uAR：\n  - 用于保存下一条微指令的地址\n\n4.**（关键）**微指令格式：\n\n| **23** | **22** | **21** | **20** | **19** | **18 - 15** | 14-12 | 11-9 | 8-6  | **5 – 0** |\n| :----: | ------ | :----: | :----: | :----: | :---------: | :---: | :--: | :--: | :-------: |\n|        |        |   WR   |   RD   |  IOMS  |    S3-S0    |   A   |  B   |  C   |  uA5-uA0  |\n\n- 24位字长\n- uA5-uA0是6位**后续微地址**\n- A、B、C是三个译码字段\n\n3.三个字段和二进制微代码表（了解即可）：\n\n[![rL7z7t.jpg](https://s3.ax1x.com/2020/12/30/rL7z7t.jpg)](https://imgchr.com/i/rL7z7t)\n\n[![rLHF1g.jpg](https://s3.ax1x.com/2020/12/30/rLHF1g.jpg)](https://imgchr.com/i/rLHF1g)\n\n4.**（关键）**微程序流程图：\n\n[![rLHUN6.jpg](https://s3.ax1x.com/2020/12/30/rLHUN6.jpg)](https://imgchr.com/i/rLHUN6)\n\n本实验中有四条机器指令：\n\n| 指令名 | 二进制代码 |\n| :----: | :--------: |\n|  ADD   | 0000 0000  |\n|   IN   | 0010 0000  |\n|  OUT   | 0011 0000  |\n|  HLT   | 0101 0000  |\n\n四条机器指令高四位在P<1>处与30进行运算，决定了后续执行哪条分支。\n\n5.**（关键）**微程序控制器工作过程：\n\n- 机器周期开始，执行**公共取指**操作\n- 读机器指令，送入**指令译码器**（同时修改PC）\n- 进行**指令译码**，取出操作码产生对应的**微程序入口地址**，送入微地址寄存器\n- 取出对应的一条微指令，送入**微指令寄存器**\n- 微指令操作字段经译码产生**一组微命令**，送入相应的执行部件\n- 在**时序控制**下完成微操作（T2/T4）\n- 产生**后续微地址**，读取下一条微指令\n- 执行完一段微程序后，开始新的机器周期\n\n\n\n## 总线基本实验\n\n1.总线是计算机各部件之间进行数据传输的公共通路，是一组导线和相关的控制、驱动电路的集合\n\n- 数据总线\n- 地址总线\n- 控制总线\n\n2.**（关键）**关于WR、RD、IOM控制信号：\n\n| **WR** | **RD** | **IOM** | **功能** |\n| :----: | :----: | :-----: | :------: |\n|   0    |   1    |    0    | 读存储器 |\n|   1    |   0    |    0    | 写存储器 |\n|   0    |   1    |    1    |  读I/O   |\n|   1    |   0    |    1    |  写I/O   |\n\n3.关于R0-B、LDR0、LDAR控制信号：\n\n- R0-B\n  - 置1时，R0寄存器输出关闭\n  - 置0时，R0寄存器输出打开\n\n- LDR0\n\n  - 置1时，R0寄存器输入打开\n\n  - 置0时，R0寄存器输入关闭\n\n- LDAR\n\n  - 置1时，允许访问地址寄存器\n\n  - 置0时，不允许访问地址寄存器\n\n\n\n## （关键）简单模型机设计实验\n\n1.**（关键）**CPU的组成\n\n[![rLX8Ts.jpg](https://s3.ax1x.com/2020/12/30/rLX8Ts.jpg)](https://imgchr.com/i/rLX8Ts)\n\n- 运算器\n  - ALU：完成数据计算或处理\n  - 暂存器A、B\n- 控制器MC：控制数据和指令的进出\n- 寄存器：用于暂存数据或指令\n  - 通用寄存器R0\n  - 指令寄存器IR\n  - 地址寄存器AR\n  - 程序计数器PC\n\n2.CPU基本功能：读取并执行指令\n\n3.CPU要完成的工作：\n\n- 取指令：读主存，装入寄存器\n- 分析指令：指令译码，决定动作\n- 取指令：从主存或I/O读取操作数\n- 处理数据：对操作数进行算术或逻辑运算\n  - 写数据：将执行结果写到主存或I/O\n\n4.**(关键)**微指令执行：\n\n[![rLjAjU.jpg](https://s3.ax1x.com/2020/12/30/rLjAjU.jpg)](https://imgchr.com/i/rLjAjU)\n\n（1）采用P(1)测试字，测试条件是指令寄存器高六位 IR7~IR2；\n\n（2）五条机器指令：\n\n- ADD（二进制加法）\n\n- IN（输入）\n- OUT（输出）\n- HLT（停机）\n- JMP（转移）\n\n\n\n## 总结\n\n除了上述标记关键的点之外，还有几个地方需要知道：\n\n- 机器周期工作过程：\n\n  单周期包括四个单节拍，单机器指令要执行多个单周期\n\n- 各种信号：见上述标注\n\n> 好了，走神了两节课整理完的机组实验结束了（虽然基本都是复制ppt内容\n>\n> 不过水了一篇推送，很快乐","source":"_posts/计算机组成原理实验.md","raw":"---\ntitle: 计算机组成原理实验知识点总结\ndate: 2020-12-30 00:00:00\ndescription: 软件工程专业计算机组成原理实验下半部分小结\ntop_img: https://s3.ax1x.com/2020/12/30/rO9C4J.jpg\ncover: https://s3.ax1x.com/2020/12/30/rO9C4J.jpg\n---\n\n> 这学期的计算机组成原理课程终于结束了，明天就要去最后答辩了。大概可能就是要回答一些问题什么的吧，所以今天剩下的时间就用来总结一下这学期学过的比较重要的一些内容。\n\n\n\n# 组成原理实验\n\n> 由于似乎后半部分是考核的重点，因此主要需要复习的是后半部分知识。\n>\n> 后半部分包括了六个实验，其中比较重要的是：**微程序控制器实验**和**简单模型机设计实验**。此外，掌握各种信号的作用也是相对比较重要的。\n>\n> 在本文档中，所有标注***关键*** 为必须掌握内容\n\n\n\n## 计算机系统认识实验\n\n1.后半部分的实验主要建立在**TD-DMA实验箱**基础上；\n\n2.**（关键）**计算机系统组成的五大部件：\n\n[![rLI8oT.jpg](https://s3.ax1x.com/2020/12/30/rLI8oT.jpg)](https://imgchr.com/i/rLI8oT)\n\n- [x] 运算器\n- [x] 控制器\n- [x] 存储器\n- [x] 输入设备\n- [x] 输出设备\n\n3.计算机系统操作过程概括：\n\n（1）通过**输入设备**接受程序和数据信息，传送到**存储器**；\n\n（2）通过**控制器**分析存放在存储器中的程序，将其中的数据信息读取到**运算器**进行处理；\n\n（3）将处理结果送到计算机的**输出设备**或**存储器**\n\n4.冯诺依曼体系：\n\n（1）指令和数据由**二进制代码**表示，即0和1；\n\n（2）采用**存储程序**方式，程序存放在连续的存储器地址中；\n\n（3）以**控制信息流**为驱动，由控制器控制整个程序和数据的存取以及程序的执行；\n\n（4）以运算器为核心，**数据信息流**被调用处理，所有的数据处理执行都经过运算器；\n\n（5）通过**程序计数器PC**来存放下一次执行的指令单元地址，顺序加1或跳转\n\n\n\n## 基本运算器实验\n\n1.运算器是计算机进行数据处理的核心部件，其核心是**算术逻辑单元（ALU）**\n\n2.运算器组成：\n\n- 三个独立的运算部件：算数、逻辑、移位\n- 暂存器：A和B\n- 控制信号：S3-S0、CN\n- 进位标志：FC\n- 判零标志：FZ\n\n3.**（关键）**三个信号的作用：\n\n（1）ALU-B置低电平：运算器单元的运算结果进入总线\n\n（2）IN-B置低电平：输入单元的数据进入总线\n\n（3）LDA/LDB置高电平：两个暂存器可以接受数据\n\n4.运算器的控制信号作用（可以控制运算）：\n\n[![rLIRld.jpg](https://s3.ax1x.com/2020/12/30/rLIRld.jpg)](https://imgchr.com/i/rLIRld)\n\n\n\n## 静态随机存储器实验\n\n1.基本存储单元：\n\n（1）能够存储一位二进制信息；\n\n（2）是一个可控制的双稳态二进制触发器；\n\n（3）选择信号、读写信号、数据信号\n\n2.**（关键）**几个控制信号的作用（前三个信号在总线那一节还会讲到）：\n\n（1）IOM：决定对I/0设备还是对存储器进行读写操作，置低电平代表对存储器进行读写操作；\n\n（2）WR：置高电平进行写操作；\n\n（3）RD：置高电平进行读操作；\n\n（4）LDAR置高电平：对地址存储器AR写数据；\n\n（5）IOR：置低电平代表从输入单元获取数据\n\n\n\n## 微程序控制器实验\n\n1.微程序控制器的基本任务：\n\n（1）完成当前指令的翻译和执行；\n\n（2）将当前指令的功能转换为可控制的硬件逻辑部件工作\n\n2.**（关键）**重要概念：\n\n| 名称             | 定义                                                         |\n| ---------------- | ------------------------------------------------------------ |\n| 微命令（微信号） | 直接作用于控制电路的控制命令                                 |\n| 微操作           | 由微命令控制实现的最基本操作：<br />取指令地址、读指令、译码、取操作数地址、取操作数、运算、写回结果等都是微操作 |\n| 微指令           | 1.一个微周期所需的微命令集，用二进制编码表示；<br />2.同时发出的控制信号所执行的一组微操作<br />一个典型的加法指令的执行可分为：取指令、计算地址、取操作数和加法运算四步，每一步都由一组微操作实现 |\n| 微周期           | 读取一条微指令并完成相应微操作所用时间，通常为一个机器周期   |\n| 微程序           | 1.若干条微指令的有序序列；<br />2.每条机器指令对应一段微程序 |\n\n- 一段程序由一系列机器指令组成\n\n  比如：in、add、out、jump……\n\n- 每一条机器指令由一段微程序实现\n\n- 每一段微程序由一组微指令表示\n\n- 每一条微指令由一组微操作实现\n\n- 一个微操作对应一条微命令\n\n3.**（关键）**微程序控制器组成：\n\n- [x] 控制存储器CM：\n  - 用于存放微程序\n  - 每个单元存放一条微指令代码，只读\n- [x] 微指令寄存器uIR：\n  - 用于存放正在指令的微指令\n  - 包括微命令控制字段和顺序控制字段两部分\n- [x] 微地址寄存器uAR：\n  - 用于保存下一条微指令的地址\n\n4.**（关键）**微指令格式：\n\n| **23** | **22** | **21** | **20** | **19** | **18 - 15** | 14-12 | 11-9 | 8-6  | **5 – 0** |\n| :----: | ------ | :----: | :----: | :----: | :---------: | :---: | :--: | :--: | :-------: |\n|        |        |   WR   |   RD   |  IOMS  |    S3-S0    |   A   |  B   |  C   |  uA5-uA0  |\n\n- 24位字长\n- uA5-uA0是6位**后续微地址**\n- A、B、C是三个译码字段\n\n3.三个字段和二进制微代码表（了解即可）：\n\n[![rL7z7t.jpg](https://s3.ax1x.com/2020/12/30/rL7z7t.jpg)](https://imgchr.com/i/rL7z7t)\n\n[![rLHF1g.jpg](https://s3.ax1x.com/2020/12/30/rLHF1g.jpg)](https://imgchr.com/i/rLHF1g)\n\n4.**（关键）**微程序流程图：\n\n[![rLHUN6.jpg](https://s3.ax1x.com/2020/12/30/rLHUN6.jpg)](https://imgchr.com/i/rLHUN6)\n\n本实验中有四条机器指令：\n\n| 指令名 | 二进制代码 |\n| :----: | :--------: |\n|  ADD   | 0000 0000  |\n|   IN   | 0010 0000  |\n|  OUT   | 0011 0000  |\n|  HLT   | 0101 0000  |\n\n四条机器指令高四位在P<1>处与30进行运算，决定了后续执行哪条分支。\n\n5.**（关键）**微程序控制器工作过程：\n\n- 机器周期开始，执行**公共取指**操作\n- 读机器指令，送入**指令译码器**（同时修改PC）\n- 进行**指令译码**，取出操作码产生对应的**微程序入口地址**，送入微地址寄存器\n- 取出对应的一条微指令，送入**微指令寄存器**\n- 微指令操作字段经译码产生**一组微命令**，送入相应的执行部件\n- 在**时序控制**下完成微操作（T2/T4）\n- 产生**后续微地址**，读取下一条微指令\n- 执行完一段微程序后，开始新的机器周期\n\n\n\n## 总线基本实验\n\n1.总线是计算机各部件之间进行数据传输的公共通路，是一组导线和相关的控制、驱动电路的集合\n\n- 数据总线\n- 地址总线\n- 控制总线\n\n2.**（关键）**关于WR、RD、IOM控制信号：\n\n| **WR** | **RD** | **IOM** | **功能** |\n| :----: | :----: | :-----: | :------: |\n|   0    |   1    |    0    | 读存储器 |\n|   1    |   0    |    0    | 写存储器 |\n|   0    |   1    |    1    |  读I/O   |\n|   1    |   0    |    1    |  写I/O   |\n\n3.关于R0-B、LDR0、LDAR控制信号：\n\n- R0-B\n  - 置1时，R0寄存器输出关闭\n  - 置0时，R0寄存器输出打开\n\n- LDR0\n\n  - 置1时，R0寄存器输入打开\n\n  - 置0时，R0寄存器输入关闭\n\n- LDAR\n\n  - 置1时，允许访问地址寄存器\n\n  - 置0时，不允许访问地址寄存器\n\n\n\n## （关键）简单模型机设计实验\n\n1.**（关键）**CPU的组成\n\n[![rLX8Ts.jpg](https://s3.ax1x.com/2020/12/30/rLX8Ts.jpg)](https://imgchr.com/i/rLX8Ts)\n\n- 运算器\n  - ALU：完成数据计算或处理\n  - 暂存器A、B\n- 控制器MC：控制数据和指令的进出\n- 寄存器：用于暂存数据或指令\n  - 通用寄存器R0\n  - 指令寄存器IR\n  - 地址寄存器AR\n  - 程序计数器PC\n\n2.CPU基本功能：读取并执行指令\n\n3.CPU要完成的工作：\n\n- 取指令：读主存，装入寄存器\n- 分析指令：指令译码，决定动作\n- 取指令：从主存或I/O读取操作数\n- 处理数据：对操作数进行算术或逻辑运算\n  - 写数据：将执行结果写到主存或I/O\n\n4.**(关键)**微指令执行：\n\n[![rLjAjU.jpg](https://s3.ax1x.com/2020/12/30/rLjAjU.jpg)](https://imgchr.com/i/rLjAjU)\n\n（1）采用P(1)测试字，测试条件是指令寄存器高六位 IR7~IR2；\n\n（2）五条机器指令：\n\n- ADD（二进制加法）\n\n- IN（输入）\n- OUT（输出）\n- HLT（停机）\n- JMP（转移）\n\n\n\n## 总结\n\n除了上述标记关键的点之外，还有几个地方需要知道：\n\n- 机器周期工作过程：\n\n  单周期包括四个单节拍，单机器指令要执行多个单周期\n\n- 各种信号：见上述标注\n\n> 好了，走神了两节课整理完的机组实验结束了（虽然基本都是复制ppt内容\n>\n> 不过水了一篇推送，很快乐","slug":"计算机组成原理实验","published":1,"updated":"2020-12-30T15:47:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmhg4qt4e000jf5fa4i5gb2ag","content":"<blockquote>\n<p>这学期的计算机组成原理课程终于结束了，明天就要去最后答辩了。大概可能就是要回答一些问题什么的吧，所以今天剩下的时间就用来总结一下这学期学过的比较重要的一些内容。</p>\n</blockquote>\n<h1 id=\"组成原理实验\"><a href=\"#组成原理实验\" class=\"headerlink\" title=\"组成原理实验\"></a>组成原理实验</h1><blockquote>\n<p>由于似乎后半部分是考核的重点，因此主要需要复习的是后半部分知识。</p>\n<p>后半部分包括了六个实验，其中比较重要的是：<strong>微程序控制器实验</strong>和<strong>简单模型机设计实验</strong>。此外，掌握各种信号的作用也是相对比较重要的。</p>\n<p>在本文档中，所有标注**<em>关键**</em> 为必须掌握内容</p>\n</blockquote>\n<h2 id=\"计算机系统认识实验\"><a href=\"#计算机系统认识实验\" class=\"headerlink\" title=\"计算机系统认识实验\"></a>计算机系统认识实验</h2><p>1.后半部分的实验主要建立在<strong>TD-DMA实验箱</strong>基础上；</p>\n<p>2.<strong>（关键）</strong>计算机系统组成的五大部件：</p>\n<p><a href=\"https://imgchr.com/i/rLI8oT\"><img src=\"https://s3.ax1x.com/2020/12/30/rLI8oT.jpg\" alt=\"rLI8oT.jpg\"></a></p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 运算器</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 控制器</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 存储器</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 输入设备</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 输出设备</li>\n</ul>\n<p>3.计算机系统操作过程概括：</p>\n<p>（1）通过<strong>输入设备</strong>接受程序和数据信息，传送到<strong>存储器</strong>；</p>\n<p>（2）通过<strong>控制器</strong>分析存放在存储器中的程序，将其中的数据信息读取到<strong>运算器</strong>进行处理；</p>\n<p>（3）将处理结果送到计算机的<strong>输出设备</strong>或<strong>存储器</strong></p>\n<p>4.冯诺依曼体系：</p>\n<p>（1）指令和数据由<strong>二进制代码</strong>表示，即0和1；</p>\n<p>（2）采用<strong>存储程序</strong>方式，程序存放在连续的存储器地址中；</p>\n<p>（3）以<strong>控制信息流</strong>为驱动，由控制器控制整个程序和数据的存取以及程序的执行；</p>\n<p>（4）以运算器为核心，<strong>数据信息流</strong>被调用处理，所有的数据处理执行都经过运算器；</p>\n<p>（5）通过<strong>程序计数器PC</strong>来存放下一次执行的指令单元地址，顺序加1或跳转</p>\n<h2 id=\"基本运算器实验\"><a href=\"#基本运算器实验\" class=\"headerlink\" title=\"基本运算器实验\"></a>基本运算器实验</h2><p>1.运算器是计算机进行数据处理的核心部件，其核心是<strong>算术逻辑单元（ALU）</strong></p>\n<p>2.运算器组成：</p>\n<ul>\n<li>三个独立的运算部件：算数、逻辑、移位</li>\n<li>暂存器：A和B</li>\n<li>控制信号：S3-S0、CN</li>\n<li>进位标志：FC</li>\n<li>判零标志：FZ</li>\n</ul>\n<p>3.<strong>（关键）</strong>三个信号的作用：</p>\n<p>（1）ALU-B置低电平：运算器单元的运算结果进入总线</p>\n<p>（2）IN-B置低电平：输入单元的数据进入总线</p>\n<p>（3）LDA/LDB置高电平：两个暂存器可以接受数据</p>\n<p>4.运算器的控制信号作用（可以控制运算）：</p>\n<p><a href=\"https://imgchr.com/i/rLIRld\"><img src=\"https://s3.ax1x.com/2020/12/30/rLIRld.jpg\" alt=\"rLIRld.jpg\"></a></p>\n<h2 id=\"静态随机存储器实验\"><a href=\"#静态随机存储器实验\" class=\"headerlink\" title=\"静态随机存储器实验\"></a>静态随机存储器实验</h2><p>1.基本存储单元：</p>\n<p>（1）能够存储一位二进制信息；</p>\n<p>（2）是一个可控制的双稳态二进制触发器；</p>\n<p>（3）选择信号、读写信号、数据信号</p>\n<p>2.<strong>（关键）</strong>几个控制信号的作用（前三个信号在总线那一节还会讲到）：</p>\n<p>（1）IOM：决定对I/0设备还是对存储器进行读写操作，置低电平代表对存储器进行读写操作；</p>\n<p>（2）WR：置高电平进行写操作；</p>\n<p>（3）RD：置高电平进行读操作；</p>\n<p>（4）LDAR置高电平：对地址存储器AR写数据；</p>\n<p>（5）IOR：置低电平代表从输入单元获取数据</p>\n<h2 id=\"微程序控制器实验\"><a href=\"#微程序控制器实验\" class=\"headerlink\" title=\"微程序控制器实验\"></a>微程序控制器实验</h2><p>1.微程序控制器的基本任务：</p>\n<p>（1）完成当前指令的翻译和执行；</p>\n<p>（2）将当前指令的功能转换为可控制的硬件逻辑部件工作</p>\n<p>2.<strong>（关键）</strong>重要概念：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>定义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>微命令（微信号）</td>\n<td>直接作用于控制电路的控制命令</td>\n</tr>\n<tr>\n<td>微操作</td>\n<td>由微命令控制实现的最基本操作：<br />取指令地址、读指令、译码、取操作数地址、取操作数、运算、写回结果等都是微操作</td>\n</tr>\n<tr>\n<td>微指令</td>\n<td>1.一个微周期所需的微命令集，用二进制编码表示；<br />2.同时发出的控制信号所执行的一组微操作<br />一个典型的加法指令的执行可分为：取指令、计算地址、取操作数和加法运算四步，每一步都由一组微操作实现</td>\n</tr>\n<tr>\n<td>微周期</td>\n<td>读取一条微指令并完成相应微操作所用时间，通常为一个机器周期</td>\n</tr>\n<tr>\n<td>微程序</td>\n<td>1.若干条微指令的有序序列；<br />2.每条机器指令对应一段微程序</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>一段程序由一系列机器指令组成</p>\n<p>比如：in、add、out、jump……</p>\n</li>\n<li><p>每一条机器指令由一段微程序实现</p>\n</li>\n<li><p>每一段微程序由一组微指令表示</p>\n</li>\n<li><p>每一条微指令由一组微操作实现</p>\n</li>\n<li><p>一个微操作对应一条微命令</p>\n</li>\n</ul>\n<p>3.<strong>（关键）</strong>微程序控制器组成：</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 控制存储器CM：<ul>\n<li>用于存放微程序</li>\n<li>每个单元存放一条微指令代码，只读</li>\n</ul>\n</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 微指令寄存器uIR：<ul>\n<li>用于存放正在指令的微指令</li>\n<li>包括微命令控制字段和顺序控制字段两部分</li>\n</ul>\n</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 微地址寄存器uAR：<ul>\n<li>用于保存下一条微指令的地址</li>\n</ul>\n</li>\n</ul>\n<p>4.<strong>（关键）</strong>微指令格式：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>23</strong></th>\n<th><strong>22</strong></th>\n<th align=\"center\"><strong>21</strong></th>\n<th align=\"center\"><strong>20</strong></th>\n<th align=\"center\"><strong>19</strong></th>\n<th align=\"center\"><strong>18 - 15</strong></th>\n<th align=\"center\">14-12</th>\n<th align=\"center\">11-9</th>\n<th align=\"center\">8-6</th>\n<th align=\"center\"><strong>5 – 0</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"></td>\n<td></td>\n<td align=\"center\">WR</td>\n<td align=\"center\">RD</td>\n<td align=\"center\">IOMS</td>\n<td align=\"center\">S3-S0</td>\n<td align=\"center\">A</td>\n<td align=\"center\">B</td>\n<td align=\"center\">C</td>\n<td align=\"center\">uA5-uA0</td>\n</tr>\n</tbody></table>\n<ul>\n<li>24位字长</li>\n<li>uA5-uA0是6位<strong>后续微地址</strong></li>\n<li>A、B、C是三个译码字段</li>\n</ul>\n<p>3.三个字段和二进制微代码表（了解即可）：</p>\n<p><a href=\"https://imgchr.com/i/rL7z7t\"><img src=\"https://s3.ax1x.com/2020/12/30/rL7z7t.jpg\" alt=\"rL7z7t.jpg\"></a></p>\n<p><a href=\"https://imgchr.com/i/rLHF1g\"><img src=\"https://s3.ax1x.com/2020/12/30/rLHF1g.jpg\" alt=\"rLHF1g.jpg\"></a></p>\n<p>4.<strong>（关键）</strong>微程序流程图：</p>\n<p><a href=\"https://imgchr.com/i/rLHUN6\"><img src=\"https://s3.ax1x.com/2020/12/30/rLHUN6.jpg\" alt=\"rLHUN6.jpg\"></a></p>\n<p>本实验中有四条机器指令：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">指令名</th>\n<th align=\"center\">二进制代码</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">ADD</td>\n<td align=\"center\">0000 0000</td>\n</tr>\n<tr>\n<td align=\"center\">IN</td>\n<td align=\"center\">0010 0000</td>\n</tr>\n<tr>\n<td align=\"center\">OUT</td>\n<td align=\"center\">0011 0000</td>\n</tr>\n<tr>\n<td align=\"center\">HLT</td>\n<td align=\"center\">0101 0000</td>\n</tr>\n</tbody></table>\n<p>四条机器指令高四位在P&lt;1&gt;处与30进行运算，决定了后续执行哪条分支。</p>\n<p>5.<strong>（关键）</strong>微程序控制器工作过程：</p>\n<ul>\n<li>机器周期开始，执行<strong>公共取指</strong>操作</li>\n<li>读机器指令，送入<strong>指令译码器</strong>（同时修改PC）</li>\n<li>进行<strong>指令译码</strong>，取出操作码产生对应的<strong>微程序入口地址</strong>，送入微地址寄存器</li>\n<li>取出对应的一条微指令，送入<strong>微指令寄存器</strong></li>\n<li>微指令操作字段经译码产生<strong>一组微命令</strong>，送入相应的执行部件</li>\n<li>在<strong>时序控制</strong>下完成微操作（T2/T4）</li>\n<li>产生<strong>后续微地址</strong>，读取下一条微指令</li>\n<li>执行完一段微程序后，开始新的机器周期</li>\n</ul>\n<h2 id=\"总线基本实验\"><a href=\"#总线基本实验\" class=\"headerlink\" title=\"总线基本实验\"></a>总线基本实验</h2><p>1.总线是计算机各部件之间进行数据传输的公共通路，是一组导线和相关的控制、驱动电路的集合</p>\n<ul>\n<li>数据总线</li>\n<li>地址总线</li>\n<li>控制总线</li>\n</ul>\n<p>2.<strong>（关键）</strong>关于WR、RD、IOM控制信号：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>WR</strong></th>\n<th align=\"center\"><strong>RD</strong></th>\n<th align=\"center\"><strong>IOM</strong></th>\n<th align=\"center\"><strong>功能</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">读存储器</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">写存储器</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">读I/O</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">写I/O</td>\n</tr>\n</tbody></table>\n<p>3.关于R0-B、LDR0、LDAR控制信号：</p>\n<ul>\n<li><p>R0-B</p>\n<ul>\n<li>置1时，R0寄存器输出关闭</li>\n<li>置0时，R0寄存器输出打开</li>\n</ul>\n</li>\n<li><p>LDR0</p>\n<ul>\n<li><p>置1时，R0寄存器输入打开</p>\n</li>\n<li><p>置0时，R0寄存器输入关闭</p>\n</li>\n</ul>\n</li>\n<li><p>LDAR</p>\n<ul>\n<li><p>置1时，允许访问地址寄存器</p>\n</li>\n<li><p>置0时，不允许访问地址寄存器</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"（关键）简单模型机设计实验\"><a href=\"#（关键）简单模型机设计实验\" class=\"headerlink\" title=\"（关键）简单模型机设计实验\"></a>（关键）简单模型机设计实验</h2><p>1.<strong>（关键）</strong>CPU的组成</p>\n<p><a href=\"https://imgchr.com/i/rLX8Ts\"><img src=\"https://s3.ax1x.com/2020/12/30/rLX8Ts.jpg\" alt=\"rLX8Ts.jpg\"></a></p>\n<ul>\n<li>运算器<ul>\n<li>ALU：完成数据计算或处理</li>\n<li>暂存器A、B</li>\n</ul>\n</li>\n<li>控制器MC：控制数据和指令的进出</li>\n<li>寄存器：用于暂存数据或指令<ul>\n<li>通用寄存器R0</li>\n<li>指令寄存器IR</li>\n<li>地址寄存器AR</li>\n<li>程序计数器PC</li>\n</ul>\n</li>\n</ul>\n<p>2.CPU基本功能：读取并执行指令</p>\n<p>3.CPU要完成的工作：</p>\n<ul>\n<li>取指令：读主存，装入寄存器</li>\n<li>分析指令：指令译码，决定动作</li>\n<li>取指令：从主存或I/O读取操作数</li>\n<li>处理数据：对操作数进行算术或逻辑运算<ul>\n<li>写数据：将执行结果写到主存或I/O</li>\n</ul>\n</li>\n</ul>\n<p>4.**(关键)**微指令执行：</p>\n<p><a href=\"https://imgchr.com/i/rLjAjU\"><img src=\"https://s3.ax1x.com/2020/12/30/rLjAjU.jpg\" alt=\"rLjAjU.jpg\"></a></p>\n<p>（1）采用P(1)测试字，测试条件是指令寄存器高六位 IR7~IR2；</p>\n<p>（2）五条机器指令：</p>\n<ul>\n<li><p>ADD（二进制加法）</p>\n</li>\n<li><p>IN（输入）</p>\n</li>\n<li><p>OUT（输出）</p>\n</li>\n<li><p>HLT（停机）</p>\n</li>\n<li><p>JMP（转移）</p>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>除了上述标记关键的点之外，还有几个地方需要知道：</p>\n<ul>\n<li><p>机器周期工作过程：</p>\n<p>单周期包括四个单节拍，单机器指令要执行多个单周期</p>\n</li>\n<li><p>各种信号：见上述标注</p>\n</li>\n</ul>\n<blockquote>\n<p>好了，走神了两节课整理完的机组实验结束了（虽然基本都是复制ppt内容</p>\n<p>不过水了一篇推送，很快乐</p>\n</blockquote>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<blockquote>\n<p>这学期的计算机组成原理课程终于结束了，明天就要去最后答辩了。大概可能就是要回答一些问题什么的吧，所以今天剩下的时间就用来总结一下这学期学过的比较重要的一些内容。</p>\n</blockquote>\n<h1 id=\"组成原理实验\"><a href=\"#组成原理实验\" class=\"headerlink\" title=\"组成原理实验\"></a>组成原理实验</h1><blockquote>\n<p>由于似乎后半部分是考核的重点，因此主要需要复习的是后半部分知识。</p>\n<p>后半部分包括了六个实验，其中比较重要的是：<strong>微程序控制器实验</strong>和<strong>简单模型机设计实验</strong>。此外，掌握各种信号的作用也是相对比较重要的。</p>\n<p>在本文档中，所有标注**<em>关键**</em> 为必须掌握内容</p>\n</blockquote>\n<h2 id=\"计算机系统认识实验\"><a href=\"#计算机系统认识实验\" class=\"headerlink\" title=\"计算机系统认识实验\"></a>计算机系统认识实验</h2><p>1.后半部分的实验主要建立在<strong>TD-DMA实验箱</strong>基础上；</p>\n<p>2.<strong>（关键）</strong>计算机系统组成的五大部件：</p>\n<p><a href=\"https://imgchr.com/i/rLI8oT\"><img src=\"https://s3.ax1x.com/2020/12/30/rLI8oT.jpg\" alt=\"rLI8oT.jpg\"></a></p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 运算器</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 控制器</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 存储器</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 输入设备</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 输出设备</li>\n</ul>\n<p>3.计算机系统操作过程概括：</p>\n<p>（1）通过<strong>输入设备</strong>接受程序和数据信息，传送到<strong>存储器</strong>；</p>\n<p>（2）通过<strong>控制器</strong>分析存放在存储器中的程序，将其中的数据信息读取到<strong>运算器</strong>进行处理；</p>\n<p>（3）将处理结果送到计算机的<strong>输出设备</strong>或<strong>存储器</strong></p>\n<p>4.冯诺依曼体系：</p>\n<p>（1）指令和数据由<strong>二进制代码</strong>表示，即0和1；</p>\n<p>（2）采用<strong>存储程序</strong>方式，程序存放在连续的存储器地址中；</p>\n<p>（3）以<strong>控制信息流</strong>为驱动，由控制器控制整个程序和数据的存取以及程序的执行；</p>\n<p>（4）以运算器为核心，<strong>数据信息流</strong>被调用处理，所有的数据处理执行都经过运算器；</p>\n<p>（5）通过<strong>程序计数器PC</strong>来存放下一次执行的指令单元地址，顺序加1或跳转</p>\n<h2 id=\"基本运算器实验\"><a href=\"#基本运算器实验\" class=\"headerlink\" title=\"基本运算器实验\"></a>基本运算器实验</h2><p>1.运算器是计算机进行数据处理的核心部件，其核心是<strong>算术逻辑单元（ALU）</strong></p>\n<p>2.运算器组成：</p>\n<ul>\n<li>三个独立的运算部件：算数、逻辑、移位</li>\n<li>暂存器：A和B</li>\n<li>控制信号：S3-S0、CN</li>\n<li>进位标志：FC</li>\n<li>判零标志：FZ</li>\n</ul>\n<p>3.<strong>（关键）</strong>三个信号的作用：</p>\n<p>（1）ALU-B置低电平：运算器单元的运算结果进入总线</p>\n<p>（2）IN-B置低电平：输入单元的数据进入总线</p>\n<p>（3）LDA/LDB置高电平：两个暂存器可以接受数据</p>\n<p>4.运算器的控制信号作用（可以控制运算）：</p>\n<p><a href=\"https://imgchr.com/i/rLIRld\"><img src=\"https://s3.ax1x.com/2020/12/30/rLIRld.jpg\" alt=\"rLIRld.jpg\"></a></p>\n<h2 id=\"静态随机存储器实验\"><a href=\"#静态随机存储器实验\" class=\"headerlink\" title=\"静态随机存储器实验\"></a>静态随机存储器实验</h2><p>1.基本存储单元：</p>\n<p>（1）能够存储一位二进制信息；</p>\n<p>（2）是一个可控制的双稳态二进制触发器；</p>\n<p>（3）选择信号、读写信号、数据信号</p>\n<p>2.<strong>（关键）</strong>几个控制信号的作用（前三个信号在总线那一节还会讲到）：</p>\n<p>（1）IOM：决定对I/0设备还是对存储器进行读写操作，置低电平代表对存储器进行读写操作；</p>\n<p>（2）WR：置高电平进行写操作；</p>\n<p>（3）RD：置高电平进行读操作；</p>\n<p>（4）LDAR置高电平：对地址存储器AR写数据；</p>\n<p>（5）IOR：置低电平代表从输入单元获取数据</p>\n<h2 id=\"微程序控制器实验\"><a href=\"#微程序控制器实验\" class=\"headerlink\" title=\"微程序控制器实验\"></a>微程序控制器实验</h2><p>1.微程序控制器的基本任务：</p>\n<p>（1）完成当前指令的翻译和执行；</p>\n<p>（2）将当前指令的功能转换为可控制的硬件逻辑部件工作</p>\n<p>2.<strong>（关键）</strong>重要概念：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>定义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>微命令（微信号）</td>\n<td>直接作用于控制电路的控制命令</td>\n</tr>\n<tr>\n<td>微操作</td>\n<td>由微命令控制实现的最基本操作：<br />取指令地址、读指令、译码、取操作数地址、取操作数、运算、写回结果等都是微操作</td>\n</tr>\n<tr>\n<td>微指令</td>\n<td>1.一个微周期所需的微命令集，用二进制编码表示；<br />2.同时发出的控制信号所执行的一组微操作<br />一个典型的加法指令的执行可分为：取指令、计算地址、取操作数和加法运算四步，每一步都由一组微操作实现</td>\n</tr>\n<tr>\n<td>微周期</td>\n<td>读取一条微指令并完成相应微操作所用时间，通常为一个机器周期</td>\n</tr>\n<tr>\n<td>微程序</td>\n<td>1.若干条微指令的有序序列；<br />2.每条机器指令对应一段微程序</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>一段程序由一系列机器指令组成</p>\n<p>比如：in、add、out、jump……</p>\n</li>\n<li><p>每一条机器指令由一段微程序实现</p>\n</li>\n<li><p>每一段微程序由一组微指令表示</p>\n</li>\n<li><p>每一条微指令由一组微操作实现</p>\n</li>\n<li><p>一个微操作对应一条微命令</p>\n</li>\n</ul>\n<p>3.<strong>（关键）</strong>微程序控制器组成：</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 控制存储器CM：<ul>\n<li>用于存放微程序</li>\n<li>每个单元存放一条微指令代码，只读</li>\n</ul>\n</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 微指令寄存器uIR：<ul>\n<li>用于存放正在指令的微指令</li>\n<li>包括微命令控制字段和顺序控制字段两部分</li>\n</ul>\n</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 微地址寄存器uAR：<ul>\n<li>用于保存下一条微指令的地址</li>\n</ul>\n</li>\n</ul>\n<p>4.<strong>（关键）</strong>微指令格式：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>23</strong></th>\n<th><strong>22</strong></th>\n<th align=\"center\"><strong>21</strong></th>\n<th align=\"center\"><strong>20</strong></th>\n<th align=\"center\"><strong>19</strong></th>\n<th align=\"center\"><strong>18 - 15</strong></th>\n<th align=\"center\">14-12</th>\n<th align=\"center\">11-9</th>\n<th align=\"center\">8-6</th>\n<th align=\"center\"><strong>5 – 0</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"></td>\n<td></td>\n<td align=\"center\">WR</td>\n<td align=\"center\">RD</td>\n<td align=\"center\">IOMS</td>\n<td align=\"center\">S3-S0</td>\n<td align=\"center\">A</td>\n<td align=\"center\">B</td>\n<td align=\"center\">C</td>\n<td align=\"center\">uA5-uA0</td>\n</tr>\n</tbody></table>\n<ul>\n<li>24位字长</li>\n<li>uA5-uA0是6位<strong>后续微地址</strong></li>\n<li>A、B、C是三个译码字段</li>\n</ul>\n<p>3.三个字段和二进制微代码表（了解即可）：</p>\n<p><a href=\"https://imgchr.com/i/rL7z7t\"><img src=\"https://s3.ax1x.com/2020/12/30/rL7z7t.jpg\" alt=\"rL7z7t.jpg\"></a></p>\n<p><a href=\"https://imgchr.com/i/rLHF1g\"><img src=\"https://s3.ax1x.com/2020/12/30/rLHF1g.jpg\" alt=\"rLHF1g.jpg\"></a></p>\n<p>4.<strong>（关键）</strong>微程序流程图：</p>\n<p><a href=\"https://imgchr.com/i/rLHUN6\"><img src=\"https://s3.ax1x.com/2020/12/30/rLHUN6.jpg\" alt=\"rLHUN6.jpg\"></a></p>\n<p>本实验中有四条机器指令：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">指令名</th>\n<th align=\"center\">二进制代码</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">ADD</td>\n<td align=\"center\">0000 0000</td>\n</tr>\n<tr>\n<td align=\"center\">IN</td>\n<td align=\"center\">0010 0000</td>\n</tr>\n<tr>\n<td align=\"center\">OUT</td>\n<td align=\"center\">0011 0000</td>\n</tr>\n<tr>\n<td align=\"center\">HLT</td>\n<td align=\"center\">0101 0000</td>\n</tr>\n</tbody></table>\n<p>四条机器指令高四位在P&lt;1&gt;处与30进行运算，决定了后续执行哪条分支。</p>\n<p>5.<strong>（关键）</strong>微程序控制器工作过程：</p>\n<ul>\n<li>机器周期开始，执行<strong>公共取指</strong>操作</li>\n<li>读机器指令，送入<strong>指令译码器</strong>（同时修改PC）</li>\n<li>进行<strong>指令译码</strong>，取出操作码产生对应的<strong>微程序入口地址</strong>，送入微地址寄存器</li>\n<li>取出对应的一条微指令，送入<strong>微指令寄存器</strong></li>\n<li>微指令操作字段经译码产生<strong>一组微命令</strong>，送入相应的执行部件</li>\n<li>在<strong>时序控制</strong>下完成微操作（T2/T4）</li>\n<li>产生<strong>后续微地址</strong>，读取下一条微指令</li>\n<li>执行完一段微程序后，开始新的机器周期</li>\n</ul>\n<h2 id=\"总线基本实验\"><a href=\"#总线基本实验\" class=\"headerlink\" title=\"总线基本实验\"></a>总线基本实验</h2><p>1.总线是计算机各部件之间进行数据传输的公共通路，是一组导线和相关的控制、驱动电路的集合</p>\n<ul>\n<li>数据总线</li>\n<li>地址总线</li>\n<li>控制总线</li>\n</ul>\n<p>2.<strong>（关键）</strong>关于WR、RD、IOM控制信号：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>WR</strong></th>\n<th align=\"center\"><strong>RD</strong></th>\n<th align=\"center\"><strong>IOM</strong></th>\n<th align=\"center\"><strong>功能</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">读存储器</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">写存储器</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">读I/O</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">写I/O</td>\n</tr>\n</tbody></table>\n<p>3.关于R0-B、LDR0、LDAR控制信号：</p>\n<ul>\n<li><p>R0-B</p>\n<ul>\n<li>置1时，R0寄存器输出关闭</li>\n<li>置0时，R0寄存器输出打开</li>\n</ul>\n</li>\n<li><p>LDR0</p>\n<ul>\n<li><p>置1时，R0寄存器输入打开</p>\n</li>\n<li><p>置0时，R0寄存器输入关闭</p>\n</li>\n</ul>\n</li>\n<li><p>LDAR</p>\n<ul>\n<li><p>置1时，允许访问地址寄存器</p>\n</li>\n<li><p>置0时，不允许访问地址寄存器</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"（关键）简单模型机设计实验\"><a href=\"#（关键）简单模型机设计实验\" class=\"headerlink\" title=\"（关键）简单模型机设计实验\"></a>（关键）简单模型机设计实验</h2><p>1.<strong>（关键）</strong>CPU的组成</p>\n<p><a href=\"https://imgchr.com/i/rLX8Ts\"><img src=\"https://s3.ax1x.com/2020/12/30/rLX8Ts.jpg\" alt=\"rLX8Ts.jpg\"></a></p>\n<ul>\n<li>运算器<ul>\n<li>ALU：完成数据计算或处理</li>\n<li>暂存器A、B</li>\n</ul>\n</li>\n<li>控制器MC：控制数据和指令的进出</li>\n<li>寄存器：用于暂存数据或指令<ul>\n<li>通用寄存器R0</li>\n<li>指令寄存器IR</li>\n<li>地址寄存器AR</li>\n<li>程序计数器PC</li>\n</ul>\n</li>\n</ul>\n<p>2.CPU基本功能：读取并执行指令</p>\n<p>3.CPU要完成的工作：</p>\n<ul>\n<li>取指令：读主存，装入寄存器</li>\n<li>分析指令：指令译码，决定动作</li>\n<li>取指令：从主存或I/O读取操作数</li>\n<li>处理数据：对操作数进行算术或逻辑运算<ul>\n<li>写数据：将执行结果写到主存或I/O</li>\n</ul>\n</li>\n</ul>\n<p>4.**(关键)**微指令执行：</p>\n<p><a href=\"https://imgchr.com/i/rLjAjU\"><img src=\"https://s3.ax1x.com/2020/12/30/rLjAjU.jpg\" alt=\"rLjAjU.jpg\"></a></p>\n<p>（1）采用P(1)测试字，测试条件是指令寄存器高六位 IR7~IR2；</p>\n<p>（2）五条机器指令：</p>\n<ul>\n<li><p>ADD（二进制加法）</p>\n</li>\n<li><p>IN（输入）</p>\n</li>\n<li><p>OUT（输出）</p>\n</li>\n<li><p>HLT（停机）</p>\n</li>\n<li><p>JMP（转移）</p>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>除了上述标记关键的点之外，还有几个地方需要知道：</p>\n<ul>\n<li><p>机器周期工作过程：</p>\n<p>单周期包括四个单节拍，单机器指令要执行多个单周期</p>\n</li>\n<li><p>各种信号：见上述标注</p>\n</li>\n</ul>\n<blockquote>\n<p>好了，走神了两节课整理完的机组实验结束了（虽然基本都是复制ppt内容</p>\n<p>不过水了一篇推送，很快乐</p>\n</blockquote>\n"},{"title":"贪心算法--加油站问题","date":"2024-09-08T04:59:43.000Z","_content":"\n\n\n## 问题\n\n有一条环形道路，沿着这条道路分布着 n 个加油站。每个加油站 i 提供的汽油量为 gas_i ，从加油站 i 到加油站 i+1 需要消耗的汽油量为 cost_i 。现在你要从某一个加油站出发，沿顺时针方向开车，绕着整个环形道路行驶一圈并返回到起点。你起步时油箱是空的。\n\n你需要找到一个起点加油站，使得从该加油站出发，经过每个加油站时，汽油量始终不小于0，并能顺利返回出发点。\n\n如果存在这样的起点，加油站编号是唯一的。如果不存在这样的起点，则说明无论从哪个加油站出发，都无法完成一圈。\n\n\n\n## 示例\n\n输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]\n\n输出: 3\n\n解释:\n\n从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油\n\n开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油\n\n开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油\n\n开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油\n\n开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油\n\n开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。\n\n因此，3 可为出发点。\n\n\n\n## 解答\n\n贪心算法\n\n如果i开不到j，那么从i里面的任何一个作为起点都开不到j\n\n所以下一次直接从j+1开始判断就行了\n","source":"_posts/贪心算法-加油站问题.md","raw":"---\ntitle: 贪心算法--加油站问题\ndate: 2024-09-08 12:59:43\ntags:\n---\n\n\n\n## 问题\n\n有一条环形道路，沿着这条道路分布着 n 个加油站。每个加油站 i 提供的汽油量为 gas_i ，从加油站 i 到加油站 i+1 需要消耗的汽油量为 cost_i 。现在你要从某一个加油站出发，沿顺时针方向开车，绕着整个环形道路行驶一圈并返回到起点。你起步时油箱是空的。\n\n你需要找到一个起点加油站，使得从该加油站出发，经过每个加油站时，汽油量始终不小于0，并能顺利返回出发点。\n\n如果存在这样的起点，加油站编号是唯一的。如果不存在这样的起点，则说明无论从哪个加油站出发，都无法完成一圈。\n\n\n\n## 示例\n\n输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]\n\n输出: 3\n\n解释:\n\n从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油\n\n开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油\n\n开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油\n\n开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油\n\n开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油\n\n开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。\n\n因此，3 可为出发点。\n\n\n\n## 解答\n\n贪心算法\n\n如果i开不到j，那么从i里面的任何一个作为起点都开不到j\n\n所以下一次直接从j+1开始判断就行了\n","slug":"贪心算法-加油站问题","published":1,"updated":"2024-10-02T05:25:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmhg4qt4e000kf5fa4pqcd6po","content":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>有一条环形道路，沿着这条道路分布着 n 个加油站。每个加油站 i 提供的汽油量为 gas_i ，从加油站 i 到加油站 i+1 需要消耗的汽油量为 cost_i 。现在你要从某一个加油站出发，沿顺时针方向开车，绕着整个环形道路行驶一圈并返回到起点。你起步时油箱是空的。</p>\n<p>你需要找到一个起点加油站，使得从该加油站出发，经过每个加油站时，汽油量始终不小于0，并能顺利返回出发点。</p>\n<p>如果存在这样的起点，加油站编号是唯一的。如果不存在这样的起点，则说明无论从哪个加油站出发，都无法完成一圈。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]</p>\n<p>输出: 3</p>\n<p>解释:</p>\n<p>从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油</p>\n<p>开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油</p>\n<p>开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油</p>\n<p>开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油</p>\n<p>开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油</p>\n<p>开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</p>\n<p>因此，3 可为出发点。</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>贪心算法</p>\n<p>如果i开不到j，那么从i里面的任何一个作为起点都开不到j</p>\n<p>所以下一次直接从j+1开始判断就行了</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>有一条环形道路，沿着这条道路分布着 n 个加油站。每个加油站 i 提供的汽油量为 gas_i ，从加油站 i 到加油站 i+1 需要消耗的汽油量为 cost_i 。现在你要从某一个加油站出发，沿顺时针方向开车，绕着整个环形道路行驶一圈并返回到起点。你起步时油箱是空的。</p>\n<p>你需要找到一个起点加油站，使得从该加油站出发，经过每个加油站时，汽油量始终不小于0，并能顺利返回出发点。</p>\n<p>如果存在这样的起点，加油站编号是唯一的。如果不存在这样的起点，则说明无论从哪个加油站出发，都无法完成一圈。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]</p>\n<p>输出: 3</p>\n<p>解释:</p>\n<p>从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油</p>\n<p>开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油</p>\n<p>开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油</p>\n<p>开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油</p>\n<p>开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油</p>\n<p>开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</p>\n<p>因此，3 可为出发点。</p>\n<h2 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h2><p>贪心算法</p>\n<p>如果i开不到j，那么从i里面的任何一个作为起点都开不到j</p>\n<p>所以下一次直接从j+1开始判断就行了</p>\n"},{"title":"需要深入理解的一些算法","date":"2024-01-20T06:51:26.000Z","_content":"\n## 算法\n\nKMP算法：https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string\n","source":"_posts/需要深入理解的一些算法.md","raw":"---\ntitle: 需要深入理解的一些算法\ndate: 2024-01-20 14:51:26\ntags: 算法\n---\n\n## 算法\n\nKMP算法：https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string\n","slug":"需要深入理解的一些算法","published":1,"updated":"2024-01-21T09:12:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmhg4qt4e000lf5fada87eghl","content":"<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><p>KMP算法：<a href=\"https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string\">https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string</a></p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><p>KMP算法：<a href=\"https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string\">https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string</a></p>\n"},{"title":"高等讲堂小技巧","date":"2023-12-28T16:00:00.000Z","cover":"https://s3.ax1x.com/2020/12/29/rbaWHf.jpg","_content":"### code\n\n```javascript\nsetInterval(function() {\n    var video = document.getElementById('example_media_1_html5_api');\n    if (video.paused) {\n        video.play();\n    }\n    console.log('自动续播')\n}, 60000);  // 60000毫秒即1分钟\n\n```\n\n如何让ID为example_media_1_html5_api的视频跳转到1小时57分的时间\n\n```javascript\nvar video = document.getElementById('example_media_1_html5_api');\nvideo.currentTime = 7020;  // 设置视频的当前时间为7020秒\nvideo.play();  // 开始播放\n```\n","source":"_posts/高等讲堂.md","raw":"---\ntitle: 高等讲堂小技巧\ndate: 2023-12-29 00:00:00\ncover: https://s3.ax1x.com/2020/12/29/rbaWHf.jpg\n---\n### code\n\n```javascript\nsetInterval(function() {\n    var video = document.getElementById('example_media_1_html5_api');\n    if (video.paused) {\n        video.play();\n    }\n    console.log('自动续播')\n}, 60000);  // 60000毫秒即1分钟\n\n```\n\n如何让ID为example_media_1_html5_api的视频跳转到1小时57分的时间\n\n```javascript\nvar video = document.getElementById('example_media_1_html5_api');\nvideo.currentTime = 7020;  // 设置视频的当前时间为7020秒\nvideo.play();  // 开始播放\n```\n","slug":"高等讲堂","published":1,"updated":"2024-01-16T05:03:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmhg4qt4f000mf5fa3wpq70bx","content":"<h3 id=\"code\"><a href=\"#code\" class=\"headerlink\" title=\"code\"></a>code</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">setInterval</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> video = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;example_media_1_html5_api&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (video.paused) &#123;</span><br><span class=\"line\">        video.play();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;自动续播&#x27;</span>)</span><br><span class=\"line\">&#125;, <span class=\"number\">60000</span>);  <span class=\"comment\">// 60000毫秒即1分钟</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>如何让ID为example_media_1_html5_api的视频跳转到1小时57分的时间</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> video = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;example_media_1_html5_api&#x27;</span>);</span><br><span class=\"line\">video.currentTime = <span class=\"number\">7020</span>;  <span class=\"comment\">// 设置视频的当前时间为7020秒</span></span><br><span class=\"line\">video.play();  <span class=\"comment\">// 开始播放</span></span><br></pre></td></tr></table></figure>","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<h3 id=\"code\"><a href=\"#code\" class=\"headerlink\" title=\"code\"></a>code</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">setInterval</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> video = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;example_media_1_html5_api&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (video.paused) &#123;</span><br><span class=\"line\">        video.play();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;自动续播&#x27;</span>)</span><br><span class=\"line\">&#125;, <span class=\"number\">60000</span>);  <span class=\"comment\">// 60000毫秒即1分钟</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>如何让ID为example_media_1_html5_api的视频跳转到1小时57分的时间</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> video = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;example_media_1_html5_api&#x27;</span>);</span><br><span class=\"line\">video.currentTime = <span class=\"number\">7020</span>;  <span class=\"comment\">// 设置视频的当前时间为7020秒</span></span><br><span class=\"line\">video.play();  <span class=\"comment\">// 开始播放</span></span><br></pre></td></tr></table></figure>"},{"title":"归海记忆的生日策划案","date":"2025-10-22T16:00:00.000Z","cover":"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/9fda8a9d12b97f3a6930b8d8fe2a41a9-20251029-153318.jpg","_content":"\n# 归海记忆的生日策划案\n\n## 准备\n\n| **项目**              | **需求**                                                     | **负责人**                        |\n| --------------------- | ------------------------------------------------------------ | --------------------------------- |\n| KTV预定及生日蛋糕预定 |                                                              | 待定                              |\n| 生日视频              | 最好是一段视频，前面是祝福语or 抽象的东西；最后是生日歌（到时候直接吃蛋糕了） | Redefinition                      |\n| 横幅+易拉             | 易拉宝：一定要那种看了就让人社死的类型横幅：一段简单有趣的   | Baokker（快递可以直接写到莹莹莹） |\n| 一些简单小游戏        | 寻宝游戏                                                     | 汪汪汪                            |\n\n\n\n## 整体流程\n\n### 下午\n\n下午四道mini解谜游戏\n\n### 晚饭\n\n![ff25eb6f8966f6eea5f5340bc408f461](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/ff25eb6f8966f6eea5f5340bc408f461-20251029-153556.jpg)\n\n吃完饭大家直接撤退（提前去布置一下现场），让归海记忆自己解密寻找到下一个地点\n\n解谜答案：星聚会KTV\n\n### 星聚会KTV\n\n来到星聚会KTV，在展板面前合照唱歌\n\n<img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/4a76407b50666b43c06c3d212cf9b43f-20251029-153611.jpg\" alt=\"4a76407b50666b43c06c3d212cf9b43f\" style=\"zoom:50%;\" />\n\n\n\nKTV过程中，归海记忆的同学莹莹下班，让他过来接她，将人吸引走\n\n吸引走后，趁机将KTV投屏自己剪辑的视频：\n\n- 前半段是正常歌曲MV（让王唱歌）\n- 黑客入侵动画\n- 祝福视频\n- （上生日蛋糕）生日歌\n\n![b8b06c879c600542427951a68218729c](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/b8b06c879c600542427951a68218729c-20251029-153742.jpg)\n","source":"_posts/归海记忆的生日策划案.md","raw":"---\ntitle: 归海记忆的生日策划案\ndate: 2025-10-23 00:00:00\ncover: https://upic-1301780692.cos.ap-shanghai.myqcloud.com/9fda8a9d12b97f3a6930b8d8fe2a41a9-20251029-153318.jpg\ntag: 生日\n---\n\n# 归海记忆的生日策划案\n\n## 准备\n\n| **项目**              | **需求**                                                     | **负责人**                        |\n| --------------------- | ------------------------------------------------------------ | --------------------------------- |\n| KTV预定及生日蛋糕预定 |                                                              | 待定                              |\n| 生日视频              | 最好是一段视频，前面是祝福语or 抽象的东西；最后是生日歌（到时候直接吃蛋糕了） | Redefinition                      |\n| 横幅+易拉             | 易拉宝：一定要那种看了就让人社死的类型横幅：一段简单有趣的   | Baokker（快递可以直接写到莹莹莹） |\n| 一些简单小游戏        | 寻宝游戏                                                     | 汪汪汪                            |\n\n\n\n## 整体流程\n\n### 下午\n\n下午四道mini解谜游戏\n\n### 晚饭\n\n![ff25eb6f8966f6eea5f5340bc408f461](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/ff25eb6f8966f6eea5f5340bc408f461-20251029-153556.jpg)\n\n吃完饭大家直接撤退（提前去布置一下现场），让归海记忆自己解密寻找到下一个地点\n\n解谜答案：星聚会KTV\n\n### 星聚会KTV\n\n来到星聚会KTV，在展板面前合照唱歌\n\n<img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/4a76407b50666b43c06c3d212cf9b43f-20251029-153611.jpg\" alt=\"4a76407b50666b43c06c3d212cf9b43f\" style=\"zoom:50%;\" />\n\n\n\nKTV过程中，归海记忆的同学莹莹下班，让他过来接她，将人吸引走\n\n吸引走后，趁机将KTV投屏自己剪辑的视频：\n\n- 前半段是正常歌曲MV（让王唱歌）\n- 黑客入侵动画\n- 祝福视频\n- （上生日蛋糕）生日歌\n\n![b8b06c879c600542427951a68218729c](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/b8b06c879c600542427951a68218729c-20251029-153742.jpg)\n","slug":"归海记忆的生日策划案","published":1,"updated":"2025-10-31T01:48:40.791Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmhg4qt4f000of5fa1r028cwo","content":"<h1 id=\"归海记忆的生日策划案\"><a href=\"#归海记忆的生日策划案\" class=\"headerlink\" title=\"归海记忆的生日策划案\"></a>归海记忆的生日策划案</h1><h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><table>\n<thead>\n<tr>\n<th><strong>项目</strong></th>\n<th><strong>需求</strong></th>\n<th><strong>负责人</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>KTV预定及生日蛋糕预定</td>\n<td></td>\n<td>待定</td>\n</tr>\n<tr>\n<td>生日视频</td>\n<td>最好是一段视频，前面是祝福语or 抽象的东西；最后是生日歌（到时候直接吃蛋糕了）</td>\n<td>Redefinition</td>\n</tr>\n<tr>\n<td>横幅+易拉</td>\n<td>易拉宝：一定要那种看了就让人社死的类型横幅：一段简单有趣的</td>\n<td>Baokker（快递可以直接写到莹莹莹）</td>\n</tr>\n<tr>\n<td>一些简单小游戏</td>\n<td>寻宝游戏</td>\n<td>汪汪汪</td>\n</tr>\n</tbody></table>\n<h2 id=\"整体流程\"><a href=\"#整体流程\" class=\"headerlink\" title=\"整体流程\"></a>整体流程</h2><h3 id=\"下午\"><a href=\"#下午\" class=\"headerlink\" title=\"下午\"></a>下午</h3><p>下午四道mini解谜游戏</p>\n<h3 id=\"晚饭\"><a href=\"#晚饭\" class=\"headerlink\" title=\"晚饭\"></a>晚饭</h3><p><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/ff25eb6f8966f6eea5f5340bc408f461-20251029-153556.jpg\" alt=\"ff25eb6f8966f6eea5f5340bc408f461\"></p>\n<p>吃完饭大家直接撤退（提前去布置一下现场），让归海记忆自己解密寻找到下一个地点</p>\n<p>解谜答案：星聚会KTV</p>\n<h3 id=\"星聚会KTV\"><a href=\"#星聚会KTV\" class=\"headerlink\" title=\"星聚会KTV\"></a>星聚会KTV</h3><p>来到星聚会KTV，在展板面前合照唱歌</p>\n<img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/4a76407b50666b43c06c3d212cf9b43f-20251029-153611.jpg\" alt=\"4a76407b50666b43c06c3d212cf9b43f\" style=\"zoom:50%;\" />\n\n\n\n<p>KTV过程中，归海记忆的同学莹莹下班，让他过来接她，将人吸引走</p>\n<p>吸引走后，趁机将KTV投屏自己剪辑的视频：</p>\n<ul>\n<li>前半段是正常歌曲MV（让王唱歌）</li>\n<li>黑客入侵动画</li>\n<li>祝福视频</li>\n<li>（上生日蛋糕）生日歌</li>\n</ul>\n<p><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/b8b06c879c600542427951a68218729c-20251029-153742.jpg\" alt=\"b8b06c879c600542427951a68218729c\"></p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<h1 id=\"归海记忆的生日策划案\"><a href=\"#归海记忆的生日策划案\" class=\"headerlink\" title=\"归海记忆的生日策划案\"></a>归海记忆的生日策划案</h1><h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><table>\n<thead>\n<tr>\n<th><strong>项目</strong></th>\n<th><strong>需求</strong></th>\n<th><strong>负责人</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>KTV预定及生日蛋糕预定</td>\n<td></td>\n<td>待定</td>\n</tr>\n<tr>\n<td>生日视频</td>\n<td>最好是一段视频，前面是祝福语or 抽象的东西；最后是生日歌（到时候直接吃蛋糕了）</td>\n<td>Redefinition</td>\n</tr>\n<tr>\n<td>横幅+易拉</td>\n<td>易拉宝：一定要那种看了就让人社死的类型横幅：一段简单有趣的</td>\n<td>Baokker（快递可以直接写到莹莹莹）</td>\n</tr>\n<tr>\n<td>一些简单小游戏</td>\n<td>寻宝游戏</td>\n<td>汪汪汪</td>\n</tr>\n</tbody></table>\n<h2 id=\"整体流程\"><a href=\"#整体流程\" class=\"headerlink\" title=\"整体流程\"></a>整体流程</h2><h3 id=\"下午\"><a href=\"#下午\" class=\"headerlink\" title=\"下午\"></a>下午</h3><p>下午四道mini解谜游戏</p>\n<h3 id=\"晚饭\"><a href=\"#晚饭\" class=\"headerlink\" title=\"晚饭\"></a>晚饭</h3><p><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/ff25eb6f8966f6eea5f5340bc408f461-20251029-153556.jpg\" alt=\"ff25eb6f8966f6eea5f5340bc408f461\"></p>\n<p>吃完饭大家直接撤退（提前去布置一下现场），让归海记忆自己解密寻找到下一个地点</p>\n<p>解谜答案：星聚会KTV</p>\n<h3 id=\"星聚会KTV\"><a href=\"#星聚会KTV\" class=\"headerlink\" title=\"星聚会KTV\"></a>星聚会KTV</h3><p>来到星聚会KTV，在展板面前合照唱歌</p>\n<img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/4a76407b50666b43c06c3d212cf9b43f-20251029-153611.jpg\" alt=\"4a76407b50666b43c06c3d212cf9b43f\" style=\"zoom:50%;\" />\n\n\n\n<p>KTV过程中，归海记忆的同学莹莹下班，让他过来接她，将人吸引走</p>\n<p>吸引走后，趁机将KTV投屏自己剪辑的视频：</p>\n<ul>\n<li>前半段是正常歌曲MV（让王唱歌）</li>\n<li>黑客入侵动画</li>\n<li>祝福视频</li>\n<li>（上生日蛋糕）生日歌</li>\n</ul>\n<p><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/b8b06c879c600542427951a68218729c-20251029-153742.jpg\" alt=\"b8b06c879c600542427951a68218729c\"></p>\n"},{"title":"暑期实习-字节面试","date":"2025-10-30T16:12:00.000Z","cover":"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20251031102636698-20251031-102637.png","_content":"\n# 暑期实习-字节面试\n\n> 节子暑期实习面试了两次，基本都挂掉了\n> 原因是因为面的太早了（1月份），准备还不是很充分。建议大家面试前一定要好好修改自己的简历，至少对简历上相关问题聊熟于心\n\n## 字节第一次面试\n1. 项目中的分库分表？（不对，需要纠正）\n2. sa-token中，token存的是什么，如何根据token找到是谁的（回答的不好）\n3. 项目中的redisson如何做到的过期检测（回答的不好）\n\nhttps://javaguide.cn/database/redis/redis-delayed-task.html#redisson-%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF\n\n4. redisson过期订单的key-value存的是什么（回答的不好）\n5. 对称加密和非对称加密\n6. 分布式锁（用redis）；但是超时或者崩溃了，如何处理；如果超时释放了之后别人去用了，但是自己又去把别人在用的锁释放了怎么办（场景引导，不太熟悉）\n7. java中保证线程安全的机制\n8. git中，fetch和pull的区别\n9. git中，rebase的作用（回答的不好）\n\nhttps://blog.csdn.net/weixin_43717839/article/details/143222436\n\n（算法）打家劫舍2\n\n\n## 字节第二次面试\n- （怪问题）为什么在蔚来实习的时候，还投了字节？\n- 在蔚来实习的时候到底做的是什么工作？\n- 统计大文件单词数量用什么数据结构？（哈希表？）如果想要降低空间复杂度呢？（没太回答好）\n- 你们的归宿系统怎么登陆的？分了几个微服务？\n- RBAC和ABAC有什么区别？哪一个更复杂？（不太熟悉）\n- 你们的归宿系统中设置登录过期机制了吗？如果快过期了应该怎么处理更好？\n- 如果redis中有一个value特别大的kv对会产生什么负面影响？\n- mysql的联合索引中，B+树的叶子节点存储的是什么？B+树有什么特点？\n- 限流和熔断的区别？\n- 归宿系统ui图是谁画的，谁写的设计稿，多少用户量，老师验收了吗，谁负责的答辩？\n- 高考是哪个省的\n- （算法）反转链表\n","source":"_posts/2025/暑期实习-字节面试.md","raw":"---\ntitle: 暑期实习-字节面试\ndate: 2025-10-31 00:12:00\ncover: https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20251031102636698-20251031-102637.png\ntag: 暑期实习\n---\n\n# 暑期实习-字节面试\n\n> 节子暑期实习面试了两次，基本都挂掉了\n> 原因是因为面的太早了（1月份），准备还不是很充分。建议大家面试前一定要好好修改自己的简历，至少对简历上相关问题聊熟于心\n\n## 字节第一次面试\n1. 项目中的分库分表？（不对，需要纠正）\n2. sa-token中，token存的是什么，如何根据token找到是谁的（回答的不好）\n3. 项目中的redisson如何做到的过期检测（回答的不好）\n\nhttps://javaguide.cn/database/redis/redis-delayed-task.html#redisson-%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF\n\n4. redisson过期订单的key-value存的是什么（回答的不好）\n5. 对称加密和非对称加密\n6. 分布式锁（用redis）；但是超时或者崩溃了，如何处理；如果超时释放了之后别人去用了，但是自己又去把别人在用的锁释放了怎么办（场景引导，不太熟悉）\n7. java中保证线程安全的机制\n8. git中，fetch和pull的区别\n9. git中，rebase的作用（回答的不好）\n\nhttps://blog.csdn.net/weixin_43717839/article/details/143222436\n\n（算法）打家劫舍2\n\n\n## 字节第二次面试\n- （怪问题）为什么在蔚来实习的时候，还投了字节？\n- 在蔚来实习的时候到底做的是什么工作？\n- 统计大文件单词数量用什么数据结构？（哈希表？）如果想要降低空间复杂度呢？（没太回答好）\n- 你们的归宿系统怎么登陆的？分了几个微服务？\n- RBAC和ABAC有什么区别？哪一个更复杂？（不太熟悉）\n- 你们的归宿系统中设置登录过期机制了吗？如果快过期了应该怎么处理更好？\n- 如果redis中有一个value特别大的kv对会产生什么负面影响？\n- mysql的联合索引中，B+树的叶子节点存储的是什么？B+树有什么特点？\n- 限流和熔断的区别？\n- 归宿系统ui图是谁画的，谁写的设计稿，多少用户量，老师验收了吗，谁负责的答辩？\n- 高考是哪个省的\n- （算法）反转链表\n","slug":"2025/暑期实习-字节面试","published":1,"updated":"2025-10-31T02:26:51.491Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmhg4qt4f000pf5fa1kzmevu7","content":"<h1 id=\"暑期实习-字节面试\"><a href=\"#暑期实习-字节面试\" class=\"headerlink\" title=\"暑期实习-字节面试\"></a>暑期实习-字节面试</h1><blockquote>\n<p>节子暑期实习面试了两次，基本都挂掉了<br>原因是因为面的太早了（1月份），准备还不是很充分。建议大家面试前一定要好好修改自己的简历，至少对简历上相关问题聊熟于心</p>\n</blockquote>\n<h2 id=\"字节第一次面试\"><a href=\"#字节第一次面试\" class=\"headerlink\" title=\"字节第一次面试\"></a>字节第一次面试</h2><ol>\n<li>项目中的分库分表？（不对，需要纠正）</li>\n<li>sa-token中，token存的是什么，如何根据token找到是谁的（回答的不好）</li>\n<li>项目中的redisson如何做到的过期检测（回答的不好）</li>\n</ol>\n<p><a href=\"https://javaguide.cn/database/redis/redis-delayed-task.html#redisson-%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF\">https://javaguide.cn/database/redis/redis-delayed-task.html#redisson-%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF</a></p>\n<ol start=\"4\">\n<li>redisson过期订单的key-value存的是什么（回答的不好）</li>\n<li>对称加密和非对称加密</li>\n<li>分布式锁（用redis）；但是超时或者崩溃了，如何处理；如果超时释放了之后别人去用了，但是自己又去把别人在用的锁释放了怎么办（场景引导，不太熟悉）</li>\n<li>java中保证线程安全的机制</li>\n<li>git中，fetch和pull的区别</li>\n<li>git中，rebase的作用（回答的不好）</li>\n</ol>\n<p><a href=\"https://blog.csdn.net/weixin_43717839/article/details/143222436\">https://blog.csdn.net/weixin_43717839/article/details/143222436</a></p>\n<p>（算法）打家劫舍2</p>\n<h2 id=\"字节第二次面试\"><a href=\"#字节第二次面试\" class=\"headerlink\" title=\"字节第二次面试\"></a>字节第二次面试</h2><ul>\n<li>（怪问题）为什么在蔚来实习的时候，还投了字节？</li>\n<li>在蔚来实习的时候到底做的是什么工作？</li>\n<li>统计大文件单词数量用什么数据结构？（哈希表？）如果想要降低空间复杂度呢？（没太回答好）</li>\n<li>你们的归宿系统怎么登陆的？分了几个微服务？</li>\n<li>RBAC和ABAC有什么区别？哪一个更复杂？（不太熟悉）</li>\n<li>你们的归宿系统中设置登录过期机制了吗？如果快过期了应该怎么处理更好？</li>\n<li>如果redis中有一个value特别大的kv对会产生什么负面影响？</li>\n<li>mysql的联合索引中，B+树的叶子节点存储的是什么？B+树有什么特点？</li>\n<li>限流和熔断的区别？</li>\n<li>归宿系统ui图是谁画的，谁写的设计稿，多少用户量，老师验收了吗，谁负责的答辩？</li>\n<li>高考是哪个省的</li>\n<li>（算法）反转链表</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<h1 id=\"暑期实习-字节面试\"><a href=\"#暑期实习-字节面试\" class=\"headerlink\" title=\"暑期实习-字节面试\"></a>暑期实习-字节面试</h1><blockquote>\n<p>节子暑期实习面试了两次，基本都挂掉了<br>原因是因为面的太早了（1月份），准备还不是很充分。建议大家面试前一定要好好修改自己的简历，至少对简历上相关问题聊熟于心</p>\n</blockquote>\n<h2 id=\"字节第一次面试\"><a href=\"#字节第一次面试\" class=\"headerlink\" title=\"字节第一次面试\"></a>字节第一次面试</h2><ol>\n<li>项目中的分库分表？（不对，需要纠正）</li>\n<li>sa-token中，token存的是什么，如何根据token找到是谁的（回答的不好）</li>\n<li>项目中的redisson如何做到的过期检测（回答的不好）</li>\n</ol>\n<p><a href=\"https://javaguide.cn/database/redis/redis-delayed-task.html#redisson-%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF\">https://javaguide.cn/database/redis/redis-delayed-task.html#redisson-%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF</a></p>\n<ol start=\"4\">\n<li>redisson过期订单的key-value存的是什么（回答的不好）</li>\n<li>对称加密和非对称加密</li>\n<li>分布式锁（用redis）；但是超时或者崩溃了，如何处理；如果超时释放了之后别人去用了，但是自己又去把别人在用的锁释放了怎么办（场景引导，不太熟悉）</li>\n<li>java中保证线程安全的机制</li>\n<li>git中，fetch和pull的区别</li>\n<li>git中，rebase的作用（回答的不好）</li>\n</ol>\n<p><a href=\"https://blog.csdn.net/weixin_43717839/article/details/143222436\">https://blog.csdn.net/weixin_43717839/article/details/143222436</a></p>\n<p>（算法）打家劫舍2</p>\n<h2 id=\"字节第二次面试\"><a href=\"#字节第二次面试\" class=\"headerlink\" title=\"字节第二次面试\"></a>字节第二次面试</h2><ul>\n<li>（怪问题）为什么在蔚来实习的时候，还投了字节？</li>\n<li>在蔚来实习的时候到底做的是什么工作？</li>\n<li>统计大文件单词数量用什么数据结构？（哈希表？）如果想要降低空间复杂度呢？（没太回答好）</li>\n<li>你们的归宿系统怎么登陆的？分了几个微服务？</li>\n<li>RBAC和ABAC有什么区别？哪一个更复杂？（不太熟悉）</li>\n<li>你们的归宿系统中设置登录过期机制了吗？如果快过期了应该怎么处理更好？</li>\n<li>如果redis中有一个value特别大的kv对会产生什么负面影响？</li>\n<li>mysql的联合索引中，B+树的叶子节点存储的是什么？B+树有什么特点？</li>\n<li>限流和熔断的区别？</li>\n<li>归宿系统ui图是谁画的，谁写的设计稿，多少用户量，老师验收了吗，谁负责的答辩？</li>\n<li>高考是哪个省的</li>\n<li>（算法）反转链表</li>\n</ul>\n"},{"title":"暑期实习-携程面试","date":"2025-10-30T16:05:00.000Z","cover":"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/u=2144682419,933249763&fm=253&app=138&f=JPEG-20251031-101400.jpeg","_content":"\n# 暑期实习-携程面试\n\n## 笔试\n（3.13 19:00-21:00）\n\n秒了，1h结束\n\n\n## 携程一面\n\n（3.21，60min）\n\n1. 自我介绍\n2. 项目介绍及讨论\n3. 实时协同编程中，如果两端同时去做变更操作，如何保证一致性（a站点的a操作作用到b站点，b站点的b操作还没作用到a站点，此时a站点又做了操作？）\n4. 如果想要实现房东查看员工数据，如何实现\n5. 如果系统想要实现角色的动态权限变更，如何实现\n6. 某一个微服务在请求其他微服务的时候，一定需要经过gateway再次鉴权吗，有什么优化方案吗\n7. 如何实现用户名带着密码登陆失败三次后，15分钟内不能登陆\n8. 50个库存的秒杀如何防止出现超卖\n9. redisson的自动续期机制是如何实现的\n10. redis如何解决缓存一致性\n11. redis的热点key的危害和解决方法\n12. cookie跨域吗\n13. 百度登录之后，百度网盘也自动登录上了，怎么实现的\n14. localStorage跨域吗（不会）\n15. 10G的11位电话号码文件，2G内存，如何获取重复率最高的电话号码\n\n\n## 携程二面\n（3.28，36min，面试官迟到30min，逆天）\n\n1. 自我介绍\n2. ot算法相关讨论\n3. 抽象语法树相关讨论\n4. 介绍数据库中的索引\n5. 建立联合索引(a, b)的时候是建立了一个索引还是两个索引\n6. 前缀匹配%在前，在后，在两侧，哪一个能使用到索引\n7. 某表中列a有上百条，列b有上万条，联合索引时（a，b）和（b，a）哪一个更好\n8. redis数据结构有哪些\n9. redis为何用跳表而不是红黑树\n10. redis中的hash如何解决冲突\n11. redis中的hash没有像java中的hashmap引入红黑树解决冲突，为什么\n12. BitMap如何实现用户签到功能，如何设计key和value\n13. BitMap中如何实现以下三个需求：（1）用户能查看到自己最近签到情况；（2）系统能统计最近一年签到次数最多的用户；（3）用户不能重复签到\n\n\n## 携程AI面\n（4.3，一共六个问题）\n\n导师或上级给了一个压力大的任务，如何解决\n\n\n","source":"_posts/2025/暑期实习-携程面试.md","raw":"---\ntitle: 暑期实习-携程面试\ndate: 2025-10-31 00:05:00\ncover: https://upic-1301780692.cos.ap-shanghai.myqcloud.com/u=2144682419,933249763&fm=253&app=138&f=JPEG-20251031-101400.jpeg\ntag: 暑期实习\n---\n\n# 暑期实习-携程面试\n\n## 笔试\n（3.13 19:00-21:00）\n\n秒了，1h结束\n\n\n## 携程一面\n\n（3.21，60min）\n\n1. 自我介绍\n2. 项目介绍及讨论\n3. 实时协同编程中，如果两端同时去做变更操作，如何保证一致性（a站点的a操作作用到b站点，b站点的b操作还没作用到a站点，此时a站点又做了操作？）\n4. 如果想要实现房东查看员工数据，如何实现\n5. 如果系统想要实现角色的动态权限变更，如何实现\n6. 某一个微服务在请求其他微服务的时候，一定需要经过gateway再次鉴权吗，有什么优化方案吗\n7. 如何实现用户名带着密码登陆失败三次后，15分钟内不能登陆\n8. 50个库存的秒杀如何防止出现超卖\n9. redisson的自动续期机制是如何实现的\n10. redis如何解决缓存一致性\n11. redis的热点key的危害和解决方法\n12. cookie跨域吗\n13. 百度登录之后，百度网盘也自动登录上了，怎么实现的\n14. localStorage跨域吗（不会）\n15. 10G的11位电话号码文件，2G内存，如何获取重复率最高的电话号码\n\n\n## 携程二面\n（3.28，36min，面试官迟到30min，逆天）\n\n1. 自我介绍\n2. ot算法相关讨论\n3. 抽象语法树相关讨论\n4. 介绍数据库中的索引\n5. 建立联合索引(a, b)的时候是建立了一个索引还是两个索引\n6. 前缀匹配%在前，在后，在两侧，哪一个能使用到索引\n7. 某表中列a有上百条，列b有上万条，联合索引时（a，b）和（b，a）哪一个更好\n8. redis数据结构有哪些\n9. redis为何用跳表而不是红黑树\n10. redis中的hash如何解决冲突\n11. redis中的hash没有像java中的hashmap引入红黑树解决冲突，为什么\n12. BitMap如何实现用户签到功能，如何设计key和value\n13. BitMap中如何实现以下三个需求：（1）用户能查看到自己最近签到情况；（2）系统能统计最近一年签到次数最多的用户；（3）用户不能重复签到\n\n\n## 携程AI面\n（4.3，一共六个问题）\n\n导师或上级给了一个压力大的任务，如何解决\n\n\n","slug":"2025/暑期实习-携程面试","published":1,"updated":"2025-10-31T02:18:29.657Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmhg4qt4g000qf5fa7lae8nb2","content":"<h1 id=\"暑期实习-携程面试\"><a href=\"#暑期实习-携程面试\" class=\"headerlink\" title=\"暑期实习-携程面试\"></a>暑期实习-携程面试</h1><h2 id=\"笔试\"><a href=\"#笔试\" class=\"headerlink\" title=\"笔试\"></a>笔试</h2><p>（3.13 19:00-21:00）</p>\n<p>秒了，1h结束</p>\n<h2 id=\"携程一面\"><a href=\"#携程一面\" class=\"headerlink\" title=\"携程一面\"></a>携程一面</h2><p>（3.21，60min）</p>\n<ol>\n<li>自我介绍</li>\n<li>项目介绍及讨论</li>\n<li>实时协同编程中，如果两端同时去做变更操作，如何保证一致性（a站点的a操作作用到b站点，b站点的b操作还没作用到a站点，此时a站点又做了操作？）</li>\n<li>如果想要实现房东查看员工数据，如何实现</li>\n<li>如果系统想要实现角色的动态权限变更，如何实现</li>\n<li>某一个微服务在请求其他微服务的时候，一定需要经过gateway再次鉴权吗，有什么优化方案吗</li>\n<li>如何实现用户名带着密码登陆失败三次后，15分钟内不能登陆</li>\n<li>50个库存的秒杀如何防止出现超卖</li>\n<li>redisson的自动续期机制是如何实现的</li>\n<li>redis如何解决缓存一致性</li>\n<li>redis的热点key的危害和解决方法</li>\n<li>cookie跨域吗</li>\n<li>百度登录之后，百度网盘也自动登录上了，怎么实现的</li>\n<li>localStorage跨域吗（不会）</li>\n<li>10G的11位电话号码文件，2G内存，如何获取重复率最高的电话号码</li>\n</ol>\n<h2 id=\"携程二面\"><a href=\"#携程二面\" class=\"headerlink\" title=\"携程二面\"></a>携程二面</h2><p>（3.28，36min，面试官迟到30min，逆天）</p>\n<ol>\n<li>自我介绍</li>\n<li>ot算法相关讨论</li>\n<li>抽象语法树相关讨论</li>\n<li>介绍数据库中的索引</li>\n<li>建立联合索引(a, b)的时候是建立了一个索引还是两个索引</li>\n<li>前缀匹配%在前，在后，在两侧，哪一个能使用到索引</li>\n<li>某表中列a有上百条，列b有上万条，联合索引时（a，b）和（b，a）哪一个更好</li>\n<li>redis数据结构有哪些</li>\n<li>redis为何用跳表而不是红黑树</li>\n<li>redis中的hash如何解决冲突</li>\n<li>redis中的hash没有像java中的hashmap引入红黑树解决冲突，为什么</li>\n<li>BitMap如何实现用户签到功能，如何设计key和value</li>\n<li>BitMap中如何实现以下三个需求：（1）用户能查看到自己最近签到情况；（2）系统能统计最近一年签到次数最多的用户；（3）用户不能重复签到</li>\n</ol>\n<h2 id=\"携程AI面\"><a href=\"#携程AI面\" class=\"headerlink\" title=\"携程AI面\"></a>携程AI面</h2><p>（4.3，一共六个问题）</p>\n<p>导师或上级给了一个压力大的任务，如何解决</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<h1 id=\"暑期实习-携程面试\"><a href=\"#暑期实习-携程面试\" class=\"headerlink\" title=\"暑期实习-携程面试\"></a>暑期实习-携程面试</h1><h2 id=\"笔试\"><a href=\"#笔试\" class=\"headerlink\" title=\"笔试\"></a>笔试</h2><p>（3.13 19:00-21:00）</p>\n<p>秒了，1h结束</p>\n<h2 id=\"携程一面\"><a href=\"#携程一面\" class=\"headerlink\" title=\"携程一面\"></a>携程一面</h2><p>（3.21，60min）</p>\n<ol>\n<li>自我介绍</li>\n<li>项目介绍及讨论</li>\n<li>实时协同编程中，如果两端同时去做变更操作，如何保证一致性（a站点的a操作作用到b站点，b站点的b操作还没作用到a站点，此时a站点又做了操作？）</li>\n<li>如果想要实现房东查看员工数据，如何实现</li>\n<li>如果系统想要实现角色的动态权限变更，如何实现</li>\n<li>某一个微服务在请求其他微服务的时候，一定需要经过gateway再次鉴权吗，有什么优化方案吗</li>\n<li>如何实现用户名带着密码登陆失败三次后，15分钟内不能登陆</li>\n<li>50个库存的秒杀如何防止出现超卖</li>\n<li>redisson的自动续期机制是如何实现的</li>\n<li>redis如何解决缓存一致性</li>\n<li>redis的热点key的危害和解决方法</li>\n<li>cookie跨域吗</li>\n<li>百度登录之后，百度网盘也自动登录上了，怎么实现的</li>\n<li>localStorage跨域吗（不会）</li>\n<li>10G的11位电话号码文件，2G内存，如何获取重复率最高的电话号码</li>\n</ol>\n<h2 id=\"携程二面\"><a href=\"#携程二面\" class=\"headerlink\" title=\"携程二面\"></a>携程二面</h2><p>（3.28，36min，面试官迟到30min，逆天）</p>\n<ol>\n<li>自我介绍</li>\n<li>ot算法相关讨论</li>\n<li>抽象语法树相关讨论</li>\n<li>介绍数据库中的索引</li>\n<li>建立联合索引(a, b)的时候是建立了一个索引还是两个索引</li>\n<li>前缀匹配%在前，在后，在两侧，哪一个能使用到索引</li>\n<li>某表中列a有上百条，列b有上万条，联合索引时（a，b）和（b，a）哪一个更好</li>\n<li>redis数据结构有哪些</li>\n<li>redis为何用跳表而不是红黑树</li>\n<li>redis中的hash如何解决冲突</li>\n<li>redis中的hash没有像java中的hashmap引入红黑树解决冲突，为什么</li>\n<li>BitMap如何实现用户签到功能，如何设计key和value</li>\n<li>BitMap中如何实现以下三个需求：（1）用户能查看到自己最近签到情况；（2）系统能统计最近一年签到次数最多的用户；（3）用户不能重复签到</li>\n</ol>\n<h2 id=\"携程AI面\"><a href=\"#携程AI面\" class=\"headerlink\" title=\"携程AI面\"></a>携程AI面</h2><p>（4.3，一共六个问题）</p>\n<p>导师或上级给了一个压力大的任务，如何解决</p>\n"},{"title":"暑期实习-淘天面试","date":"2025-10-30T16:01:00.000Z","cover":"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20251031095355352-20251031-095355.png","_content":"\n# 暑期实习-淘天面试\n\n## 笔试\n3.8，做的一般\n\n只ac了1.4/3\n\n\n## 淘天电话面\n（3.7，49min，电话面试）\n\n1. 自我介绍\n2. Java中用过什么类（我详细介绍了集合）\n3. Java除了并发容器，还有什么保证并发安全的手段？（回答了锁之类的，最后暗示下回答了ThreadLocal）\n4. 项目用了令牌桶算法，算法介绍，和其他限流算法的比较？\n5. 不同微服务不同的限流策略是如何制定的？\n6. 对于被限流算法拒绝的API请求，用什么策略？（我说用的就是直接返回错误码，似乎想要其他方案）\n   - 发送端重试，指数退避；在header里放个retry-after，或者放到返回的体里\n   - 服务端要及时处理，服务降级，暂时屏蔽掉非核心业务的API请求\n7. 服务器运行后某时刻突然CPU占用率特别高，如何确定问题\n8. 如何确定是哪一行Java代码造成的CPU异常偏高（定位到代码逻辑）\n9. JDK用的什么版本\n10. 介绍下该JDK版本的内存区域和垃圾回收器\n11. 日常开发如何解决问题？\n12. 平时会干些什么？（我理解是学习外的，说的就是健身/剧本杀，最后提到看一些有意思的项目）\n13. 如何去看一个开源项目？\n14. 进入公司1-3年，会是如何的成长路线？\n15. 中间件和业务层，更想做哪一块工作？（提问者是中间件，回答显然）\n16. 印象最深刻的项目？（介绍了iGEM和梦想教室）\n\n## 淘天一面\n（3.14，60min）\n\n1. 自我介绍\n2. 介绍实验室项目（10+min）\n3. 编译原理了解程度（不了解哈）\n4. Spring Gateway是如何让鉴权、限流生效的，底层原理（不知道）\n5. 平时看什么底层代码（我提到mysql的hash join）\n6. join hash介绍一下\n7. hashmap的底层原理\n8. 线程池用过哪些（我补充最好不要用）\n9. 简历中提到的蓝桥杯\n10. ForkJoinPool了解吗\n11. B+树的底层原理\n12. 为什么对磁盘操作通常比对内存操作要慢\n13. 数据到了网卡，如何最后到达操作系统，内存如何能够读取到数据（不知道）\n14. linux中的mmap是什么（不知道）\n15. 最近有在做什么项目\n16. 日常会读什么技术文档\n17. （漫谈）有没有了解什么AI工具\n18. 反问：建议提升哪里？（答复）多了解一些技术上原理的东西（如Spring Gateway），因为是做中间件的\n\n\n## 淘天二面\n\n（3.25，41min）\n\n1. 自我介绍\n2. 介绍一个印象最深的项目（归宿）\n3. 这个项目中设定了什么目标，达成度如何\n4. 项目中遇到了什么挑战\n5. 通过这个项目自己得到了什么成长\n6. 实时协同编程项目中自己作为一个什么身份参与的，参与了哪些内容\n7. 该项目中一致性体现在哪里\n8. ot算法如何保证一致性\n9. 自己在项目中是否有一些开创性的思考和进阶的要求\n10. 最近一年学习什么知识\n11. 分布式系统看到哪里了，有什么感受\n12. 除了理论性的学习，有没有做什么实践性的任务\n13. 反问：业务是什么\n\n\n## 淘天HR面\n\n（4.1，42min）\n\n1. 自我介绍\n2. 实验室项目介绍\n3. 归宿项目经历介绍\n4. 介绍自己在这个项目中设定的目标、担任的角色、完成的核心工作，达成的结果\n5. 介绍国际基因工程大赛经历\n6. 自己学习新的技术栈的经历\n7. 未来职业规划\n8. 简历中提到的\n9. 和组员发生冲突的经历\n10. 反问：能力需求\n\n\n> 结果意外的没有通过HR面，个人评估可能是因为HR面的时候自己表现的不太积极？\n> 或者可能是之前技术面的时候回答问题回答的一般？\n","source":"_posts/2025/暑期实习-淘天面试.md","raw":"---\ntitle: 暑期实习-淘天面试\ndate: 2025-10-31 00:01:00\ncover: https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20251031095355352-20251031-095355.png\ntag: 暑期实习\n---\n\n# 暑期实习-淘天面试\n\n## 笔试\n3.8，做的一般\n\n只ac了1.4/3\n\n\n## 淘天电话面\n（3.7，49min，电话面试）\n\n1. 自我介绍\n2. Java中用过什么类（我详细介绍了集合）\n3. Java除了并发容器，还有什么保证并发安全的手段？（回答了锁之类的，最后暗示下回答了ThreadLocal）\n4. 项目用了令牌桶算法，算法介绍，和其他限流算法的比较？\n5. 不同微服务不同的限流策略是如何制定的？\n6. 对于被限流算法拒绝的API请求，用什么策略？（我说用的就是直接返回错误码，似乎想要其他方案）\n   - 发送端重试，指数退避；在header里放个retry-after，或者放到返回的体里\n   - 服务端要及时处理，服务降级，暂时屏蔽掉非核心业务的API请求\n7. 服务器运行后某时刻突然CPU占用率特别高，如何确定问题\n8. 如何确定是哪一行Java代码造成的CPU异常偏高（定位到代码逻辑）\n9. JDK用的什么版本\n10. 介绍下该JDK版本的内存区域和垃圾回收器\n11. 日常开发如何解决问题？\n12. 平时会干些什么？（我理解是学习外的，说的就是健身/剧本杀，最后提到看一些有意思的项目）\n13. 如何去看一个开源项目？\n14. 进入公司1-3年，会是如何的成长路线？\n15. 中间件和业务层，更想做哪一块工作？（提问者是中间件，回答显然）\n16. 印象最深刻的项目？（介绍了iGEM和梦想教室）\n\n## 淘天一面\n（3.14，60min）\n\n1. 自我介绍\n2. 介绍实验室项目（10+min）\n3. 编译原理了解程度（不了解哈）\n4. Spring Gateway是如何让鉴权、限流生效的，底层原理（不知道）\n5. 平时看什么底层代码（我提到mysql的hash join）\n6. join hash介绍一下\n7. hashmap的底层原理\n8. 线程池用过哪些（我补充最好不要用）\n9. 简历中提到的蓝桥杯\n10. ForkJoinPool了解吗\n11. B+树的底层原理\n12. 为什么对磁盘操作通常比对内存操作要慢\n13. 数据到了网卡，如何最后到达操作系统，内存如何能够读取到数据（不知道）\n14. linux中的mmap是什么（不知道）\n15. 最近有在做什么项目\n16. 日常会读什么技术文档\n17. （漫谈）有没有了解什么AI工具\n18. 反问：建议提升哪里？（答复）多了解一些技术上原理的东西（如Spring Gateway），因为是做中间件的\n\n\n## 淘天二面\n\n（3.25，41min）\n\n1. 自我介绍\n2. 介绍一个印象最深的项目（归宿）\n3. 这个项目中设定了什么目标，达成度如何\n4. 项目中遇到了什么挑战\n5. 通过这个项目自己得到了什么成长\n6. 实时协同编程项目中自己作为一个什么身份参与的，参与了哪些内容\n7. 该项目中一致性体现在哪里\n8. ot算法如何保证一致性\n9. 自己在项目中是否有一些开创性的思考和进阶的要求\n10. 最近一年学习什么知识\n11. 分布式系统看到哪里了，有什么感受\n12. 除了理论性的学习，有没有做什么实践性的任务\n13. 反问：业务是什么\n\n\n## 淘天HR面\n\n（4.1，42min）\n\n1. 自我介绍\n2. 实验室项目介绍\n3. 归宿项目经历介绍\n4. 介绍自己在这个项目中设定的目标、担任的角色、完成的核心工作，达成的结果\n5. 介绍国际基因工程大赛经历\n6. 自己学习新的技术栈的经历\n7. 未来职业规划\n8. 简历中提到的\n9. 和组员发生冲突的经历\n10. 反问：能力需求\n\n\n> 结果意外的没有通过HR面，个人评估可能是因为HR面的时候自己表现的不太积极？\n> 或者可能是之前技术面的时候回答问题回答的一般？\n","slug":"2025/暑期实习-淘天面试","published":1,"updated":"2025-10-31T02:18:53.237Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmhg4qt4g000tf5faddox3lyr","content":"<h1 id=\"暑期实习-淘天面试\"><a href=\"#暑期实习-淘天面试\" class=\"headerlink\" title=\"暑期实习-淘天面试\"></a>暑期实习-淘天面试</h1><h2 id=\"笔试\"><a href=\"#笔试\" class=\"headerlink\" title=\"笔试\"></a>笔试</h2><p>3.8，做的一般</p>\n<p>只ac了1.4/3</p>\n<h2 id=\"淘天电话面\"><a href=\"#淘天电话面\" class=\"headerlink\" title=\"淘天电话面\"></a>淘天电话面</h2><p>（3.7，49min，电话面试）</p>\n<ol>\n<li>自我介绍</li>\n<li>Java中用过什么类（我详细介绍了集合）</li>\n<li>Java除了并发容器，还有什么保证并发安全的手段？（回答了锁之类的，最后暗示下回答了ThreadLocal）</li>\n<li>项目用了令牌桶算法，算法介绍，和其他限流算法的比较？</li>\n<li>不同微服务不同的限流策略是如何制定的？</li>\n<li>对于被限流算法拒绝的API请求，用什么策略？（我说用的就是直接返回错误码，似乎想要其他方案）<ul>\n<li>发送端重试，指数退避；在header里放个retry-after，或者放到返回的体里</li>\n<li>服务端要及时处理，服务降级，暂时屏蔽掉非核心业务的API请求</li>\n</ul>\n</li>\n<li>服务器运行后某时刻突然CPU占用率特别高，如何确定问题</li>\n<li>如何确定是哪一行Java代码造成的CPU异常偏高（定位到代码逻辑）</li>\n<li>JDK用的什么版本</li>\n<li>介绍下该JDK版本的内存区域和垃圾回收器</li>\n<li>日常开发如何解决问题？</li>\n<li>平时会干些什么？（我理解是学习外的，说的就是健身/剧本杀，最后提到看一些有意思的项目）</li>\n<li>如何去看一个开源项目？</li>\n<li>进入公司1-3年，会是如何的成长路线？</li>\n<li>中间件和业务层，更想做哪一块工作？（提问者是中间件，回答显然）</li>\n<li>印象最深刻的项目？（介绍了iGEM和梦想教室）</li>\n</ol>\n<h2 id=\"淘天一面\"><a href=\"#淘天一面\" class=\"headerlink\" title=\"淘天一面\"></a>淘天一面</h2><p>（3.14，60min）</p>\n<ol>\n<li>自我介绍</li>\n<li>介绍实验室项目（10+min）</li>\n<li>编译原理了解程度（不了解哈）</li>\n<li>Spring Gateway是如何让鉴权、限流生效的，底层原理（不知道）</li>\n<li>平时看什么底层代码（我提到mysql的hash join）</li>\n<li>join hash介绍一下</li>\n<li>hashmap的底层原理</li>\n<li>线程池用过哪些（我补充最好不要用）</li>\n<li>简历中提到的蓝桥杯</li>\n<li>ForkJoinPool了解吗</li>\n<li>B+树的底层原理</li>\n<li>为什么对磁盘操作通常比对内存操作要慢</li>\n<li>数据到了网卡，如何最后到达操作系统，内存如何能够读取到数据（不知道）</li>\n<li>linux中的mmap是什么（不知道）</li>\n<li>最近有在做什么项目</li>\n<li>日常会读什么技术文档</li>\n<li>（漫谈）有没有了解什么AI工具</li>\n<li>反问：建议提升哪里？（答复）多了解一些技术上原理的东西（如Spring Gateway），因为是做中间件的</li>\n</ol>\n<h2 id=\"淘天二面\"><a href=\"#淘天二面\" class=\"headerlink\" title=\"淘天二面\"></a>淘天二面</h2><p>（3.25，41min）</p>\n<ol>\n<li>自我介绍</li>\n<li>介绍一个印象最深的项目（归宿）</li>\n<li>这个项目中设定了什么目标，达成度如何</li>\n<li>项目中遇到了什么挑战</li>\n<li>通过这个项目自己得到了什么成长</li>\n<li>实时协同编程项目中自己作为一个什么身份参与的，参与了哪些内容</li>\n<li>该项目中一致性体现在哪里</li>\n<li>ot算法如何保证一致性</li>\n<li>自己在项目中是否有一些开创性的思考和进阶的要求</li>\n<li>最近一年学习什么知识</li>\n<li>分布式系统看到哪里了，有什么感受</li>\n<li>除了理论性的学习，有没有做什么实践性的任务</li>\n<li>反问：业务是什么</li>\n</ol>\n<h2 id=\"淘天HR面\"><a href=\"#淘天HR面\" class=\"headerlink\" title=\"淘天HR面\"></a>淘天HR面</h2><p>（4.1，42min）</p>\n<ol>\n<li>自我介绍</li>\n<li>实验室项目介绍</li>\n<li>归宿项目经历介绍</li>\n<li>介绍自己在这个项目中设定的目标、担任的角色、完成的核心工作，达成的结果</li>\n<li>介绍国际基因工程大赛经历</li>\n<li>自己学习新的技术栈的经历</li>\n<li>未来职业规划</li>\n<li>简历中提到的</li>\n<li>和组员发生冲突的经历</li>\n<li>反问：能力需求</li>\n</ol>\n<blockquote>\n<p>结果意外的没有通过HR面，个人评估可能是因为HR面的时候自己表现的不太积极？<br>或者可能是之前技术面的时候回答问题回答的一般？</p>\n</blockquote>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<h1 id=\"暑期实习-淘天面试\"><a href=\"#暑期实习-淘天面试\" class=\"headerlink\" title=\"暑期实习-淘天面试\"></a>暑期实习-淘天面试</h1><h2 id=\"笔试\"><a href=\"#笔试\" class=\"headerlink\" title=\"笔试\"></a>笔试</h2><p>3.8，做的一般</p>\n<p>只ac了1.4/3</p>\n<h2 id=\"淘天电话面\"><a href=\"#淘天电话面\" class=\"headerlink\" title=\"淘天电话面\"></a>淘天电话面</h2><p>（3.7，49min，电话面试）</p>\n<ol>\n<li>自我介绍</li>\n<li>Java中用过什么类（我详细介绍了集合）</li>\n<li>Java除了并发容器，还有什么保证并发安全的手段？（回答了锁之类的，最后暗示下回答了ThreadLocal）</li>\n<li>项目用了令牌桶算法，算法介绍，和其他限流算法的比较？</li>\n<li>不同微服务不同的限流策略是如何制定的？</li>\n<li>对于被限流算法拒绝的API请求，用什么策略？（我说用的就是直接返回错误码，似乎想要其他方案）<ul>\n<li>发送端重试，指数退避；在header里放个retry-after，或者放到返回的体里</li>\n<li>服务端要及时处理，服务降级，暂时屏蔽掉非核心业务的API请求</li>\n</ul>\n</li>\n<li>服务器运行后某时刻突然CPU占用率特别高，如何确定问题</li>\n<li>如何确定是哪一行Java代码造成的CPU异常偏高（定位到代码逻辑）</li>\n<li>JDK用的什么版本</li>\n<li>介绍下该JDK版本的内存区域和垃圾回收器</li>\n<li>日常开发如何解决问题？</li>\n<li>平时会干些什么？（我理解是学习外的，说的就是健身/剧本杀，最后提到看一些有意思的项目）</li>\n<li>如何去看一个开源项目？</li>\n<li>进入公司1-3年，会是如何的成长路线？</li>\n<li>中间件和业务层，更想做哪一块工作？（提问者是中间件，回答显然）</li>\n<li>印象最深刻的项目？（介绍了iGEM和梦想教室）</li>\n</ol>\n<h2 id=\"淘天一面\"><a href=\"#淘天一面\" class=\"headerlink\" title=\"淘天一面\"></a>淘天一面</h2><p>（3.14，60min）</p>\n<ol>\n<li>自我介绍</li>\n<li>介绍实验室项目（10+min）</li>\n<li>编译原理了解程度（不了解哈）</li>\n<li>Spring Gateway是如何让鉴权、限流生效的，底层原理（不知道）</li>\n<li>平时看什么底层代码（我提到mysql的hash join）</li>\n<li>join hash介绍一下</li>\n<li>hashmap的底层原理</li>\n<li>线程池用过哪些（我补充最好不要用）</li>\n<li>简历中提到的蓝桥杯</li>\n<li>ForkJoinPool了解吗</li>\n<li>B+树的底层原理</li>\n<li>为什么对磁盘操作通常比对内存操作要慢</li>\n<li>数据到了网卡，如何最后到达操作系统，内存如何能够读取到数据（不知道）</li>\n<li>linux中的mmap是什么（不知道）</li>\n<li>最近有在做什么项目</li>\n<li>日常会读什么技术文档</li>\n<li>（漫谈）有没有了解什么AI工具</li>\n<li>反问：建议提升哪里？（答复）多了解一些技术上原理的东西（如Spring Gateway），因为是做中间件的</li>\n</ol>\n<h2 id=\"淘天二面\"><a href=\"#淘天二面\" class=\"headerlink\" title=\"淘天二面\"></a>淘天二面</h2><p>（3.25，41min）</p>\n<ol>\n<li>自我介绍</li>\n<li>介绍一个印象最深的项目（归宿）</li>\n<li>这个项目中设定了什么目标，达成度如何</li>\n<li>项目中遇到了什么挑战</li>\n<li>通过这个项目自己得到了什么成长</li>\n<li>实时协同编程项目中自己作为一个什么身份参与的，参与了哪些内容</li>\n<li>该项目中一致性体现在哪里</li>\n<li>ot算法如何保证一致性</li>\n<li>自己在项目中是否有一些开创性的思考和进阶的要求</li>\n<li>最近一年学习什么知识</li>\n<li>分布式系统看到哪里了，有什么感受</li>\n<li>除了理论性的学习，有没有做什么实践性的任务</li>\n<li>反问：业务是什么</li>\n</ol>\n<h2 id=\"淘天HR面\"><a href=\"#淘天HR面\" class=\"headerlink\" title=\"淘天HR面\"></a>淘天HR面</h2><p>（4.1，42min）</p>\n<ol>\n<li>自我介绍</li>\n<li>实验室项目介绍</li>\n<li>归宿项目经历介绍</li>\n<li>介绍自己在这个项目中设定的目标、担任的角色、完成的核心工作，达成的结果</li>\n<li>介绍国际基因工程大赛经历</li>\n<li>自己学习新的技术栈的经历</li>\n<li>未来职业规划</li>\n<li>简历中提到的</li>\n<li>和组员发生冲突的经历</li>\n<li>反问：能力需求</li>\n</ol>\n<blockquote>\n<p>结果意外的没有通过HR面，个人评估可能是因为HR面的时候自己表现的不太积极？<br>或者可能是之前技术面的时候回答问题回答的一般？</p>\n</blockquote>\n"},{"title":"暑期实习-笔试记录","date":"2025-10-30T16:10:00.000Z","cover":"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/u=4081467303,2852188992&fm=253&app=138&f=JPEG-20251031-102218.jpeg","_content":"\n# 暑期实习-笔试记录\n\n## 快速读取\n\n> 理论上下面这段代码要能够默写出来，算法考试的时候直接用下面的就行了\n\n```java\nimport java.io.*;\nimport java.util.*;\npublic class Main {\n    static BufferedReader br;\n    static StringTokenizer st;\n  \n    static String next() throws IOException {\n        while (!st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return st.nextToken();\n    }\n\n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        st = new StringTokenizer(\"\");\n\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        int n = nextInt();\n        bw.write(n + \" \"); \n        bw.newLine();\n        bw.flush();   \n        bw.close();\n    }\n}\n```\n\n## oppo笔试\n\n自由时间，3.15， 做了52分钟（限时2h）\n\n20选择+3编程题\n\n第一题：一个数组，必须选择将其中一个数更改为其相反数，使得最后总和最大\n\n第二题：一个数组（0～10^9范围），MSN定义为删除某一个数字之后，剩余数字中没有出现的最小非负整数（如0 1 4 5 6就是2）。求数组中删除每个数字后的的MSN\n\n最后一题：字符串中有一些问号，如：3?2?2?222 。填充？，共有多少种方式使得最后能被3整除，要求不能有前导0（结果较大，整除10^9 + 7）\n\n选择题：\n\nLinux中匹配符：?; *; [charset]; {str1, ... ,str2}分别有什么作用\n\n![image-20250315134700444](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250315134700444-20250315-134703.png)\n\n以下哪种设备不支持共享读取：内存；磁盘；磁带；U盘\n\n## 拼多多笔试\n\n3.23，69分钟，秒了\n\n## bilibili笔试\n\n3.23，一小时（不到时不给交卷）\n\n做了35分钟，ac了\n\n但是最后一题只过了98.33%，很神奇\n\n## 虾皮笔试\n\n3.23，35分钟（要求做两个小时）\n\n三题很简单ac，做完b站赶着做了一下\n\n## EA笔试\n\n3.29，10:00-12:00，做了40min\n\n8道选择有不少概率论；机器学习和Python的不太会，如：\n\n```python\na, *b, c = [1,2,3,4,5]\nprint(b)\n```\n\npython中去重且不改变顺序的内置函数是：`set()`, `remove_dumplicates()`\n\n2道多选题，一题是tls的问题\n\n三道编程题：\n\n1. 给一个非递减数组，看是否能划分为多个子数组。这些子数组长度都大于3，且元素都是连续的。如 `[1,2]`不可以，`[1,2,3,3,4,4,5,6]`可以（划分为 `[1,2,3,4]`和 `[3,4,5,6]`）。没想到好的方法，直接判断 `n<3`返回 `false`，其他时候返回 `true`就过了70%就没想了（反正12分的题，最多扣5分）\n2. 第二题用二分即可解决\n3. 第三题就是LIS最长递增子序列\n\n## 米哈游笔试\n\n（3.29，2h）\n\n第一题通过，第二题通过95%，第三题通过20%","source":"_posts/2025/暑期实习-笔试记录.md","raw":"---\ntitle: 暑期实习-笔试记录\ndate: 2025-10-31 00:10:00\ncover: https://upic-1301780692.cos.ap-shanghai.myqcloud.com/u=4081467303,2852188992&fm=253&app=138&f=JPEG-20251031-102218.jpeg\ntag: 暑期实习\n---\n\n# 暑期实习-笔试记录\n\n## 快速读取\n\n> 理论上下面这段代码要能够默写出来，算法考试的时候直接用下面的就行了\n\n```java\nimport java.io.*;\nimport java.util.*;\npublic class Main {\n    static BufferedReader br;\n    static StringTokenizer st;\n  \n    static String next() throws IOException {\n        while (!st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return st.nextToken();\n    }\n\n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        st = new StringTokenizer(\"\");\n\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        int n = nextInt();\n        bw.write(n + \" \"); \n        bw.newLine();\n        bw.flush();   \n        bw.close();\n    }\n}\n```\n\n## oppo笔试\n\n自由时间，3.15， 做了52分钟（限时2h）\n\n20选择+3编程题\n\n第一题：一个数组，必须选择将其中一个数更改为其相反数，使得最后总和最大\n\n第二题：一个数组（0～10^9范围），MSN定义为删除某一个数字之后，剩余数字中没有出现的最小非负整数（如0 1 4 5 6就是2）。求数组中删除每个数字后的的MSN\n\n最后一题：字符串中有一些问号，如：3?2?2?222 。填充？，共有多少种方式使得最后能被3整除，要求不能有前导0（结果较大，整除10^9 + 7）\n\n选择题：\n\nLinux中匹配符：?; *; [charset]; {str1, ... ,str2}分别有什么作用\n\n![image-20250315134700444](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250315134700444-20250315-134703.png)\n\n以下哪种设备不支持共享读取：内存；磁盘；磁带；U盘\n\n## 拼多多笔试\n\n3.23，69分钟，秒了\n\n## bilibili笔试\n\n3.23，一小时（不到时不给交卷）\n\n做了35分钟，ac了\n\n但是最后一题只过了98.33%，很神奇\n\n## 虾皮笔试\n\n3.23，35分钟（要求做两个小时）\n\n三题很简单ac，做完b站赶着做了一下\n\n## EA笔试\n\n3.29，10:00-12:00，做了40min\n\n8道选择有不少概率论；机器学习和Python的不太会，如：\n\n```python\na, *b, c = [1,2,3,4,5]\nprint(b)\n```\n\npython中去重且不改变顺序的内置函数是：`set()`, `remove_dumplicates()`\n\n2道多选题，一题是tls的问题\n\n三道编程题：\n\n1. 给一个非递减数组，看是否能划分为多个子数组。这些子数组长度都大于3，且元素都是连续的。如 `[1,2]`不可以，`[1,2,3,3,4,4,5,6]`可以（划分为 `[1,2,3,4]`和 `[3,4,5,6]`）。没想到好的方法，直接判断 `n<3`返回 `false`，其他时候返回 `true`就过了70%就没想了（反正12分的题，最多扣5分）\n2. 第二题用二分即可解决\n3. 第三题就是LIS最长递增子序列\n\n## 米哈游笔试\n\n（3.29，2h）\n\n第一题通过，第二题通过95%，第三题通过20%","slug":"2025/暑期实习-笔试记录","published":1,"updated":"2025-10-31T02:23:38.413Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmhg4qt4h000uf5faamxlbykn","content":"<h1 id=\"暑期实习-笔试记录\"><a href=\"#暑期实习-笔试记录\" class=\"headerlink\" title=\"暑期实习-笔试记录\"></a>暑期实习-笔试记录</h1><h2 id=\"快速读取\"><a href=\"#快速读取\" class=\"headerlink\" title=\"快速读取\"></a>快速读取</h2><blockquote>\n<p>理论上下面这段代码要能够默写出来，算法考试的时候直接用下面的就行了</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> BufferedReader br;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> StringTokenizer st;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> String <span class=\"title\">next</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!st.hasMoreTokens()) &#123;</span><br><span class=\"line\">            st = <span class=\"keyword\">new</span> StringTokenizer(br.readLine());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> st.nextToken();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(System.in));</span><br><span class=\"line\">        st = <span class=\"keyword\">new</span> StringTokenizer(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        BufferedWriter bw = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> OutputStreamWriter(System.out));</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = nextInt();</span><br><span class=\"line\">        bw.write(n + <span class=\"string\">&quot; &quot;</span>); </span><br><span class=\"line\">        bw.newLine();</span><br><span class=\"line\">        bw.flush();   </span><br><span class=\"line\">        bw.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"oppo笔试\"><a href=\"#oppo笔试\" class=\"headerlink\" title=\"oppo笔试\"></a>oppo笔试</h2><p>自由时间，3.15， 做了52分钟（限时2h）</p>\n<p>20选择+3编程题</p>\n<p>第一题：一个数组，必须选择将其中一个数更改为其相反数，使得最后总和最大</p>\n<p>第二题：一个数组（0～10^9范围），MSN定义为删除某一个数字之后，剩余数字中没有出现的最小非负整数（如0 1 4 5 6就是2）。求数组中删除每个数字后的的MSN</p>\n<p>最后一题：字符串中有一些问号，如：3?2?2?222 。填充？，共有多少种方式使得最后能被3整除，要求不能有前导0（结果较大，整除10^9 + 7）</p>\n<p>选择题：</p>\n<p>Linux中匹配符：?; *; [charset]; {str1, … ,str2}分别有什么作用</p>\n<p><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250315134700444-20250315-134703.png\" alt=\"image-20250315134700444\"></p>\n<p>以下哪种设备不支持共享读取：内存；磁盘；磁带；U盘</p>\n<h2 id=\"拼多多笔试\"><a href=\"#拼多多笔试\" class=\"headerlink\" title=\"拼多多笔试\"></a>拼多多笔试</h2><p>3.23，69分钟，秒了</p>\n<h2 id=\"bilibili笔试\"><a href=\"#bilibili笔试\" class=\"headerlink\" title=\"bilibili笔试\"></a>bilibili笔试</h2><p>3.23，一小时（不到时不给交卷）</p>\n<p>做了35分钟，ac了</p>\n<p>但是最后一题只过了98.33%，很神奇</p>\n<h2 id=\"虾皮笔试\"><a href=\"#虾皮笔试\" class=\"headerlink\" title=\"虾皮笔试\"></a>虾皮笔试</h2><p>3.23，35分钟（要求做两个小时）</p>\n<p>三题很简单ac，做完b站赶着做了一下</p>\n<h2 id=\"EA笔试\"><a href=\"#EA笔试\" class=\"headerlink\" title=\"EA笔试\"></a>EA笔试</h2><p>3.29，10:00-12:00，做了40min</p>\n<p>8道选择有不少概率论；机器学习和Python的不太会，如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a, *b, c = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]</span><br><span class=\"line\">print(b)</span><br></pre></td></tr></table></figure>\n<p>python中去重且不改变顺序的内置函数是：<code>set()</code>, <code>remove_dumplicates()</code></p>\n<p>2道多选题，一题是tls的问题</p>\n<p>三道编程题：</p>\n<ol>\n<li>给一个非递减数组，看是否能划分为多个子数组。这些子数组长度都大于3，且元素都是连续的。如 <code>[1,2]</code>不可以，<code>[1,2,3,3,4,4,5,6]</code>可以（划分为 <code>[1,2,3,4]</code>和 <code>[3,4,5,6]</code>）。没想到好的方法，直接判断 <code>n&lt;3</code>返回 <code>false</code>，其他时候返回 <code>true</code>就过了70%就没想了（反正12分的题，最多扣5分）</li>\n<li>第二题用二分即可解决</li>\n<li>第三题就是LIS最长递增子序列</li>\n</ol>\n<h2 id=\"米哈游笔试\"><a href=\"#米哈游笔试\" class=\"headerlink\" title=\"米哈游笔试\"></a>米哈游笔试</h2><p>（3.29，2h）</p>\n<p>第一题通过，第二题通过95%，第三题通过20%</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<h1 id=\"暑期实习-笔试记录\"><a href=\"#暑期实习-笔试记录\" class=\"headerlink\" title=\"暑期实习-笔试记录\"></a>暑期实习-笔试记录</h1><h2 id=\"快速读取\"><a href=\"#快速读取\" class=\"headerlink\" title=\"快速读取\"></a>快速读取</h2><blockquote>\n<p>理论上下面这段代码要能够默写出来，算法考试的时候直接用下面的就行了</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> BufferedReader br;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> StringTokenizer st;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> String <span class=\"title\">next</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!st.hasMoreTokens()) &#123;</span><br><span class=\"line\">            st = <span class=\"keyword\">new</span> StringTokenizer(br.readLine());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> st.nextToken();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(System.in));</span><br><span class=\"line\">        st = <span class=\"keyword\">new</span> StringTokenizer(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        BufferedWriter bw = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> OutputStreamWriter(System.out));</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = nextInt();</span><br><span class=\"line\">        bw.write(n + <span class=\"string\">&quot; &quot;</span>); </span><br><span class=\"line\">        bw.newLine();</span><br><span class=\"line\">        bw.flush();   </span><br><span class=\"line\">        bw.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"oppo笔试\"><a href=\"#oppo笔试\" class=\"headerlink\" title=\"oppo笔试\"></a>oppo笔试</h2><p>自由时间，3.15， 做了52分钟（限时2h）</p>\n<p>20选择+3编程题</p>\n<p>第一题：一个数组，必须选择将其中一个数更改为其相反数，使得最后总和最大</p>\n<p>第二题：一个数组（0～10^9范围），MSN定义为删除某一个数字之后，剩余数字中没有出现的最小非负整数（如0 1 4 5 6就是2）。求数组中删除每个数字后的的MSN</p>\n<p>最后一题：字符串中有一些问号，如：3?2?2?222 。填充？，共有多少种方式使得最后能被3整除，要求不能有前导0（结果较大，整除10^9 + 7）</p>\n<p>选择题：</p>\n<p>Linux中匹配符：?; *; [charset]; {str1, … ,str2}分别有什么作用</p>\n<p><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250315134700444-20250315-134703.png\" alt=\"image-20250315134700444\"></p>\n<p>以下哪种设备不支持共享读取：内存；磁盘；磁带；U盘</p>\n<h2 id=\"拼多多笔试\"><a href=\"#拼多多笔试\" class=\"headerlink\" title=\"拼多多笔试\"></a>拼多多笔试</h2><p>3.23，69分钟，秒了</p>\n<h2 id=\"bilibili笔试\"><a href=\"#bilibili笔试\" class=\"headerlink\" title=\"bilibili笔试\"></a>bilibili笔试</h2><p>3.23，一小时（不到时不给交卷）</p>\n<p>做了35分钟，ac了</p>\n<p>但是最后一题只过了98.33%，很神奇</p>\n<h2 id=\"虾皮笔试\"><a href=\"#虾皮笔试\" class=\"headerlink\" title=\"虾皮笔试\"></a>虾皮笔试</h2><p>3.23，35分钟（要求做两个小时）</p>\n<p>三题很简单ac，做完b站赶着做了一下</p>\n<h2 id=\"EA笔试\"><a href=\"#EA笔试\" class=\"headerlink\" title=\"EA笔试\"></a>EA笔试</h2><p>3.29，10:00-12:00，做了40min</p>\n<p>8道选择有不少概率论；机器学习和Python的不太会，如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a, *b, c = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]</span><br><span class=\"line\">print(b)</span><br></pre></td></tr></table></figure>\n<p>python中去重且不改变顺序的内置函数是：<code>set()</code>, <code>remove_dumplicates()</code></p>\n<p>2道多选题，一题是tls的问题</p>\n<p>三道编程题：</p>\n<ol>\n<li>给一个非递减数组，看是否能划分为多个子数组。这些子数组长度都大于3，且元素都是连续的。如 <code>[1,2]</code>不可以，<code>[1,2,3,3,4,4,5,6]</code>可以（划分为 <code>[1,2,3,4]</code>和 <code>[3,4,5,6]</code>）。没想到好的方法，直接判断 <code>n&lt;3</code>返回 <code>false</code>，其他时候返回 <code>true</code>就过了70%就没想了（反正12分的题，最多扣5分）</li>\n<li>第二题用二分即可解决</li>\n<li>第三题就是LIS最长递增子序列</li>\n</ol>\n<h2 id=\"米哈游笔试\"><a href=\"#米哈游笔试\" class=\"headerlink\" title=\"米哈游笔试\"></a>米哈游笔试</h2><p>（3.29，2h）</p>\n<p>第一题通过，第二题通过95%，第三题通过20%</p>\n"},{"title":"暑期实习-京东面试","date":"2025-10-30T16:02:00.000Z","cover":"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20251031095639754-20251031-095639.png","_content":"\n# 暑期实习-京东面试\n\n## 京东一面\n（3.18，53分钟）\n\n1. 自我介绍\n2. 实习经历介绍\n3. 算法题（口述思路）：寻找第K大的数\n4. 介绍Java中的JVM\n5. 介绍Spring框架中的AOP\n6. 介绍mysql的索引\n7. 介绍分库分表\n8. 介绍分布式事务（不太了解）\n9. 介绍事务的四大特性\n10. 为什么普遍用redis以及五种基本数据类型\n11. 学习能力如何，佐证\n12. 职业发展规划\n13. 如何看待北京和京东\n14. 为啥18年入学（不要介意）\n15. 反问（业务：京东科技板块，京东金融APP大后端）\n\n面试官：非常满意，不比复旦华东五校的差\n\n这是提前准秋招，如果三轮面试都通过建议提前来实习（4月初入职，7月前满3个月）\n\n\n## 京东二面\n\n（3.21，17分钟，HR面？）\n\n1. 自我介绍\n2. 梦想教室是什么\n3. 高中三年感受如何，压力大吗\n4. 个人缺点\n5. 最有成就感的一件事：中间遇到什么问题，最后如何解决的，个人什么能力发挥了作用\n6. 解决问题会个人解决还是寻求他人帮助，比例100各自是多少\n7. 如果只有一个offer，为什么会给到我\n8. 未来职业发展规划\n9. 对上一轮面试官有什么感受\n10. 什么时候入职\n11. 现在有什么offer\n12. （反问）3天脱产培训，第四天返岗（mentor+leader）；90天后3次转正机会\n\n\n## 京东三面\n（3.27，27min，Leader面）\n\n1. 自我介绍\n2. 近期完成的工作\n3. 实时协同编程环境所解决的问题\n4. 实时协同编程所使用的编程语言\n5. 归宿项目所负责的工作\n6. 使用redis所带来的问题\n7. 从软件工程的视角来看，自己有哪些优势和不足\n8. 未来职业发展规划\n9. （反问）业务\n\n\n> 整体面试比较简单，面试官也期望我过去\n> 但是由于base在北京，很难过去..","source":"_posts/2025/暑期实习-京东面试.md","raw":"---\ntitle: 暑期实习-京东面试\ndate: 2025-10-31 00:02:00\ncover: https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20251031095639754-20251031-095639.png\ntag: 暑期实习\n---\n\n# 暑期实习-京东面试\n\n## 京东一面\n（3.18，53分钟）\n\n1. 自我介绍\n2. 实习经历介绍\n3. 算法题（口述思路）：寻找第K大的数\n4. 介绍Java中的JVM\n5. 介绍Spring框架中的AOP\n6. 介绍mysql的索引\n7. 介绍分库分表\n8. 介绍分布式事务（不太了解）\n9. 介绍事务的四大特性\n10. 为什么普遍用redis以及五种基本数据类型\n11. 学习能力如何，佐证\n12. 职业发展规划\n13. 如何看待北京和京东\n14. 为啥18年入学（不要介意）\n15. 反问（业务：京东科技板块，京东金融APP大后端）\n\n面试官：非常满意，不比复旦华东五校的差\n\n这是提前准秋招，如果三轮面试都通过建议提前来实习（4月初入职，7月前满3个月）\n\n\n## 京东二面\n\n（3.21，17分钟，HR面？）\n\n1. 自我介绍\n2. 梦想教室是什么\n3. 高中三年感受如何，压力大吗\n4. 个人缺点\n5. 最有成就感的一件事：中间遇到什么问题，最后如何解决的，个人什么能力发挥了作用\n6. 解决问题会个人解决还是寻求他人帮助，比例100各自是多少\n7. 如果只有一个offer，为什么会给到我\n8. 未来职业发展规划\n9. 对上一轮面试官有什么感受\n10. 什么时候入职\n11. 现在有什么offer\n12. （反问）3天脱产培训，第四天返岗（mentor+leader）；90天后3次转正机会\n\n\n## 京东三面\n（3.27，27min，Leader面）\n\n1. 自我介绍\n2. 近期完成的工作\n3. 实时协同编程环境所解决的问题\n4. 实时协同编程所使用的编程语言\n5. 归宿项目所负责的工作\n6. 使用redis所带来的问题\n7. 从软件工程的视角来看，自己有哪些优势和不足\n8. 未来职业发展规划\n9. （反问）业务\n\n\n> 整体面试比较简单，面试官也期望我过去\n> 但是由于base在北京，很难过去..","slug":"2025/暑期实习-京东面试","published":1,"updated":"2025-10-31T01:58:09.269Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmhg4qt4h000wf5fa01dia13p","content":"<h1 id=\"暑期实习-京东面试\"><a href=\"#暑期实习-京东面试\" class=\"headerlink\" title=\"暑期实习-京东面试\"></a>暑期实习-京东面试</h1><h2 id=\"京东一面\"><a href=\"#京东一面\" class=\"headerlink\" title=\"京东一面\"></a>京东一面</h2><p>（3.18，53分钟）</p>\n<ol>\n<li>自我介绍</li>\n<li>实习经历介绍</li>\n<li>算法题（口述思路）：寻找第K大的数</li>\n<li>介绍Java中的JVM</li>\n<li>介绍Spring框架中的AOP</li>\n<li>介绍mysql的索引</li>\n<li>介绍分库分表</li>\n<li>介绍分布式事务（不太了解）</li>\n<li>介绍事务的四大特性</li>\n<li>为什么普遍用redis以及五种基本数据类型</li>\n<li>学习能力如何，佐证</li>\n<li>职业发展规划</li>\n<li>如何看待北京和京东</li>\n<li>为啥18年入学（不要介意）</li>\n<li>反问（业务：京东科技板块，京东金融APP大后端）</li>\n</ol>\n<p>面试官：非常满意，不比复旦华东五校的差</p>\n<p>这是提前准秋招，如果三轮面试都通过建议提前来实习（4月初入职，7月前满3个月）</p>\n<h2 id=\"京东二面\"><a href=\"#京东二面\" class=\"headerlink\" title=\"京东二面\"></a>京东二面</h2><p>（3.21，17分钟，HR面？）</p>\n<ol>\n<li>自我介绍</li>\n<li>梦想教室是什么</li>\n<li>高中三年感受如何，压力大吗</li>\n<li>个人缺点</li>\n<li>最有成就感的一件事：中间遇到什么问题，最后如何解决的，个人什么能力发挥了作用</li>\n<li>解决问题会个人解决还是寻求他人帮助，比例100各自是多少</li>\n<li>如果只有一个offer，为什么会给到我</li>\n<li>未来职业发展规划</li>\n<li>对上一轮面试官有什么感受</li>\n<li>什么时候入职</li>\n<li>现在有什么offer</li>\n<li>（反问）3天脱产培训，第四天返岗（mentor+leader）；90天后3次转正机会</li>\n</ol>\n<h2 id=\"京东三面\"><a href=\"#京东三面\" class=\"headerlink\" title=\"京东三面\"></a>京东三面</h2><p>（3.27，27min，Leader面）</p>\n<ol>\n<li>自我介绍</li>\n<li>近期完成的工作</li>\n<li>实时协同编程环境所解决的问题</li>\n<li>实时协同编程所使用的编程语言</li>\n<li>归宿项目所负责的工作</li>\n<li>使用redis所带来的问题</li>\n<li>从软件工程的视角来看，自己有哪些优势和不足</li>\n<li>未来职业发展规划</li>\n<li>（反问）业务</li>\n</ol>\n<blockquote>\n<p>整体面试比较简单，面试官也期望我过去<br>但是由于base在北京，很难过去..</p>\n</blockquote>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<h1 id=\"暑期实习-京东面试\"><a href=\"#暑期实习-京东面试\" class=\"headerlink\" title=\"暑期实习-京东面试\"></a>暑期实习-京东面试</h1><h2 id=\"京东一面\"><a href=\"#京东一面\" class=\"headerlink\" title=\"京东一面\"></a>京东一面</h2><p>（3.18，53分钟）</p>\n<ol>\n<li>自我介绍</li>\n<li>实习经历介绍</li>\n<li>算法题（口述思路）：寻找第K大的数</li>\n<li>介绍Java中的JVM</li>\n<li>介绍Spring框架中的AOP</li>\n<li>介绍mysql的索引</li>\n<li>介绍分库分表</li>\n<li>介绍分布式事务（不太了解）</li>\n<li>介绍事务的四大特性</li>\n<li>为什么普遍用redis以及五种基本数据类型</li>\n<li>学习能力如何，佐证</li>\n<li>职业发展规划</li>\n<li>如何看待北京和京东</li>\n<li>为啥18年入学（不要介意）</li>\n<li>反问（业务：京东科技板块，京东金融APP大后端）</li>\n</ol>\n<p>面试官：非常满意，不比复旦华东五校的差</p>\n<p>这是提前准秋招，如果三轮面试都通过建议提前来实习（4月初入职，7月前满3个月）</p>\n<h2 id=\"京东二面\"><a href=\"#京东二面\" class=\"headerlink\" title=\"京东二面\"></a>京东二面</h2><p>（3.21，17分钟，HR面？）</p>\n<ol>\n<li>自我介绍</li>\n<li>梦想教室是什么</li>\n<li>高中三年感受如何，压力大吗</li>\n<li>个人缺点</li>\n<li>最有成就感的一件事：中间遇到什么问题，最后如何解决的，个人什么能力发挥了作用</li>\n<li>解决问题会个人解决还是寻求他人帮助，比例100各自是多少</li>\n<li>如果只有一个offer，为什么会给到我</li>\n<li>未来职业发展规划</li>\n<li>对上一轮面试官有什么感受</li>\n<li>什么时候入职</li>\n<li>现在有什么offer</li>\n<li>（反问）3天脱产培训，第四天返岗（mentor+leader）；90天后3次转正机会</li>\n</ol>\n<h2 id=\"京东三面\"><a href=\"#京东三面\" class=\"headerlink\" title=\"京东三面\"></a>京东三面</h2><p>（3.27，27min，Leader面）</p>\n<ol>\n<li>自我介绍</li>\n<li>近期完成的工作</li>\n<li>实时协同编程环境所解决的问题</li>\n<li>实时协同编程所使用的编程语言</li>\n<li>归宿项目所负责的工作</li>\n<li>使用redis所带来的问题</li>\n<li>从软件工程的视角来看，自己有哪些优势和不足</li>\n<li>未来职业发展规划</li>\n<li>（反问）业务</li>\n</ol>\n<blockquote>\n<p>整体面试比较简单，面试官也期望我过去<br>但是由于base在北京，很难过去..</p>\n</blockquote>\n"},{"title":"暑期实习-美团面试","date":"2025-10-30T16:06:00.000Z","cover":"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/u=3581427709,860796011&fm=253&app=138&f=JPEG-20251031-101635.jpeg","_content":"\n# 暑期实习-美团面试\n\n## 笔试\n3.22，ac了2.2\n\n最后一题需要查看一下思路\n\n\n## 美团AI面\n1. TCP和UDP的区别，适用于什么场景\n2. Java的内部类是什么？介绍一下匿名内部类\n3. 垃圾回收是什么？如何触发垃圾回收\n4. 介绍聚簇索引和非聚簇索引\n5. 介绍5种Java集合，以及特点\n6. 如何保证商品不出现超卖\n7. 介绍如何去学习的\n8. 介绍解决某个问题是否需要投入大量时间，从哪些方面考虑\n9. 未来三年的职业规划\n\n\n## 美团一面\n（3.27，47min）\n\n1. 自我介绍\n2. 最能体现技术能力的项目介绍\n3. 如何设计实现一个定时任务执行器\n4. 如果不希望cpu空转，如何设计一个定时任务执行器\n5. 实习项目用到了Spring Task定时任务，说一说\n6. 介绍令牌桶算法\n7. 哪些地方应用到了惰性机制\n8. 介绍项目中提到的冗余表和索引\n9. 是否遇到过索引失效\n10. 数据区分度足够高，如何建立索引：select * from table where x = 1 and y < 1 order by z;\n11. 是否存在查询同时使用两个索引的情况；\n12. 算法：K个一组反转链表\n\n```java\n// 代码中已指定的类名、方法名、参数名，请勿修改，直接返回方法规定的值即可\n\nclass Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        if (k <= 1) {\n          return head;\n        }\n      \n        ListNode dummpy = new ListNode(0, head);\n        // 找到末尾的k个节点\n        ListNode node = dummpy;\n      \n        while (node != null) {\n          // 获取后k个节点\n          boolean hasKNode = true;\n          ListNode tail = node;\n          for (int i = 0; i < k; ++i) {\n            tail = tail.next;\n            if (tail == null) {\n              hasKNode = false;\n              break;\n            }\n          }\n          // 如果剩下部分不存在K个节点\n          if (!hasKNode) {\n            break;\n          }\n        \n          // 反转这k个节点\n          ListNode nodeNext = tail.next;\n          tail.next = null;\n          // 记录新的尾节点\n          ListNode newTail = node.next;\n        \n          ListNode firstNode = newTail;\n          ListNode prev = null;\n        \n          while (firstNode != null) {\n            ListNode next = firstNode.next;\n            firstNode.next = prev;\n            prev = firstNode;\n            firstNode = next;\n          }\n        \n          // 此时prev指向反转后的第一个节点\n          node.next = prev;\n          newTail.next = nodeNext; \n        \n          // node要指向下一段\n          node = newTail;\n        }\n      \n        return dummpy.next;\n    }\n}\n```\n13. （反问）base和业务：美团到店结算交易平台\n\n## 美团二面\n（3.31，52min）\n\n1. 自我介绍\n2. 实时协同编程系统参与了什么工作\n3. 实时协同编程环境中遇到了什么问题\n4. 归宿项目中负责了什么工作\n5. 最左匹配原则\n6. 那(经度，纬度) 联合索引可以生效吗\n7. 介绍JVM\n8. 介绍垃圾回收算法\n9. 你们平时使用什么垃圾回收算法\n10. Java中四种垃圾回收机制\n11. 软引用是Full GC的时候回收吗\n12. Java中的设计模式了解如何\n13. 为面试准备了多久，如何学习\n14. 一个月时间如何更快学习\n15. （算法）124 二叉树中最大路径和+改造为方法线程安全的单例模式\n\n```java\n// 代码中已指定的类名、方法名、参数名，请勿修改，直接返回方法规定的值即可\n\n/**\n * Definition for a binary tree node. \n *  public class TreeNode { \n *      int val; \n *      TreeNode left; \n *      TreeNode right; \n *      TreeNode() {} \n *      TreeNode(int val) { this.val = val; } \n *      TreeNode(int val, TreeNode left, TreeNode right) { \n *          this.val = val; \n *          this.left = left; \n *          this.right = right; \n *      }\n *  } \n *  \n**/\nclass Solution {\n  \n    private static volatile Solution instance;\n  \n    private Solution() {\n      // initialize\n    }\n  \n    public static Solution getInstance() {\n      if (instance == null) {\n        synchronized (Solution.class) {\n          if (instance == null) {\n            instance = new Instance();\n          }\n        }\n      }\n      return instance;\n    }\n  \n  \n  \n    private volatile int maxVal = Integer.MIN_VALUE;\n  \n    public int maxPathSum2(TreeNode root) {\n      int maxValCur = Integer.MIN_VALUE;\n      // Deque\n      Deque<TreeNode> deque = new ArrayDeque<>();\n    \n      deque.add(root);\n      // and so on\n    }\n  \n   \n    public synchronized int maxPathSum(TreeNode root) {\n        maxVal = Integer.MIN_VALUE;\n        maxPathSumHelper(root);\n        return maxVal;\n    }\n  \n    private synchronized int maxPathSumHelper(TreeNode node) {\n      if (node == null) {\n        return 0;\n      }\n      // 获取子树的最大val\n      int leftVal = maxPathSumHelper(node.left);\n      int rightVal = maxPathSumHelper(node.right);\n    \n      // 查看能否被更新\n      int newVal = Math.max(0, leftVal) + Math.max(0, rightVal) + node.val;\n      maxVal = Math.max(maxVal, newVal);\n    \n      return Math.max(0, Math.max(leftVal, rightVal)) + node.val;\n    }\n}\n```","source":"_posts/2025/暑期实习-美团面试.md","raw":"---\ntitle: 暑期实习-美团面试\ndate: 2025-10-31 00:06:00\ncover: https://upic-1301780692.cos.ap-shanghai.myqcloud.com/u=3581427709,860796011&fm=253&app=138&f=JPEG-20251031-101635.jpeg\ntag: 暑期实习\n---\n\n# 暑期实习-美团面试\n\n## 笔试\n3.22，ac了2.2\n\n最后一题需要查看一下思路\n\n\n## 美团AI面\n1. TCP和UDP的区别，适用于什么场景\n2. Java的内部类是什么？介绍一下匿名内部类\n3. 垃圾回收是什么？如何触发垃圾回收\n4. 介绍聚簇索引和非聚簇索引\n5. 介绍5种Java集合，以及特点\n6. 如何保证商品不出现超卖\n7. 介绍如何去学习的\n8. 介绍解决某个问题是否需要投入大量时间，从哪些方面考虑\n9. 未来三年的职业规划\n\n\n## 美团一面\n（3.27，47min）\n\n1. 自我介绍\n2. 最能体现技术能力的项目介绍\n3. 如何设计实现一个定时任务执行器\n4. 如果不希望cpu空转，如何设计一个定时任务执行器\n5. 实习项目用到了Spring Task定时任务，说一说\n6. 介绍令牌桶算法\n7. 哪些地方应用到了惰性机制\n8. 介绍项目中提到的冗余表和索引\n9. 是否遇到过索引失效\n10. 数据区分度足够高，如何建立索引：select * from table where x = 1 and y < 1 order by z;\n11. 是否存在查询同时使用两个索引的情况；\n12. 算法：K个一组反转链表\n\n```java\n// 代码中已指定的类名、方法名、参数名，请勿修改，直接返回方法规定的值即可\n\nclass Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        if (k <= 1) {\n          return head;\n        }\n      \n        ListNode dummpy = new ListNode(0, head);\n        // 找到末尾的k个节点\n        ListNode node = dummpy;\n      \n        while (node != null) {\n          // 获取后k个节点\n          boolean hasKNode = true;\n          ListNode tail = node;\n          for (int i = 0; i < k; ++i) {\n            tail = tail.next;\n            if (tail == null) {\n              hasKNode = false;\n              break;\n            }\n          }\n          // 如果剩下部分不存在K个节点\n          if (!hasKNode) {\n            break;\n          }\n        \n          // 反转这k个节点\n          ListNode nodeNext = tail.next;\n          tail.next = null;\n          // 记录新的尾节点\n          ListNode newTail = node.next;\n        \n          ListNode firstNode = newTail;\n          ListNode prev = null;\n        \n          while (firstNode != null) {\n            ListNode next = firstNode.next;\n            firstNode.next = prev;\n            prev = firstNode;\n            firstNode = next;\n          }\n        \n          // 此时prev指向反转后的第一个节点\n          node.next = prev;\n          newTail.next = nodeNext; \n        \n          // node要指向下一段\n          node = newTail;\n        }\n      \n        return dummpy.next;\n    }\n}\n```\n13. （反问）base和业务：美团到店结算交易平台\n\n## 美团二面\n（3.31，52min）\n\n1. 自我介绍\n2. 实时协同编程系统参与了什么工作\n3. 实时协同编程环境中遇到了什么问题\n4. 归宿项目中负责了什么工作\n5. 最左匹配原则\n6. 那(经度，纬度) 联合索引可以生效吗\n7. 介绍JVM\n8. 介绍垃圾回收算法\n9. 你们平时使用什么垃圾回收算法\n10. Java中四种垃圾回收机制\n11. 软引用是Full GC的时候回收吗\n12. Java中的设计模式了解如何\n13. 为面试准备了多久，如何学习\n14. 一个月时间如何更快学习\n15. （算法）124 二叉树中最大路径和+改造为方法线程安全的单例模式\n\n```java\n// 代码中已指定的类名、方法名、参数名，请勿修改，直接返回方法规定的值即可\n\n/**\n * Definition for a binary tree node. \n *  public class TreeNode { \n *      int val; \n *      TreeNode left; \n *      TreeNode right; \n *      TreeNode() {} \n *      TreeNode(int val) { this.val = val; } \n *      TreeNode(int val, TreeNode left, TreeNode right) { \n *          this.val = val; \n *          this.left = left; \n *          this.right = right; \n *      }\n *  } \n *  \n**/\nclass Solution {\n  \n    private static volatile Solution instance;\n  \n    private Solution() {\n      // initialize\n    }\n  \n    public static Solution getInstance() {\n      if (instance == null) {\n        synchronized (Solution.class) {\n          if (instance == null) {\n            instance = new Instance();\n          }\n        }\n      }\n      return instance;\n    }\n  \n  \n  \n    private volatile int maxVal = Integer.MIN_VALUE;\n  \n    public int maxPathSum2(TreeNode root) {\n      int maxValCur = Integer.MIN_VALUE;\n      // Deque\n      Deque<TreeNode> deque = new ArrayDeque<>();\n    \n      deque.add(root);\n      // and so on\n    }\n  \n   \n    public synchronized int maxPathSum(TreeNode root) {\n        maxVal = Integer.MIN_VALUE;\n        maxPathSumHelper(root);\n        return maxVal;\n    }\n  \n    private synchronized int maxPathSumHelper(TreeNode node) {\n      if (node == null) {\n        return 0;\n      }\n      // 获取子树的最大val\n      int leftVal = maxPathSumHelper(node.left);\n      int rightVal = maxPathSumHelper(node.right);\n    \n      // 查看能否被更新\n      int newVal = Math.max(0, leftVal) + Math.max(0, rightVal) + node.val;\n      maxVal = Math.max(maxVal, newVal);\n    \n      return Math.max(0, Math.max(leftVal, rightVal)) + node.val;\n    }\n}\n```","slug":"2025/暑期实习-美团面试","published":1,"updated":"2025-10-31T02:18:15.375Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmhg4qt4h000yf5fa3s222pcy","content":"<h1 id=\"暑期实习-美团面试\"><a href=\"#暑期实习-美团面试\" class=\"headerlink\" title=\"暑期实习-美团面试\"></a>暑期实习-美团面试</h1><h2 id=\"笔试\"><a href=\"#笔试\" class=\"headerlink\" title=\"笔试\"></a>笔试</h2><p>3.22，ac了2.2</p>\n<p>最后一题需要查看一下思路</p>\n<h2 id=\"美团AI面\"><a href=\"#美团AI面\" class=\"headerlink\" title=\"美团AI面\"></a>美团AI面</h2><ol>\n<li>TCP和UDP的区别，适用于什么场景</li>\n<li>Java的内部类是什么？介绍一下匿名内部类</li>\n<li>垃圾回收是什么？如何触发垃圾回收</li>\n<li>介绍聚簇索引和非聚簇索引</li>\n<li>介绍5种Java集合，以及特点</li>\n<li>如何保证商品不出现超卖</li>\n<li>介绍如何去学习的</li>\n<li>介绍解决某个问题是否需要投入大量时间，从哪些方面考虑</li>\n<li>未来三年的职业规划</li>\n</ol>\n<h2 id=\"美团一面\"><a href=\"#美团一面\" class=\"headerlink\" title=\"美团一面\"></a>美团一面</h2><p>（3.27，47min）</p>\n<ol>\n<li>自我介绍</li>\n<li>最能体现技术能力的项目介绍</li>\n<li>如何设计实现一个定时任务执行器</li>\n<li>如果不希望cpu空转，如何设计一个定时任务执行器</li>\n<li>实习项目用到了Spring Task定时任务，说一说</li>\n<li>介绍令牌桶算法</li>\n<li>哪些地方应用到了惰性机制</li>\n<li>介绍项目中提到的冗余表和索引</li>\n<li>是否遇到过索引失效</li>\n<li>数据区分度足够高，如何建立索引：select * from table where x = 1 and y &lt; 1 order by z;</li>\n<li>是否存在查询同时使用两个索引的情况；</li>\n<li>算法：K个一组反转链表</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码中已指定的类名、方法名、参数名，请勿修改，直接返回方法规定的值即可</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">reverseKGroup</span><span class=\"params\">(ListNode head, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">        ListNode dummpy = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>, head);</span><br><span class=\"line\">        <span class=\"comment\">// 找到末尾的k个节点</span></span><br><span class=\"line\">        ListNode node = dummpy;</span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (node != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 获取后k个节点</span></span><br><span class=\"line\">          <span class=\"keyword\">boolean</span> hasKNode = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">          ListNode tail = node;</span><br><span class=\"line\">          <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; k; ++i) &#123;</span><br><span class=\"line\">            tail = tail.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tail == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">              hasKNode = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"comment\">// 如果剩下部分不存在K个节点</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (!hasKNode) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">          <span class=\"comment\">// 反转这k个节点</span></span><br><span class=\"line\">          ListNode nodeNext = tail.next;</span><br><span class=\"line\">          tail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">          <span class=\"comment\">// 记录新的尾节点</span></span><br><span class=\"line\">          ListNode newTail = node.next;</span><br><span class=\"line\">        </span><br><span class=\"line\">          ListNode firstNode = newTail;</span><br><span class=\"line\">          ListNode prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">          <span class=\"keyword\">while</span> (firstNode != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            ListNode next = firstNode.next;</span><br><span class=\"line\">            firstNode.next = prev;</span><br><span class=\"line\">            prev = firstNode;</span><br><span class=\"line\">            firstNode = next;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">          <span class=\"comment\">// 此时prev指向反转后的第一个节点</span></span><br><span class=\"line\">          node.next = prev;</span><br><span class=\"line\">          newTail.next = nodeNext; </span><br><span class=\"line\">        </span><br><span class=\"line\">          <span class=\"comment\">// node要指向下一段</span></span><br><span class=\"line\">          node = newTail;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummpy.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"13\">\n<li>（反问）base和业务：美团到店结算交易平台</li>\n</ol>\n<h2 id=\"美团二面\"><a href=\"#美团二面\" class=\"headerlink\" title=\"美团二面\"></a>美团二面</h2><p>（3.31，52min）</p>\n<ol>\n<li>自我介绍</li>\n<li>实时协同编程系统参与了什么工作</li>\n<li>实时协同编程环境中遇到了什么问题</li>\n<li>归宿项目中负责了什么工作</li>\n<li>最左匹配原则</li>\n<li>那(经度，纬度) 联合索引可以生效吗</li>\n<li>介绍JVM</li>\n<li>介绍垃圾回收算法</li>\n<li>你们平时使用什么垃圾回收算法</li>\n<li>Java中四种垃圾回收机制</li>\n<li>软引用是Full GC的时候回收吗</li>\n<li>Java中的设计模式了解如何</li>\n<li>为面试准备了多久，如何学习</li>\n<li>一个月时间如何更快学习</li>\n<li>（算法）124 二叉树中最大路径和+改造为方法线程安全的单例模式</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码中已指定的类名、方法名、参数名，请勿修改，直接返回方法规定的值即可</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node. </span></span><br><span class=\"line\"><span class=\"comment\"> *  public class TreeNode &#123; </span></span><br><span class=\"line\"><span class=\"comment\"> *      int val; </span></span><br><span class=\"line\"><span class=\"comment\"> *      TreeNode left; </span></span><br><span class=\"line\"><span class=\"comment\"> *      TreeNode right; </span></span><br><span class=\"line\"><span class=\"comment\"> *      TreeNode() &#123;&#125; </span></span><br><span class=\"line\"><span class=\"comment\"> *      TreeNode(int val) &#123; this.val = val; &#125; </span></span><br><span class=\"line\"><span class=\"comment\"> *      TreeNode(int val, TreeNode left, TreeNode right) &#123; </span></span><br><span class=\"line\"><span class=\"comment\"> *          this.val = val; </span></span><br><span class=\"line\"><span class=\"comment\"> *          this.left = left; </span></span><br><span class=\"line\"><span class=\"comment\"> *          this.right = right; </span></span><br><span class=\"line\"><span class=\"comment\"> *      &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *  &#125; </span></span><br><span class=\"line\"><span class=\"comment\"> *  </span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> Solution instance;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Solution</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// initialize</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Solution <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (Solution.class) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> Instance();</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> maxVal = Integer.MIN_VALUE;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxPathSum2</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> maxValCur = Integer.MIN_VALUE;</span><br><span class=\"line\">      <span class=\"comment\">// Deque</span></span><br><span class=\"line\">      Deque&lt;TreeNode&gt; deque = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</span><br><span class=\"line\">    </span><br><span class=\"line\">      deque.add(root);</span><br><span class=\"line\">      <span class=\"comment\">// and so on</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">int</span> <span class=\"title\">maxPathSum</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        maxVal = Integer.MIN_VALUE;</span><br><span class=\"line\">        maxPathSumHelper(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxVal;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">int</span> <span class=\"title\">maxPathSumHelper</span><span class=\"params\">(TreeNode node)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 获取子树的最大val</span></span><br><span class=\"line\">      <span class=\"keyword\">int</span> leftVal = maxPathSumHelper(node.left);</span><br><span class=\"line\">      <span class=\"keyword\">int</span> rightVal = maxPathSumHelper(node.right);</span><br><span class=\"line\">    </span><br><span class=\"line\">      <span class=\"comment\">// 查看能否被更新</span></span><br><span class=\"line\">      <span class=\"keyword\">int</span> newVal = Math.max(<span class=\"number\">0</span>, leftVal) + Math.max(<span class=\"number\">0</span>, rightVal) + node.val;</span><br><span class=\"line\">      maxVal = Math.max(maxVal, newVal);</span><br><span class=\"line\">    </span><br><span class=\"line\">      <span class=\"keyword\">return</span> Math.max(<span class=\"number\">0</span>, Math.max(leftVal, rightVal)) + node.val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<h1 id=\"暑期实习-美团面试\"><a href=\"#暑期实习-美团面试\" class=\"headerlink\" title=\"暑期实习-美团面试\"></a>暑期实习-美团面试</h1><h2 id=\"笔试\"><a href=\"#笔试\" class=\"headerlink\" title=\"笔试\"></a>笔试</h2><p>3.22，ac了2.2</p>\n<p>最后一题需要查看一下思路</p>\n<h2 id=\"美团AI面\"><a href=\"#美团AI面\" class=\"headerlink\" title=\"美团AI面\"></a>美团AI面</h2><ol>\n<li>TCP和UDP的区别，适用于什么场景</li>\n<li>Java的内部类是什么？介绍一下匿名内部类</li>\n<li>垃圾回收是什么？如何触发垃圾回收</li>\n<li>介绍聚簇索引和非聚簇索引</li>\n<li>介绍5种Java集合，以及特点</li>\n<li>如何保证商品不出现超卖</li>\n<li>介绍如何去学习的</li>\n<li>介绍解决某个问题是否需要投入大量时间，从哪些方面考虑</li>\n<li>未来三年的职业规划</li>\n</ol>\n<h2 id=\"美团一面\"><a href=\"#美团一面\" class=\"headerlink\" title=\"美团一面\"></a>美团一面</h2><p>（3.27，47min）</p>\n<ol>\n<li>自我介绍</li>\n<li>最能体现技术能力的项目介绍</li>\n<li>如何设计实现一个定时任务执行器</li>\n<li>如果不希望cpu空转，如何设计一个定时任务执行器</li>\n<li>实习项目用到了Spring Task定时任务，说一说</li>\n<li>介绍令牌桶算法</li>\n<li>哪些地方应用到了惰性机制</li>\n<li>介绍项目中提到的冗余表和索引</li>\n<li>是否遇到过索引失效</li>\n<li>数据区分度足够高，如何建立索引：select * from table where x = 1 and y &lt; 1 order by z;</li>\n<li>是否存在查询同时使用两个索引的情况；</li>\n<li>算法：K个一组反转链表</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码中已指定的类名、方法名、参数名，请勿修改，直接返回方法规定的值即可</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">reverseKGroup</span><span class=\"params\">(ListNode head, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">        ListNode dummpy = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>, head);</span><br><span class=\"line\">        <span class=\"comment\">// 找到末尾的k个节点</span></span><br><span class=\"line\">        ListNode node = dummpy;</span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (node != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 获取后k个节点</span></span><br><span class=\"line\">          <span class=\"keyword\">boolean</span> hasKNode = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">          ListNode tail = node;</span><br><span class=\"line\">          <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; k; ++i) &#123;</span><br><span class=\"line\">            tail = tail.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tail == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">              hasKNode = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">              <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"comment\">// 如果剩下部分不存在K个节点</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (!hasKNode) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">          <span class=\"comment\">// 反转这k个节点</span></span><br><span class=\"line\">          ListNode nodeNext = tail.next;</span><br><span class=\"line\">          tail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">          <span class=\"comment\">// 记录新的尾节点</span></span><br><span class=\"line\">          ListNode newTail = node.next;</span><br><span class=\"line\">        </span><br><span class=\"line\">          ListNode firstNode = newTail;</span><br><span class=\"line\">          ListNode prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">          <span class=\"keyword\">while</span> (firstNode != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            ListNode next = firstNode.next;</span><br><span class=\"line\">            firstNode.next = prev;</span><br><span class=\"line\">            prev = firstNode;</span><br><span class=\"line\">            firstNode = next;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">          <span class=\"comment\">// 此时prev指向反转后的第一个节点</span></span><br><span class=\"line\">          node.next = prev;</span><br><span class=\"line\">          newTail.next = nodeNext; </span><br><span class=\"line\">        </span><br><span class=\"line\">          <span class=\"comment\">// node要指向下一段</span></span><br><span class=\"line\">          node = newTail;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummpy.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"13\">\n<li>（反问）base和业务：美团到店结算交易平台</li>\n</ol>\n<h2 id=\"美团二面\"><a href=\"#美团二面\" class=\"headerlink\" title=\"美团二面\"></a>美团二面</h2><p>（3.31，52min）</p>\n<ol>\n<li>自我介绍</li>\n<li>实时协同编程系统参与了什么工作</li>\n<li>实时协同编程环境中遇到了什么问题</li>\n<li>归宿项目中负责了什么工作</li>\n<li>最左匹配原则</li>\n<li>那(经度，纬度) 联合索引可以生效吗</li>\n<li>介绍JVM</li>\n<li>介绍垃圾回收算法</li>\n<li>你们平时使用什么垃圾回收算法</li>\n<li>Java中四种垃圾回收机制</li>\n<li>软引用是Full GC的时候回收吗</li>\n<li>Java中的设计模式了解如何</li>\n<li>为面试准备了多久，如何学习</li>\n<li>一个月时间如何更快学习</li>\n<li>（算法）124 二叉树中最大路径和+改造为方法线程安全的单例模式</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 代码中已指定的类名、方法名、参数名，请勿修改，直接返回方法规定的值即可</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node. </span></span><br><span class=\"line\"><span class=\"comment\"> *  public class TreeNode &#123; </span></span><br><span class=\"line\"><span class=\"comment\"> *      int val; </span></span><br><span class=\"line\"><span class=\"comment\"> *      TreeNode left; </span></span><br><span class=\"line\"><span class=\"comment\"> *      TreeNode right; </span></span><br><span class=\"line\"><span class=\"comment\"> *      TreeNode() &#123;&#125; </span></span><br><span class=\"line\"><span class=\"comment\"> *      TreeNode(int val) &#123; this.val = val; &#125; </span></span><br><span class=\"line\"><span class=\"comment\"> *      TreeNode(int val, TreeNode left, TreeNode right) &#123; </span></span><br><span class=\"line\"><span class=\"comment\"> *          this.val = val; </span></span><br><span class=\"line\"><span class=\"comment\"> *          this.left = left; </span></span><br><span class=\"line\"><span class=\"comment\"> *          this.right = right; </span></span><br><span class=\"line\"><span class=\"comment\"> *      &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *  &#125; </span></span><br><span class=\"line\"><span class=\"comment\"> *  </span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> Solution instance;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Solution</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// initialize</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Solution <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (Solution.class) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> Instance();</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> maxVal = Integer.MIN_VALUE;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxPathSum2</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> maxValCur = Integer.MIN_VALUE;</span><br><span class=\"line\">      <span class=\"comment\">// Deque</span></span><br><span class=\"line\">      Deque&lt;TreeNode&gt; deque = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</span><br><span class=\"line\">    </span><br><span class=\"line\">      deque.add(root);</span><br><span class=\"line\">      <span class=\"comment\">// and so on</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">int</span> <span class=\"title\">maxPathSum</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        maxVal = Integer.MIN_VALUE;</span><br><span class=\"line\">        maxPathSumHelper(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxVal;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">int</span> <span class=\"title\">maxPathSumHelper</span><span class=\"params\">(TreeNode node)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 获取子树的最大val</span></span><br><span class=\"line\">      <span class=\"keyword\">int</span> leftVal = maxPathSumHelper(node.left);</span><br><span class=\"line\">      <span class=\"keyword\">int</span> rightVal = maxPathSumHelper(node.right);</span><br><span class=\"line\">    </span><br><span class=\"line\">      <span class=\"comment\">// 查看能否被更新</span></span><br><span class=\"line\">      <span class=\"keyword\">int</span> newVal = Math.max(<span class=\"number\">0</span>, leftVal) + Math.max(<span class=\"number\">0</span>, rightVal) + node.val;</span><br><span class=\"line\">      maxVal = Math.max(maxVal, newVal);</span><br><span class=\"line\">    </span><br><span class=\"line\">      <span class=\"keyword\">return</span> Math.max(<span class=\"number\">0</span>, Math.max(leftVal, rightVal)) + node.val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"暑期实习-腾讯面试","date":"2025-10-30T16:00:00.000Z","cover":"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20251031095108945-20251031-095110.png","_content":"\n# 暑期实习-腾讯面试\n\n## 腾讯一面\n（2.21投递，3.3，40min）\n1. 个人经历介绍\n2. 实验室项目介绍，简历项目介绍\n3. 实习经历介绍：SQL优化在哪里做的\n4. java中protected和private有什么区别  \n5. Java中一定无法获取到其他类的private变量吗\n6. Java的集合\n7. TreeMap的底层是什么\n8. 红黑树是什么，时间复杂度是多少\n9. 了解java中的锁吗\n10. 如何创建一个线程\n11. 用过什么线程池\n12. Spring的IOC和AOP\n13. 了解什么设计模式\n14. 贪心算法和动态规划有什么区别：（1）贪心：贪心选择策略和最优子结构；（2）动态规划：重叠子问题、最优子结构\n15. B树和B+树有什么区别\n16. MVCC了解吗\n17. redo log和undo log\n18. SQL的执行过程\n19. tcp的四次挥手\n20. （算法）删除链表倒数第N个节点：写完介绍思路；测试了一下边界条件，len=1，n=1\n\n## 腾讯二面\n（3.6，30min）\n\n1. 开发团队介绍\n2. 自我介绍\n3. 项目经历介绍\n4. 项目经历提到了redis，redis如何保证缓存一致（很长的讨论，最后漏了监听binlog写入redis）\n5. 实习项目介绍\n6. 实习项目提到了主要通过索引进行优化，索引B+树和B树的优势\n7. Mysql从底层来说，如何能更快的查询（很长的讨论，似乎最后他想要的听到的是和Buffer Pool有些关系）\n\n\n## 腾讯三面\n（3.13，50min，交叉面）\n\n1. 自我介绍\n2. 介绍HashMap数据结构\n3. 如果要用HashMap实现元素快速遍历，如何去做\n4. 在此基础上，需要对元素实现快速插入和删除，如何去做\n5. 数据库的join操作时间复杂度\n6. 仿照着上面的技术方案，如何优化join操作（hash join）\n7. 仿照上面的技术方案hash join可能的数据结构\n8. 并发场景下，hash join可能怎么做\n9. 如果两张表有时间属性，如何加快hash join\n10. redis简单介绍\n11. redis的aof是如何做的（子进程）\n12. 父子进程通信方式（匿名管道）\n13. 虚拟地址如何对应到物理地址\n14. 子进程是如何拷贝父进程数据的\n15. 跳表的数据结构\n16. zset的应用场景\n\n\n## 腾讯四面\n\n（3.17，23min）\n\n1. 自我介绍\n2. 项目介绍（继续介绍实时协同编程）\n3. 项目中引入redis可能会带来什么问题\n4. 如何确保redis和mysql的数据一致性\n5. 在这个过程中，可能会出现什么故障\n6. 监听binlog的过程可能会发生什么问题\n7. 职业发展及规划\n8. 反问\n\n\n## 腾讯HR面\n（3.22，12min）\n\n1. 对之前四轮面试感受如何\n2. 介绍印象最深的项目\n3. 项目过程中遇到的挑战\n4. 如果现在去做，哪些地方可以优化\n5. 项目过程中遇到的沟通上的问题\n6. （例行问题）有没有亲属、没有大病\n7. 老家在哪里，是否支持上海工作\n8. （反问）是否有导师；base在上海吗；是否有转正机会\n\n> 最终通过了，暑期实习也是在腾讯参加的。\n> 四面的原因应当是因为自己的base地选在了上海，所以加了一轮面试","source":"_posts/2025/暑期实习-腾讯面试.md","raw":"---\ntitle: 暑期实习-腾讯面试\ndate: 2025-10-31 00:00:00\ncover: https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20251031095108945-20251031-095110.png\ntag: 暑期实习\n---\n\n# 暑期实习-腾讯面试\n\n## 腾讯一面\n（2.21投递，3.3，40min）\n1. 个人经历介绍\n2. 实验室项目介绍，简历项目介绍\n3. 实习经历介绍：SQL优化在哪里做的\n4. java中protected和private有什么区别  \n5. Java中一定无法获取到其他类的private变量吗\n6. Java的集合\n7. TreeMap的底层是什么\n8. 红黑树是什么，时间复杂度是多少\n9. 了解java中的锁吗\n10. 如何创建一个线程\n11. 用过什么线程池\n12. Spring的IOC和AOP\n13. 了解什么设计模式\n14. 贪心算法和动态规划有什么区别：（1）贪心：贪心选择策略和最优子结构；（2）动态规划：重叠子问题、最优子结构\n15. B树和B+树有什么区别\n16. MVCC了解吗\n17. redo log和undo log\n18. SQL的执行过程\n19. tcp的四次挥手\n20. （算法）删除链表倒数第N个节点：写完介绍思路；测试了一下边界条件，len=1，n=1\n\n## 腾讯二面\n（3.6，30min）\n\n1. 开发团队介绍\n2. 自我介绍\n3. 项目经历介绍\n4. 项目经历提到了redis，redis如何保证缓存一致（很长的讨论，最后漏了监听binlog写入redis）\n5. 实习项目介绍\n6. 实习项目提到了主要通过索引进行优化，索引B+树和B树的优势\n7. Mysql从底层来说，如何能更快的查询（很长的讨论，似乎最后他想要的听到的是和Buffer Pool有些关系）\n\n\n## 腾讯三面\n（3.13，50min，交叉面）\n\n1. 自我介绍\n2. 介绍HashMap数据结构\n3. 如果要用HashMap实现元素快速遍历，如何去做\n4. 在此基础上，需要对元素实现快速插入和删除，如何去做\n5. 数据库的join操作时间复杂度\n6. 仿照着上面的技术方案，如何优化join操作（hash join）\n7. 仿照上面的技术方案hash join可能的数据结构\n8. 并发场景下，hash join可能怎么做\n9. 如果两张表有时间属性，如何加快hash join\n10. redis简单介绍\n11. redis的aof是如何做的（子进程）\n12. 父子进程通信方式（匿名管道）\n13. 虚拟地址如何对应到物理地址\n14. 子进程是如何拷贝父进程数据的\n15. 跳表的数据结构\n16. zset的应用场景\n\n\n## 腾讯四面\n\n（3.17，23min）\n\n1. 自我介绍\n2. 项目介绍（继续介绍实时协同编程）\n3. 项目中引入redis可能会带来什么问题\n4. 如何确保redis和mysql的数据一致性\n5. 在这个过程中，可能会出现什么故障\n6. 监听binlog的过程可能会发生什么问题\n7. 职业发展及规划\n8. 反问\n\n\n## 腾讯HR面\n（3.22，12min）\n\n1. 对之前四轮面试感受如何\n2. 介绍印象最深的项目\n3. 项目过程中遇到的挑战\n4. 如果现在去做，哪些地方可以优化\n5. 项目过程中遇到的沟通上的问题\n6. （例行问题）有没有亲属、没有大病\n7. 老家在哪里，是否支持上海工作\n8. （反问）是否有导师；base在上海吗；是否有转正机会\n\n> 最终通过了，暑期实习也是在腾讯参加的。\n> 四面的原因应当是因为自己的base地选在了上海，所以加了一轮面试","slug":"2025/暑期实习-腾讯面试","published":1,"updated":"2025-10-31T01:52:33.223Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmhg4qt4l0011f5faf5hfhz53","content":"<h1 id=\"暑期实习-腾讯面试\"><a href=\"#暑期实习-腾讯面试\" class=\"headerlink\" title=\"暑期实习-腾讯面试\"></a>暑期实习-腾讯面试</h1><h2 id=\"腾讯一面\"><a href=\"#腾讯一面\" class=\"headerlink\" title=\"腾讯一面\"></a>腾讯一面</h2><p>（2.21投递，3.3，40min）</p>\n<ol>\n<li>个人经历介绍</li>\n<li>实验室项目介绍，简历项目介绍</li>\n<li>实习经历介绍：SQL优化在哪里做的</li>\n<li>java中protected和private有什么区别  </li>\n<li>Java中一定无法获取到其他类的private变量吗</li>\n<li>Java的集合</li>\n<li>TreeMap的底层是什么</li>\n<li>红黑树是什么，时间复杂度是多少</li>\n<li>了解java中的锁吗</li>\n<li>如何创建一个线程</li>\n<li>用过什么线程池</li>\n<li>Spring的IOC和AOP</li>\n<li>了解什么设计模式</li>\n<li>贪心算法和动态规划有什么区别：（1）贪心：贪心选择策略和最优子结构；（2）动态规划：重叠子问题、最优子结构</li>\n<li>B树和B+树有什么区别</li>\n<li>MVCC了解吗</li>\n<li>redo log和undo log</li>\n<li>SQL的执行过程</li>\n<li>tcp的四次挥手</li>\n<li>（算法）删除链表倒数第N个节点：写完介绍思路；测试了一下边界条件，len=1，n=1</li>\n</ol>\n<h2 id=\"腾讯二面\"><a href=\"#腾讯二面\" class=\"headerlink\" title=\"腾讯二面\"></a>腾讯二面</h2><p>（3.6，30min）</p>\n<ol>\n<li>开发团队介绍</li>\n<li>自我介绍</li>\n<li>项目经历介绍</li>\n<li>项目经历提到了redis，redis如何保证缓存一致（很长的讨论，最后漏了监听binlog写入redis）</li>\n<li>实习项目介绍</li>\n<li>实习项目提到了主要通过索引进行优化，索引B+树和B树的优势</li>\n<li>Mysql从底层来说，如何能更快的查询（很长的讨论，似乎最后他想要的听到的是和Buffer Pool有些关系）</li>\n</ol>\n<h2 id=\"腾讯三面\"><a href=\"#腾讯三面\" class=\"headerlink\" title=\"腾讯三面\"></a>腾讯三面</h2><p>（3.13，50min，交叉面）</p>\n<ol>\n<li>自我介绍</li>\n<li>介绍HashMap数据结构</li>\n<li>如果要用HashMap实现元素快速遍历，如何去做</li>\n<li>在此基础上，需要对元素实现快速插入和删除，如何去做</li>\n<li>数据库的join操作时间复杂度</li>\n<li>仿照着上面的技术方案，如何优化join操作（hash join）</li>\n<li>仿照上面的技术方案hash join可能的数据结构</li>\n<li>并发场景下，hash join可能怎么做</li>\n<li>如果两张表有时间属性，如何加快hash join</li>\n<li>redis简单介绍</li>\n<li>redis的aof是如何做的（子进程）</li>\n<li>父子进程通信方式（匿名管道）</li>\n<li>虚拟地址如何对应到物理地址</li>\n<li>子进程是如何拷贝父进程数据的</li>\n<li>跳表的数据结构</li>\n<li>zset的应用场景</li>\n</ol>\n<h2 id=\"腾讯四面\"><a href=\"#腾讯四面\" class=\"headerlink\" title=\"腾讯四面\"></a>腾讯四面</h2><p>（3.17，23min）</p>\n<ol>\n<li>自我介绍</li>\n<li>项目介绍（继续介绍实时协同编程）</li>\n<li>项目中引入redis可能会带来什么问题</li>\n<li>如何确保redis和mysql的数据一致性</li>\n<li>在这个过程中，可能会出现什么故障</li>\n<li>监听binlog的过程可能会发生什么问题</li>\n<li>职业发展及规划</li>\n<li>反问</li>\n</ol>\n<h2 id=\"腾讯HR面\"><a href=\"#腾讯HR面\" class=\"headerlink\" title=\"腾讯HR面\"></a>腾讯HR面</h2><p>（3.22，12min）</p>\n<ol>\n<li>对之前四轮面试感受如何</li>\n<li>介绍印象最深的项目</li>\n<li>项目过程中遇到的挑战</li>\n<li>如果现在去做，哪些地方可以优化</li>\n<li>项目过程中遇到的沟通上的问题</li>\n<li>（例行问题）有没有亲属、没有大病</li>\n<li>老家在哪里，是否支持上海工作</li>\n<li>（反问）是否有导师；base在上海吗；是否有转正机会</li>\n</ol>\n<blockquote>\n<p>最终通过了，暑期实习也是在腾讯参加的。<br>四面的原因应当是因为自己的base地选在了上海，所以加了一轮面试</p>\n</blockquote>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<h1 id=\"暑期实习-腾讯面试\"><a href=\"#暑期实习-腾讯面试\" class=\"headerlink\" title=\"暑期实习-腾讯面试\"></a>暑期实习-腾讯面试</h1><h2 id=\"腾讯一面\"><a href=\"#腾讯一面\" class=\"headerlink\" title=\"腾讯一面\"></a>腾讯一面</h2><p>（2.21投递，3.3，40min）</p>\n<ol>\n<li>个人经历介绍</li>\n<li>实验室项目介绍，简历项目介绍</li>\n<li>实习经历介绍：SQL优化在哪里做的</li>\n<li>java中protected和private有什么区别  </li>\n<li>Java中一定无法获取到其他类的private变量吗</li>\n<li>Java的集合</li>\n<li>TreeMap的底层是什么</li>\n<li>红黑树是什么，时间复杂度是多少</li>\n<li>了解java中的锁吗</li>\n<li>如何创建一个线程</li>\n<li>用过什么线程池</li>\n<li>Spring的IOC和AOP</li>\n<li>了解什么设计模式</li>\n<li>贪心算法和动态规划有什么区别：（1）贪心：贪心选择策略和最优子结构；（2）动态规划：重叠子问题、最优子结构</li>\n<li>B树和B+树有什么区别</li>\n<li>MVCC了解吗</li>\n<li>redo log和undo log</li>\n<li>SQL的执行过程</li>\n<li>tcp的四次挥手</li>\n<li>（算法）删除链表倒数第N个节点：写完介绍思路；测试了一下边界条件，len=1，n=1</li>\n</ol>\n<h2 id=\"腾讯二面\"><a href=\"#腾讯二面\" class=\"headerlink\" title=\"腾讯二面\"></a>腾讯二面</h2><p>（3.6，30min）</p>\n<ol>\n<li>开发团队介绍</li>\n<li>自我介绍</li>\n<li>项目经历介绍</li>\n<li>项目经历提到了redis，redis如何保证缓存一致（很长的讨论，最后漏了监听binlog写入redis）</li>\n<li>实习项目介绍</li>\n<li>实习项目提到了主要通过索引进行优化，索引B+树和B树的优势</li>\n<li>Mysql从底层来说，如何能更快的查询（很长的讨论，似乎最后他想要的听到的是和Buffer Pool有些关系）</li>\n</ol>\n<h2 id=\"腾讯三面\"><a href=\"#腾讯三面\" class=\"headerlink\" title=\"腾讯三面\"></a>腾讯三面</h2><p>（3.13，50min，交叉面）</p>\n<ol>\n<li>自我介绍</li>\n<li>介绍HashMap数据结构</li>\n<li>如果要用HashMap实现元素快速遍历，如何去做</li>\n<li>在此基础上，需要对元素实现快速插入和删除，如何去做</li>\n<li>数据库的join操作时间复杂度</li>\n<li>仿照着上面的技术方案，如何优化join操作（hash join）</li>\n<li>仿照上面的技术方案hash join可能的数据结构</li>\n<li>并发场景下，hash join可能怎么做</li>\n<li>如果两张表有时间属性，如何加快hash join</li>\n<li>redis简单介绍</li>\n<li>redis的aof是如何做的（子进程）</li>\n<li>父子进程通信方式（匿名管道）</li>\n<li>虚拟地址如何对应到物理地址</li>\n<li>子进程是如何拷贝父进程数据的</li>\n<li>跳表的数据结构</li>\n<li>zset的应用场景</li>\n</ol>\n<h2 id=\"腾讯四面\"><a href=\"#腾讯四面\" class=\"headerlink\" title=\"腾讯四面\"></a>腾讯四面</h2><p>（3.17，23min）</p>\n<ol>\n<li>自我介绍</li>\n<li>项目介绍（继续介绍实时协同编程）</li>\n<li>项目中引入redis可能会带来什么问题</li>\n<li>如何确保redis和mysql的数据一致性</li>\n<li>在这个过程中，可能会出现什么故障</li>\n<li>监听binlog的过程可能会发生什么问题</li>\n<li>职业发展及规划</li>\n<li>反问</li>\n</ol>\n<h2 id=\"腾讯HR面\"><a href=\"#腾讯HR面\" class=\"headerlink\" title=\"腾讯HR面\"></a>腾讯HR面</h2><p>（3.22，12min）</p>\n<ol>\n<li>对之前四轮面试感受如何</li>\n<li>介绍印象最深的项目</li>\n<li>项目过程中遇到的挑战</li>\n<li>如果现在去做，哪些地方可以优化</li>\n<li>项目过程中遇到的沟通上的问题</li>\n<li>（例行问题）有没有亲属、没有大病</li>\n<li>老家在哪里，是否支持上海工作</li>\n<li>（反问）是否有导师；base在上海吗；是否有转正机会</li>\n</ol>\n<blockquote>\n<p>最终通过了，暑期实习也是在腾讯参加的。<br>四面的原因应当是因为自己的base地选在了上海，所以加了一轮面试</p>\n</blockquote>\n"},{"title":"暑期实习-蚂蚁面试","date":"2025-10-30T16:07:00.000Z","cover":"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/u=2193217229,3865826716&fm=253&app=138&f=JPEG-20251031-101944.jpeg","_content":"\n# 暑期实习-蚂蚁面试\n\n## 笔试\n\n（TCP报文数据总量）数据包1400字节，tcp头部20字节，应用层数据大小为1360字节，发送100个数据包，那么传输的字节数是多少？\n\n> 传输的总字节数为 **140,000 字节**（140 KB）\n\numask为022，在创建文件的时候的权限是？\n\n> 当 `umask` 设置为 **022** 时，新创建文件的权限为 **rw-r--r--**（即权限码 `644`）\n>\n> - **umask 作用**： umask 通过**屏蔽（禁用）**权限位来限制默认权限。计算方式为： 实际权限=默认权限 &  umask实际权限=默认权限& umask\n>\n> 文件基础权限：666（rw-rw-rw-），即所有用户可读可写，但不可执行（Linux默认不给文件执行权限）。\n> 目录基础权限：777（rwxrwxrwx），即所有用户可读、写、执行。\n> umask作用：通过按位取反后与基础权限进行逻辑与操作，屏蔽不需要的权限。\n\n（结构型设计模式）责任链模式属于什么类型的设计模式？\n\n> 属于 **行为型设计模式**，其核心目标是解耦请求的发送者与接收者，通过构建链式结构让多个对象依次处理同一请求，直到有对象处理成功或传递至链尾\n\n主键不能为null吗？\n\n> 是的，主键不能为null\n\n对象可以调用线程的run方法吗？\n\n> 是的，对象可以调用线程的 `run()` 方法，但这种方式并不会启动新线程，而是以**同步方式在当前线程中执行** `run()` 方法内的代码。这与 `start()` 方法启动线程的机制有本质区别\n\n以下哪些适合强制缓存？静态图片；css；API\n\n> **强制缓存**适用于内容不频繁变更的静态资源，其核心原理是通过设置 `Cache-Control` 或 `Expires` 响应头\n>\n> 静态图片和css文件适合\n\n（哈夫曼树）(a, 5), (g, 90), (t, 53), (i, 80), (e, 49)构造成哈夫曼树，那么哈夫曼树的权值是多少\n\n```shell\n      277\n     /   \\\n    107   170\n   /  \\   / \\\n  53  54 80 90\n     / \\\n    5  49\n```\n\n做了2.75题\n\n第一题：贪心就行，很简单\n\n第二题：排序+二分就行\n\n第三题：质数筛 + 组合方法？（最后只过了80%）\n\n> int count = new int[10]表示数字0～9的个数，用他们组成不同的排列数如：0，1，1，2可以组成1120，1210，2110，1012，1102，1021，1201，2011，2101，112，121，211（忽略前导0，前导0等价于没有0），那么一共有多少种方式？理论上组合数就能解决，不需要动态规划\n\n做完后思考：想复杂了，其实0当作普通的数字处理即可\n\n```java\nimport java.util.*;\nimport java.io.*;\n\n\n\npublic class Main {\n    static BufferedReader br;\n    static StringTokenizer st;\n\n    static String next() throws IOException {\n        while (!st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return st.nextToken();\n    }\n\n    static Integer nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    static Long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        st = new StringTokenizer(\"\");\n\n        int T = nextInt();\n\n        boolean[] zhishu = new boolean[1001];\n        Arrays.fill(zhishu, true);\n        zhishu[1] = false;\n        zhishu[0] = false;\n        for (int num = 2; num <= 1000; ++num) {\n            if (!zhishu[num]) {\n                continue;\n            }\n            for (int i = 2; i * num <= 1000; i++) {\n                zhishu[i * num] = false;\n            }\n        }\n\n\n        while (T-- > 0) {\n            int x = nextInt();\n\n            // 记录数位之和\n            // 还需要看每个数字有几个\n            int[] count = new int[10];\n            String s = String.valueOf(x);\n            int sum = 0;\n            for (char ch : s.toCharArray()) {\n                int index = ch - '0';\n                count[index]++;\n                sum += index;\n            }\n\n            if (!zhishu[sum]) {\n                System.out.println(0);\n                continue;\n            }\n\n            // 本质就是看这些数字有多少种排列方式\n            // 2 1 0 3 ->\n\n            // 对于放不放0的一些情况\n            // Set<Integer> set = new HashSet<>();\n            int len = s.length();\n\n            // dfs(0, len, 0, count, set);\n            // System.out.println(set.size() - 1);\n\n            long ans = 1;\n\n            int nonZeroCount = len - count[0];\n            // 阶乘\n            for (int i = 2; i <= nonZeroCount; ++i) {\n                ans *= i;\n            }\n            // 除以出现重复的数量\n            for (int num = 1; num <= 9; ++num) {\n                if (count[num] <= 1) {\n                    continue;\n                }\n                // 除以 num的阶乘\n                for (int i = 2; i <= count[num]; ++i) {\n                    ans /= i;\n                }\n            }\n\n            // 接下来再把0塞进去\n            // 0 有nonZeroCount + 1 个位置可以放\n            int zeroCount = count[0];\n\n\n            // 第i个数字放在第 j个0后面的方法\n            long[][] dp = new long[nonZeroCount + 1][zeroCount + 1];\n            Arrays.fill(dp[1], 1);\n\n            for (int i = 2; i <= nonZeroCount; ++i) {\n                for (int j = 0; j <= zeroCount; ++j) {\n                    for (int k = 0; k <= j; ++k) {\n                        dp[i][j] += dp[i - 1][k];\n                    }\n                }\n            }\n\n            // 数字的总放置方法\n            long tot = 0;\n            for (int j = 0; j <= zeroCount; ++j) {\n                tot += dp[nonZeroCount][j];\n            }\n            ans *= tot;\n\n            System.out.println(ans - 1);\n        }\n\n    }\n\n    // 本质就是先不考虑0，把数字塞进去\n    public static void dfs(int index, int len, int cur, int[] count,\n                           Set<Integer> s) {\n        if (index >= len) {\n            s.add(cur);\n            return;\n        }\n        for (int num = 0; num <= 9; ++num) {\n            if (count[num] == 0) {\n                continue;\n            }\n            count[num]--;\n            dfs(index + 1, len, cur * 10 + num, count, s);\n            count[num]++;\n        }\n    }\n\n}\n```\n\n## 蚂蚁一面\n（3.25，57min，电话面）\n\n1. 自我介绍\n2. 对微服务的理解\n3. spring cloud中微服务A（支付受理）之间如何调用微服务B（支付资金扣减），A如何知道B的地址（eureka+gateway转发）\n4. gateway请求压力不会很大吗，微服务A可以直接调用微服务B吗\n5. 如果某个节点挂掉了，其他微服务怎么知道这件事情呢\n6. 介绍线程池的参数\n7. 当线程池的一个线程执行完任务之后，该线程处于什么状态\n8. 线程池的5个核心线程，大小为2的阻塞队列，最大线程数为8，最开始有几个核心线程\n9. 当核心线程的任务都执行完毕后，新到来的任务会交给哪个核心线程\n10. 线程池的阻塞队列“阻塞”的是什么\n11. 阻塞队列的实现原理\n12. LinkedBlockingQueue用两个锁有什么优势\n13. 介绍ThreadLocal实现原理\n14. Java中有哪几种引用类型\n15. 了解RPC吗\n16. 如果自己实现一个限流算法，如实现QPS不超过10\n17. 你实现的固定窗口限流算法如何解决前半段和后半段激增的流量\n18. 你实现的限流算法如何解决短时间内突然到来的大量请求\n19. 限流算法必须一个线程在那里给令牌桶添加令牌吗，有其他实现方法吗\n20. 了解RateLimiter源码吗\n21. 选一个最有挑战性的项目介绍\n22. 有学习过大模型，如RAG和SFT吗\n23. 反问：base杭州，信贷风控\n\n\n## 蚂蚁二面\n（3.31，40min，电话面）\n\n1. 自我介绍\n2. 实时协同编程的系列问题探讨\n3. 实时协同编程应用场景的探讨\n4. 实习项目2s优化到300ms的探讨\n5. 数据库层面怎么优化的探讨\n6. 大模型是否了解等问题\n7. 什么是一个agent\n8. （反问）大模型相关问题的探讨；流程疑问\n\n> 面完后就没后续了，就没管了\n","source":"_posts/2025/暑期实习-蚂蚁面试.md","raw":"---\ntitle: 暑期实习-蚂蚁面试\ndate: 2025-10-31 00:07:00\ncover: https://upic-1301780692.cos.ap-shanghai.myqcloud.com/u=2193217229,3865826716&fm=253&app=138&f=JPEG-20251031-101944.jpeg\ntag: 暑期实习\n---\n\n# 暑期实习-蚂蚁面试\n\n## 笔试\n\n（TCP报文数据总量）数据包1400字节，tcp头部20字节，应用层数据大小为1360字节，发送100个数据包，那么传输的字节数是多少？\n\n> 传输的总字节数为 **140,000 字节**（140 KB）\n\numask为022，在创建文件的时候的权限是？\n\n> 当 `umask` 设置为 **022** 时，新创建文件的权限为 **rw-r--r--**（即权限码 `644`）\n>\n> - **umask 作用**： umask 通过**屏蔽（禁用）**权限位来限制默认权限。计算方式为： 实际权限=默认权限 &  umask实际权限=默认权限& umask\n>\n> 文件基础权限：666（rw-rw-rw-），即所有用户可读可写，但不可执行（Linux默认不给文件执行权限）。\n> 目录基础权限：777（rwxrwxrwx），即所有用户可读、写、执行。\n> umask作用：通过按位取反后与基础权限进行逻辑与操作，屏蔽不需要的权限。\n\n（结构型设计模式）责任链模式属于什么类型的设计模式？\n\n> 属于 **行为型设计模式**，其核心目标是解耦请求的发送者与接收者，通过构建链式结构让多个对象依次处理同一请求，直到有对象处理成功或传递至链尾\n\n主键不能为null吗？\n\n> 是的，主键不能为null\n\n对象可以调用线程的run方法吗？\n\n> 是的，对象可以调用线程的 `run()` 方法，但这种方式并不会启动新线程，而是以**同步方式在当前线程中执行** `run()` 方法内的代码。这与 `start()` 方法启动线程的机制有本质区别\n\n以下哪些适合强制缓存？静态图片；css；API\n\n> **强制缓存**适用于内容不频繁变更的静态资源，其核心原理是通过设置 `Cache-Control` 或 `Expires` 响应头\n>\n> 静态图片和css文件适合\n\n（哈夫曼树）(a, 5), (g, 90), (t, 53), (i, 80), (e, 49)构造成哈夫曼树，那么哈夫曼树的权值是多少\n\n```shell\n      277\n     /   \\\n    107   170\n   /  \\   / \\\n  53  54 80 90\n     / \\\n    5  49\n```\n\n做了2.75题\n\n第一题：贪心就行，很简单\n\n第二题：排序+二分就行\n\n第三题：质数筛 + 组合方法？（最后只过了80%）\n\n> int count = new int[10]表示数字0～9的个数，用他们组成不同的排列数如：0，1，1，2可以组成1120，1210，2110，1012，1102，1021，1201，2011，2101，112，121，211（忽略前导0，前导0等价于没有0），那么一共有多少种方式？理论上组合数就能解决，不需要动态规划\n\n做完后思考：想复杂了，其实0当作普通的数字处理即可\n\n```java\nimport java.util.*;\nimport java.io.*;\n\n\n\npublic class Main {\n    static BufferedReader br;\n    static StringTokenizer st;\n\n    static String next() throws IOException {\n        while (!st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return st.nextToken();\n    }\n\n    static Integer nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    static Long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        st = new StringTokenizer(\"\");\n\n        int T = nextInt();\n\n        boolean[] zhishu = new boolean[1001];\n        Arrays.fill(zhishu, true);\n        zhishu[1] = false;\n        zhishu[0] = false;\n        for (int num = 2; num <= 1000; ++num) {\n            if (!zhishu[num]) {\n                continue;\n            }\n            for (int i = 2; i * num <= 1000; i++) {\n                zhishu[i * num] = false;\n            }\n        }\n\n\n        while (T-- > 0) {\n            int x = nextInt();\n\n            // 记录数位之和\n            // 还需要看每个数字有几个\n            int[] count = new int[10];\n            String s = String.valueOf(x);\n            int sum = 0;\n            for (char ch : s.toCharArray()) {\n                int index = ch - '0';\n                count[index]++;\n                sum += index;\n            }\n\n            if (!zhishu[sum]) {\n                System.out.println(0);\n                continue;\n            }\n\n            // 本质就是看这些数字有多少种排列方式\n            // 2 1 0 3 ->\n\n            // 对于放不放0的一些情况\n            // Set<Integer> set = new HashSet<>();\n            int len = s.length();\n\n            // dfs(0, len, 0, count, set);\n            // System.out.println(set.size() - 1);\n\n            long ans = 1;\n\n            int nonZeroCount = len - count[0];\n            // 阶乘\n            for (int i = 2; i <= nonZeroCount; ++i) {\n                ans *= i;\n            }\n            // 除以出现重复的数量\n            for (int num = 1; num <= 9; ++num) {\n                if (count[num] <= 1) {\n                    continue;\n                }\n                // 除以 num的阶乘\n                for (int i = 2; i <= count[num]; ++i) {\n                    ans /= i;\n                }\n            }\n\n            // 接下来再把0塞进去\n            // 0 有nonZeroCount + 1 个位置可以放\n            int zeroCount = count[0];\n\n\n            // 第i个数字放在第 j个0后面的方法\n            long[][] dp = new long[nonZeroCount + 1][zeroCount + 1];\n            Arrays.fill(dp[1], 1);\n\n            for (int i = 2; i <= nonZeroCount; ++i) {\n                for (int j = 0; j <= zeroCount; ++j) {\n                    for (int k = 0; k <= j; ++k) {\n                        dp[i][j] += dp[i - 1][k];\n                    }\n                }\n            }\n\n            // 数字的总放置方法\n            long tot = 0;\n            for (int j = 0; j <= zeroCount; ++j) {\n                tot += dp[nonZeroCount][j];\n            }\n            ans *= tot;\n\n            System.out.println(ans - 1);\n        }\n\n    }\n\n    // 本质就是先不考虑0，把数字塞进去\n    public static void dfs(int index, int len, int cur, int[] count,\n                           Set<Integer> s) {\n        if (index >= len) {\n            s.add(cur);\n            return;\n        }\n        for (int num = 0; num <= 9; ++num) {\n            if (count[num] == 0) {\n                continue;\n            }\n            count[num]--;\n            dfs(index + 1, len, cur * 10 + num, count, s);\n            count[num]++;\n        }\n    }\n\n}\n```\n\n## 蚂蚁一面\n（3.25，57min，电话面）\n\n1. 自我介绍\n2. 对微服务的理解\n3. spring cloud中微服务A（支付受理）之间如何调用微服务B（支付资金扣减），A如何知道B的地址（eureka+gateway转发）\n4. gateway请求压力不会很大吗，微服务A可以直接调用微服务B吗\n5. 如果某个节点挂掉了，其他微服务怎么知道这件事情呢\n6. 介绍线程池的参数\n7. 当线程池的一个线程执行完任务之后，该线程处于什么状态\n8. 线程池的5个核心线程，大小为2的阻塞队列，最大线程数为8，最开始有几个核心线程\n9. 当核心线程的任务都执行完毕后，新到来的任务会交给哪个核心线程\n10. 线程池的阻塞队列“阻塞”的是什么\n11. 阻塞队列的实现原理\n12. LinkedBlockingQueue用两个锁有什么优势\n13. 介绍ThreadLocal实现原理\n14. Java中有哪几种引用类型\n15. 了解RPC吗\n16. 如果自己实现一个限流算法，如实现QPS不超过10\n17. 你实现的固定窗口限流算法如何解决前半段和后半段激增的流量\n18. 你实现的限流算法如何解决短时间内突然到来的大量请求\n19. 限流算法必须一个线程在那里给令牌桶添加令牌吗，有其他实现方法吗\n20. 了解RateLimiter源码吗\n21. 选一个最有挑战性的项目介绍\n22. 有学习过大模型，如RAG和SFT吗\n23. 反问：base杭州，信贷风控\n\n\n## 蚂蚁二面\n（3.31，40min，电话面）\n\n1. 自我介绍\n2. 实时协同编程的系列问题探讨\n3. 实时协同编程应用场景的探讨\n4. 实习项目2s优化到300ms的探讨\n5. 数据库层面怎么优化的探讨\n6. 大模型是否了解等问题\n7. 什么是一个agent\n8. （反问）大模型相关问题的探讨；流程疑问\n\n> 面完后就没后续了，就没管了\n","slug":"2025/暑期实习-蚂蚁面试","published":1,"updated":"2025-10-31T02:21:03.850Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmhg4qt4w0013f5fa13xd4yzr","content":"<h1 id=\"暑期实习-蚂蚁面试\"><a href=\"#暑期实习-蚂蚁面试\" class=\"headerlink\" title=\"暑期实习-蚂蚁面试\"></a>暑期实习-蚂蚁面试</h1><h2 id=\"笔试\"><a href=\"#笔试\" class=\"headerlink\" title=\"笔试\"></a>笔试</h2><p>（TCP报文数据总量）数据包1400字节，tcp头部20字节，应用层数据大小为1360字节，发送100个数据包，那么传输的字节数是多少？</p>\n<blockquote>\n<p>传输的总字节数为 <strong>140,000 字节</strong>（140 KB）</p>\n</blockquote>\n<p>umask为022，在创建文件的时候的权限是？</p>\n<blockquote>\n<p>当 <code>umask</code> 设置为 <strong>022</strong> 时，新创建文件的权限为 **rw-r–r–**（即权限码 <code>644</code>）</p>\n<ul>\n<li><strong>umask 作用</strong>： umask 通过<strong>屏蔽（禁用）</strong>权限位来限制默认权限。计算方式为： 实际权限=默认权限 &amp;  umask实际权限=默认权限&amp; umask</li>\n</ul>\n<p>文件基础权限：666（rw-rw-rw-），即所有用户可读可写，但不可执行（Linux默认不给文件执行权限）。<br>目录基础权限：777（rwxrwxrwx），即所有用户可读、写、执行。<br>umask作用：通过按位取反后与基础权限进行逻辑与操作，屏蔽不需要的权限。</p>\n</blockquote>\n<p>（结构型设计模式）责任链模式属于什么类型的设计模式？</p>\n<blockquote>\n<p>属于 <strong>行为型设计模式</strong>，其核心目标是解耦请求的发送者与接收者，通过构建链式结构让多个对象依次处理同一请求，直到有对象处理成功或传递至链尾</p>\n</blockquote>\n<p>主键不能为null吗？</p>\n<blockquote>\n<p>是的，主键不能为null</p>\n</blockquote>\n<p>对象可以调用线程的run方法吗？</p>\n<blockquote>\n<p>是的，对象可以调用线程的 <code>run()</code> 方法，但这种方式并不会启动新线程，而是以<strong>同步方式在当前线程中执行</strong> <code>run()</code> 方法内的代码。这与 <code>start()</code> 方法启动线程的机制有本质区别</p>\n</blockquote>\n<p>以下哪些适合强制缓存？静态图片；css；API</p>\n<blockquote>\n<p><strong>强制缓存</strong>适用于内容不频繁变更的静态资源，其核心原理是通过设置 <code>Cache-Control</code> 或 <code>Expires</code> 响应头</p>\n<p>静态图片和css文件适合</p>\n</blockquote>\n<p>（哈夫曼树）(a, 5), (g, 90), (t, 53), (i, 80), (e, 49)构造成哈夫曼树，那么哈夫曼树的权值是多少</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    277</span><br><span class=\"line\">   /   \\</span><br><span class=\"line\">  107   170</span><br><span class=\"line\"> /  \\   / \\</span><br><span class=\"line\">53  54 80 90</span><br><span class=\"line\">   / \\</span><br><span class=\"line\">  5  49</span><br></pre></td></tr></table></figure>\n<p>做了2.75题</p>\n<p>第一题：贪心就行，很简单</p>\n<p>第二题：排序+二分就行</p>\n<p>第三题：质数筛 + 组合方法？（最后只过了80%）</p>\n<blockquote>\n<p>int count = new int[10]表示数字0～9的个数，用他们组成不同的排列数如：0，1，1，2可以组成1120，1210，2110，1012，1102，1021，1201，2011，2101，112，121，211（忽略前导0，前导0等价于没有0），那么一共有多少种方式？理论上组合数就能解决，不需要动态规划</p>\n</blockquote>\n<p>做完后思考：想复杂了，其实0当作普通的数字处理即可</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> BufferedReader br;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> StringTokenizer st;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> String <span class=\"title\">next</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!st.hasMoreTokens()) &#123;</span><br><span class=\"line\">            st = <span class=\"keyword\">new</span> StringTokenizer(br.readLine());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> st.nextToken();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> Integer <span class=\"title\">nextInt</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Integer.parseInt(next());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> Long <span class=\"title\">nextLong</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Long.parseLong(next());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(System.in));</span><br><span class=\"line\">        st = <span class=\"keyword\">new</span> StringTokenizer(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> T = nextInt();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span>[] zhishu = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[<span class=\"number\">1001</span>];</span><br><span class=\"line\">        Arrays.fill(zhishu, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        zhishu[<span class=\"number\">1</span>] = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        zhishu[<span class=\"number\">0</span>] = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num = <span class=\"number\">2</span>; num &lt;= <span class=\"number\">1000</span>; ++num) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!zhishu[num]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i * num &lt;= <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">                zhishu[i * num] = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (T-- &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> x = nextInt();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 记录数位之和</span></span><br><span class=\"line\">            <span class=\"comment\">// 还需要看每个数字有几个</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span>[] count = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>];</span><br><span class=\"line\">            String s = String.valueOf(x);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> ch : s.toCharArray()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> index = ch - <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">                count[index]++;</span><br><span class=\"line\">                sum += index;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!zhishu[sum]) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"number\">0</span>);</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 本质就是看这些数字有多少种排列方式</span></span><br><span class=\"line\">            <span class=\"comment\">// 2 1 0 3 -&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 对于放不放0的一些情况</span></span><br><span class=\"line\">            <span class=\"comment\">// Set&lt;Integer&gt; set = new HashSet&lt;&gt;();</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> len = s.length();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// dfs(0, len, 0, count, set);</span></span><br><span class=\"line\">            <span class=\"comment\">// System.out.println(set.size() - 1);</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">long</span> ans = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">int</span> nonZeroCount = len - count[<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"comment\">// 阶乘</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= nonZeroCount; ++i) &#123;</span><br><span class=\"line\">                ans *= i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 除以出现重复的数量</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num = <span class=\"number\">1</span>; num &lt;= <span class=\"number\">9</span>; ++num) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (count[num] &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 除以 num的阶乘</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= count[num]; ++i) &#123;</span><br><span class=\"line\">                    ans /= i;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 接下来再把0塞进去</span></span><br><span class=\"line\">            <span class=\"comment\">// 0 有nonZeroCount + 1 个位置可以放</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> zeroCount = count[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 第i个数字放在第 j个0后面的方法</span></span><br><span class=\"line\">            <span class=\"keyword\">long</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">long</span>[nonZeroCount + <span class=\"number\">1</span>][zeroCount + <span class=\"number\">1</span>];</span><br><span class=\"line\">            Arrays.fill(dp[<span class=\"number\">1</span>], <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= nonZeroCount; ++i) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;= zeroCount; ++j) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt;= j; ++k) &#123;</span><br><span class=\"line\">                        dp[i][j] += dp[i - <span class=\"number\">1</span>][k];</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 数字的总放置方法</span></span><br><span class=\"line\">            <span class=\"keyword\">long</span> tot = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;= zeroCount; ++j) &#123;</span><br><span class=\"line\">                tot += dp[nonZeroCount][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans *= tot;</span><br><span class=\"line\"></span><br><span class=\"line\">            System.out.println(ans - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 本质就是先不考虑0，把数字塞进去</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> index, <span class=\"keyword\">int</span> len, <span class=\"keyword\">int</span> cur, <span class=\"keyword\">int</span>[] count,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                           Set&lt;Integer&gt; s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &gt;= len) &#123;</span><br><span class=\"line\">            s.add(cur);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num = <span class=\"number\">0</span>; num &lt;= <span class=\"number\">9</span>; ++num) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (count[num] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            count[num]--;</span><br><span class=\"line\">            dfs(index + <span class=\"number\">1</span>, len, cur * <span class=\"number\">10</span> + num, count, s);</span><br><span class=\"line\">            count[num]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"蚂蚁一面\"><a href=\"#蚂蚁一面\" class=\"headerlink\" title=\"蚂蚁一面\"></a>蚂蚁一面</h2><p>（3.25，57min，电话面）</p>\n<ol>\n<li>自我介绍</li>\n<li>对微服务的理解</li>\n<li>spring cloud中微服务A（支付受理）之间如何调用微服务B（支付资金扣减），A如何知道B的地址（eureka+gateway转发）</li>\n<li>gateway请求压力不会很大吗，微服务A可以直接调用微服务B吗</li>\n<li>如果某个节点挂掉了，其他微服务怎么知道这件事情呢</li>\n<li>介绍线程池的参数</li>\n<li>当线程池的一个线程执行完任务之后，该线程处于什么状态</li>\n<li>线程池的5个核心线程，大小为2的阻塞队列，最大线程数为8，最开始有几个核心线程</li>\n<li>当核心线程的任务都执行完毕后，新到来的任务会交给哪个核心线程</li>\n<li>线程池的阻塞队列“阻塞”的是什么</li>\n<li>阻塞队列的实现原理</li>\n<li>LinkedBlockingQueue用两个锁有什么优势</li>\n<li>介绍ThreadLocal实现原理</li>\n<li>Java中有哪几种引用类型</li>\n<li>了解RPC吗</li>\n<li>如果自己实现一个限流算法，如实现QPS不超过10</li>\n<li>你实现的固定窗口限流算法如何解决前半段和后半段激增的流量</li>\n<li>你实现的限流算法如何解决短时间内突然到来的大量请求</li>\n<li>限流算法必须一个线程在那里给令牌桶添加令牌吗，有其他实现方法吗</li>\n<li>了解RateLimiter源码吗</li>\n<li>选一个最有挑战性的项目介绍</li>\n<li>有学习过大模型，如RAG和SFT吗</li>\n<li>反问：base杭州，信贷风控</li>\n</ol>\n<h2 id=\"蚂蚁二面\"><a href=\"#蚂蚁二面\" class=\"headerlink\" title=\"蚂蚁二面\"></a>蚂蚁二面</h2><p>（3.31，40min，电话面）</p>\n<ol>\n<li>自我介绍</li>\n<li>实时协同编程的系列问题探讨</li>\n<li>实时协同编程应用场景的探讨</li>\n<li>实习项目2s优化到300ms的探讨</li>\n<li>数据库层面怎么优化的探讨</li>\n<li>大模型是否了解等问题</li>\n<li>什么是一个agent</li>\n<li>（反问）大模型相关问题的探讨；流程疑问</li>\n</ol>\n<blockquote>\n<p>面完后就没后续了，就没管了</p>\n</blockquote>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<h1 id=\"暑期实习-蚂蚁面试\"><a href=\"#暑期实习-蚂蚁面试\" class=\"headerlink\" title=\"暑期实习-蚂蚁面试\"></a>暑期实习-蚂蚁面试</h1><h2 id=\"笔试\"><a href=\"#笔试\" class=\"headerlink\" title=\"笔试\"></a>笔试</h2><p>（TCP报文数据总量）数据包1400字节，tcp头部20字节，应用层数据大小为1360字节，发送100个数据包，那么传输的字节数是多少？</p>\n<blockquote>\n<p>传输的总字节数为 <strong>140,000 字节</strong>（140 KB）</p>\n</blockquote>\n<p>umask为022，在创建文件的时候的权限是？</p>\n<blockquote>\n<p>当 <code>umask</code> 设置为 <strong>022</strong> 时，新创建文件的权限为 **rw-r–r–**（即权限码 <code>644</code>）</p>\n<ul>\n<li><strong>umask 作用</strong>： umask 通过<strong>屏蔽（禁用）</strong>权限位来限制默认权限。计算方式为： 实际权限=默认权限 &amp;  umask实际权限=默认权限&amp; umask</li>\n</ul>\n<p>文件基础权限：666（rw-rw-rw-），即所有用户可读可写，但不可执行（Linux默认不给文件执行权限）。<br>目录基础权限：777（rwxrwxrwx），即所有用户可读、写、执行。<br>umask作用：通过按位取反后与基础权限进行逻辑与操作，屏蔽不需要的权限。</p>\n</blockquote>\n<p>（结构型设计模式）责任链模式属于什么类型的设计模式？</p>\n<blockquote>\n<p>属于 <strong>行为型设计模式</strong>，其核心目标是解耦请求的发送者与接收者，通过构建链式结构让多个对象依次处理同一请求，直到有对象处理成功或传递至链尾</p>\n</blockquote>\n<p>主键不能为null吗？</p>\n<blockquote>\n<p>是的，主键不能为null</p>\n</blockquote>\n<p>对象可以调用线程的run方法吗？</p>\n<blockquote>\n<p>是的，对象可以调用线程的 <code>run()</code> 方法，但这种方式并不会启动新线程，而是以<strong>同步方式在当前线程中执行</strong> <code>run()</code> 方法内的代码。这与 <code>start()</code> 方法启动线程的机制有本质区别</p>\n</blockquote>\n<p>以下哪些适合强制缓存？静态图片；css；API</p>\n<blockquote>\n<p><strong>强制缓存</strong>适用于内容不频繁变更的静态资源，其核心原理是通过设置 <code>Cache-Control</code> 或 <code>Expires</code> 响应头</p>\n<p>静态图片和css文件适合</p>\n</blockquote>\n<p>（哈夫曼树）(a, 5), (g, 90), (t, 53), (i, 80), (e, 49)构造成哈夫曼树，那么哈夫曼树的权值是多少</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    277</span><br><span class=\"line\">   /   \\</span><br><span class=\"line\">  107   170</span><br><span class=\"line\"> /  \\   / \\</span><br><span class=\"line\">53  54 80 90</span><br><span class=\"line\">   / \\</span><br><span class=\"line\">  5  49</span><br></pre></td></tr></table></figure>\n<p>做了2.75题</p>\n<p>第一题：贪心就行，很简单</p>\n<p>第二题：排序+二分就行</p>\n<p>第三题：质数筛 + 组合方法？（最后只过了80%）</p>\n<blockquote>\n<p>int count = new int[10]表示数字0～9的个数，用他们组成不同的排列数如：0，1，1，2可以组成1120，1210，2110，1012，1102，1021，1201，2011，2101，112，121，211（忽略前导0，前导0等价于没有0），那么一共有多少种方式？理论上组合数就能解决，不需要动态规划</p>\n</blockquote>\n<p>做完后思考：想复杂了，其实0当作普通的数字处理即可</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> BufferedReader br;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> StringTokenizer st;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> String <span class=\"title\">next</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!st.hasMoreTokens()) &#123;</span><br><span class=\"line\">            st = <span class=\"keyword\">new</span> StringTokenizer(br.readLine());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> st.nextToken();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> Integer <span class=\"title\">nextInt</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Integer.parseInt(next());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> Long <span class=\"title\">nextLong</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Long.parseLong(next());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(System.in));</span><br><span class=\"line\">        st = <span class=\"keyword\">new</span> StringTokenizer(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> T = nextInt();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span>[] zhishu = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[<span class=\"number\">1001</span>];</span><br><span class=\"line\">        Arrays.fill(zhishu, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        zhishu[<span class=\"number\">1</span>] = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        zhishu[<span class=\"number\">0</span>] = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num = <span class=\"number\">2</span>; num &lt;= <span class=\"number\">1000</span>; ++num) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!zhishu[num]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i * num &lt;= <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">                zhishu[i * num] = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (T-- &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> x = nextInt();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 记录数位之和</span></span><br><span class=\"line\">            <span class=\"comment\">// 还需要看每个数字有几个</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span>[] count = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>];</span><br><span class=\"line\">            String s = String.valueOf(x);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">char</span> ch : s.toCharArray()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> index = ch - <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">                count[index]++;</span><br><span class=\"line\">                sum += index;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!zhishu[sum]) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"number\">0</span>);</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 本质就是看这些数字有多少种排列方式</span></span><br><span class=\"line\">            <span class=\"comment\">// 2 1 0 3 -&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 对于放不放0的一些情况</span></span><br><span class=\"line\">            <span class=\"comment\">// Set&lt;Integer&gt; set = new HashSet&lt;&gt;();</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> len = s.length();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// dfs(0, len, 0, count, set);</span></span><br><span class=\"line\">            <span class=\"comment\">// System.out.println(set.size() - 1);</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">long</span> ans = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">int</span> nonZeroCount = len - count[<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"comment\">// 阶乘</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= nonZeroCount; ++i) &#123;</span><br><span class=\"line\">                ans *= i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 除以出现重复的数量</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num = <span class=\"number\">1</span>; num &lt;= <span class=\"number\">9</span>; ++num) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (count[num] &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 除以 num的阶乘</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= count[num]; ++i) &#123;</span><br><span class=\"line\">                    ans /= i;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 接下来再把0塞进去</span></span><br><span class=\"line\">            <span class=\"comment\">// 0 有nonZeroCount + 1 个位置可以放</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> zeroCount = count[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 第i个数字放在第 j个0后面的方法</span></span><br><span class=\"line\">            <span class=\"keyword\">long</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">long</span>[nonZeroCount + <span class=\"number\">1</span>][zeroCount + <span class=\"number\">1</span>];</span><br><span class=\"line\">            Arrays.fill(dp[<span class=\"number\">1</span>], <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt;= nonZeroCount; ++i) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;= zeroCount; ++j) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt;= j; ++k) &#123;</span><br><span class=\"line\">                        dp[i][j] += dp[i - <span class=\"number\">1</span>][k];</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 数字的总放置方法</span></span><br><span class=\"line\">            <span class=\"keyword\">long</span> tot = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;= zeroCount; ++j) &#123;</span><br><span class=\"line\">                tot += dp[nonZeroCount][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans *= tot;</span><br><span class=\"line\"></span><br><span class=\"line\">            System.out.println(ans - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 本质就是先不考虑0，把数字塞进去</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> index, <span class=\"keyword\">int</span> len, <span class=\"keyword\">int</span> cur, <span class=\"keyword\">int</span>[] count,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                           Set&lt;Integer&gt; s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &gt;= len) &#123;</span><br><span class=\"line\">            s.add(cur);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num = <span class=\"number\">0</span>; num &lt;= <span class=\"number\">9</span>; ++num) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (count[num] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            count[num]--;</span><br><span class=\"line\">            dfs(index + <span class=\"number\">1</span>, len, cur * <span class=\"number\">10</span> + num, count, s);</span><br><span class=\"line\">            count[num]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"蚂蚁一面\"><a href=\"#蚂蚁一面\" class=\"headerlink\" title=\"蚂蚁一面\"></a>蚂蚁一面</h2><p>（3.25，57min，电话面）</p>\n<ol>\n<li>自我介绍</li>\n<li>对微服务的理解</li>\n<li>spring cloud中微服务A（支付受理）之间如何调用微服务B（支付资金扣减），A如何知道B的地址（eureka+gateway转发）</li>\n<li>gateway请求压力不会很大吗，微服务A可以直接调用微服务B吗</li>\n<li>如果某个节点挂掉了，其他微服务怎么知道这件事情呢</li>\n<li>介绍线程池的参数</li>\n<li>当线程池的一个线程执行完任务之后，该线程处于什么状态</li>\n<li>线程池的5个核心线程，大小为2的阻塞队列，最大线程数为8，最开始有几个核心线程</li>\n<li>当核心线程的任务都执行完毕后，新到来的任务会交给哪个核心线程</li>\n<li>线程池的阻塞队列“阻塞”的是什么</li>\n<li>阻塞队列的实现原理</li>\n<li>LinkedBlockingQueue用两个锁有什么优势</li>\n<li>介绍ThreadLocal实现原理</li>\n<li>Java中有哪几种引用类型</li>\n<li>了解RPC吗</li>\n<li>如果自己实现一个限流算法，如实现QPS不超过10</li>\n<li>你实现的固定窗口限流算法如何解决前半段和后半段激增的流量</li>\n<li>你实现的限流算法如何解决短时间内突然到来的大量请求</li>\n<li>限流算法必须一个线程在那里给令牌桶添加令牌吗，有其他实现方法吗</li>\n<li>了解RateLimiter源码吗</li>\n<li>选一个最有挑战性的项目介绍</li>\n<li>有学习过大模型，如RAG和SFT吗</li>\n<li>反问：base杭州，信贷风控</li>\n</ol>\n<h2 id=\"蚂蚁二面\"><a href=\"#蚂蚁二面\" class=\"headerlink\" title=\"蚂蚁二面\"></a>蚂蚁二面</h2><p>（3.31，40min，电话面）</p>\n<ol>\n<li>自我介绍</li>\n<li>实时协同编程的系列问题探讨</li>\n<li>实时协同编程应用场景的探讨</li>\n<li>实习项目2s优化到300ms的探讨</li>\n<li>数据库层面怎么优化的探讨</li>\n<li>大模型是否了解等问题</li>\n<li>什么是一个agent</li>\n<li>（反问）大模型相关问题的探讨；流程疑问</li>\n</ol>\n<blockquote>\n<p>面完后就没后续了，就没管了</p>\n</blockquote>\n"},{"title":"暑期实习-腾讯音乐面试","date":"2025-10-30T16:04:00.000Z","cover":"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/41defd59228f8a2b5874b5a9234abf98-20251031-100150.jpg","_content":"\n# 暑期实习-腾讯音乐面试\n\n## 腾讯音乐一面\n（3.19，50分钟）\n\n1. 为什么来深圳\n2. 自我介绍\n3. 实习经历介绍\n4. 为什么选用Spring Task\n5. 线程池的参数有哪些\n6. 线程池的核心线程数如何选择\n7. mysql的索引机制\n8. 有联合索引(a,b)，但是走了索引b，可能因为什么原因\n9. 如何强制走某一个索引\n10. mysql如何去做查询优化\n11. 用过redis的什么数据类型或者是否了解数据类型\n12. redis的持久化机制\n13. 令牌桶算法\n14. 还知道哪些其他的限流算法\n15. 如何去实现一个高可用、高性能的系统\n16. Spring Bean对象的生命周期，以A a = new A()；为例\n17. Spring如何解决循环依赖\n18. 项目中实时协同编程AST如何衡量代码是否重要\n19. 共享屏幕场景题1：写一个单例模式，以及是否有其他实现方式（我写了惰性加载、直接加载和Enum的方式）\n20. 场景题2：三个线程循环打印ABC\n\n```java\npublic static void main(String[] args) {\n    Semaphore semaphore1 = new Semaphore(1);\n    Semaphore semaphore2 = new Semaphore(0);\n    Semaphore semaphore3 = new Semaphore(0);\n    Thread thread1 = new Thread(() -> {\n        while (true) {\n            try {\n                semaphore1.acquire();\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n            System.out.println(Thread.currentThread().getName() + \": A\");\n            semaphore2.release();\n        }\n    });\n    Thread thread2 = new Thread(() -> {\n        while (true) {\n            try {\n                semaphore2.acquire();\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n            System.out.println(Thread.currentThread().getName() + \": B\");\n            semaphore3.release();\n        }\n    });\n    Thread thread3 = new Thread(() -> {\n        while (true) {\n            try {\n                semaphore3.acquire();\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n            System.out.println(Thread.currentThread().getName() + \": C\");\n            semaphore1.release();\n        }\n    });\n    thread1.start();\n    thread2.start();\n    thread3.start();\n}\n```\n\n21. 是否有其他offer（我说只有京东）；什么时候能到岗\n22. 反问（业务：歌曲版权生命周期；面试流程：2轮技术+1轮hr）\n\n## 腾讯音乐二面\n（3.24，55min）\n\n1. 为啥来深圳，有啥offer\n2. 自我介绍\n3. 最有难度的项目介绍\n4. 在这个场景下，如何将服务运行多份实例，这种情况下之前的方案存在什么问题，可以用什么解决方案\n5. xxl-job了解吗（不了解）\n6. mysql的执行计划分析了解吗\n7. explain中了解哪些字段，最应该关注什么字段\n8. extra中的filesort了解吗（不了解）\n9. filesort本质就是对外部文件进行排序，推测一下它的过程\n10. springboot中动态代理和静态代理有什么区别\n11. springboot中如何实现动态代理\n12. 举一个例子，A接口有test方法，B类实现了A接口，写一个B类的静态代理类\n13. 为什么要这样写（C实现A的接口）\n14. 除了上面的写法，还有什么方法吗（子类的方法）\n15. 你觉得这两种方法本质有什么区别（本质就是动态代理的两种实现）\n16. 用过kafka之类的消息中间件吗（没有）\n17. spring中事务传播机制本质是解决了什么问题，为什么在数据库有acid的基础上要额外有这个机制\n18. 扣库存和修改订单两个操作在有@Transactional和没有的情况下，分别发生了几次数据库连接操作\n19. 什么时候能来实习\n20. 反问：没问题，就是暗示我在学习分布式\n\n（后面可能会有三轮技术面，也有可能没有）\n\n\n## 腾讯音乐三面\n（3.26，46min）\n\n1. 自我介绍\n2. spring cloud的微服务中有哪些组成部分\n3. 为什么是其他微服务从eureka拉取其他节点信息，而不是eureka向其他微服务推送节点（AP模型，牺牲一致性保证高可用）\n4. 如果eureka节点坏了，怎么办（多eureka设计；本地缓存兜底）\n5. 除了eureka还知道什么（只说出了一个名词nanos）\n6. RBAC模型介绍\n7. 你们系统中定义的资源是什么\n8. 部门管理者和下面的员工，如何实现员工只能看见自己创建的数据，部门管理者可以看见部门下全部数据呢\n9. 知道功能权限和数据权限的切分吗\n10. 深度分页问题了解吗（mysql有100kW条数据，每次读100个数据会变慢，可以自己去了解下）\n11. 冗余表设计的问题（被质疑没有太大意义）\n12. 多张表join命中了索引，但是还是比较慢，可以怎么优化\n13. tcp七层模型\n14. http的请求头有哪些内容（真不熟）\n15. tcp和udp的区别\n16. 项目中有用到udp协议吗（用到了websocket）\n17. https是什么\n18. 用过linux吗，知道哪些常见指令\n19. 项目中实现了下单到支付的全流程，那下单和支付如何保证一致性\n20. 了解分布式事务吗（不知道）\n21. 知道单机事务吗\n22. 有了解哪些新技术\n23. （反问）推荐学习什么：elastic search等\n\n\n## 腾讯音乐HR面\n（4.2，9min，电话面）\n\n1. 实习经历所做的事\n2. 遇到的挑战，自己所发挥的长处\n3. 是否有其他offer\n4. 为什么更喜欢深圳\n5. （反问）腾讯音乐培养体系\n","source":"_posts/2025/暑期实习-腾讯音乐面试.md","raw":"---\ntitle: 暑期实习-腾讯音乐面试\ndate: 2025-10-31 00:04:00\ncover: https://upic-1301780692.cos.ap-shanghai.myqcloud.com/41defd59228f8a2b5874b5a9234abf98-20251031-100150.jpg\ntag: 暑期实习\n---\n\n# 暑期实习-腾讯音乐面试\n\n## 腾讯音乐一面\n（3.19，50分钟）\n\n1. 为什么来深圳\n2. 自我介绍\n3. 实习经历介绍\n4. 为什么选用Spring Task\n5. 线程池的参数有哪些\n6. 线程池的核心线程数如何选择\n7. mysql的索引机制\n8. 有联合索引(a,b)，但是走了索引b，可能因为什么原因\n9. 如何强制走某一个索引\n10. mysql如何去做查询优化\n11. 用过redis的什么数据类型或者是否了解数据类型\n12. redis的持久化机制\n13. 令牌桶算法\n14. 还知道哪些其他的限流算法\n15. 如何去实现一个高可用、高性能的系统\n16. Spring Bean对象的生命周期，以A a = new A()；为例\n17. Spring如何解决循环依赖\n18. 项目中实时协同编程AST如何衡量代码是否重要\n19. 共享屏幕场景题1：写一个单例模式，以及是否有其他实现方式（我写了惰性加载、直接加载和Enum的方式）\n20. 场景题2：三个线程循环打印ABC\n\n```java\npublic static void main(String[] args) {\n    Semaphore semaphore1 = new Semaphore(1);\n    Semaphore semaphore2 = new Semaphore(0);\n    Semaphore semaphore3 = new Semaphore(0);\n    Thread thread1 = new Thread(() -> {\n        while (true) {\n            try {\n                semaphore1.acquire();\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n            System.out.println(Thread.currentThread().getName() + \": A\");\n            semaphore2.release();\n        }\n    });\n    Thread thread2 = new Thread(() -> {\n        while (true) {\n            try {\n                semaphore2.acquire();\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n            System.out.println(Thread.currentThread().getName() + \": B\");\n            semaphore3.release();\n        }\n    });\n    Thread thread3 = new Thread(() -> {\n        while (true) {\n            try {\n                semaphore3.acquire();\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n            System.out.println(Thread.currentThread().getName() + \": C\");\n            semaphore1.release();\n        }\n    });\n    thread1.start();\n    thread2.start();\n    thread3.start();\n}\n```\n\n21. 是否有其他offer（我说只有京东）；什么时候能到岗\n22. 反问（业务：歌曲版权生命周期；面试流程：2轮技术+1轮hr）\n\n## 腾讯音乐二面\n（3.24，55min）\n\n1. 为啥来深圳，有啥offer\n2. 自我介绍\n3. 最有难度的项目介绍\n4. 在这个场景下，如何将服务运行多份实例，这种情况下之前的方案存在什么问题，可以用什么解决方案\n5. xxl-job了解吗（不了解）\n6. mysql的执行计划分析了解吗\n7. explain中了解哪些字段，最应该关注什么字段\n8. extra中的filesort了解吗（不了解）\n9. filesort本质就是对外部文件进行排序，推测一下它的过程\n10. springboot中动态代理和静态代理有什么区别\n11. springboot中如何实现动态代理\n12. 举一个例子，A接口有test方法，B类实现了A接口，写一个B类的静态代理类\n13. 为什么要这样写（C实现A的接口）\n14. 除了上面的写法，还有什么方法吗（子类的方法）\n15. 你觉得这两种方法本质有什么区别（本质就是动态代理的两种实现）\n16. 用过kafka之类的消息中间件吗（没有）\n17. spring中事务传播机制本质是解决了什么问题，为什么在数据库有acid的基础上要额外有这个机制\n18. 扣库存和修改订单两个操作在有@Transactional和没有的情况下，分别发生了几次数据库连接操作\n19. 什么时候能来实习\n20. 反问：没问题，就是暗示我在学习分布式\n\n（后面可能会有三轮技术面，也有可能没有）\n\n\n## 腾讯音乐三面\n（3.26，46min）\n\n1. 自我介绍\n2. spring cloud的微服务中有哪些组成部分\n3. 为什么是其他微服务从eureka拉取其他节点信息，而不是eureka向其他微服务推送节点（AP模型，牺牲一致性保证高可用）\n4. 如果eureka节点坏了，怎么办（多eureka设计；本地缓存兜底）\n5. 除了eureka还知道什么（只说出了一个名词nanos）\n6. RBAC模型介绍\n7. 你们系统中定义的资源是什么\n8. 部门管理者和下面的员工，如何实现员工只能看见自己创建的数据，部门管理者可以看见部门下全部数据呢\n9. 知道功能权限和数据权限的切分吗\n10. 深度分页问题了解吗（mysql有100kW条数据，每次读100个数据会变慢，可以自己去了解下）\n11. 冗余表设计的问题（被质疑没有太大意义）\n12. 多张表join命中了索引，但是还是比较慢，可以怎么优化\n13. tcp七层模型\n14. http的请求头有哪些内容（真不熟）\n15. tcp和udp的区别\n16. 项目中有用到udp协议吗（用到了websocket）\n17. https是什么\n18. 用过linux吗，知道哪些常见指令\n19. 项目中实现了下单到支付的全流程，那下单和支付如何保证一致性\n20. 了解分布式事务吗（不知道）\n21. 知道单机事务吗\n22. 有了解哪些新技术\n23. （反问）推荐学习什么：elastic search等\n\n\n## 腾讯音乐HR面\n（4.2，9min，电话面）\n\n1. 实习经历所做的事\n2. 遇到的挑战，自己所发挥的长处\n3. 是否有其他offer\n4. 为什么更喜欢深圳\n5. （反问）腾讯音乐培养体系\n","slug":"2025/暑期实习-腾讯音乐面试","published":1,"updated":"2025-10-31T02:04:03.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmhg4qt4z0016f5fa696eb4j1","content":"<h1 id=\"暑期实习-腾讯音乐面试\"><a href=\"#暑期实习-腾讯音乐面试\" class=\"headerlink\" title=\"暑期实习-腾讯音乐面试\"></a>暑期实习-腾讯音乐面试</h1><h2 id=\"腾讯音乐一面\"><a href=\"#腾讯音乐一面\" class=\"headerlink\" title=\"腾讯音乐一面\"></a>腾讯音乐一面</h2><p>（3.19，50分钟）</p>\n<ol>\n<li>为什么来深圳</li>\n<li>自我介绍</li>\n<li>实习经历介绍</li>\n<li>为什么选用Spring Task</li>\n<li>线程池的参数有哪些</li>\n<li>线程池的核心线程数如何选择</li>\n<li>mysql的索引机制</li>\n<li>有联合索引(a,b)，但是走了索引b，可能因为什么原因</li>\n<li>如何强制走某一个索引</li>\n<li>mysql如何去做查询优化</li>\n<li>用过redis的什么数据类型或者是否了解数据类型</li>\n<li>redis的持久化机制</li>\n<li>令牌桶算法</li>\n<li>还知道哪些其他的限流算法</li>\n<li>如何去实现一个高可用、高性能的系统</li>\n<li>Spring Bean对象的生命周期，以A a = new A()；为例</li>\n<li>Spring如何解决循环依赖</li>\n<li>项目中实时协同编程AST如何衡量代码是否重要</li>\n<li>共享屏幕场景题1：写一个单例模式，以及是否有其他实现方式（我写了惰性加载、直接加载和Enum的方式）</li>\n<li>场景题2：三个线程循环打印ABC</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Semaphore semaphore1 = <span class=\"keyword\">new</span> Semaphore(<span class=\"number\">1</span>);</span><br><span class=\"line\">    Semaphore semaphore2 = <span class=\"keyword\">new</span> Semaphore(<span class=\"number\">0</span>);</span><br><span class=\"line\">    Semaphore semaphore3 = <span class=\"keyword\">new</span> Semaphore(<span class=\"number\">0</span>);</span><br><span class=\"line\">    Thread thread1 = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                semaphore1.acquire();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;: A&quot;</span>);</span><br><span class=\"line\">            semaphore2.release();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    Thread thread2 = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                semaphore2.acquire();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;: B&quot;</span>);</span><br><span class=\"line\">            semaphore3.release();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    Thread thread3 = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                semaphore3.acquire();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;: C&quot;</span>);</span><br><span class=\"line\">            semaphore1.release();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    thread1.start();</span><br><span class=\"line\">    thread2.start();</span><br><span class=\"line\">    thread3.start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"21\">\n<li>是否有其他offer（我说只有京东）；什么时候能到岗</li>\n<li>反问（业务：歌曲版权生命周期；面试流程：2轮技术+1轮hr）</li>\n</ol>\n<h2 id=\"腾讯音乐二面\"><a href=\"#腾讯音乐二面\" class=\"headerlink\" title=\"腾讯音乐二面\"></a>腾讯音乐二面</h2><p>（3.24，55min）</p>\n<ol>\n<li>为啥来深圳，有啥offer</li>\n<li>自我介绍</li>\n<li>最有难度的项目介绍</li>\n<li>在这个场景下，如何将服务运行多份实例，这种情况下之前的方案存在什么问题，可以用什么解决方案</li>\n<li>xxl-job了解吗（不了解）</li>\n<li>mysql的执行计划分析了解吗</li>\n<li>explain中了解哪些字段，最应该关注什么字段</li>\n<li>extra中的filesort了解吗（不了解）</li>\n<li>filesort本质就是对外部文件进行排序，推测一下它的过程</li>\n<li>springboot中动态代理和静态代理有什么区别</li>\n<li>springboot中如何实现动态代理</li>\n<li>举一个例子，A接口有test方法，B类实现了A接口，写一个B类的静态代理类</li>\n<li>为什么要这样写（C实现A的接口）</li>\n<li>除了上面的写法，还有什么方法吗（子类的方法）</li>\n<li>你觉得这两种方法本质有什么区别（本质就是动态代理的两种实现）</li>\n<li>用过kafka之类的消息中间件吗（没有）</li>\n<li>spring中事务传播机制本质是解决了什么问题，为什么在数据库有acid的基础上要额外有这个机制</li>\n<li>扣库存和修改订单两个操作在有@Transactional和没有的情况下，分别发生了几次数据库连接操作</li>\n<li>什么时候能来实习</li>\n<li>反问：没问题，就是暗示我在学习分布式</li>\n</ol>\n<p>（后面可能会有三轮技术面，也有可能没有）</p>\n<h2 id=\"腾讯音乐三面\"><a href=\"#腾讯音乐三面\" class=\"headerlink\" title=\"腾讯音乐三面\"></a>腾讯音乐三面</h2><p>（3.26，46min）</p>\n<ol>\n<li>自我介绍</li>\n<li>spring cloud的微服务中有哪些组成部分</li>\n<li>为什么是其他微服务从eureka拉取其他节点信息，而不是eureka向其他微服务推送节点（AP模型，牺牲一致性保证高可用）</li>\n<li>如果eureka节点坏了，怎么办（多eureka设计；本地缓存兜底）</li>\n<li>除了eureka还知道什么（只说出了一个名词nanos）</li>\n<li>RBAC模型介绍</li>\n<li>你们系统中定义的资源是什么</li>\n<li>部门管理者和下面的员工，如何实现员工只能看见自己创建的数据，部门管理者可以看见部门下全部数据呢</li>\n<li>知道功能权限和数据权限的切分吗</li>\n<li>深度分页问题了解吗（mysql有100kW条数据，每次读100个数据会变慢，可以自己去了解下）</li>\n<li>冗余表设计的问题（被质疑没有太大意义）</li>\n<li>多张表join命中了索引，但是还是比较慢，可以怎么优化</li>\n<li>tcp七层模型</li>\n<li>http的请求头有哪些内容（真不熟）</li>\n<li>tcp和udp的区别</li>\n<li>项目中有用到udp协议吗（用到了websocket）</li>\n<li>https是什么</li>\n<li>用过linux吗，知道哪些常见指令</li>\n<li>项目中实现了下单到支付的全流程，那下单和支付如何保证一致性</li>\n<li>了解分布式事务吗（不知道）</li>\n<li>知道单机事务吗</li>\n<li>有了解哪些新技术</li>\n<li>（反问）推荐学习什么：elastic search等</li>\n</ol>\n<h2 id=\"腾讯音乐HR面\"><a href=\"#腾讯音乐HR面\" class=\"headerlink\" title=\"腾讯音乐HR面\"></a>腾讯音乐HR面</h2><p>（4.2，9min，电话面）</p>\n<ol>\n<li>实习经历所做的事</li>\n<li>遇到的挑战，自己所发挥的长处</li>\n<li>是否有其他offer</li>\n<li>为什么更喜欢深圳</li>\n<li>（反问）腾讯音乐培养体系</li>\n</ol>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<h1 id=\"暑期实习-腾讯音乐面试\"><a href=\"#暑期实习-腾讯音乐面试\" class=\"headerlink\" title=\"暑期实习-腾讯音乐面试\"></a>暑期实习-腾讯音乐面试</h1><h2 id=\"腾讯音乐一面\"><a href=\"#腾讯音乐一面\" class=\"headerlink\" title=\"腾讯音乐一面\"></a>腾讯音乐一面</h2><p>（3.19，50分钟）</p>\n<ol>\n<li>为什么来深圳</li>\n<li>自我介绍</li>\n<li>实习经历介绍</li>\n<li>为什么选用Spring Task</li>\n<li>线程池的参数有哪些</li>\n<li>线程池的核心线程数如何选择</li>\n<li>mysql的索引机制</li>\n<li>有联合索引(a,b)，但是走了索引b，可能因为什么原因</li>\n<li>如何强制走某一个索引</li>\n<li>mysql如何去做查询优化</li>\n<li>用过redis的什么数据类型或者是否了解数据类型</li>\n<li>redis的持久化机制</li>\n<li>令牌桶算法</li>\n<li>还知道哪些其他的限流算法</li>\n<li>如何去实现一个高可用、高性能的系统</li>\n<li>Spring Bean对象的生命周期，以A a = new A()；为例</li>\n<li>Spring如何解决循环依赖</li>\n<li>项目中实时协同编程AST如何衡量代码是否重要</li>\n<li>共享屏幕场景题1：写一个单例模式，以及是否有其他实现方式（我写了惰性加载、直接加载和Enum的方式）</li>\n<li>场景题2：三个线程循环打印ABC</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Semaphore semaphore1 = <span class=\"keyword\">new</span> Semaphore(<span class=\"number\">1</span>);</span><br><span class=\"line\">    Semaphore semaphore2 = <span class=\"keyword\">new</span> Semaphore(<span class=\"number\">0</span>);</span><br><span class=\"line\">    Semaphore semaphore3 = <span class=\"keyword\">new</span> Semaphore(<span class=\"number\">0</span>);</span><br><span class=\"line\">    Thread thread1 = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                semaphore1.acquire();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;: A&quot;</span>);</span><br><span class=\"line\">            semaphore2.release();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    Thread thread2 = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                semaphore2.acquire();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;: B&quot;</span>);</span><br><span class=\"line\">            semaphore3.release();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    Thread thread3 = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                semaphore3.acquire();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;: C&quot;</span>);</span><br><span class=\"line\">            semaphore1.release();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    thread1.start();</span><br><span class=\"line\">    thread2.start();</span><br><span class=\"line\">    thread3.start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"21\">\n<li>是否有其他offer（我说只有京东）；什么时候能到岗</li>\n<li>反问（业务：歌曲版权生命周期；面试流程：2轮技术+1轮hr）</li>\n</ol>\n<h2 id=\"腾讯音乐二面\"><a href=\"#腾讯音乐二面\" class=\"headerlink\" title=\"腾讯音乐二面\"></a>腾讯音乐二面</h2><p>（3.24，55min）</p>\n<ol>\n<li>为啥来深圳，有啥offer</li>\n<li>自我介绍</li>\n<li>最有难度的项目介绍</li>\n<li>在这个场景下，如何将服务运行多份实例，这种情况下之前的方案存在什么问题，可以用什么解决方案</li>\n<li>xxl-job了解吗（不了解）</li>\n<li>mysql的执行计划分析了解吗</li>\n<li>explain中了解哪些字段，最应该关注什么字段</li>\n<li>extra中的filesort了解吗（不了解）</li>\n<li>filesort本质就是对外部文件进行排序，推测一下它的过程</li>\n<li>springboot中动态代理和静态代理有什么区别</li>\n<li>springboot中如何实现动态代理</li>\n<li>举一个例子，A接口有test方法，B类实现了A接口，写一个B类的静态代理类</li>\n<li>为什么要这样写（C实现A的接口）</li>\n<li>除了上面的写法，还有什么方法吗（子类的方法）</li>\n<li>你觉得这两种方法本质有什么区别（本质就是动态代理的两种实现）</li>\n<li>用过kafka之类的消息中间件吗（没有）</li>\n<li>spring中事务传播机制本质是解决了什么问题，为什么在数据库有acid的基础上要额外有这个机制</li>\n<li>扣库存和修改订单两个操作在有@Transactional和没有的情况下，分别发生了几次数据库连接操作</li>\n<li>什么时候能来实习</li>\n<li>反问：没问题，就是暗示我在学习分布式</li>\n</ol>\n<p>（后面可能会有三轮技术面，也有可能没有）</p>\n<h2 id=\"腾讯音乐三面\"><a href=\"#腾讯音乐三面\" class=\"headerlink\" title=\"腾讯音乐三面\"></a>腾讯音乐三面</h2><p>（3.26，46min）</p>\n<ol>\n<li>自我介绍</li>\n<li>spring cloud的微服务中有哪些组成部分</li>\n<li>为什么是其他微服务从eureka拉取其他节点信息，而不是eureka向其他微服务推送节点（AP模型，牺牲一致性保证高可用）</li>\n<li>如果eureka节点坏了，怎么办（多eureka设计；本地缓存兜底）</li>\n<li>除了eureka还知道什么（只说出了一个名词nanos）</li>\n<li>RBAC模型介绍</li>\n<li>你们系统中定义的资源是什么</li>\n<li>部门管理者和下面的员工，如何实现员工只能看见自己创建的数据，部门管理者可以看见部门下全部数据呢</li>\n<li>知道功能权限和数据权限的切分吗</li>\n<li>深度分页问题了解吗（mysql有100kW条数据，每次读100个数据会变慢，可以自己去了解下）</li>\n<li>冗余表设计的问题（被质疑没有太大意义）</li>\n<li>多张表join命中了索引，但是还是比较慢，可以怎么优化</li>\n<li>tcp七层模型</li>\n<li>http的请求头有哪些内容（真不熟）</li>\n<li>tcp和udp的区别</li>\n<li>项目中有用到udp协议吗（用到了websocket）</li>\n<li>https是什么</li>\n<li>用过linux吗，知道哪些常见指令</li>\n<li>项目中实现了下单到支付的全流程，那下单和支付如何保证一致性</li>\n<li>了解分布式事务吗（不知道）</li>\n<li>知道单机事务吗</li>\n<li>有了解哪些新技术</li>\n<li>（反问）推荐学习什么：elastic search等</li>\n</ol>\n<h2 id=\"腾讯音乐HR面\"><a href=\"#腾讯音乐HR面\" class=\"headerlink\" title=\"腾讯音乐HR面\"></a>腾讯音乐HR面</h2><p>（4.2，9min，电话面）</p>\n<ol>\n<li>实习经历所做的事</li>\n<li>遇到的挑战，自己所发挥的长处</li>\n<li>是否有其他offer</li>\n<li>为什么更喜欢深圳</li>\n<li>（反问）腾讯音乐培养体系</li>\n</ol>\n"},{"title":"秋招面试-小米","date":"2025-11-01T10:00:00.000Z","cover":"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/o4IANoiAuCvAHg9X2hQAFFEAmeDgNpAqhfoaZC~tplv-dy-aweme-images:q75-20251101-180224.webp","_content":"\n# 秋招面试-小米\n\n## 小米一面\n\n（8.27 45min）\n\n1. 自我介绍\n2. JVM内存模型\n3. 哪些内存结构会发生OOM\n4. 发生OOM如何排查\n5. 有哪些垃圾回收算法\n6. G1垃圾回收器相比于CMS最大的优势是什么\n7. 有阅读过G1垃圾回收器的源码吗\n8. ArrayList和LinkedList的区别\n9. 线程池的参数有哪些\n10. ThreadLocal是什么\n11. Springboot和Spring的区别\n12. Springboot如何做到自动装配\n13. http请求的过程\n14. 介绍网络拥塞\n15. rpc和http的区别\n16. 实习项目介绍\n17. 实习项目引申：如果分布式锁过期了，该如何处理\n18. 日常如何学习\n19. （算法，手动输入输出）第K大的元素\n\n\n## 小米二面\n\n（8.28 35min）\n\n1. 自我介绍\n2. 家乡\n3. 实习项目介绍 + challenge一些细节\n4. 文件系统和数据库的区别\n5. SQL的全称\n6. 介绍Zookeeper的备份机制\n7. CAP理论\n8. Zookeeper是CP还是AP\n9. Zookeeper的CP产生的问题如何解决\n10. （算法）第K大的元素 + 1000瓶水用小鼠找毒药\n","source":"_posts/2025/秋招面试-小米.md","raw":"---\ntitle: 秋招面试-小米\ndate: 2025-11-01 18:00:00\ncover: https://upic-1301780692.cos.ap-shanghai.myqcloud.com/o4IANoiAuCvAHg9X2hQAFFEAmeDgNpAqhfoaZC~tplv-dy-aweme-images:q75-20251101-180224.webp\ntag: 秋招\n---\n\n# 秋招面试-小米\n\n## 小米一面\n\n（8.27 45min）\n\n1. 自我介绍\n2. JVM内存模型\n3. 哪些内存结构会发生OOM\n4. 发生OOM如何排查\n5. 有哪些垃圾回收算法\n6. G1垃圾回收器相比于CMS最大的优势是什么\n7. 有阅读过G1垃圾回收器的源码吗\n8. ArrayList和LinkedList的区别\n9. 线程池的参数有哪些\n10. ThreadLocal是什么\n11. Springboot和Spring的区别\n12. Springboot如何做到自动装配\n13. http请求的过程\n14. 介绍网络拥塞\n15. rpc和http的区别\n16. 实习项目介绍\n17. 实习项目引申：如果分布式锁过期了，该如何处理\n18. 日常如何学习\n19. （算法，手动输入输出）第K大的元素\n\n\n## 小米二面\n\n（8.28 35min）\n\n1. 自我介绍\n2. 家乡\n3. 实习项目介绍 + challenge一些细节\n4. 文件系统和数据库的区别\n5. SQL的全称\n6. 介绍Zookeeper的备份机制\n7. CAP理论\n8. Zookeeper是CP还是AP\n9. Zookeeper的CP产生的问题如何解决\n10. （算法）第K大的元素 + 1000瓶水用小鼠找毒药\n","slug":"2025/秋招面试-小米","published":1,"updated":"2025-11-01T10:03:35.756Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmhg4qt520018f5fa6bwselp6","content":"<h1 id=\"秋招面试-小米\"><a href=\"#秋招面试-小米\" class=\"headerlink\" title=\"秋招面试-小米\"></a>秋招面试-小米</h1><h2 id=\"小米一面\"><a href=\"#小米一面\" class=\"headerlink\" title=\"小米一面\"></a>小米一面</h2><p>（8.27 45min）</p>\n<ol>\n<li>自我介绍</li>\n<li>JVM内存模型</li>\n<li>哪些内存结构会发生OOM</li>\n<li>发生OOM如何排查</li>\n<li>有哪些垃圾回收算法</li>\n<li>G1垃圾回收器相比于CMS最大的优势是什么</li>\n<li>有阅读过G1垃圾回收器的源码吗</li>\n<li>ArrayList和LinkedList的区别</li>\n<li>线程池的参数有哪些</li>\n<li>ThreadLocal是什么</li>\n<li>Springboot和Spring的区别</li>\n<li>Springboot如何做到自动装配</li>\n<li>http请求的过程</li>\n<li>介绍网络拥塞</li>\n<li>rpc和http的区别</li>\n<li>实习项目介绍</li>\n<li>实习项目引申：如果分布式锁过期了，该如何处理</li>\n<li>日常如何学习</li>\n<li>（算法，手动输入输出）第K大的元素</li>\n</ol>\n<h2 id=\"小米二面\"><a href=\"#小米二面\" class=\"headerlink\" title=\"小米二面\"></a>小米二面</h2><p>（8.28 35min）</p>\n<ol>\n<li>自我介绍</li>\n<li>家乡</li>\n<li>实习项目介绍 + challenge一些细节</li>\n<li>文件系统和数据库的区别</li>\n<li>SQL的全称</li>\n<li>介绍Zookeeper的备份机制</li>\n<li>CAP理论</li>\n<li>Zookeeper是CP还是AP</li>\n<li>Zookeeper的CP产生的问题如何解决</li>\n<li>（算法）第K大的元素 + 1000瓶水用小鼠找毒药</li>\n</ol>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<h1 id=\"秋招面试-小米\"><a href=\"#秋招面试-小米\" class=\"headerlink\" title=\"秋招面试-小米\"></a>秋招面试-小米</h1><h2 id=\"小米一面\"><a href=\"#小米一面\" class=\"headerlink\" title=\"小米一面\"></a>小米一面</h2><p>（8.27 45min）</p>\n<ol>\n<li>自我介绍</li>\n<li>JVM内存模型</li>\n<li>哪些内存结构会发生OOM</li>\n<li>发生OOM如何排查</li>\n<li>有哪些垃圾回收算法</li>\n<li>G1垃圾回收器相比于CMS最大的优势是什么</li>\n<li>有阅读过G1垃圾回收器的源码吗</li>\n<li>ArrayList和LinkedList的区别</li>\n<li>线程池的参数有哪些</li>\n<li>ThreadLocal是什么</li>\n<li>Springboot和Spring的区别</li>\n<li>Springboot如何做到自动装配</li>\n<li>http请求的过程</li>\n<li>介绍网络拥塞</li>\n<li>rpc和http的区别</li>\n<li>实习项目介绍</li>\n<li>实习项目引申：如果分布式锁过期了，该如何处理</li>\n<li>日常如何学习</li>\n<li>（算法，手动输入输出）第K大的元素</li>\n</ol>\n<h2 id=\"小米二面\"><a href=\"#小米二面\" class=\"headerlink\" title=\"小米二面\"></a>小米二面</h2><p>（8.28 35min）</p>\n<ol>\n<li>自我介绍</li>\n<li>家乡</li>\n<li>实习项目介绍 + challenge一些细节</li>\n<li>文件系统和数据库的区别</li>\n<li>SQL的全称</li>\n<li>介绍Zookeeper的备份机制</li>\n<li>CAP理论</li>\n<li>Zookeeper是CP还是AP</li>\n<li>Zookeeper的CP产生的问题如何解决</li>\n<li>（算法）第K大的元素 + 1000瓶水用小鼠找毒药</li>\n</ol>\n"},{"title":"秋招面试-虾皮","date":"2025-11-01T09:57:00.000Z","cover":"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/26c9324913c021677768-20251101-180143.png","_content":"\n# 秋招面试-虾皮\n\n## 虾皮一面\n（8.5，50min）\n\n### 自我介绍+项目\n（约20分钟）\n\n自我介绍\n\n腾讯实习介绍+面试官challenge细节\n\n蔚来实习介绍\n\n实验室项目介绍+面试官challenge细节\n\n\n### 算法\n算法题（把树上每一层的节点全部往左移动，右边剩下的的位置设置为空）\n\n纯代码编辑器，但是跟面试官说只写核心算法。因为没跑，所以最开始忘记把每一层后面的节点都置为null了\n\n### 八股部分\n\n死锁\n\n如何解决死锁\n\n进程间的通信方式\n\n用过哪些linux命令\n\nmysql为什么用B+树，而非B树和二叉树\n\n跳表为什么不行\n\nmysql如何查询优化\n\nselect b from tab where a =xxx 为什么没走(a,b)索引\n\nTCP三次握手和四次挥手\n\n反问\n\n## 虾皮二面\n\n（8.8）\n\n1. 业务介绍\n2. 自我介绍\n3. 腾讯实习项目介绍，以及面试官的一些challenge\n4. volatile如何实现可见性？每次都必须要从主存中拿数据吗？\n5. 二维数组按行访问和按列访问的时间分别是多少？\n6. index(a, b, c) select * from t where b = 1 and a = 2 order by c; 走了索引的哪些字段？\n7. 现在上面这个查询语句没有走索引，为什么？\n8. 现在每个商家有自己的一张订单表，要实现某一个商家下载订单表全部数据的功能。如何查询订单表全部的数据？\n{% raw %}\n9. 算法题：K个有序数组 {{1,3}, {2,4,5,6,7,9}, {1,2,7,9,10,11,12}}，将其合并为一个数组{1,1,2,2,...}\n{% endraw %}\n\n\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[][] nums = {{1,3}, {2,4,5,6,7,9}, {1,2,7,9,10,11,12}};\n        int[] ans = sort(nums, 0, 2);\n\n        for (int i = 0; i < ans.length; ++i) {\n            System.out.print(ans[i] + \",\");\n        }\n    }\n    // k * n\n    // 时间复杂度：O(nlogK)\n    // 空间复杂度：O(k*n)\n    public static int[] sort(int[][] nums, int left, int right) {\n        if (left >= right) {\n            return nums[left];\n        }\n        int mid = left + (right - left) / 2;\n        int[] nums1 = sort(nums, left, mid);\n        int[] nums2 = sort(nums, mid + 1, right);\n        // 合并成一个更大的数组\n        int len1 = nums1.length;\n        int len2 = nums2.length;\n        // System.out.println(len1 + \", \" + len2);\n        int[] sumNums = new int[len1 + len2];\n        int i = 0, j = 0;\n        int index = 0;\n        while (i < len1 && j < len2) {\n            if (nums1[i] < nums2[j]) {\n                sumNums[index] = nums1[i];\n                ++i;\n            } else {\n                sumNums[index] = nums2[j];\n                ++j;\n            }\n            ++index;\n        }\n        while (i < len1) {\n            sumNums[index] = nums1[i];\n            ++i;\n            ++index;\n        }\n        while (j < len2) {\n            sumNums[index] = nums2[j];\n            ++j;\n            ++index;\n        }\n        return sumNums;\n    }\n}\n```\n\n## 虾皮HR面\n（8.13）\n","source":"_posts/2025/秋招面试-虾皮.md","raw":"---\ntitle: 秋招面试-虾皮\ndate: 2025-11-01 17:57:00\ncover: https://upic-1301780692.cos.ap-shanghai.myqcloud.com/26c9324913c021677768-20251101-180143.png\ntag: 秋招\n---\n\n# 秋招面试-虾皮\n\n## 虾皮一面\n（8.5，50min）\n\n### 自我介绍+项目\n（约20分钟）\n\n自我介绍\n\n腾讯实习介绍+面试官challenge细节\n\n蔚来实习介绍\n\n实验室项目介绍+面试官challenge细节\n\n\n### 算法\n算法题（把树上每一层的节点全部往左移动，右边剩下的的位置设置为空）\n\n纯代码编辑器，但是跟面试官说只写核心算法。因为没跑，所以最开始忘记把每一层后面的节点都置为null了\n\n### 八股部分\n\n死锁\n\n如何解决死锁\n\n进程间的通信方式\n\n用过哪些linux命令\n\nmysql为什么用B+树，而非B树和二叉树\n\n跳表为什么不行\n\nmysql如何查询优化\n\nselect b from tab where a =xxx 为什么没走(a,b)索引\n\nTCP三次握手和四次挥手\n\n反问\n\n## 虾皮二面\n\n（8.8）\n\n1. 业务介绍\n2. 自我介绍\n3. 腾讯实习项目介绍，以及面试官的一些challenge\n4. volatile如何实现可见性？每次都必须要从主存中拿数据吗？\n5. 二维数组按行访问和按列访问的时间分别是多少？\n6. index(a, b, c) select * from t where b = 1 and a = 2 order by c; 走了索引的哪些字段？\n7. 现在上面这个查询语句没有走索引，为什么？\n8. 现在每个商家有自己的一张订单表，要实现某一个商家下载订单表全部数据的功能。如何查询订单表全部的数据？\n{% raw %}\n9. 算法题：K个有序数组 {{1,3}, {2,4,5,6,7,9}, {1,2,7,9,10,11,12}}，将其合并为一个数组{1,1,2,2,...}\n{% endraw %}\n\n\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[][] nums = {{1,3}, {2,4,5,6,7,9}, {1,2,7,9,10,11,12}};\n        int[] ans = sort(nums, 0, 2);\n\n        for (int i = 0; i < ans.length; ++i) {\n            System.out.print(ans[i] + \",\");\n        }\n    }\n    // k * n\n    // 时间复杂度：O(nlogK)\n    // 空间复杂度：O(k*n)\n    public static int[] sort(int[][] nums, int left, int right) {\n        if (left >= right) {\n            return nums[left];\n        }\n        int mid = left + (right - left) / 2;\n        int[] nums1 = sort(nums, left, mid);\n        int[] nums2 = sort(nums, mid + 1, right);\n        // 合并成一个更大的数组\n        int len1 = nums1.length;\n        int len2 = nums2.length;\n        // System.out.println(len1 + \", \" + len2);\n        int[] sumNums = new int[len1 + len2];\n        int i = 0, j = 0;\n        int index = 0;\n        while (i < len1 && j < len2) {\n            if (nums1[i] < nums2[j]) {\n                sumNums[index] = nums1[i];\n                ++i;\n            } else {\n                sumNums[index] = nums2[j];\n                ++j;\n            }\n            ++index;\n        }\n        while (i < len1) {\n            sumNums[index] = nums1[i];\n            ++i;\n            ++index;\n        }\n        while (j < len2) {\n            sumNums[index] = nums2[j];\n            ++j;\n            ++index;\n        }\n        return sumNums;\n    }\n}\n```\n\n## 虾皮HR面\n（8.13）\n","slug":"2025/秋招面试-虾皮","published":1,"updated":"2025-11-01T10:14:31.255Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmhg4qt54001bf5fa53os8knw","content":"<h1 id=\"秋招面试-虾皮\"><a href=\"#秋招面试-虾皮\" class=\"headerlink\" title=\"秋招面试-虾皮\"></a>秋招面试-虾皮</h1><h2 id=\"虾皮一面\"><a href=\"#虾皮一面\" class=\"headerlink\" title=\"虾皮一面\"></a>虾皮一面</h2><p>（8.5，50min）</p>\n<h3 id=\"自我介绍-项目\"><a href=\"#自我介绍-项目\" class=\"headerlink\" title=\"自我介绍+项目\"></a>自我介绍+项目</h3><p>（约20分钟）</p>\n<p>自我介绍</p>\n<p>腾讯实习介绍+面试官challenge细节</p>\n<p>蔚来实习介绍</p>\n<p>实验室项目介绍+面试官challenge细节</p>\n<h3 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h3><p>算法题（把树上每一层的节点全部往左移动，右边剩下的的位置设置为空）</p>\n<p>纯代码编辑器，但是跟面试官说只写核心算法。因为没跑，所以最开始忘记把每一层后面的节点都置为null了</p>\n<h3 id=\"八股部分\"><a href=\"#八股部分\" class=\"headerlink\" title=\"八股部分\"></a>八股部分</h3><p>死锁</p>\n<p>如何解决死锁</p>\n<p>进程间的通信方式</p>\n<p>用过哪些linux命令</p>\n<p>mysql为什么用B+树，而非B树和二叉树</p>\n<p>跳表为什么不行</p>\n<p>mysql如何查询优化</p>\n<p>select b from tab where a =xxx 为什么没走(a,b)索引</p>\n<p>TCP三次握手和四次挥手</p>\n<p>反问</p>\n<h2 id=\"虾皮二面\"><a href=\"#虾皮二面\" class=\"headerlink\" title=\"虾皮二面\"></a>虾皮二面</h2><p>（8.8）</p>\n<ol>\n<li>业务介绍</li>\n<li>自我介绍</li>\n<li>腾讯实习项目介绍，以及面试官的一些challenge</li>\n<li>volatile如何实现可见性？每次都必须要从主存中拿数据吗？</li>\n<li>二维数组按行访问和按列访问的时间分别是多少？</li>\n<li>index(a, b, c) select * from t where b = 1 and a = 2 order by c; 走了索引的哪些字段？</li>\n<li>现在上面这个查询语句没有走索引，为什么？</li>\n<li>现在每个商家有自己的一张订单表，要实现某一个商家下载订单表全部数据的功能。如何查询订单表全部的数据？\n9. 算法题：K个有序数组 {{1,3}, {2,4,5,6,7,9}, {1,2,7,9,10,11,12}}，将其合并为一个数组{1,1,2,2,...}\n\n\n\n\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] nums = &#123;&#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>&#125;, &#123;<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">9</span>&#125;, &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">7</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>,<span class=\"number\">11</span>,<span class=\"number\">12</span>&#125;&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] ans = sort(nums, <span class=\"number\">0</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; ans.length; ++i) &#123;</span><br><span class=\"line\">            System.out.print(ans[i] + <span class=\"string\">&quot;,&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// k * n</span></span><br><span class=\"line\">    <span class=\"comment\">// 时间复杂度：O(nlogK)</span></span><br><span class=\"line\">    <span class=\"comment\">// 空间复杂度：O(k*n)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] sort(<span class=\"keyword\">int</span>[][] nums, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &gt;= right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums[left];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] nums1 = sort(nums, left, mid);</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] nums2 = sort(nums, mid + <span class=\"number\">1</span>, right);</span><br><span class=\"line\">        <span class=\"comment\">// 合并成一个更大的数组</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> len1 = nums1.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len2 = nums2.length;</span><br><span class=\"line\">        <span class=\"comment\">// System.out.println(len1 + &quot;, &quot; + len2);</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] sumNums = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[len1 + len2];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; len1 &amp;&amp; j &lt; len2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums1[i] &lt; nums2[j]) &#123;</span><br><span class=\"line\">                sumNums[index] = nums1[i];</span><br><span class=\"line\">                ++i;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                sumNums[index] = nums2[j];</span><br><span class=\"line\">                ++j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ++index;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; len1) &#123;</span><br><span class=\"line\">            sumNums[index] = nums1[i];</span><br><span class=\"line\">            ++i;</span><br><span class=\"line\">            ++index;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (j &lt; len2) &#123;</span><br><span class=\"line\">            sumNums[index] = nums2[j];</span><br><span class=\"line\">            ++j;</span><br><span class=\"line\">            ++index;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sumNums;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"虾皮HR面\"><a href=\"#虾皮HR面\" class=\"headerlink\" title=\"虾皮HR面\"></a>虾皮HR面</h2><p>（8.13）</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<h1 id=\"秋招面试-虾皮\"><a href=\"#秋招面试-虾皮\" class=\"headerlink\" title=\"秋招面试-虾皮\"></a>秋招面试-虾皮</h1><h2 id=\"虾皮一面\"><a href=\"#虾皮一面\" class=\"headerlink\" title=\"虾皮一面\"></a>虾皮一面</h2><p>（8.5，50min）</p>\n<h3 id=\"自我介绍-项目\"><a href=\"#自我介绍-项目\" class=\"headerlink\" title=\"自我介绍+项目\"></a>自我介绍+项目</h3><p>（约20分钟）</p>\n<p>自我介绍</p>\n<p>腾讯实习介绍+面试官challenge细节</p>\n<p>蔚来实习介绍</p>\n<p>实验室项目介绍+面试官challenge细节</p>\n<h3 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h3><p>算法题（把树上每一层的节点全部往左移动，右边剩下的的位置设置为空）</p>\n<p>纯代码编辑器，但是跟面试官说只写核心算法。因为没跑，所以最开始忘记把每一层后面的节点都置为null了</p>\n<h3 id=\"八股部分\"><a href=\"#八股部分\" class=\"headerlink\" title=\"八股部分\"></a>八股部分</h3><p>死锁</p>\n<p>如何解决死锁</p>\n<p>进程间的通信方式</p>\n<p>用过哪些linux命令</p>\n<p>mysql为什么用B+树，而非B树和二叉树</p>\n<p>跳表为什么不行</p>\n<p>mysql如何查询优化</p>\n<p>select b from tab where a =xxx 为什么没走(a,b)索引</p>\n<p>TCP三次握手和四次挥手</p>\n<p>反问</p>\n<h2 id=\"虾皮二面\"><a href=\"#虾皮二面\" class=\"headerlink\" title=\"虾皮二面\"></a>虾皮二面</h2><p>（8.8）</p>\n<ol>\n<li>业务介绍</li>\n<li>自我介绍</li>\n<li>腾讯实习项目介绍，以及面试官的一些challenge</li>\n<li>volatile如何实现可见性？每次都必须要从主存中拿数据吗？</li>\n<li>二维数组按行访问和按列访问的时间分别是多少？</li>\n<li>index(a, b, c) select * from t where b = 1 and a = 2 order by c; 走了索引的哪些字段？</li>\n<li>现在上面这个查询语句没有走索引，为什么？</li>\n<li>现在每个商家有自己的一张订单表，要实现某一个商家下载订单表全部数据的功能。如何查询订单表全部的数据？\n9. 算法题：K个有序数组 {{1,3}, {2,4,5,6,7,9}, {1,2,7,9,10,11,12}}，将其合并为一个数组{1,1,2,2,...}\n\n\n\n\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] nums = &#123;&#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>&#125;, &#123;<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">9</span>&#125;, &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">7</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>,<span class=\"number\">11</span>,<span class=\"number\">12</span>&#125;&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] ans = sort(nums, <span class=\"number\">0</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; ans.length; ++i) &#123;</span><br><span class=\"line\">            System.out.print(ans[i] + <span class=\"string\">&quot;,&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// k * n</span></span><br><span class=\"line\">    <span class=\"comment\">// 时间复杂度：O(nlogK)</span></span><br><span class=\"line\">    <span class=\"comment\">// 空间复杂度：O(k*n)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] sort(<span class=\"keyword\">int</span>[][] nums, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &gt;= right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums[left];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] nums1 = sort(nums, left, mid);</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] nums2 = sort(nums, mid + <span class=\"number\">1</span>, right);</span><br><span class=\"line\">        <span class=\"comment\">// 合并成一个更大的数组</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> len1 = nums1.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len2 = nums2.length;</span><br><span class=\"line\">        <span class=\"comment\">// System.out.println(len1 + &quot;, &quot; + len2);</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] sumNums = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[len1 + len2];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; len1 &amp;&amp; j &lt; len2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums1[i] &lt; nums2[j]) &#123;</span><br><span class=\"line\">                sumNums[index] = nums1[i];</span><br><span class=\"line\">                ++i;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                sumNums[index] = nums2[j];</span><br><span class=\"line\">                ++j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ++index;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; len1) &#123;</span><br><span class=\"line\">            sumNums[index] = nums1[i];</span><br><span class=\"line\">            ++i;</span><br><span class=\"line\">            ++index;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (j &lt; len2) &#123;</span><br><span class=\"line\">            sumNums[index] = nums2[j];</span><br><span class=\"line\">            ++j;</span><br><span class=\"line\">            ++index;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sumNums;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"虾皮HR面\"><a href=\"#虾皮HR面\" class=\"headerlink\" title=\"虾皮HR面\"></a>虾皮HR面</h2><p>（8.13）</p>\n"},{"title":"Git基本操作整理","date":"2022-03-29T04:00:00.000Z","description":"git的一些基本操作，一起交流学习","cover":"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f9be0486.png","_content":"\n# Git 基本操作整理\n\n## 前言\n\n本文档通过整理CS-Notes中的Git命令操作与实战Learn Git Branching来学习掌握Git方法。因为文档主要分为两部分，第一部分参考CS-Notes并查阅资料为Git理论知识，第二部分为实战Learn Git Branching给出个人思考与过程。\n\n参考资料来源:\n\n1. [CS-Notes Git部分](http://www.cyc2018.xyz/%E5%85%B6%E5%AE%83/%E7%BC%96%E7%A0%81%E5%AE%9E%E8%B7%B5/Git.html#%E9%9B%86%E4%B8%AD%E5%BC%8F%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F)\n\n2. [Learn Git Branching](https://learngitbranching.js.org/?demo=&locale=zh_CN)\n\n## Git知识\n\n\n\n## Learn Git Branching\n\n### Level 1. Git基础内容\n\n#### Git Commit\n\nGit 仓库中的提交记录保存的是你的目录下所有文件的快照，就像是把整个目录复制，然后再粘贴一样，但比复制粘贴优雅许多！\n\nGit 希望提交记录尽可能地轻量，因此在你每次进行提交时，它并不会盲目地复制整个目录。条件允许的情况下，它会将当前版本与仓库中的上一个版本进行对比，并把所有的差异打包到一起作为一个提交记录。Git 还保存了提交的历史记录。这也是为什么大多数提交记录的上面都有父节点的原因。对于项目组的成员来说，维护提交历史对大家都有好处。\n\nGit Commit 就是在父节点下进行一次内容的提交。使用的命令很简单为：\n\n💯==**git commit**==\n\n\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f9be0486.png)\n\n------\n\n#### Git Branch\n\nGit 的分支也非常轻量。它们只是简单地指向某个提交纪录 —— 仅此而已。\n\n所以许多 Git 爱好者传颂：😍**早建分支，多用分支！**\n\n这是因为即使创建再多的分支也不会造成储存或内存上的开销，并且按逻辑分解工作到不同的分支要比维护那些特别臃肿的分支简单多了。\n\n在将分支和提交记录结合起来后，我们会看到两者如何协作。现在只要记住使用分支其实就相当于在说：“**我想基于这个提交以及它所有的父提交进行新的工作。**”\n\n创建分支的命令最基础的就是：\n\n💯==**git branch <branch_name>**==\n\n创建好的分支会指向当前的提交记录。但是通过上述命令创建的分支并不是我们现在所使用的分支，如果我们此刻进行了git commit操作，那么我们的行为仍然是操作于原来的分支。所以我们如果想要使用这个新分支，我们需要使用切换分支的命令：\n\n💯==**git checkout <branch_name>**==\n\n有一个简洁的方式，如果你想创建一个新的分支同时切换到新创建的分支的话，可以通过 \n\n💯==**git checkout -b \\<your-branch-name\\>**==\n\n\n\n![](https://i0.hdslb.com/bfs/album/a11e89444b0b5c7d221325a9637f26e54ebe12c6.png)\n\n------\n\n#### Git Merge\n\n在知道如何提交以及如何使用分支的前提下，接下来是如何将两个分支合并到一起。就是说我们新建一个分支，在其上开发某个新功能，开发完成后再合并回主线。\n\n第一种方法是通过git merge实现的。在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个父节点。翻译成自然语言相当于：“我要把这两个父节点本身及它们所有的祖先都包含进来。”因此，git合并分支的命令是：\n\n💯==**git merge <branch_name>**==\n\n该命令是将branch_name合并到当前的分支下\n\n例如：我们有这两个分支main与bugFix，我们可以通过git merge命令来将两者合并：\n\n<img src=\"https://i0.hdslb.com/bfs/album/1a7e02089e6db4f76cec7be3ca3766caa38c1fd7.png\" style=\"zoom:50%;\" />\n\n合并后，我们发现新的分支是保留了两条路径指向父节点，并没有断了与任何一条分支的联系，因此这个过程支持了Git对历史版本信息的维护。\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f858fa9e.png\" style=\"zoom:50%;\" />\n\n接下来，可以将main分支合并到bugFix中\n\n通过`git checkout bugFix; git merge main`\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f8526a06.png\" style=\"zoom:50%;\" />\n\n因为 main 继承自 bugFix ，Git 什么都不用做，只是简单地把 bugFix 移动到 main 所指向的那个提交记录。\n\n![](https://i0.hdslb.com/bfs/album/08d9d8343a7164f9c6b01eccca5471872790f07f.png)\n\n------\n\n#### Git Rebase\n\n第二种合并分支的方法是 git rebase。Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。\n\nRebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。Rebase的命令如下：\n\n💯==**git rebase <branch_name>**==\n\n例如：同样我们有两个分支main和bugFix，我们可以通过rebase来将两者合并：\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f857516e.png\" style=\"zoom:50%;\" />\n\n通过rebase命令后，不同于原来的merge建立两条关于父节点的链接，而是通过提取一系列的提交记录然后建立一个基于main的副本，这样生成的线性的提交历史：\n\n<img src=\"https://i0.hdslb.com/bfs/album/59f7e1df1314389ddbbcb14fda46a0a679d6c999.png\" style=\"zoom:50%;\" />\n\n此时，原先分支的C3并没有被删除，接下来可以切换到main分支，通过rebase向前推进一个版本\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f857627e.png\" style=\"zoom:50%;\" />\n\nrebase命令维护一条线性的提交记录使得历史提交很清晰。我理解的话，主要是通过在代合并的分支上补充原有分支的一些历史提交信息，然后类似于“复制”了一个版本到待合并分支下，实现一个合并操作。\n\n![](https://i0.hdslb.com/bfs/album/8ee6ba5797dbd7b567f3a9f05c43a9d88472e13d.png)\n\n------\n\n### Level 2. Git高级内容\n\n#### 分离HEAD\n\nHEAD 是一个对当前检出记录的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。\n\nHEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。\n\nHEAD 通常情况下是指向分支名的（如 bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。\n\n**分离的 HEAD 就是让其指向了某个具体的提交记录而不是分支名。**在命令执行之前的状态如下所示：\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242631f0352b.png\" style=\"zoom:50%;\" />\n\nHEAD -> main -> C1\n\nHEAD 指向 main， main 指向 C1\n\n再通过 **git checkout C1** 后变成了：\n\nHEAD -> C1\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624263c60010b.png\" style=\"zoom:50%;\" />\n\n\n\n所以分离当前HEAD是通过：\n\n💯==**git checkout \\<hash_commit\\>**==\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624264090b652.png)\n\n------\n\n#### 相对引用(^)\n\n通过指定提交记录哈希值的方式在 Git 中移动不太方便。在实际应用时，并没有像本程序中这么漂亮的可视化提交树供你参考，所以你就不得不用 `git log` 来查查看提交记录的哈希值。\n\n并且哈希值在真实的 Git 世界中也会更长（e.g. 基于 SHA-1，共 40 位）。例如前一关的介绍中的提交记录的哈希值可能是 `fed2da64c0efc5293610bdd892f82a58e8cbc5d8`。比较令人欣慰的是，Git 对哈希的处理很智能。你只需要提供能够唯一标识提交记录的前几个字符即可。因此我可以仅输入`fed2` 而不是上面的一长串字符。\n\n通过哈希值提交记录很不方便，所以git引用了相对引用。使用相对引用的话，就可以从一个易于记忆的地方（比如 `bugFix` 分支或 `HEAD`）开始计算。\n\n相对引用非常给力，这里我介绍两个简单的用法：\n\n- 使用 `^` 向上移动 1 个提交记录\n- 使用 `~<num>` 向上移动多个提交记录，如 `~3`\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624274834cddb.png\" style=\"zoom:50%;\" />\n\n通过使用(\\^)可以相对很方便找到main的父节点，而不是通过哈希的方式，以此类推，可以通过main\\^\\^来实现寻找父节点的父节点\n💯==**git checkout main\\^**==\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624274aea1027.png\" style=\"zoom:50%;\" />\n\n\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624276378ff5f.png)\n\n------\n\n#### 相对引用2(~)\n\n如果你想在提交树中向上移动很多步的话，敲那么多 `^` 貌似也挺烦人的，Git 当然也考虑到了这一点，于是又引入了操作符 `~`。该操作符后面可以跟一个数字（可选，不跟数字时与 `^` 相同，向上移动一次），指定向上移动多少次。\n\n通过多次移动的相对引用命令，实现简洁的后退操作：\n\n💯==**git checkout HEAD\\~\\<num\\>**==\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624276db5423e.png\" style=\"zoom:50%;\" />\n\n\n\n使用相对引用比较多的场景就是移动分支。可以直接使用 `-f` 选项让分支指向另一个提交，达到强制修改分支的目的，例如:\n\n💯==**git branch -f main HEAD~3**==\n\n上面的命令会将 main 分支强制指向 HEAD 的第 3 级父提交。\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62427882a6119.png\" style=\"zoom:50%;\" />\n\n可以发现main分支指向了是HEAD向后移动3级父提交记录上\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a3729f60c.png\" style=\"zoom:50%;\" />\n\n合理使用git branch -f 与git checkout 可以实现对当前提交节点与分支的转换。\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a5ae757e9.png)\n\n------\n\n#### 撤销变更\n\n在 Git 里撤销变更的方法很多。和提交一样，撤销变更由底层部分（暂存区的独立文件或者片段）和上层部分（变更到底是通过哪种方式被撤销的）组成。我们这个应用主要关注的是后者。\n\n主要有两种方法用来撤销变更 —— 一是 `git reset`，还有就是 `git revert`。\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a6fb59604.png\" style=\"zoom:50%;\" />\n\n通过一下撤销变更的命令：\n\n💯==**git reset HEAD~1**==\n\nGit 把 main 分支移回到 C1；现在我们的本地代码库根本就不知道有 C2 这个提交了。但是在reset后， C2 所做的变更还在，但是处于未加入暂存区状态。\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a76660edc.png\" style=\"zoom:50%;\" />\n\ngit reset 撤销的方式对大家一起使用的远端分支是无效的，为了撤销更改并分享给别人，我们需要使用：\n\n💯==**git revert HEAD**==\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a82f31d87.png\" style=\"zoom:50%;\" />\n\n在我们要撤销的提交记录后面居然多了一个新提交！这是因为新提交记录 C2' 引入了**更改** —— 这些更改刚好是用来撤销 C2 这个提交的。也就是说 C2' 的状态与 C1 是相同的。revert 之后就可以把你的更改推送到远程仓库与别人分享啦。\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a9486b1f8.png)\n\n刚才试了一下reset的作用，其实就是本地回退到上一个版本得话，可以在更改一些功能后，通过rebase或者merge指定遗弃分支进行合并或者完全放弃？🤔\n\n------\n\n### Level 3. Git移动提交记录\n\n#### Git Cherry-pick\n\n接下来要讨论的这个话题是“整理提交记录” —— 开发人员有时会说“我想要把这个提交放到这里, 那个提交放到刚才那个提交的后面”, 而接下来就讲的就是它的实现方式，非常清晰、灵活，还很生动。\n\n如果你想将一些提交复制到当前所在的位置（`HEAD`）下面的话， Cherry-pick 是最直接的方式了。命令为：\n\n💯==**git cherry-pick \\<commit_version\\>**==\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242aab507c99.png\" style=\"zoom:50%;\" />\n\n这里有一个仓库, 我们想将 side 分支上的工作复制到 main 分支，rebase 可以解决这个问题，但是也可以通过 cherry-pick, 我们执行命令 git cherry-pick C2 C4\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ab6297234.png\" style=\"zoom:50%;\" />\n\n通过cherry-pick可以直接选取我们要的提交记录在当前分支之下，感觉git的整理提交记录的思想在于维护一条提交的线(主干线)\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242abd0e399a.png)\n\n------\n\n#### 交互式rebase\n\n当你知道你所需要的提交记录（**并且**还知道这些提交记录的哈希值）时, 用 cherry-pick 再好不过了 —— 没有比这更简单的方式了。但是如果你不清楚你想要的提交记录的哈希值呢? 幸好 Git 帮你想到了这一点, 我们可以利用交互式的 rebase —— 如果你想从一系列的提交记录中找到想要的记录, 这就是最好的方法了。\n\n交互式 rebase 指的是使用带参数 `--interactive` 的 rebase 命令, 简写为 `-i`\n\n如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。\n\n在实际使用时，所谓的 UI 窗口一般会在文本编辑器 —— 如 Vim —— 中打开一个文件。\n\n当 rebase UI界面打开时, 你能做3件事:\n\n- 调整提交记录的顺序（通过鼠标拖放来完成）\n- 删除你不想要的提交（通过切换 `pick` 的状态来完成，关闭就意味着你不想要这个提交记录）\n- 合并提交。\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242af2c739cb.png\" style=\"zoom:50%;\" />\n\n输入交互式rebase命令后：\n\n💯==**git rebase -i HEAD[~\\<num\\>|^]**==\n\n通过rebase -i HEAD~4实现对后续提交内容进行调整顺序，删除omit提交与合并\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242b17d54c69.png\" style=\"zoom:50%;\" />\n\n完全重新整理了commit的顺序，但是感觉需要以合理的机会使用，要不然真的会很艰难。\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242b33615af6.png)\n\n------\n\n### Level 4. 杂项\n\n#### 只取一个提交记录\n\n来看一个在开发中经常会遇到的情况：我正在解决某个特别棘手的 Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息。\n\n这些调试和打印语句都在它们各自的提交记录里。最后我终于找到了造成这个 Bug 的根本原因，解决掉以后觉得沾沾自喜！\n\n最后就差把 `bugFix` 分支里的工作合并回 `main` 分支了。你可以选择通过 fast-forward 快速合并到 `main` 分支上，但这样的话 `main` 分支就会包含我这些调试语句了。你肯定不想这样，应该还有更好的方式……\n\n实际我们只要让 Git 复制解决问题的那一个提交记录就可以了。跟之前我们在“整理提交记录”中学到的一样，我们可以使用\n\n- `git rebase -i`\n- `git cherry-pick`\n\n来达到目的。\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242b98be1504.png)\n\n------\n\n#### 提交的技巧 #1\n\n接下来这种情况也是很常见的：你之前在 newImage 分支上进行了一次提交，然后又基于它创建了 caption 分支，然后又提交了一次。\n\n此时你想对某个以前的提交记录进行一些小小的调整。比如设计师想修改一下 `newImage` 中图片的分辨率，尽管那个提交记录并不是最新的了。\n\n我们可以通过下面的方法来克服困难：\n\n- 先用 `git rebase -i` 将提交重新排序，然后把我们想要修改的提交记录挪到最前\n- 然后用 `git commit --amend` 来进行一些小修改\n- 接着再用 `git rebase -i` 来将他们调回原来的顺序\n- 最后我们把 main 移到修改的最前端（用你自己喜欢的方法），就大功告成啦！\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242dbc3cd20f.png)\n\n------\n\n#### 提交的技巧 #2\n\n正如你在上一关所见到的，我们可以使用 `rebase -i` 对提交记录进行重新排序。只要把我们想要的提交记录挪到最前端，我们就可以很轻松的用 `--amend` 修改它，然后把它们重新排成我们想要的顺序。\n\n但这样做就唯一的问题就是要进行两次排序，而这有可能造成由 rebase 而导致的冲突。因此选择使用cherry-pick来实现上述问题。\n\ncherry-pick 可以将提交树上任何地方的提交记录取过来追加到 HEAD 上\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ddc84217c.png)\n\n------\n\n#### Git Tag\n\n分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。有没有什么可以永远指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢？\n\nGit 的 tag 可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。更难得的是，它们并不会随着新的提交而移动。你也不能切换到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。\n\ntag的命令是：\n\n💯==**git tag \\<tag_name\\> \\<commit_name\\>**==\n\n![image-20220329183103581](C:\\Users\\14218\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220329183103581.png)\n\n------\n\n#### Git Describe\n\n由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来**描述**离你最近的锚点（也就是标签），它就是 `git describe`！\n\nGit Describe 能帮你在提交历史中移动了多次以后找到方向；当你用 `git bisect`（一个查找产生 Bug 的提交记录的指令）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时， 可能会用到这个命令。\n\ngit describe的语法是：\n\n💯==**git describe \\<ref\\>**==\t\n\nref 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（HEAD）.\n\n返回类型为💯==**\\<tag\\>\\_\\<numCommits\\>\\_g\\<hash\\>**==\t\n\ntag 表示的是离 ref 最近的标签， numCommits 是表示这个 ref 与 tag 相差有多少个提交记录， hash 表示的是你所给定的 ref 所表示的提交记录哈希值的前几位。当 ref 提交记录上有某个标签时，则只输出标签名称。\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e388a4335.png)\n\n------\n\n### Level 5. Git 高级话题(某些应用)\n\n#### 多分支rebase\n\n通过rebase实现多个分支的合并操作，其实通过rebase branch1 branch2 可以很快的实现，并且记住的是branch1是branch2的父分支的话就很容易实现了，每次rebase应该省略的是branch2的参数(如果不给的话)\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e564c9d33.png)\n\n------\n\n#### 两个父节点\n\n操作符 `^` 与 `~` 符一样，后面也可以跟一个数字。\n\n但是该操作符后面的数字与 `~` 后面的不同，并不是用来指定向上返回几代，而是指定合并提交记录的某个父提交。还记得前面提到过的一个合并提交有两个父提交吧，所以遇到这样的节点时该选择哪条路径就不是很清晰了。\n\nGit 默认选择合并提交的“第一个”父提交，在操作符 `^` 后跟一个数字可以改变这一默认行为。\n\n例如，执行 git checkout main^2 的过程就是回到第二个父提交节点的意思。\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e67ed88f1.png\" style=\"zoom:50%;\" />\n\n并且git支持两个操作符的链式操作 git checkout main\\~\\^2\\~2\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e6cb0c441.png\" style=\"zoom:50%;\" />\n\n\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e85b0e9c3.png)\n\n------\n\n#### 纠缠不清的分支\n\n实现这种不同分支梳理最好的方式是通过cherry-pick，如果方便知道commit的提交哈希值的话。\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e9658f176.png)\n\n------\n\n### Level 6. Push & Pull —— Git 远程仓库\n\n#### Git Clone\n\n远程仓库并不复杂, 在如今的云计算盛行的世界很容易把远程仓库想象成一个富有魔力的东西, 但实际上它们只是你的仓库在另个一台计算机上的拷贝。你可以通过因特网与这台计算机通信 —— 也就是增加或是获取提交记录\n\n话虽如此, 远程仓库却有一系列强大的特性\n\n- 首先也是最重要的的点, 远程仓库是一个强大的备份。本地仓库也有恢复文件到指定版本的能力, 但所有的信息都是保存在本地的。有了远程仓库以后，即使丢失了本地所有数据, 你仍可以通过远程仓库拿回你丢失的数据。\n- 还有就是, 远程让代码社交化了! 既然你的项目被托管到别的地方了, 你的朋友可以更容易地为你的项目做贡献(或者拉取最新的变更)\n\n💯==**git clone**==\n\n通过git clone 可以从远端拉取仓库到本地\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ea37dc283.png)\n\n------\n\n#### 远端分支\n\n你可能注意到的第一个事就是在我们的本地仓库多了一个名为 `o/main` 的分支, 这种类型的分支就叫**远程**分支。由于远程分支的特性导致其拥有一些特殊属性。\n\n远程分支反映了远程仓库(在你上次和它通信时)的**状态**。这会有助于你理解本地的工作与公共工作的差别 —— 这是你与别人分享工作成果前至关重要的一步.\n\n远程分支有一个特别的属性，在你检出时自动进入分离 HEAD 状态。Git 这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作, （更新了远程分支之后）再用远程分享你的工作成果。\n\no/main的意思就是\\<remote name\\>/\\<branch name\\>\n\n如果当前选择的是远端分支的话，进行commit操作是不会直接进行远端分支的更新，而是使本地处于分离HEAD的状态。\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242eb32490c4.png)\n\n------\n\n#### Git Fetch\n\nGit 远程仓库相当的操作实际可以归纳为两点：向远程仓库传输数据以及从远程仓库获取数据。既然我们能与远程仓库同步，那么就可以分享任何能被 Git 管理的更新（因此可以分享代码、文件、想法、情书等等）。\n\n如何从远程仓库获取数据 —— 命令如其名，它就是 git fetch 。\n\n💯==**git fetch**==\n\n**Git Fetch Do:**\n\ngit fetch 完成了仅有的但是很重要的两步:\n\n- 从远程仓库下载本地仓库中缺失的提交记录\n- 更新远程分支指针(如 `o/main`)\n\ngit fetch 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。\n\n如果你还记得上一节课程中我们说过的，远程分支反映了远程仓库在你**最后一次与它通信时**的状态，git fetch 就是你与远程仓库通信的方式了！\n\n**Git Fetch Not Do:**\n\ngit fetch 并不会改变你本地仓库的状态。它不会更新你的 main 分支，也不会修改你磁盘上的文件。\n\n理解这一点很重要，因为许多开发人员误以为执行了 git fetch 以后，他们本地仓库就与远程仓库同步了。它可能已经将进行这一操作所需的所有数据都下载了下来，但是**并没有**修改你本地的文件。git fetch 就是单纯的下载资源的操作。\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ecb8f2bac.png)\n\n------\n\n#### Git Pull\n\n其实有很多方法的 —— 当远程分支中有新的提交时，你可以像合并本地分支那样来合并远程分支。也就是说就是你可以执行以下命令:\n\n- `git cherry-pick o/main`\n- `git rebase o/main`\n- `git merge o/main`\n- 等等\n\n实际上，由于先抓取更新再合并到本地分支这个流程很常用，因此 Git 提供了一个专门的命令来完成这两个操作。\n\n💯==**git pull**==\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ed89ae9c4.png\" style=\"zoom:50%;\" />\n\ngit pull 就是 git fetch 和 git merge的缩写\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ee13e8cad.png)\n\n------\n\n#### 模拟团队合作\n\n在远端操作进行一定更新后，可以通过pull进行及时的拉去更新本地分支\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ee9fb29ea.png)\n\n------\n\n#### Git Push\n\n传自己分享内容与下载他人的分享刚好相反，git push 负责将**你的**变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录。一旦 git push 完成, 你的朋友们就可以从这个远程仓库下载你分享的成果了！\n\n💯==**git push**==\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ef5af3f83.png)\n\n------\n\n#### 偏离的提交历史\n\n假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕，可以发布了。但是 —— 天啊！你的同事这周写了一堆代码，还改了许多你的功能中使用的 API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库了，因此你的工作就变成了基于项目**旧版**的代码，与远程仓库最新的代码不匹配了。\n\n这种情况下, `git push` 就不知道该如何操作了。如果你执行 `git push`，Git 应该让远程仓库回到星期一那天的状态吗？还是直接在新代码的基础上添加你的代码，亦或由于你的提交已经过时而直接忽略你的提交？\n\n因为这情况（历史偏离）有许多的不确定性，Git 是不会允许你 `push` 变更的。实际上它会强制你先合并远程最新的代码，然后才能分享你的工作。\n\n因此主要的解决办法就是先把远端的分支pull下来，然后再merge或者rebase自己的工作到远端分支，然后再合并分支到远端仓库\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242f10bed8b1.png)\n\n------\n\n#### Locked Main\n\n如果你是在一个大的合作团队中工作, 很可能是main被锁定了, 需要一些Pull Request流程来合并修改。如果你直接提交(commit)到本地main, 然后试图推送(push)修改, 你将会收到这样类似的信息:\n\n*! [远程服务器拒绝] main -> main (TF402455: 不允许推送(push)这个分支; 你必须使用pull request来更新这个分支.)*\n\n就是在团队合作的时候，防止过多人频繁push自己的代码到远端仓库，因此需要走pr的审查流程。\n\n解决办法为：新建一个分支feature, 推送到远程服务器. 然后reset你的main分支和远程服务器保持一致, 否则下次你pull并且他人的提交和你冲突的时候就会有问题.\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242f48497d61.png)\n\n------\n\n### Level 7. 关于 origin 和它的周边 —— Git 远程仓库高级操作\n\n#### 推送主分支\n\n在大型项目中开发人员通常会在（从 `main` 上分出来的）特性分支上工作，工作完成后只做一次集成。这跟前面课程的描述很相像（把 side 分支推送到远程仓库），不过本节我们会深入一些.\n\n但是有些开发人员只在 main 上做 push、pull —— 这样的话 main 总是最新的，始终与远程分支 (o/main) 保持一致。\n\n对于接下来这个工作流，我们集成了两个步骤：\n\n- 将特性分支集成到 `main` 上\n- 推送并更新远程分支\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242fc03cb835.png)\n\n过程就是先 git pull --rebase 然后再rebase 合并分支\n\n------\n\n#### 合并远端仓库\n\n在开发社区里，有许多关于 merge 与 rebase 的讨论。以下是关于 rebase 的优缺点：\n\n优点:\n\n- Rebase 使你的提交树变得很干净, 所有的提交都在一条线上\n\n缺点:\n\n- Rebase 修改了提交树的历史\n\n比如, 提交 C1 可以被 rebase 到 C3 之后。这看起来 C1 中的工作是在 C3 之后进行的，但实际上是在 C3 之前。\n\n一些开发人员喜欢保留提交历史，因此更偏爱 merge。而其他人（比如我自己）可能更喜欢干净的提交树，于是偏爱 rebase。仁者见仁，智者见智。 \n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242fd476265d.png)\n\n相对来说，更有细节，更能体现提交历史\n\n#### 远程追踪\n\nGit 好像知道 `main` 与 `o/main` 是相关的。当然这些分支的名字是相似的，可能会让你觉得是依此将远程分支 main 和本地的 main 分支进行了关联。这种关联在以下两种情况下可以清楚地得到展示：\n\n- pull 操作时, 提交记录会被先下载到 o/main 上，之后再合并到本地的 main 分支。隐含的合并目标由这个关联确定的。\n- push 操作时, 我们把工作从 `main` 推到远程仓库中的 `main` 分支(同时会更新远程分支 `o/main`) 。这个推送的目的地也是由这种关联确定的！\n\n直接了当地讲，`main` 和 `o/main` 的关联关系就是由分支的“remote tracking”属性决定的。`main` 被设定为跟踪 `o/main` —— 这意味着为 `main` 分支指定了推送的目的地以及拉取后合并的目标。\n\n你可能想知道 `main` 分支上这个属性是怎么被设定的，你并没有用任何命令指定过这个属性呀！好吧, 当你克隆仓库的时候, Git 就自动帮你把这个属性设置好了。\n\n当你克隆时, Git 会为远程仓库中的每个分支在本地仓库中创建一个远程分支（比如 `o/main`）。然后再创建一个跟踪远程仓库中活动分支的本地分支，默认情况下这个本地分支会被命名为 `main`。\n\n克隆完成后，你会得到一个本地分支（如果没有这个本地分支的话，你的目录就是“空白”的），但是可以查看远程仓库中所有的分支（如果你好奇心很强的话）。这样做对于本地仓库和远程仓库来说，都是最佳选择。\n\n💯==**git checkout -b totallyNotMain o/main**==\n\n可以创建一个totallyNotMain来追踪远程分支o/main\n\n💯==**git branch -u o/main foo**==\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ff7627ed3.png)\n\n------\n\n#### Git Push的参数\n\n首先来看 `git push`。在远程跟踪课程中，你已经学到了 Git 是通过当前检出分支的属性来确定远程仓库以及要 push 的目的地的。这是未指定参数时的行为，我们可以为 push 指定参数，语法是：\n\n💯==**git push \\<remote\\> \\<place\\>**==\n\n把这个命令翻译过来就是：\n\n*切到本地仓库中的“main”分支，获取所有的提交，再到远程仓库“origin”中找到“main”分支，将远程仓库中没有的提交记录都添加上去，搞定之后告诉我。*\n\n我们通过“place”参数来告诉 Git 提交记录来自于 main, 要推送到远程仓库中的 main。它实际就是要同步的两个仓库的位置。\n\n需要注意的是，因为我们通过指定参数告诉了 Git 所有它需要的信息, 所以它就忽略了我们所检出的分支的属性！\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624300d69d378.png)\n\n------\n\n#### Git Push的参数2\n\n，当为 git push 指定 place 参数为 `main` 时，我们同时指定了提交记录的来源和去向。\n\n你可能想问 —— 如果来源和去向分支的名称不同呢？比如你想把本地的 `foo` 分支推送到远程仓库中的 `bar` 分支。\n\n要同时为源和目的地指定 `<place>` 的话，只需要用冒号 `:` 将二者连起来就可以了：\n\n💯==**git push origin \\<source\\>:\\<destination\\>**==\n\n这个参数实际的值是个 refspec，“refspec” 是一个自造的词，意思是 Git 能识别的位置（比如分支 `foo` 或者 `HEAD~1`）\n\n一旦你指定了独立的来源和目的地，就可以组织出言简意赅的远程操作命令了.\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624301c9cddfe.png)\n\n------\n\n#### Git Fetch的参数\n\n`git fetch` 的参数和 `git push` 极其相似。他们的概念是相同的，只是方向相反罢了（因为现在你是下载，而非上传）\n\n💯==**git fetch \\<remote\\> \\<place\\>**==\n\nGit 会到远程仓库的分支上，然后获取所有本地不存在的提交，放到本地的相应分支上。\n\n💯==**git fetch origin \\<source\\>:\\<destination\\>**==\n\n但是命令很不常用就是了\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624301c9cddfe.png)\n\n------\n\n#### 没有source的source\n\nGit 有两种关于 `<source>` 的用法是比较诡异的，即你可以在 git push 或 git fetch 时不指定任何 `source`，方法就是仅保留冒号和 destination 部分，source 部分留空。\n\n- `git push origin :side`\n- `git fetch origin :bugFix`\n\n我们分别来看一下这两条命令的作用……\n\n如果 push 空 到远程仓库会如何呢？它会删除远程仓库中的分支！\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624313c20ceea.png\" style=\"zoom:50%;\" />\n\n如果 fetch 空 到本地，会在本地创建一个新分支。\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624314368592a.png\" style=\"zoom:50%;\" />\n\n\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6243147a70f05.png)\n\n------\n\n#### Git Pull的参数\n\n git pull 到头来就是 fetch 后跟 merge 的缩写。你可以理解为用同样的参数执行 git fetch，然后再 merge 你所抓取到的提交记录。\n\n`git pull origin foo` 相当于：\n\n```\ngit fetch origin foo; git merge o/foo\n```\n\n还有...\n\n`git pull origin bar~1:bugFix` 相当于：\n\n```\ngit fetch origin bar~1:bugFix; git merge bugFix\n```\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624316d49f61c.png)\n\n------\n\n\n\n## Git操作实例\n\n> 在这一个月多的工作里，我也遇到了需要用到git的一些操作，在此总结如下情景：\n\n### 先暂存当前工作而去完成另一个工作\n\n> 遇到过这种情况：在做某个工作到一半还没完成的时候，突然被提醒先去做另外一个工作。这种情况下，现在没做完的工作咋办？\n\n首先，在看了上面的内容之后，不管如果我们一定要先进行 `git commit` 操作。\n\n因为只有在commit之后，当前工作才会成为一个结点。\n\n同时，为了唯一标识当前结点，我们可以采用新建分支或者新建tag的方式标记当前结点：\n\n```\ngit tag tag_name HEAD\n```\n\n在完成该操作后，我们就回到上一个结点，也就是远端所在结点：\n\n```\ngit checkout HEAD^\n\ngit branch -f master HEAD\n\ngit checkout master\n```\n\n此后，我们便可以开始新的工作，以正常的方式进行新的操作（commit啊，push啊都可以）。\n\n当前工作完成之后，我们就可以通过 ` git checkout tag_name ` 回到之前没有完成的工作中去了！\n\n### 更改两次提交的顺序\n\n> 这是今天遇到的一个情况：先完成了一个提交，之后去做另一个工作提交了一次。但这时被提示之前的提交有问题，需要修改。\n>\n> 这个时候，后一次的提交没有问题，可以被点进主分支中。但由于它的父结点是前一次的提交，因此点不进去，怎么办呢？\n\n这个时候，我们就要考虑切换两个分支的顺序了。\n\n首先最重要的是，我们还是要加一个标签标记当前的位置，否则以后就找不到了：\n\n```\ngit tag tag_name HEAD\n```\n\n然后，我们回到上上一次的位置：\n\n```\ngit checkout HEAD~2\n\ngit branch -f master HEAD\n\ngit checkout master\n```\n\n这个时候，我们只要通过 ` cherry-pick ` 操作把刚刚的两个操作反过来串联在一起就行了。\n\n当然，通过前面的学习，我们知道  ` git rebase -i `也是可行的，在这里不再赘述。\n\n","source":"_posts/git基本操作整理.md","raw":"---\ntitle: Git基本操作整理\ndate: 2022-3-29 12:00:00\ndescription: git的一些基本操作，一起交流学习\ncover: https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f9be0486.png\n---\n\n# Git 基本操作整理\n\n## 前言\n\n本文档通过整理CS-Notes中的Git命令操作与实战Learn Git Branching来学习掌握Git方法。因为文档主要分为两部分，第一部分参考CS-Notes并查阅资料为Git理论知识，第二部分为实战Learn Git Branching给出个人思考与过程。\n\n参考资料来源:\n\n1. [CS-Notes Git部分](http://www.cyc2018.xyz/%E5%85%B6%E5%AE%83/%E7%BC%96%E7%A0%81%E5%AE%9E%E8%B7%B5/Git.html#%E9%9B%86%E4%B8%AD%E5%BC%8F%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F)\n\n2. [Learn Git Branching](https://learngitbranching.js.org/?demo=&locale=zh_CN)\n\n## Git知识\n\n\n\n## Learn Git Branching\n\n### Level 1. Git基础内容\n\n#### Git Commit\n\nGit 仓库中的提交记录保存的是你的目录下所有文件的快照，就像是把整个目录复制，然后再粘贴一样，但比复制粘贴优雅许多！\n\nGit 希望提交记录尽可能地轻量，因此在你每次进行提交时，它并不会盲目地复制整个目录。条件允许的情况下，它会将当前版本与仓库中的上一个版本进行对比，并把所有的差异打包到一起作为一个提交记录。Git 还保存了提交的历史记录。这也是为什么大多数提交记录的上面都有父节点的原因。对于项目组的成员来说，维护提交历史对大家都有好处。\n\nGit Commit 就是在父节点下进行一次内容的提交。使用的命令很简单为：\n\n💯==**git commit**==\n\n\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f9be0486.png)\n\n------\n\n#### Git Branch\n\nGit 的分支也非常轻量。它们只是简单地指向某个提交纪录 —— 仅此而已。\n\n所以许多 Git 爱好者传颂：😍**早建分支，多用分支！**\n\n这是因为即使创建再多的分支也不会造成储存或内存上的开销，并且按逻辑分解工作到不同的分支要比维护那些特别臃肿的分支简单多了。\n\n在将分支和提交记录结合起来后，我们会看到两者如何协作。现在只要记住使用分支其实就相当于在说：“**我想基于这个提交以及它所有的父提交进行新的工作。**”\n\n创建分支的命令最基础的就是：\n\n💯==**git branch <branch_name>**==\n\n创建好的分支会指向当前的提交记录。但是通过上述命令创建的分支并不是我们现在所使用的分支，如果我们此刻进行了git commit操作，那么我们的行为仍然是操作于原来的分支。所以我们如果想要使用这个新分支，我们需要使用切换分支的命令：\n\n💯==**git checkout <branch_name>**==\n\n有一个简洁的方式，如果你想创建一个新的分支同时切换到新创建的分支的话，可以通过 \n\n💯==**git checkout -b \\<your-branch-name\\>**==\n\n\n\n![](https://i0.hdslb.com/bfs/album/a11e89444b0b5c7d221325a9637f26e54ebe12c6.png)\n\n------\n\n#### Git Merge\n\n在知道如何提交以及如何使用分支的前提下，接下来是如何将两个分支合并到一起。就是说我们新建一个分支，在其上开发某个新功能，开发完成后再合并回主线。\n\n第一种方法是通过git merge实现的。在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个父节点。翻译成自然语言相当于：“我要把这两个父节点本身及它们所有的祖先都包含进来。”因此，git合并分支的命令是：\n\n💯==**git merge <branch_name>**==\n\n该命令是将branch_name合并到当前的分支下\n\n例如：我们有这两个分支main与bugFix，我们可以通过git merge命令来将两者合并：\n\n<img src=\"https://i0.hdslb.com/bfs/album/1a7e02089e6db4f76cec7be3ca3766caa38c1fd7.png\" style=\"zoom:50%;\" />\n\n合并后，我们发现新的分支是保留了两条路径指向父节点，并没有断了与任何一条分支的联系，因此这个过程支持了Git对历史版本信息的维护。\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f858fa9e.png\" style=\"zoom:50%;\" />\n\n接下来，可以将main分支合并到bugFix中\n\n通过`git checkout bugFix; git merge main`\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f8526a06.png\" style=\"zoom:50%;\" />\n\n因为 main 继承自 bugFix ，Git 什么都不用做，只是简单地把 bugFix 移动到 main 所指向的那个提交记录。\n\n![](https://i0.hdslb.com/bfs/album/08d9d8343a7164f9c6b01eccca5471872790f07f.png)\n\n------\n\n#### Git Rebase\n\n第二种合并分支的方法是 git rebase。Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。\n\nRebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。Rebase的命令如下：\n\n💯==**git rebase <branch_name>**==\n\n例如：同样我们有两个分支main和bugFix，我们可以通过rebase来将两者合并：\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f857516e.png\" style=\"zoom:50%;\" />\n\n通过rebase命令后，不同于原来的merge建立两条关于父节点的链接，而是通过提取一系列的提交记录然后建立一个基于main的副本，这样生成的线性的提交历史：\n\n<img src=\"https://i0.hdslb.com/bfs/album/59f7e1df1314389ddbbcb14fda46a0a679d6c999.png\" style=\"zoom:50%;\" />\n\n此时，原先分支的C3并没有被删除，接下来可以切换到main分支，通过rebase向前推进一个版本\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f857627e.png\" style=\"zoom:50%;\" />\n\nrebase命令维护一条线性的提交记录使得历史提交很清晰。我理解的话，主要是通过在代合并的分支上补充原有分支的一些历史提交信息，然后类似于“复制”了一个版本到待合并分支下，实现一个合并操作。\n\n![](https://i0.hdslb.com/bfs/album/8ee6ba5797dbd7b567f3a9f05c43a9d88472e13d.png)\n\n------\n\n### Level 2. Git高级内容\n\n#### 分离HEAD\n\nHEAD 是一个对当前检出记录的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。\n\nHEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。\n\nHEAD 通常情况下是指向分支名的（如 bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。\n\n**分离的 HEAD 就是让其指向了某个具体的提交记录而不是分支名。**在命令执行之前的状态如下所示：\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242631f0352b.png\" style=\"zoom:50%;\" />\n\nHEAD -> main -> C1\n\nHEAD 指向 main， main 指向 C1\n\n再通过 **git checkout C1** 后变成了：\n\nHEAD -> C1\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624263c60010b.png\" style=\"zoom:50%;\" />\n\n\n\n所以分离当前HEAD是通过：\n\n💯==**git checkout \\<hash_commit\\>**==\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624264090b652.png)\n\n------\n\n#### 相对引用(^)\n\n通过指定提交记录哈希值的方式在 Git 中移动不太方便。在实际应用时，并没有像本程序中这么漂亮的可视化提交树供你参考，所以你就不得不用 `git log` 来查查看提交记录的哈希值。\n\n并且哈希值在真实的 Git 世界中也会更长（e.g. 基于 SHA-1，共 40 位）。例如前一关的介绍中的提交记录的哈希值可能是 `fed2da64c0efc5293610bdd892f82a58e8cbc5d8`。比较令人欣慰的是，Git 对哈希的处理很智能。你只需要提供能够唯一标识提交记录的前几个字符即可。因此我可以仅输入`fed2` 而不是上面的一长串字符。\n\n通过哈希值提交记录很不方便，所以git引用了相对引用。使用相对引用的话，就可以从一个易于记忆的地方（比如 `bugFix` 分支或 `HEAD`）开始计算。\n\n相对引用非常给力，这里我介绍两个简单的用法：\n\n- 使用 `^` 向上移动 1 个提交记录\n- 使用 `~<num>` 向上移动多个提交记录，如 `~3`\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624274834cddb.png\" style=\"zoom:50%;\" />\n\n通过使用(\\^)可以相对很方便找到main的父节点，而不是通过哈希的方式，以此类推，可以通过main\\^\\^来实现寻找父节点的父节点\n💯==**git checkout main\\^**==\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624274aea1027.png\" style=\"zoom:50%;\" />\n\n\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624276378ff5f.png)\n\n------\n\n#### 相对引用2(~)\n\n如果你想在提交树中向上移动很多步的话，敲那么多 `^` 貌似也挺烦人的，Git 当然也考虑到了这一点，于是又引入了操作符 `~`。该操作符后面可以跟一个数字（可选，不跟数字时与 `^` 相同，向上移动一次），指定向上移动多少次。\n\n通过多次移动的相对引用命令，实现简洁的后退操作：\n\n💯==**git checkout HEAD\\~\\<num\\>**==\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624276db5423e.png\" style=\"zoom:50%;\" />\n\n\n\n使用相对引用比较多的场景就是移动分支。可以直接使用 `-f` 选项让分支指向另一个提交，达到强制修改分支的目的，例如:\n\n💯==**git branch -f main HEAD~3**==\n\n上面的命令会将 main 分支强制指向 HEAD 的第 3 级父提交。\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62427882a6119.png\" style=\"zoom:50%;\" />\n\n可以发现main分支指向了是HEAD向后移动3级父提交记录上\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a3729f60c.png\" style=\"zoom:50%;\" />\n\n合理使用git branch -f 与git checkout 可以实现对当前提交节点与分支的转换。\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a5ae757e9.png)\n\n------\n\n#### 撤销变更\n\n在 Git 里撤销变更的方法很多。和提交一样，撤销变更由底层部分（暂存区的独立文件或者片段）和上层部分（变更到底是通过哪种方式被撤销的）组成。我们这个应用主要关注的是后者。\n\n主要有两种方法用来撤销变更 —— 一是 `git reset`，还有就是 `git revert`。\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a6fb59604.png\" style=\"zoom:50%;\" />\n\n通过一下撤销变更的命令：\n\n💯==**git reset HEAD~1**==\n\nGit 把 main 分支移回到 C1；现在我们的本地代码库根本就不知道有 C2 这个提交了。但是在reset后， C2 所做的变更还在，但是处于未加入暂存区状态。\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a76660edc.png\" style=\"zoom:50%;\" />\n\ngit reset 撤销的方式对大家一起使用的远端分支是无效的，为了撤销更改并分享给别人，我们需要使用：\n\n💯==**git revert HEAD**==\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a82f31d87.png\" style=\"zoom:50%;\" />\n\n在我们要撤销的提交记录后面居然多了一个新提交！这是因为新提交记录 C2' 引入了**更改** —— 这些更改刚好是用来撤销 C2 这个提交的。也就是说 C2' 的状态与 C1 是相同的。revert 之后就可以把你的更改推送到远程仓库与别人分享啦。\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a9486b1f8.png)\n\n刚才试了一下reset的作用，其实就是本地回退到上一个版本得话，可以在更改一些功能后，通过rebase或者merge指定遗弃分支进行合并或者完全放弃？🤔\n\n------\n\n### Level 3. Git移动提交记录\n\n#### Git Cherry-pick\n\n接下来要讨论的这个话题是“整理提交记录” —— 开发人员有时会说“我想要把这个提交放到这里, 那个提交放到刚才那个提交的后面”, 而接下来就讲的就是它的实现方式，非常清晰、灵活，还很生动。\n\n如果你想将一些提交复制到当前所在的位置（`HEAD`）下面的话， Cherry-pick 是最直接的方式了。命令为：\n\n💯==**git cherry-pick \\<commit_version\\>**==\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242aab507c99.png\" style=\"zoom:50%;\" />\n\n这里有一个仓库, 我们想将 side 分支上的工作复制到 main 分支，rebase 可以解决这个问题，但是也可以通过 cherry-pick, 我们执行命令 git cherry-pick C2 C4\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ab6297234.png\" style=\"zoom:50%;\" />\n\n通过cherry-pick可以直接选取我们要的提交记录在当前分支之下，感觉git的整理提交记录的思想在于维护一条提交的线(主干线)\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242abd0e399a.png)\n\n------\n\n#### 交互式rebase\n\n当你知道你所需要的提交记录（**并且**还知道这些提交记录的哈希值）时, 用 cherry-pick 再好不过了 —— 没有比这更简单的方式了。但是如果你不清楚你想要的提交记录的哈希值呢? 幸好 Git 帮你想到了这一点, 我们可以利用交互式的 rebase —— 如果你想从一系列的提交记录中找到想要的记录, 这就是最好的方法了。\n\n交互式 rebase 指的是使用带参数 `--interactive` 的 rebase 命令, 简写为 `-i`\n\n如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。\n\n在实际使用时，所谓的 UI 窗口一般会在文本编辑器 —— 如 Vim —— 中打开一个文件。\n\n当 rebase UI界面打开时, 你能做3件事:\n\n- 调整提交记录的顺序（通过鼠标拖放来完成）\n- 删除你不想要的提交（通过切换 `pick` 的状态来完成，关闭就意味着你不想要这个提交记录）\n- 合并提交。\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242af2c739cb.png\" style=\"zoom:50%;\" />\n\n输入交互式rebase命令后：\n\n💯==**git rebase -i HEAD[~\\<num\\>|^]**==\n\n通过rebase -i HEAD~4实现对后续提交内容进行调整顺序，删除omit提交与合并\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242b17d54c69.png\" style=\"zoom:50%;\" />\n\n完全重新整理了commit的顺序，但是感觉需要以合理的机会使用，要不然真的会很艰难。\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242b33615af6.png)\n\n------\n\n### Level 4. 杂项\n\n#### 只取一个提交记录\n\n来看一个在开发中经常会遇到的情况：我正在解决某个特别棘手的 Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息。\n\n这些调试和打印语句都在它们各自的提交记录里。最后我终于找到了造成这个 Bug 的根本原因，解决掉以后觉得沾沾自喜！\n\n最后就差把 `bugFix` 分支里的工作合并回 `main` 分支了。你可以选择通过 fast-forward 快速合并到 `main` 分支上，但这样的话 `main` 分支就会包含我这些调试语句了。你肯定不想这样，应该还有更好的方式……\n\n实际我们只要让 Git 复制解决问题的那一个提交记录就可以了。跟之前我们在“整理提交记录”中学到的一样，我们可以使用\n\n- `git rebase -i`\n- `git cherry-pick`\n\n来达到目的。\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242b98be1504.png)\n\n------\n\n#### 提交的技巧 #1\n\n接下来这种情况也是很常见的：你之前在 newImage 分支上进行了一次提交，然后又基于它创建了 caption 分支，然后又提交了一次。\n\n此时你想对某个以前的提交记录进行一些小小的调整。比如设计师想修改一下 `newImage` 中图片的分辨率，尽管那个提交记录并不是最新的了。\n\n我们可以通过下面的方法来克服困难：\n\n- 先用 `git rebase -i` 将提交重新排序，然后把我们想要修改的提交记录挪到最前\n- 然后用 `git commit --amend` 来进行一些小修改\n- 接着再用 `git rebase -i` 来将他们调回原来的顺序\n- 最后我们把 main 移到修改的最前端（用你自己喜欢的方法），就大功告成啦！\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242dbc3cd20f.png)\n\n------\n\n#### 提交的技巧 #2\n\n正如你在上一关所见到的，我们可以使用 `rebase -i` 对提交记录进行重新排序。只要把我们想要的提交记录挪到最前端，我们就可以很轻松的用 `--amend` 修改它，然后把它们重新排成我们想要的顺序。\n\n但这样做就唯一的问题就是要进行两次排序，而这有可能造成由 rebase 而导致的冲突。因此选择使用cherry-pick来实现上述问题。\n\ncherry-pick 可以将提交树上任何地方的提交记录取过来追加到 HEAD 上\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ddc84217c.png)\n\n------\n\n#### Git Tag\n\n分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。有没有什么可以永远指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢？\n\nGit 的 tag 可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。更难得的是，它们并不会随着新的提交而移动。你也不能切换到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。\n\ntag的命令是：\n\n💯==**git tag \\<tag_name\\> \\<commit_name\\>**==\n\n![image-20220329183103581](C:\\Users\\14218\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220329183103581.png)\n\n------\n\n#### Git Describe\n\n由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来**描述**离你最近的锚点（也就是标签），它就是 `git describe`！\n\nGit Describe 能帮你在提交历史中移动了多次以后找到方向；当你用 `git bisect`（一个查找产生 Bug 的提交记录的指令）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时， 可能会用到这个命令。\n\ngit describe的语法是：\n\n💯==**git describe \\<ref\\>**==\t\n\nref 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（HEAD）.\n\n返回类型为💯==**\\<tag\\>\\_\\<numCommits\\>\\_g\\<hash\\>**==\t\n\ntag 表示的是离 ref 最近的标签， numCommits 是表示这个 ref 与 tag 相差有多少个提交记录， hash 表示的是你所给定的 ref 所表示的提交记录哈希值的前几位。当 ref 提交记录上有某个标签时，则只输出标签名称。\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e388a4335.png)\n\n------\n\n### Level 5. Git 高级话题(某些应用)\n\n#### 多分支rebase\n\n通过rebase实现多个分支的合并操作，其实通过rebase branch1 branch2 可以很快的实现，并且记住的是branch1是branch2的父分支的话就很容易实现了，每次rebase应该省略的是branch2的参数(如果不给的话)\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e564c9d33.png)\n\n------\n\n#### 两个父节点\n\n操作符 `^` 与 `~` 符一样，后面也可以跟一个数字。\n\n但是该操作符后面的数字与 `~` 后面的不同，并不是用来指定向上返回几代，而是指定合并提交记录的某个父提交。还记得前面提到过的一个合并提交有两个父提交吧，所以遇到这样的节点时该选择哪条路径就不是很清晰了。\n\nGit 默认选择合并提交的“第一个”父提交，在操作符 `^` 后跟一个数字可以改变这一默认行为。\n\n例如，执行 git checkout main^2 的过程就是回到第二个父提交节点的意思。\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e67ed88f1.png\" style=\"zoom:50%;\" />\n\n并且git支持两个操作符的链式操作 git checkout main\\~\\^2\\~2\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e6cb0c441.png\" style=\"zoom:50%;\" />\n\n\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e85b0e9c3.png)\n\n------\n\n#### 纠缠不清的分支\n\n实现这种不同分支梳理最好的方式是通过cherry-pick，如果方便知道commit的提交哈希值的话。\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e9658f176.png)\n\n------\n\n### Level 6. Push & Pull —— Git 远程仓库\n\n#### Git Clone\n\n远程仓库并不复杂, 在如今的云计算盛行的世界很容易把远程仓库想象成一个富有魔力的东西, 但实际上它们只是你的仓库在另个一台计算机上的拷贝。你可以通过因特网与这台计算机通信 —— 也就是增加或是获取提交记录\n\n话虽如此, 远程仓库却有一系列强大的特性\n\n- 首先也是最重要的的点, 远程仓库是一个强大的备份。本地仓库也有恢复文件到指定版本的能力, 但所有的信息都是保存在本地的。有了远程仓库以后，即使丢失了本地所有数据, 你仍可以通过远程仓库拿回你丢失的数据。\n- 还有就是, 远程让代码社交化了! 既然你的项目被托管到别的地方了, 你的朋友可以更容易地为你的项目做贡献(或者拉取最新的变更)\n\n💯==**git clone**==\n\n通过git clone 可以从远端拉取仓库到本地\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ea37dc283.png)\n\n------\n\n#### 远端分支\n\n你可能注意到的第一个事就是在我们的本地仓库多了一个名为 `o/main` 的分支, 这种类型的分支就叫**远程**分支。由于远程分支的特性导致其拥有一些特殊属性。\n\n远程分支反映了远程仓库(在你上次和它通信时)的**状态**。这会有助于你理解本地的工作与公共工作的差别 —— 这是你与别人分享工作成果前至关重要的一步.\n\n远程分支有一个特别的属性，在你检出时自动进入分离 HEAD 状态。Git 这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作, （更新了远程分支之后）再用远程分享你的工作成果。\n\no/main的意思就是\\<remote name\\>/\\<branch name\\>\n\n如果当前选择的是远端分支的话，进行commit操作是不会直接进行远端分支的更新，而是使本地处于分离HEAD的状态。\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242eb32490c4.png)\n\n------\n\n#### Git Fetch\n\nGit 远程仓库相当的操作实际可以归纳为两点：向远程仓库传输数据以及从远程仓库获取数据。既然我们能与远程仓库同步，那么就可以分享任何能被 Git 管理的更新（因此可以分享代码、文件、想法、情书等等）。\n\n如何从远程仓库获取数据 —— 命令如其名，它就是 git fetch 。\n\n💯==**git fetch**==\n\n**Git Fetch Do:**\n\ngit fetch 完成了仅有的但是很重要的两步:\n\n- 从远程仓库下载本地仓库中缺失的提交记录\n- 更新远程分支指针(如 `o/main`)\n\ngit fetch 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。\n\n如果你还记得上一节课程中我们说过的，远程分支反映了远程仓库在你**最后一次与它通信时**的状态，git fetch 就是你与远程仓库通信的方式了！\n\n**Git Fetch Not Do:**\n\ngit fetch 并不会改变你本地仓库的状态。它不会更新你的 main 分支，也不会修改你磁盘上的文件。\n\n理解这一点很重要，因为许多开发人员误以为执行了 git fetch 以后，他们本地仓库就与远程仓库同步了。它可能已经将进行这一操作所需的所有数据都下载了下来，但是**并没有**修改你本地的文件。git fetch 就是单纯的下载资源的操作。\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ecb8f2bac.png)\n\n------\n\n#### Git Pull\n\n其实有很多方法的 —— 当远程分支中有新的提交时，你可以像合并本地分支那样来合并远程分支。也就是说就是你可以执行以下命令:\n\n- `git cherry-pick o/main`\n- `git rebase o/main`\n- `git merge o/main`\n- 等等\n\n实际上，由于先抓取更新再合并到本地分支这个流程很常用，因此 Git 提供了一个专门的命令来完成这两个操作。\n\n💯==**git pull**==\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ed89ae9c4.png\" style=\"zoom:50%;\" />\n\ngit pull 就是 git fetch 和 git merge的缩写\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ee13e8cad.png)\n\n------\n\n#### 模拟团队合作\n\n在远端操作进行一定更新后，可以通过pull进行及时的拉去更新本地分支\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ee9fb29ea.png)\n\n------\n\n#### Git Push\n\n传自己分享内容与下载他人的分享刚好相反，git push 负责将**你的**变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录。一旦 git push 完成, 你的朋友们就可以从这个远程仓库下载你分享的成果了！\n\n💯==**git push**==\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ef5af3f83.png)\n\n------\n\n#### 偏离的提交历史\n\n假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕，可以发布了。但是 —— 天啊！你的同事这周写了一堆代码，还改了许多你的功能中使用的 API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库了，因此你的工作就变成了基于项目**旧版**的代码，与远程仓库最新的代码不匹配了。\n\n这种情况下, `git push` 就不知道该如何操作了。如果你执行 `git push`，Git 应该让远程仓库回到星期一那天的状态吗？还是直接在新代码的基础上添加你的代码，亦或由于你的提交已经过时而直接忽略你的提交？\n\n因为这情况（历史偏离）有许多的不确定性，Git 是不会允许你 `push` 变更的。实际上它会强制你先合并远程最新的代码，然后才能分享你的工作。\n\n因此主要的解决办法就是先把远端的分支pull下来，然后再merge或者rebase自己的工作到远端分支，然后再合并分支到远端仓库\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242f10bed8b1.png)\n\n------\n\n#### Locked Main\n\n如果你是在一个大的合作团队中工作, 很可能是main被锁定了, 需要一些Pull Request流程来合并修改。如果你直接提交(commit)到本地main, 然后试图推送(push)修改, 你将会收到这样类似的信息:\n\n*! [远程服务器拒绝] main -> main (TF402455: 不允许推送(push)这个分支; 你必须使用pull request来更新这个分支.)*\n\n就是在团队合作的时候，防止过多人频繁push自己的代码到远端仓库，因此需要走pr的审查流程。\n\n解决办法为：新建一个分支feature, 推送到远程服务器. 然后reset你的main分支和远程服务器保持一致, 否则下次你pull并且他人的提交和你冲突的时候就会有问题.\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242f48497d61.png)\n\n------\n\n### Level 7. 关于 origin 和它的周边 —— Git 远程仓库高级操作\n\n#### 推送主分支\n\n在大型项目中开发人员通常会在（从 `main` 上分出来的）特性分支上工作，工作完成后只做一次集成。这跟前面课程的描述很相像（把 side 分支推送到远程仓库），不过本节我们会深入一些.\n\n但是有些开发人员只在 main 上做 push、pull —— 这样的话 main 总是最新的，始终与远程分支 (o/main) 保持一致。\n\n对于接下来这个工作流，我们集成了两个步骤：\n\n- 将特性分支集成到 `main` 上\n- 推送并更新远程分支\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242fc03cb835.png)\n\n过程就是先 git pull --rebase 然后再rebase 合并分支\n\n------\n\n#### 合并远端仓库\n\n在开发社区里，有许多关于 merge 与 rebase 的讨论。以下是关于 rebase 的优缺点：\n\n优点:\n\n- Rebase 使你的提交树变得很干净, 所有的提交都在一条线上\n\n缺点:\n\n- Rebase 修改了提交树的历史\n\n比如, 提交 C1 可以被 rebase 到 C3 之后。这看起来 C1 中的工作是在 C3 之后进行的，但实际上是在 C3 之前。\n\n一些开发人员喜欢保留提交历史，因此更偏爱 merge。而其他人（比如我自己）可能更喜欢干净的提交树，于是偏爱 rebase。仁者见仁，智者见智。 \n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242fd476265d.png)\n\n相对来说，更有细节，更能体现提交历史\n\n#### 远程追踪\n\nGit 好像知道 `main` 与 `o/main` 是相关的。当然这些分支的名字是相似的，可能会让你觉得是依此将远程分支 main 和本地的 main 分支进行了关联。这种关联在以下两种情况下可以清楚地得到展示：\n\n- pull 操作时, 提交记录会被先下载到 o/main 上，之后再合并到本地的 main 分支。隐含的合并目标由这个关联确定的。\n- push 操作时, 我们把工作从 `main` 推到远程仓库中的 `main` 分支(同时会更新远程分支 `o/main`) 。这个推送的目的地也是由这种关联确定的！\n\n直接了当地讲，`main` 和 `o/main` 的关联关系就是由分支的“remote tracking”属性决定的。`main` 被设定为跟踪 `o/main` —— 这意味着为 `main` 分支指定了推送的目的地以及拉取后合并的目标。\n\n你可能想知道 `main` 分支上这个属性是怎么被设定的，你并没有用任何命令指定过这个属性呀！好吧, 当你克隆仓库的时候, Git 就自动帮你把这个属性设置好了。\n\n当你克隆时, Git 会为远程仓库中的每个分支在本地仓库中创建一个远程分支（比如 `o/main`）。然后再创建一个跟踪远程仓库中活动分支的本地分支，默认情况下这个本地分支会被命名为 `main`。\n\n克隆完成后，你会得到一个本地分支（如果没有这个本地分支的话，你的目录就是“空白”的），但是可以查看远程仓库中所有的分支（如果你好奇心很强的话）。这样做对于本地仓库和远程仓库来说，都是最佳选择。\n\n💯==**git checkout -b totallyNotMain o/main**==\n\n可以创建一个totallyNotMain来追踪远程分支o/main\n\n💯==**git branch -u o/main foo**==\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ff7627ed3.png)\n\n------\n\n#### Git Push的参数\n\n首先来看 `git push`。在远程跟踪课程中，你已经学到了 Git 是通过当前检出分支的属性来确定远程仓库以及要 push 的目的地的。这是未指定参数时的行为，我们可以为 push 指定参数，语法是：\n\n💯==**git push \\<remote\\> \\<place\\>**==\n\n把这个命令翻译过来就是：\n\n*切到本地仓库中的“main”分支，获取所有的提交，再到远程仓库“origin”中找到“main”分支，将远程仓库中没有的提交记录都添加上去，搞定之后告诉我。*\n\n我们通过“place”参数来告诉 Git 提交记录来自于 main, 要推送到远程仓库中的 main。它实际就是要同步的两个仓库的位置。\n\n需要注意的是，因为我们通过指定参数告诉了 Git 所有它需要的信息, 所以它就忽略了我们所检出的分支的属性！\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624300d69d378.png)\n\n------\n\n#### Git Push的参数2\n\n，当为 git push 指定 place 参数为 `main` 时，我们同时指定了提交记录的来源和去向。\n\n你可能想问 —— 如果来源和去向分支的名称不同呢？比如你想把本地的 `foo` 分支推送到远程仓库中的 `bar` 分支。\n\n要同时为源和目的地指定 `<place>` 的话，只需要用冒号 `:` 将二者连起来就可以了：\n\n💯==**git push origin \\<source\\>:\\<destination\\>**==\n\n这个参数实际的值是个 refspec，“refspec” 是一个自造的词，意思是 Git 能识别的位置（比如分支 `foo` 或者 `HEAD~1`）\n\n一旦你指定了独立的来源和目的地，就可以组织出言简意赅的远程操作命令了.\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624301c9cddfe.png)\n\n------\n\n#### Git Fetch的参数\n\n`git fetch` 的参数和 `git push` 极其相似。他们的概念是相同的，只是方向相反罢了（因为现在你是下载，而非上传）\n\n💯==**git fetch \\<remote\\> \\<place\\>**==\n\nGit 会到远程仓库的分支上，然后获取所有本地不存在的提交，放到本地的相应分支上。\n\n💯==**git fetch origin \\<source\\>:\\<destination\\>**==\n\n但是命令很不常用就是了\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624301c9cddfe.png)\n\n------\n\n#### 没有source的source\n\nGit 有两种关于 `<source>` 的用法是比较诡异的，即你可以在 git push 或 git fetch 时不指定任何 `source`，方法就是仅保留冒号和 destination 部分，source 部分留空。\n\n- `git push origin :side`\n- `git fetch origin :bugFix`\n\n我们分别来看一下这两条命令的作用……\n\n如果 push 空 到远程仓库会如何呢？它会删除远程仓库中的分支！\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624313c20ceea.png\" style=\"zoom:50%;\" />\n\n如果 fetch 空 到本地，会在本地创建一个新分支。\n\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624314368592a.png\" style=\"zoom:50%;\" />\n\n\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6243147a70f05.png)\n\n------\n\n#### Git Pull的参数\n\n git pull 到头来就是 fetch 后跟 merge 的缩写。你可以理解为用同样的参数执行 git fetch，然后再 merge 你所抓取到的提交记录。\n\n`git pull origin foo` 相当于：\n\n```\ngit fetch origin foo; git merge o/foo\n```\n\n还有...\n\n`git pull origin bar~1:bugFix` 相当于：\n\n```\ngit fetch origin bar~1:bugFix; git merge bugFix\n```\n\n![](https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624316d49f61c.png)\n\n------\n\n\n\n## Git操作实例\n\n> 在这一个月多的工作里，我也遇到了需要用到git的一些操作，在此总结如下情景：\n\n### 先暂存当前工作而去完成另一个工作\n\n> 遇到过这种情况：在做某个工作到一半还没完成的时候，突然被提醒先去做另外一个工作。这种情况下，现在没做完的工作咋办？\n\n首先，在看了上面的内容之后，不管如果我们一定要先进行 `git commit` 操作。\n\n因为只有在commit之后，当前工作才会成为一个结点。\n\n同时，为了唯一标识当前结点，我们可以采用新建分支或者新建tag的方式标记当前结点：\n\n```\ngit tag tag_name HEAD\n```\n\n在完成该操作后，我们就回到上一个结点，也就是远端所在结点：\n\n```\ngit checkout HEAD^\n\ngit branch -f master HEAD\n\ngit checkout master\n```\n\n此后，我们便可以开始新的工作，以正常的方式进行新的操作（commit啊，push啊都可以）。\n\n当前工作完成之后，我们就可以通过 ` git checkout tag_name ` 回到之前没有完成的工作中去了！\n\n### 更改两次提交的顺序\n\n> 这是今天遇到的一个情况：先完成了一个提交，之后去做另一个工作提交了一次。但这时被提示之前的提交有问题，需要修改。\n>\n> 这个时候，后一次的提交没有问题，可以被点进主分支中。但由于它的父结点是前一次的提交，因此点不进去，怎么办呢？\n\n这个时候，我们就要考虑切换两个分支的顺序了。\n\n首先最重要的是，我们还是要加一个标签标记当前的位置，否则以后就找不到了：\n\n```\ngit tag tag_name HEAD\n```\n\n然后，我们回到上上一次的位置：\n\n```\ngit checkout HEAD~2\n\ngit branch -f master HEAD\n\ngit checkout master\n```\n\n这个时候，我们只要通过 ` cherry-pick ` 操作把刚刚的两个操作反过来串联在一起就行了。\n\n当然，通过前面的学习，我们知道  ` git rebase -i `也是可行的，在这里不再赘述。\n\n","slug":"git基本操作整理","published":1,"updated":"2022-04-03T12:19:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmhg4qvmy001kf5fa0mtl3ovs","content":"<h1 id=\"Git-基本操作整理\"><a href=\"#Git-基本操作整理\" class=\"headerlink\" title=\"Git 基本操作整理\"></a>Git 基本操作整理</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文档通过整理CS-Notes中的Git命令操作与实战Learn Git Branching来学习掌握Git方法。因为文档主要分为两部分，第一部分参考CS-Notes并查阅资料为Git理论知识，第二部分为实战Learn Git Branching给出个人思考与过程。</p>\n<p>参考资料来源:</p>\n<ol>\n<li><p><a href=\"http://www.cyc2018.xyz/%E5%85%B6%E5%AE%83/%E7%BC%96%E7%A0%81%E5%AE%9E%E8%B7%B5/Git.html#%E9%9B%86%E4%B8%AD%E5%BC%8F%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F\">CS-Notes Git部分</a></p>\n</li>\n<li><p><a href=\"https://learngitbranching.js.org/?demo=&locale=zh_CN\">Learn Git Branching</a></p>\n</li>\n</ol>\n<h2 id=\"Git知识\"><a href=\"#Git知识\" class=\"headerlink\" title=\"Git知识\"></a>Git知识</h2><h2 id=\"Learn-Git-Branching\"><a href=\"#Learn-Git-Branching\" class=\"headerlink\" title=\"Learn Git Branching\"></a>Learn Git Branching</h2><h3 id=\"Level-1-Git基础内容\"><a href=\"#Level-1-Git基础内容\" class=\"headerlink\" title=\"Level 1. Git基础内容\"></a>Level 1. Git基础内容</h3><h4 id=\"Git-Commit\"><a href=\"#Git-Commit\" class=\"headerlink\" title=\"Git Commit\"></a>Git Commit</h4><p>Git 仓库中的提交记录保存的是你的目录下所有文件的快照，就像是把整个目录复制，然后再粘贴一样，但比复制粘贴优雅许多！</p>\n<p>Git 希望提交记录尽可能地轻量，因此在你每次进行提交时，它并不会盲目地复制整个目录。条件允许的情况下，它会将当前版本与仓库中的上一个版本进行对比，并把所有的差异打包到一起作为一个提交记录。Git 还保存了提交的历史记录。这也是为什么大多数提交记录的上面都有父节点的原因。对于项目组的成员来说，维护提交历史对大家都有好处。</p>\n<p>Git Commit 就是在父节点下进行一次内容的提交。使用的命令很简单为：</p>\n<p>💯==<strong>git commit</strong>==</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f9be0486.png\"></p>\n<hr>\n<h4 id=\"Git-Branch\"><a href=\"#Git-Branch\" class=\"headerlink\" title=\"Git Branch\"></a>Git Branch</h4><p>Git 的分支也非常轻量。它们只是简单地指向某个提交纪录 —— 仅此而已。</p>\n<p>所以许多 Git 爱好者传颂：😍<strong>早建分支，多用分支！</strong></p>\n<p>这是因为即使创建再多的分支也不会造成储存或内存上的开销，并且按逻辑分解工作到不同的分支要比维护那些特别臃肿的分支简单多了。</p>\n<p>在将分支和提交记录结合起来后，我们会看到两者如何协作。现在只要记住使用分支其实就相当于在说：“<strong>我想基于这个提交以及它所有的父提交进行新的工作。</strong>”</p>\n<p>创建分支的命令最基础的就是：</p>\n<p>💯==<strong>git branch <branch_name></strong>==</p>\n<p>创建好的分支会指向当前的提交记录。但是通过上述命令创建的分支并不是我们现在所使用的分支，如果我们此刻进行了git commit操作，那么我们的行为仍然是操作于原来的分支。所以我们如果想要使用这个新分支，我们需要使用切换分支的命令：</p>\n<p>💯==<strong>git checkout <branch_name></strong>==</p>\n<p>有一个简洁的方式，如果你想创建一个新的分支同时切换到新创建的分支的话，可以通过 </p>\n<p>💯==<strong>git checkout -b &lt;your-branch-name&gt;</strong>==</p>\n<p><img src=\"https://i0.hdslb.com/bfs/album/a11e89444b0b5c7d221325a9637f26e54ebe12c6.png\"></p>\n<hr>\n<h4 id=\"Git-Merge\"><a href=\"#Git-Merge\" class=\"headerlink\" title=\"Git Merge\"></a>Git Merge</h4><p>在知道如何提交以及如何使用分支的前提下，接下来是如何将两个分支合并到一起。就是说我们新建一个分支，在其上开发某个新功能，开发完成后再合并回主线。</p>\n<p>第一种方法是通过git merge实现的。在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个父节点。翻译成自然语言相当于：“我要把这两个父节点本身及它们所有的祖先都包含进来。”因此，git合并分支的命令是：</p>\n<p>💯==<strong>git merge <branch_name></strong>==</p>\n<p>该命令是将branch_name合并到当前的分支下</p>\n<p>例如：我们有这两个分支main与bugFix，我们可以通过git merge命令来将两者合并：</p>\n<img src=\"https://i0.hdslb.com/bfs/album/1a7e02089e6db4f76cec7be3ca3766caa38c1fd7.png\" style=\"zoom:50%;\" />\n\n<p>合并后，我们发现新的分支是保留了两条路径指向父节点，并没有断了与任何一条分支的联系，因此这个过程支持了Git对历史版本信息的维护。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f858fa9e.png\" style=\"zoom:50%;\" />\n\n<p>接下来，可以将main分支合并到bugFix中</p>\n<p>通过<code>git checkout bugFix; git merge main</code></p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f8526a06.png\" style=\"zoom:50%;\" />\n\n<p>因为 main 继承自 bugFix ，Git 什么都不用做，只是简单地把 bugFix 移动到 main 所指向的那个提交记录。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/album/08d9d8343a7164f9c6b01eccca5471872790f07f.png\"></p>\n<hr>\n<h4 id=\"Git-Rebase\"><a href=\"#Git-Rebase\" class=\"headerlink\" title=\"Git Rebase\"></a>Git Rebase</h4><p>第二种合并分支的方法是 git rebase。Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。</p>\n<p>Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。Rebase的命令如下：</p>\n<p>💯==<strong>git rebase <branch_name></strong>==</p>\n<p>例如：同样我们有两个分支main和bugFix，我们可以通过rebase来将两者合并：</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f857516e.png\" style=\"zoom:50%;\" />\n\n<p>通过rebase命令后，不同于原来的merge建立两条关于父节点的链接，而是通过提取一系列的提交记录然后建立一个基于main的副本，这样生成的线性的提交历史：</p>\n<img src=\"https://i0.hdslb.com/bfs/album/59f7e1df1314389ddbbcb14fda46a0a679d6c999.png\" style=\"zoom:50%;\" />\n\n<p>此时，原先分支的C3并没有被删除，接下来可以切换到main分支，通过rebase向前推进一个版本</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f857627e.png\" style=\"zoom:50%;\" />\n\n<p>rebase命令维护一条线性的提交记录使得历史提交很清晰。我理解的话，主要是通过在代合并的分支上补充原有分支的一些历史提交信息，然后类似于“复制”了一个版本到待合并分支下，实现一个合并操作。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/album/8ee6ba5797dbd7b567f3a9f05c43a9d88472e13d.png\"></p>\n<hr>\n<h3 id=\"Level-2-Git高级内容\"><a href=\"#Level-2-Git高级内容\" class=\"headerlink\" title=\"Level 2. Git高级内容\"></a>Level 2. Git高级内容</h3><h4 id=\"分离HEAD\"><a href=\"#分离HEAD\" class=\"headerlink\" title=\"分离HEAD\"></a>分离HEAD</h4><p>HEAD 是一个对当前检出记录的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。</p>\n<p>HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。</p>\n<p>HEAD 通常情况下是指向分支名的（如 bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。</p>\n<p><strong>分离的 HEAD 就是让其指向了某个具体的提交记录而不是分支名。</strong>在命令执行之前的状态如下所示：</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242631f0352b.png\" style=\"zoom:50%;\" />\n\n<p>HEAD -&gt; main -&gt; C1</p>\n<p>HEAD 指向 main， main 指向 C1</p>\n<p>再通过 <strong>git checkout C1</strong> 后变成了：</p>\n<p>HEAD -&gt; C1</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624263c60010b.png\" style=\"zoom:50%;\" />\n\n\n\n<p>所以分离当前HEAD是通过：</p>\n<p>💯==<strong>git checkout &lt;hash_commit&gt;</strong>==</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624264090b652.png\"></p>\n<hr>\n<h4 id=\"相对引用\"><a href=\"#相对引用\" class=\"headerlink\" title=\"相对引用(^)\"></a>相对引用(^)</h4><p>通过指定提交记录哈希值的方式在 Git 中移动不太方便。在实际应用时，并没有像本程序中这么漂亮的可视化提交树供你参考，所以你就不得不用 <code>git log</code> 来查查看提交记录的哈希值。</p>\n<p>并且哈希值在真实的 Git 世界中也会更长（e.g. 基于 SHA-1，共 40 位）。例如前一关的介绍中的提交记录的哈希值可能是 <code>fed2da64c0efc5293610bdd892f82a58e8cbc5d8</code>。比较令人欣慰的是，Git 对哈希的处理很智能。你只需要提供能够唯一标识提交记录的前几个字符即可。因此我可以仅输入<code>fed2</code> 而不是上面的一长串字符。</p>\n<p>通过哈希值提交记录很不方便，所以git引用了相对引用。使用相对引用的话，就可以从一个易于记忆的地方（比如 <code>bugFix</code> 分支或 <code>HEAD</code>）开始计算。</p>\n<p>相对引用非常给力，这里我介绍两个简单的用法：</p>\n<ul>\n<li>使用 <code>^</code> 向上移动 1 个提交记录</li>\n<li>使用 <code>~&lt;num&gt;</code> 向上移动多个提交记录，如 <code>~3</code></li>\n</ul>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624274834cddb.png\" style=\"zoom:50%;\" />\n\n<p>通过使用(^)可以相对很方便找到main的父节点，而不是通过哈希的方式，以此类推，可以通过main^^来实现寻找父节点的父节点<br>💯==<strong>git checkout main^</strong>==</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624274aea1027.png\" style=\"zoom:50%;\" />\n\n\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624276378ff5f.png\"></p>\n<hr>\n<h4 id=\"相对引用2\"><a href=\"#相对引用2\" class=\"headerlink\" title=\"相对引用2(~)\"></a>相对引用2(~)</h4><p>如果你想在提交树中向上移动很多步的话，敲那么多 <code>^</code> 貌似也挺烦人的，Git 当然也考虑到了这一点，于是又引入了操作符 <code>~</code>。该操作符后面可以跟一个数字（可选，不跟数字时与 <code>^</code> 相同，向上移动一次），指定向上移动多少次。</p>\n<p>通过多次移动的相对引用命令，实现简洁的后退操作：</p>\n<p>💯==<strong>git checkout HEAD~&lt;num&gt;</strong>==</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624276db5423e.png\" style=\"zoom:50%;\" />\n\n\n\n<p>使用相对引用比较多的场景就是移动分支。可以直接使用 <code>-f</code> 选项让分支指向另一个提交，达到强制修改分支的目的，例如:</p>\n<p>💯==<strong>git branch -f main HEAD~3</strong>==</p>\n<p>上面的命令会将 main 分支强制指向 HEAD 的第 3 级父提交。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62427882a6119.png\" style=\"zoom:50%;\" />\n\n<p>可以发现main分支指向了是HEAD向后移动3级父提交记录上</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a3729f60c.png\" style=\"zoom:50%;\" />\n\n<p>合理使用git branch -f 与git checkout 可以实现对当前提交节点与分支的转换。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a5ae757e9.png\"></p>\n<hr>\n<h4 id=\"撤销变更\"><a href=\"#撤销变更\" class=\"headerlink\" title=\"撤销变更\"></a>撤销变更</h4><p>在 Git 里撤销变更的方法很多。和提交一样，撤销变更由底层部分（暂存区的独立文件或者片段）和上层部分（变更到底是通过哪种方式被撤销的）组成。我们这个应用主要关注的是后者。</p>\n<p>主要有两种方法用来撤销变更 —— 一是 <code>git reset</code>，还有就是 <code>git revert</code>。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a6fb59604.png\" style=\"zoom:50%;\" />\n\n<p>通过一下撤销变更的命令：</p>\n<p>💯==<strong>git reset HEAD~1</strong>==</p>\n<p>Git 把 main 分支移回到 C1；现在我们的本地代码库根本就不知道有 C2 这个提交了。但是在reset后， C2 所做的变更还在，但是处于未加入暂存区状态。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a76660edc.png\" style=\"zoom:50%;\" />\n\n<p>git reset 撤销的方式对大家一起使用的远端分支是无效的，为了撤销更改并分享给别人，我们需要使用：</p>\n<p>💯==<strong>git revert HEAD</strong>==</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a82f31d87.png\" style=\"zoom:50%;\" />\n\n<p>在我们要撤销的提交记录后面居然多了一个新提交！这是因为新提交记录 C2’ 引入了<strong>更改</strong> —— 这些更改刚好是用来撤销 C2 这个提交的。也就是说 C2’ 的状态与 C1 是相同的。revert 之后就可以把你的更改推送到远程仓库与别人分享啦。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a9486b1f8.png\"></p>\n<p>刚才试了一下reset的作用，其实就是本地回退到上一个版本得话，可以在更改一些功能后，通过rebase或者merge指定遗弃分支进行合并或者完全放弃？🤔</p>\n<hr>\n<h3 id=\"Level-3-Git移动提交记录\"><a href=\"#Level-3-Git移动提交记录\" class=\"headerlink\" title=\"Level 3. Git移动提交记录\"></a>Level 3. Git移动提交记录</h3><h4 id=\"Git-Cherry-pick\"><a href=\"#Git-Cherry-pick\" class=\"headerlink\" title=\"Git Cherry-pick\"></a>Git Cherry-pick</h4><p>接下来要讨论的这个话题是“整理提交记录” —— 开发人员有时会说“我想要把这个提交放到这里, 那个提交放到刚才那个提交的后面”, 而接下来就讲的就是它的实现方式，非常清晰、灵活，还很生动。</p>\n<p>如果你想将一些提交复制到当前所在的位置（<code>HEAD</code>）下面的话， Cherry-pick 是最直接的方式了。命令为：</p>\n<p>💯==<strong>git cherry-pick &lt;commit_version&gt;</strong>==</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242aab507c99.png\" style=\"zoom:50%;\" />\n\n<p>这里有一个仓库, 我们想将 side 分支上的工作复制到 main 分支，rebase 可以解决这个问题，但是也可以通过 cherry-pick, 我们执行命令 git cherry-pick C2 C4</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ab6297234.png\" style=\"zoom:50%;\" />\n\n<p>通过cherry-pick可以直接选取我们要的提交记录在当前分支之下，感觉git的整理提交记录的思想在于维护一条提交的线(主干线)</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242abd0e399a.png\"></p>\n<hr>\n<h4 id=\"交互式rebase\"><a href=\"#交互式rebase\" class=\"headerlink\" title=\"交互式rebase\"></a>交互式rebase</h4><p>当你知道你所需要的提交记录（<strong>并且</strong>还知道这些提交记录的哈希值）时, 用 cherry-pick 再好不过了 —— 没有比这更简单的方式了。但是如果你不清楚你想要的提交记录的哈希值呢? 幸好 Git 帮你想到了这一点, 我们可以利用交互式的 rebase —— 如果你想从一系列的提交记录中找到想要的记录, 这就是最好的方法了。</p>\n<p>交互式 rebase 指的是使用带参数 <code>--interactive</code> 的 rebase 命令, 简写为 <code>-i</code></p>\n<p>如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。</p>\n<p>在实际使用时，所谓的 UI 窗口一般会在文本编辑器 —— 如 Vim —— 中打开一个文件。</p>\n<p>当 rebase UI界面打开时, 你能做3件事:</p>\n<ul>\n<li>调整提交记录的顺序（通过鼠标拖放来完成）</li>\n<li>删除你不想要的提交（通过切换 <code>pick</code> 的状态来完成，关闭就意味着你不想要这个提交记录）</li>\n<li>合并提交。</li>\n</ul>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242af2c739cb.png\" style=\"zoom:50%;\" />\n\n<p>输入交互式rebase命令后：</p>\n<p>💯==<strong>git rebase -i HEAD[~&lt;num&gt;|^]</strong>==</p>\n<p>通过rebase -i HEAD~4实现对后续提交内容进行调整顺序，删除omit提交与合并</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242b17d54c69.png\" style=\"zoom:50%;\" />\n\n<p>完全重新整理了commit的顺序，但是感觉需要以合理的机会使用，要不然真的会很艰难。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242b33615af6.png\"></p>\n<hr>\n<h3 id=\"Level-4-杂项\"><a href=\"#Level-4-杂项\" class=\"headerlink\" title=\"Level 4. 杂项\"></a>Level 4. 杂项</h3><h4 id=\"只取一个提交记录\"><a href=\"#只取一个提交记录\" class=\"headerlink\" title=\"只取一个提交记录\"></a>只取一个提交记录</h4><p>来看一个在开发中经常会遇到的情况：我正在解决某个特别棘手的 Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息。</p>\n<p>这些调试和打印语句都在它们各自的提交记录里。最后我终于找到了造成这个 Bug 的根本原因，解决掉以后觉得沾沾自喜！</p>\n<p>最后就差把 <code>bugFix</code> 分支里的工作合并回 <code>main</code> 分支了。你可以选择通过 fast-forward 快速合并到 <code>main</code> 分支上，但这样的话 <code>main</code> 分支就会包含我这些调试语句了。你肯定不想这样，应该还有更好的方式……</p>\n<p>实际我们只要让 Git 复制解决问题的那一个提交记录就可以了。跟之前我们在“整理提交记录”中学到的一样，我们可以使用</p>\n<ul>\n<li><code>git rebase -i</code></li>\n<li><code>git cherry-pick</code></li>\n</ul>\n<p>来达到目的。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242b98be1504.png\"></p>\n<hr>\n<h4 id=\"提交的技巧-1\"><a href=\"#提交的技巧-1\" class=\"headerlink\" title=\"提交的技巧 #1\"></a>提交的技巧 #1</h4><p>接下来这种情况也是很常见的：你之前在 newImage 分支上进行了一次提交，然后又基于它创建了 caption 分支，然后又提交了一次。</p>\n<p>此时你想对某个以前的提交记录进行一些小小的调整。比如设计师想修改一下 <code>newImage</code> 中图片的分辨率，尽管那个提交记录并不是最新的了。</p>\n<p>我们可以通过下面的方法来克服困难：</p>\n<ul>\n<li>先用 <code>git rebase -i</code> 将提交重新排序，然后把我们想要修改的提交记录挪到最前</li>\n<li>然后用 <code>git commit --amend</code> 来进行一些小修改</li>\n<li>接着再用 <code>git rebase -i</code> 来将他们调回原来的顺序</li>\n<li>最后我们把 main 移到修改的最前端（用你自己喜欢的方法），就大功告成啦！</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242dbc3cd20f.png\"></p>\n<hr>\n<h4 id=\"提交的技巧-2\"><a href=\"#提交的技巧-2\" class=\"headerlink\" title=\"提交的技巧 #2\"></a>提交的技巧 #2</h4><p>正如你在上一关所见到的，我们可以使用 <code>rebase -i</code> 对提交记录进行重新排序。只要把我们想要的提交记录挪到最前端，我们就可以很轻松的用 <code>--amend</code> 修改它，然后把它们重新排成我们想要的顺序。</p>\n<p>但这样做就唯一的问题就是要进行两次排序，而这有可能造成由 rebase 而导致的冲突。因此选择使用cherry-pick来实现上述问题。</p>\n<p>cherry-pick 可以将提交树上任何地方的提交记录取过来追加到 HEAD 上</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ddc84217c.png\"></p>\n<hr>\n<h4 id=\"Git-Tag\"><a href=\"#Git-Tag\" class=\"headerlink\" title=\"Git Tag\"></a>Git Tag</h4><p>分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。有没有什么可以永远指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢？</p>\n<p>Git 的 tag 可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。更难得的是，它们并不会随着新的提交而移动。你也不能切换到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。</p>\n<p>tag的命令是：</p>\n<p>💯==<strong>git tag &lt;tag_name&gt; &lt;commit_name&gt;</strong>==</p>\n<p><img src=\"C:\\Users\\14218\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220329183103581.png\" alt=\"image-20220329183103581\"></p>\n<hr>\n<h4 id=\"Git-Describe\"><a href=\"#Git-Describe\" class=\"headerlink\" title=\"Git Describe\"></a>Git Describe</h4><p>由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来<strong>描述</strong>离你最近的锚点（也就是标签），它就是 <code>git describe</code>！</p>\n<p>Git Describe 能帮你在提交历史中移动了多次以后找到方向；当你用 <code>git bisect</code>（一个查找产生 Bug 的提交记录的指令）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时， 可能会用到这个命令。</p>\n<p>git describe的语法是：</p>\n<p>💯==<strong>git describe &lt;ref&gt;</strong>==    </p>\n<p>ref 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（HEAD）.</p>\n<p>返回类型为💯==<strong>&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;</strong>==    </p>\n<p>tag 表示的是离 ref 最近的标签， numCommits 是表示这个 ref 与 tag 相差有多少个提交记录， hash 表示的是你所给定的 ref 所表示的提交记录哈希值的前几位。当 ref 提交记录上有某个标签时，则只输出标签名称。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e388a4335.png\"></p>\n<hr>\n<h3 id=\"Level-5-Git-高级话题-某些应用\"><a href=\"#Level-5-Git-高级话题-某些应用\" class=\"headerlink\" title=\"Level 5. Git 高级话题(某些应用)\"></a>Level 5. Git 高级话题(某些应用)</h3><h4 id=\"多分支rebase\"><a href=\"#多分支rebase\" class=\"headerlink\" title=\"多分支rebase\"></a>多分支rebase</h4><p>通过rebase实现多个分支的合并操作，其实通过rebase branch1 branch2 可以很快的实现，并且记住的是branch1是branch2的父分支的话就很容易实现了，每次rebase应该省略的是branch2的参数(如果不给的话)</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e564c9d33.png\"></p>\n<hr>\n<h4 id=\"两个父节点\"><a href=\"#两个父节点\" class=\"headerlink\" title=\"两个父节点\"></a>两个父节点</h4><p>操作符 <code>^</code> 与 <code>~</code> 符一样，后面也可以跟一个数字。</p>\n<p>但是该操作符后面的数字与 <code>~</code> 后面的不同，并不是用来指定向上返回几代，而是指定合并提交记录的某个父提交。还记得前面提到过的一个合并提交有两个父提交吧，所以遇到这样的节点时该选择哪条路径就不是很清晰了。</p>\n<p>Git 默认选择合并提交的“第一个”父提交，在操作符 <code>^</code> 后跟一个数字可以改变这一默认行为。</p>\n<p>例如，执行 git checkout main^2 的过程就是回到第二个父提交节点的意思。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e67ed88f1.png\" style=\"zoom:50%;\" />\n\n<p>并且git支持两个操作符的链式操作 git checkout main~^2~2</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e6cb0c441.png\" style=\"zoom:50%;\" />\n\n\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e85b0e9c3.png\"></p>\n<hr>\n<h4 id=\"纠缠不清的分支\"><a href=\"#纠缠不清的分支\" class=\"headerlink\" title=\"纠缠不清的分支\"></a>纠缠不清的分支</h4><p>实现这种不同分支梳理最好的方式是通过cherry-pick，如果方便知道commit的提交哈希值的话。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e9658f176.png\"></p>\n<hr>\n<h3 id=\"Level-6-Push-amp-Pull-——-Git-远程仓库\"><a href=\"#Level-6-Push-amp-Pull-——-Git-远程仓库\" class=\"headerlink\" title=\"Level 6. Push &amp; Pull —— Git 远程仓库\"></a>Level 6. Push &amp; Pull —— Git 远程仓库</h3><h4 id=\"Git-Clone\"><a href=\"#Git-Clone\" class=\"headerlink\" title=\"Git Clone\"></a>Git Clone</h4><p>远程仓库并不复杂, 在如今的云计算盛行的世界很容易把远程仓库想象成一个富有魔力的东西, 但实际上它们只是你的仓库在另个一台计算机上的拷贝。你可以通过因特网与这台计算机通信 —— 也就是增加或是获取提交记录</p>\n<p>话虽如此, 远程仓库却有一系列强大的特性</p>\n<ul>\n<li>首先也是最重要的的点, 远程仓库是一个强大的备份。本地仓库也有恢复文件到指定版本的能力, 但所有的信息都是保存在本地的。有了远程仓库以后，即使丢失了本地所有数据, 你仍可以通过远程仓库拿回你丢失的数据。</li>\n<li>还有就是, 远程让代码社交化了! 既然你的项目被托管到别的地方了, 你的朋友可以更容易地为你的项目做贡献(或者拉取最新的变更)</li>\n</ul>\n<p>💯==<strong>git clone</strong>==</p>\n<p>通过git clone 可以从远端拉取仓库到本地</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ea37dc283.png\"></p>\n<hr>\n<h4 id=\"远端分支\"><a href=\"#远端分支\" class=\"headerlink\" title=\"远端分支\"></a>远端分支</h4><p>你可能注意到的第一个事就是在我们的本地仓库多了一个名为 <code>o/main</code> 的分支, 这种类型的分支就叫<strong>远程</strong>分支。由于远程分支的特性导致其拥有一些特殊属性。</p>\n<p>远程分支反映了远程仓库(在你上次和它通信时)的<strong>状态</strong>。这会有助于你理解本地的工作与公共工作的差别 —— 这是你与别人分享工作成果前至关重要的一步.</p>\n<p>远程分支有一个特别的属性，在你检出时自动进入分离 HEAD 状态。Git 这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作, （更新了远程分支之后）再用远程分享你的工作成果。</p>\n<p>o/main的意思就是&lt;remote name&gt;/&lt;branch name&gt;</p>\n<p>如果当前选择的是远端分支的话，进行commit操作是不会直接进行远端分支的更新，而是使本地处于分离HEAD的状态。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242eb32490c4.png\"></p>\n<hr>\n<h4 id=\"Git-Fetch\"><a href=\"#Git-Fetch\" class=\"headerlink\" title=\"Git Fetch\"></a>Git Fetch</h4><p>Git 远程仓库相当的操作实际可以归纳为两点：向远程仓库传输数据以及从远程仓库获取数据。既然我们能与远程仓库同步，那么就可以分享任何能被 Git 管理的更新（因此可以分享代码、文件、想法、情书等等）。</p>\n<p>如何从远程仓库获取数据 —— 命令如其名，它就是 git fetch 。</p>\n<p>💯==<strong>git fetch</strong>==</p>\n<p><strong>Git Fetch Do:</strong></p>\n<p>git fetch 完成了仅有的但是很重要的两步:</p>\n<ul>\n<li>从远程仓库下载本地仓库中缺失的提交记录</li>\n<li>更新远程分支指针(如 <code>o/main</code>)</li>\n</ul>\n<p>git fetch 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。</p>\n<p>如果你还记得上一节课程中我们说过的，远程分支反映了远程仓库在你<strong>最后一次与它通信时</strong>的状态，git fetch 就是你与远程仓库通信的方式了！</p>\n<p><strong>Git Fetch Not Do:</strong></p>\n<p>git fetch 并不会改变你本地仓库的状态。它不会更新你的 main 分支，也不会修改你磁盘上的文件。</p>\n<p>理解这一点很重要，因为许多开发人员误以为执行了 git fetch 以后，他们本地仓库就与远程仓库同步了。它可能已经将进行这一操作所需的所有数据都下载了下来，但是<strong>并没有</strong>修改你本地的文件。git fetch 就是单纯的下载资源的操作。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ecb8f2bac.png\"></p>\n<hr>\n<h4 id=\"Git-Pull\"><a href=\"#Git-Pull\" class=\"headerlink\" title=\"Git Pull\"></a>Git Pull</h4><p>其实有很多方法的 —— 当远程分支中有新的提交时，你可以像合并本地分支那样来合并远程分支。也就是说就是你可以执行以下命令:</p>\n<ul>\n<li><code>git cherry-pick o/main</code></li>\n<li><code>git rebase o/main</code></li>\n<li><code>git merge o/main</code></li>\n<li>等等</li>\n</ul>\n<p>实际上，由于先抓取更新再合并到本地分支这个流程很常用，因此 Git 提供了一个专门的命令来完成这两个操作。</p>\n<p>💯==<strong>git pull</strong>==</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ed89ae9c4.png\" style=\"zoom:50%;\" />\n\n<p>git pull 就是 git fetch 和 git merge的缩写</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ee13e8cad.png\"></p>\n<hr>\n<h4 id=\"模拟团队合作\"><a href=\"#模拟团队合作\" class=\"headerlink\" title=\"模拟团队合作\"></a>模拟团队合作</h4><p>在远端操作进行一定更新后，可以通过pull进行及时的拉去更新本地分支</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ee9fb29ea.png\"></p>\n<hr>\n<h4 id=\"Git-Push\"><a href=\"#Git-Push\" class=\"headerlink\" title=\"Git Push\"></a>Git Push</h4><p>传自己分享内容与下载他人的分享刚好相反，git push 负责将<strong>你的</strong>变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录。一旦 git push 完成, 你的朋友们就可以从这个远程仓库下载你分享的成果了！</p>\n<p>💯==<strong>git push</strong>==</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ef5af3f83.png\"></p>\n<hr>\n<h4 id=\"偏离的提交历史\"><a href=\"#偏离的提交历史\" class=\"headerlink\" title=\"偏离的提交历史\"></a>偏离的提交历史</h4><p>假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕，可以发布了。但是 —— 天啊！你的同事这周写了一堆代码，还改了许多你的功能中使用的 API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库了，因此你的工作就变成了基于项目<strong>旧版</strong>的代码，与远程仓库最新的代码不匹配了。</p>\n<p>这种情况下, <code>git push</code> 就不知道该如何操作了。如果你执行 <code>git push</code>，Git 应该让远程仓库回到星期一那天的状态吗？还是直接在新代码的基础上添加你的代码，亦或由于你的提交已经过时而直接忽略你的提交？</p>\n<p>因为这情况（历史偏离）有许多的不确定性，Git 是不会允许你 <code>push</code> 变更的。实际上它会强制你先合并远程最新的代码，然后才能分享你的工作。</p>\n<p>因此主要的解决办法就是先把远端的分支pull下来，然后再merge或者rebase自己的工作到远端分支，然后再合并分支到远端仓库</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242f10bed8b1.png\"></p>\n<hr>\n<h4 id=\"Locked-Main\"><a href=\"#Locked-Main\" class=\"headerlink\" title=\"Locked Main\"></a>Locked Main</h4><p>如果你是在一个大的合作团队中工作, 很可能是main被锁定了, 需要一些Pull Request流程来合并修改。如果你直接提交(commit)到本地main, 然后试图推送(push)修改, 你将会收到这样类似的信息:</p>\n<p><em>! [远程服务器拒绝] main -&gt; main (TF402455: 不允许推送(push)这个分支; 你必须使用pull request来更新这个分支.)</em></p>\n<p>就是在团队合作的时候，防止过多人频繁push自己的代码到远端仓库，因此需要走pr的审查流程。</p>\n<p>解决办法为：新建一个分支feature, 推送到远程服务器. 然后reset你的main分支和远程服务器保持一致, 否则下次你pull并且他人的提交和你冲突的时候就会有问题.</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242f48497d61.png\"></p>\n<hr>\n<h3 id=\"Level-7-关于-origin-和它的周边-——-Git-远程仓库高级操作\"><a href=\"#Level-7-关于-origin-和它的周边-——-Git-远程仓库高级操作\" class=\"headerlink\" title=\"Level 7. 关于 origin 和它的周边 —— Git 远程仓库高级操作\"></a>Level 7. 关于 origin 和它的周边 —— Git 远程仓库高级操作</h3><h4 id=\"推送主分支\"><a href=\"#推送主分支\" class=\"headerlink\" title=\"推送主分支\"></a>推送主分支</h4><p>在大型项目中开发人员通常会在（从 <code>main</code> 上分出来的）特性分支上工作，工作完成后只做一次集成。这跟前面课程的描述很相像（把 side 分支推送到远程仓库），不过本节我们会深入一些.</p>\n<p>但是有些开发人员只在 main 上做 push、pull —— 这样的话 main 总是最新的，始终与远程分支 (o/main) 保持一致。</p>\n<p>对于接下来这个工作流，我们集成了两个步骤：</p>\n<ul>\n<li>将特性分支集成到 <code>main</code> 上</li>\n<li>推送并更新远程分支</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242fc03cb835.png\"></p>\n<p>过程就是先 git pull –rebase 然后再rebase 合并分支</p>\n<hr>\n<h4 id=\"合并远端仓库\"><a href=\"#合并远端仓库\" class=\"headerlink\" title=\"合并远端仓库\"></a>合并远端仓库</h4><p>在开发社区里，有许多关于 merge 与 rebase 的讨论。以下是关于 rebase 的优缺点：</p>\n<p>优点:</p>\n<ul>\n<li>Rebase 使你的提交树变得很干净, 所有的提交都在一条线上</li>\n</ul>\n<p>缺点:</p>\n<ul>\n<li>Rebase 修改了提交树的历史</li>\n</ul>\n<p>比如, 提交 C1 可以被 rebase 到 C3 之后。这看起来 C1 中的工作是在 C3 之后进行的，但实际上是在 C3 之前。</p>\n<p>一些开发人员喜欢保留提交历史，因此更偏爱 merge。而其他人（比如我自己）可能更喜欢干净的提交树，于是偏爱 rebase。仁者见仁，智者见智。 </p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242fd476265d.png\"></p>\n<p>相对来说，更有细节，更能体现提交历史</p>\n<h4 id=\"远程追踪\"><a href=\"#远程追踪\" class=\"headerlink\" title=\"远程追踪\"></a>远程追踪</h4><p>Git 好像知道 <code>main</code> 与 <code>o/main</code> 是相关的。当然这些分支的名字是相似的，可能会让你觉得是依此将远程分支 main 和本地的 main 分支进行了关联。这种关联在以下两种情况下可以清楚地得到展示：</p>\n<ul>\n<li>pull 操作时, 提交记录会被先下载到 o/main 上，之后再合并到本地的 main 分支。隐含的合并目标由这个关联确定的。</li>\n<li>push 操作时, 我们把工作从 <code>main</code> 推到远程仓库中的 <code>main</code> 分支(同时会更新远程分支 <code>o/main</code>) 。这个推送的目的地也是由这种关联确定的！</li>\n</ul>\n<p>直接了当地讲，<code>main</code> 和 <code>o/main</code> 的关联关系就是由分支的“remote tracking”属性决定的。<code>main</code> 被设定为跟踪 <code>o/main</code> —— 这意味着为 <code>main</code> 分支指定了推送的目的地以及拉取后合并的目标。</p>\n<p>你可能想知道 <code>main</code> 分支上这个属性是怎么被设定的，你并没有用任何命令指定过这个属性呀！好吧, 当你克隆仓库的时候, Git 就自动帮你把这个属性设置好了。</p>\n<p>当你克隆时, Git 会为远程仓库中的每个分支在本地仓库中创建一个远程分支（比如 <code>o/main</code>）。然后再创建一个跟踪远程仓库中活动分支的本地分支，默认情况下这个本地分支会被命名为 <code>main</code>。</p>\n<p>克隆完成后，你会得到一个本地分支（如果没有这个本地分支的话，你的目录就是“空白”的），但是可以查看远程仓库中所有的分支（如果你好奇心很强的话）。这样做对于本地仓库和远程仓库来说，都是最佳选择。</p>\n<p>💯==<strong>git checkout -b totallyNotMain o/main</strong>==</p>\n<p>可以创建一个totallyNotMain来追踪远程分支o/main</p>\n<p>💯==<strong>git branch -u o/main foo</strong>==</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ff7627ed3.png\"></p>\n<hr>\n<h4 id=\"Git-Push的参数\"><a href=\"#Git-Push的参数\" class=\"headerlink\" title=\"Git Push的参数\"></a>Git Push的参数</h4><p>首先来看 <code>git push</code>。在远程跟踪课程中，你已经学到了 Git 是通过当前检出分支的属性来确定远程仓库以及要 push 的目的地的。这是未指定参数时的行为，我们可以为 push 指定参数，语法是：</p>\n<p>💯==<strong>git push &lt;remote&gt; &lt;place&gt;</strong>==</p>\n<p>把这个命令翻译过来就是：</p>\n<p><em>切到本地仓库中的“main”分支，获取所有的提交，再到远程仓库“origin”中找到“main”分支，将远程仓库中没有的提交记录都添加上去，搞定之后告诉我。</em></p>\n<p>我们通过“place”参数来告诉 Git 提交记录来自于 main, 要推送到远程仓库中的 main。它实际就是要同步的两个仓库的位置。</p>\n<p>需要注意的是，因为我们通过指定参数告诉了 Git 所有它需要的信息, 所以它就忽略了我们所检出的分支的属性！</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624300d69d378.png\"></p>\n<hr>\n<h4 id=\"Git-Push的参数2\"><a href=\"#Git-Push的参数2\" class=\"headerlink\" title=\"Git Push的参数2\"></a>Git Push的参数2</h4><p>，当为 git push 指定 place 参数为 <code>main</code> 时，我们同时指定了提交记录的来源和去向。</p>\n<p>你可能想问 —— 如果来源和去向分支的名称不同呢？比如你想把本地的 <code>foo</code> 分支推送到远程仓库中的 <code>bar</code> 分支。</p>\n<p>要同时为源和目的地指定 <code>&lt;place&gt;</code> 的话，只需要用冒号 <code>:</code> 将二者连起来就可以了：</p>\n<p>💯==<strong>git push origin &lt;source&gt;:&lt;destination&gt;</strong>==</p>\n<p>这个参数实际的值是个 refspec，“refspec” 是一个自造的词，意思是 Git 能识别的位置（比如分支 <code>foo</code> 或者 <code>HEAD~1</code>）</p>\n<p>一旦你指定了独立的来源和目的地，就可以组织出言简意赅的远程操作命令了.</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624301c9cddfe.png\"></p>\n<hr>\n<h4 id=\"Git-Fetch的参数\"><a href=\"#Git-Fetch的参数\" class=\"headerlink\" title=\"Git Fetch的参数\"></a>Git Fetch的参数</h4><p><code>git fetch</code> 的参数和 <code>git push</code> 极其相似。他们的概念是相同的，只是方向相反罢了（因为现在你是下载，而非上传）</p>\n<p>💯==<strong>git fetch &lt;remote&gt; &lt;place&gt;</strong>==</p>\n<p>Git 会到远程仓库的分支上，然后获取所有本地不存在的提交，放到本地的相应分支上。</p>\n<p>💯==<strong>git fetch origin &lt;source&gt;:&lt;destination&gt;</strong>==</p>\n<p>但是命令很不常用就是了</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624301c9cddfe.png\"></p>\n<hr>\n<h4 id=\"没有source的source\"><a href=\"#没有source的source\" class=\"headerlink\" title=\"没有source的source\"></a>没有source的source</h4><p>Git 有两种关于 <code>&lt;source&gt;</code> 的用法是比较诡异的，即你可以在 git push 或 git fetch 时不指定任何 <code>source</code>，方法就是仅保留冒号和 destination 部分，source 部分留空。</p>\n<ul>\n<li><code>git push origin :side</code></li>\n<li><code>git fetch origin :bugFix</code></li>\n</ul>\n<p>我们分别来看一下这两条命令的作用……</p>\n<p>如果 push 空 到远程仓库会如何呢？它会删除远程仓库中的分支！</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624313c20ceea.png\" style=\"zoom:50%;\" />\n\n<p>如果 fetch 空 到本地，会在本地创建一个新分支。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624314368592a.png\" style=\"zoom:50%;\" />\n\n\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6243147a70f05.png\"></p>\n<hr>\n<h4 id=\"Git-Pull的参数\"><a href=\"#Git-Pull的参数\" class=\"headerlink\" title=\"Git Pull的参数\"></a>Git Pull的参数</h4><p> git pull 到头来就是 fetch 后跟 merge 的缩写。你可以理解为用同样的参数执行 git fetch，然后再 merge 你所抓取到的提交记录。</p>\n<p><code>git pull origin foo</code> 相当于：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch origin foo; git merge o&#x2F;foo</span><br></pre></td></tr></table></figure>\n<p>还有…</p>\n<p><code>git pull origin bar~1:bugFix</code> 相当于：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch origin bar~1:bugFix; git merge bugFix</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624316d49f61c.png\"></p>\n<hr>\n<h2 id=\"Git操作实例\"><a href=\"#Git操作实例\" class=\"headerlink\" title=\"Git操作实例\"></a>Git操作实例</h2><blockquote>\n<p>在这一个月多的工作里，我也遇到了需要用到git的一些操作，在此总结如下情景：</p>\n</blockquote>\n<h3 id=\"先暂存当前工作而去完成另一个工作\"><a href=\"#先暂存当前工作而去完成另一个工作\" class=\"headerlink\" title=\"先暂存当前工作而去完成另一个工作\"></a>先暂存当前工作而去完成另一个工作</h3><blockquote>\n<p>遇到过这种情况：在做某个工作到一半还没完成的时候，突然被提醒先去做另外一个工作。这种情况下，现在没做完的工作咋办？</p>\n</blockquote>\n<p>首先，在看了上面的内容之后，不管如果我们一定要先进行 <code>git commit</code> 操作。</p>\n<p>因为只有在commit之后，当前工作才会成为一个结点。</p>\n<p>同时，为了唯一标识当前结点，我们可以采用新建分支或者新建tag的方式标记当前结点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag tag_name HEAD</span><br></pre></td></tr></table></figure>\n<p>在完成该操作后，我们就回到上一个结点，也就是远端所在结点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout HEAD^</span><br><span class=\"line\"></span><br><span class=\"line\">git branch -f master HEAD</span><br><span class=\"line\"></span><br><span class=\"line\">git checkout master</span><br></pre></td></tr></table></figure>\n<p>此后，我们便可以开始新的工作，以正常的方式进行新的操作（commit啊，push啊都可以）。</p>\n<p>当前工作完成之后，我们就可以通过 <code>git checkout tag_name</code> 回到之前没有完成的工作中去了！</p>\n<h3 id=\"更改两次提交的顺序\"><a href=\"#更改两次提交的顺序\" class=\"headerlink\" title=\"更改两次提交的顺序\"></a>更改两次提交的顺序</h3><blockquote>\n<p>这是今天遇到的一个情况：先完成了一个提交，之后去做另一个工作提交了一次。但这时被提示之前的提交有问题，需要修改。</p>\n<p>这个时候，后一次的提交没有问题，可以被点进主分支中。但由于它的父结点是前一次的提交，因此点不进去，怎么办呢？</p>\n</blockquote>\n<p>这个时候，我们就要考虑切换两个分支的顺序了。</p>\n<p>首先最重要的是，我们还是要加一个标签标记当前的位置，否则以后就找不到了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag tag_name HEAD</span><br></pre></td></tr></table></figure>\n<p>然后，我们回到上上一次的位置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout HEAD~2</span><br><span class=\"line\"></span><br><span class=\"line\">git branch -f master HEAD</span><br><span class=\"line\"></span><br><span class=\"line\">git checkout master</span><br></pre></td></tr></table></figure>\n<p>这个时候，我们只要通过 <code>cherry-pick</code> 操作把刚刚的两个操作反过来串联在一起就行了。</p>\n<p>当然，通过前面的学习，我们知道  <code>git rebase -i</code>也是可行的，在这里不再赘述。</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<h1 id=\"Git-基本操作整理\"><a href=\"#Git-基本操作整理\" class=\"headerlink\" title=\"Git 基本操作整理\"></a>Git 基本操作整理</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文档通过整理CS-Notes中的Git命令操作与实战Learn Git Branching来学习掌握Git方法。因为文档主要分为两部分，第一部分参考CS-Notes并查阅资料为Git理论知识，第二部分为实战Learn Git Branching给出个人思考与过程。</p>\n<p>参考资料来源:</p>\n<ol>\n<li><p><a href=\"http://www.cyc2018.xyz/%E5%85%B6%E5%AE%83/%E7%BC%96%E7%A0%81%E5%AE%9E%E8%B7%B5/Git.html#%E9%9B%86%E4%B8%AD%E5%BC%8F%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F\">CS-Notes Git部分</a></p>\n</li>\n<li><p><a href=\"https://learngitbranching.js.org/?demo=&locale=zh_CN\">Learn Git Branching</a></p>\n</li>\n</ol>\n<h2 id=\"Git知识\"><a href=\"#Git知识\" class=\"headerlink\" title=\"Git知识\"></a>Git知识</h2><h2 id=\"Learn-Git-Branching\"><a href=\"#Learn-Git-Branching\" class=\"headerlink\" title=\"Learn Git Branching\"></a>Learn Git Branching</h2><h3 id=\"Level-1-Git基础内容\"><a href=\"#Level-1-Git基础内容\" class=\"headerlink\" title=\"Level 1. Git基础内容\"></a>Level 1. Git基础内容</h3><h4 id=\"Git-Commit\"><a href=\"#Git-Commit\" class=\"headerlink\" title=\"Git Commit\"></a>Git Commit</h4><p>Git 仓库中的提交记录保存的是你的目录下所有文件的快照，就像是把整个目录复制，然后再粘贴一样，但比复制粘贴优雅许多！</p>\n<p>Git 希望提交记录尽可能地轻量，因此在你每次进行提交时，它并不会盲目地复制整个目录。条件允许的情况下，它会将当前版本与仓库中的上一个版本进行对比，并把所有的差异打包到一起作为一个提交记录。Git 还保存了提交的历史记录。这也是为什么大多数提交记录的上面都有父节点的原因。对于项目组的成员来说，维护提交历史对大家都有好处。</p>\n<p>Git Commit 就是在父节点下进行一次内容的提交。使用的命令很简单为：</p>\n<p>💯==<strong>git commit</strong>==</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f9be0486.png\"></p>\n<hr>\n<h4 id=\"Git-Branch\"><a href=\"#Git-Branch\" class=\"headerlink\" title=\"Git Branch\"></a>Git Branch</h4><p>Git 的分支也非常轻量。它们只是简单地指向某个提交纪录 —— 仅此而已。</p>\n<p>所以许多 Git 爱好者传颂：😍<strong>早建分支，多用分支！</strong></p>\n<p>这是因为即使创建再多的分支也不会造成储存或内存上的开销，并且按逻辑分解工作到不同的分支要比维护那些特别臃肿的分支简单多了。</p>\n<p>在将分支和提交记录结合起来后，我们会看到两者如何协作。现在只要记住使用分支其实就相当于在说：“<strong>我想基于这个提交以及它所有的父提交进行新的工作。</strong>”</p>\n<p>创建分支的命令最基础的就是：</p>\n<p>💯==<strong>git branch <branch_name></strong>==</p>\n<p>创建好的分支会指向当前的提交记录。但是通过上述命令创建的分支并不是我们现在所使用的分支，如果我们此刻进行了git commit操作，那么我们的行为仍然是操作于原来的分支。所以我们如果想要使用这个新分支，我们需要使用切换分支的命令：</p>\n<p>💯==<strong>git checkout <branch_name></strong>==</p>\n<p>有一个简洁的方式，如果你想创建一个新的分支同时切换到新创建的分支的话，可以通过 </p>\n<p>💯==<strong>git checkout -b &lt;your-branch-name&gt;</strong>==</p>\n<p><img src=\"https://i0.hdslb.com/bfs/album/a11e89444b0b5c7d221325a9637f26e54ebe12c6.png\"></p>\n<hr>\n<h4 id=\"Git-Merge\"><a href=\"#Git-Merge\" class=\"headerlink\" title=\"Git Merge\"></a>Git Merge</h4><p>在知道如何提交以及如何使用分支的前提下，接下来是如何将两个分支合并到一起。就是说我们新建一个分支，在其上开发某个新功能，开发完成后再合并回主线。</p>\n<p>第一种方法是通过git merge实现的。在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个父节点。翻译成自然语言相当于：“我要把这两个父节点本身及它们所有的祖先都包含进来。”因此，git合并分支的命令是：</p>\n<p>💯==<strong>git merge <branch_name></strong>==</p>\n<p>该命令是将branch_name合并到当前的分支下</p>\n<p>例如：我们有这两个分支main与bugFix，我们可以通过git merge命令来将两者合并：</p>\n<img src=\"https://i0.hdslb.com/bfs/album/1a7e02089e6db4f76cec7be3ca3766caa38c1fd7.png\" style=\"zoom:50%;\" />\n\n<p>合并后，我们发现新的分支是保留了两条路径指向父节点，并没有断了与任何一条分支的联系，因此这个过程支持了Git对历史版本信息的维护。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f858fa9e.png\" style=\"zoom:50%;\" />\n\n<p>接下来，可以将main分支合并到bugFix中</p>\n<p>通过<code>git checkout bugFix; git merge main</code></p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f8526a06.png\" style=\"zoom:50%;\" />\n\n<p>因为 main 继承自 bugFix ，Git 什么都不用做，只是简单地把 bugFix 移动到 main 所指向的那个提交记录。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/album/08d9d8343a7164f9c6b01eccca5471872790f07f.png\"></p>\n<hr>\n<h4 id=\"Git-Rebase\"><a href=\"#Git-Rebase\" class=\"headerlink\" title=\"Git Rebase\"></a>Git Rebase</h4><p>第二种合并分支的方法是 git rebase。Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。</p>\n<p>Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。Rebase的命令如下：</p>\n<p>💯==<strong>git rebase <branch_name></strong>==</p>\n<p>例如：同样我们有两个分支main和bugFix，我们可以通过rebase来将两者合并：</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f857516e.png\" style=\"zoom:50%;\" />\n\n<p>通过rebase命令后，不同于原来的merge建立两条关于父节点的链接，而是通过提取一系列的提交记录然后建立一个基于main的副本，这样生成的线性的提交历史：</p>\n<img src=\"https://i0.hdslb.com/bfs/album/59f7e1df1314389ddbbcb14fda46a0a679d6c999.png\" style=\"zoom:50%;\" />\n\n<p>此时，原先分支的C3并没有被删除，接下来可以切换到main分支，通过rebase向前推进一个版本</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62425f857627e.png\" style=\"zoom:50%;\" />\n\n<p>rebase命令维护一条线性的提交记录使得历史提交很清晰。我理解的话，主要是通过在代合并的分支上补充原有分支的一些历史提交信息，然后类似于“复制”了一个版本到待合并分支下，实现一个合并操作。</p>\n<p><img src=\"https://i0.hdslb.com/bfs/album/8ee6ba5797dbd7b567f3a9f05c43a9d88472e13d.png\"></p>\n<hr>\n<h3 id=\"Level-2-Git高级内容\"><a href=\"#Level-2-Git高级内容\" class=\"headerlink\" title=\"Level 2. Git高级内容\"></a>Level 2. Git高级内容</h3><h4 id=\"分离HEAD\"><a href=\"#分离HEAD\" class=\"headerlink\" title=\"分离HEAD\"></a>分离HEAD</h4><p>HEAD 是一个对当前检出记录的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。</p>\n<p>HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。</p>\n<p>HEAD 通常情况下是指向分支名的（如 bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。</p>\n<p><strong>分离的 HEAD 就是让其指向了某个具体的提交记录而不是分支名。</strong>在命令执行之前的状态如下所示：</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242631f0352b.png\" style=\"zoom:50%;\" />\n\n<p>HEAD -&gt; main -&gt; C1</p>\n<p>HEAD 指向 main， main 指向 C1</p>\n<p>再通过 <strong>git checkout C1</strong> 后变成了：</p>\n<p>HEAD -&gt; C1</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624263c60010b.png\" style=\"zoom:50%;\" />\n\n\n\n<p>所以分离当前HEAD是通过：</p>\n<p>💯==<strong>git checkout &lt;hash_commit&gt;</strong>==</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624264090b652.png\"></p>\n<hr>\n<h4 id=\"相对引用\"><a href=\"#相对引用\" class=\"headerlink\" title=\"相对引用(^)\"></a>相对引用(^)</h4><p>通过指定提交记录哈希值的方式在 Git 中移动不太方便。在实际应用时，并没有像本程序中这么漂亮的可视化提交树供你参考，所以你就不得不用 <code>git log</code> 来查查看提交记录的哈希值。</p>\n<p>并且哈希值在真实的 Git 世界中也会更长（e.g. 基于 SHA-1，共 40 位）。例如前一关的介绍中的提交记录的哈希值可能是 <code>fed2da64c0efc5293610bdd892f82a58e8cbc5d8</code>。比较令人欣慰的是，Git 对哈希的处理很智能。你只需要提供能够唯一标识提交记录的前几个字符即可。因此我可以仅输入<code>fed2</code> 而不是上面的一长串字符。</p>\n<p>通过哈希值提交记录很不方便，所以git引用了相对引用。使用相对引用的话，就可以从一个易于记忆的地方（比如 <code>bugFix</code> 分支或 <code>HEAD</code>）开始计算。</p>\n<p>相对引用非常给力，这里我介绍两个简单的用法：</p>\n<ul>\n<li>使用 <code>^</code> 向上移动 1 个提交记录</li>\n<li>使用 <code>~&lt;num&gt;</code> 向上移动多个提交记录，如 <code>~3</code></li>\n</ul>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624274834cddb.png\" style=\"zoom:50%;\" />\n\n<p>通过使用(^)可以相对很方便找到main的父节点，而不是通过哈希的方式，以此类推，可以通过main^^来实现寻找父节点的父节点<br>💯==<strong>git checkout main^</strong>==</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624274aea1027.png\" style=\"zoom:50%;\" />\n\n\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624276378ff5f.png\"></p>\n<hr>\n<h4 id=\"相对引用2\"><a href=\"#相对引用2\" class=\"headerlink\" title=\"相对引用2(~)\"></a>相对引用2(~)</h4><p>如果你想在提交树中向上移动很多步的话，敲那么多 <code>^</code> 貌似也挺烦人的，Git 当然也考虑到了这一点，于是又引入了操作符 <code>~</code>。该操作符后面可以跟一个数字（可选，不跟数字时与 <code>^</code> 相同，向上移动一次），指定向上移动多少次。</p>\n<p>通过多次移动的相对引用命令，实现简洁的后退操作：</p>\n<p>💯==<strong>git checkout HEAD~&lt;num&gt;</strong>==</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624276db5423e.png\" style=\"zoom:50%;\" />\n\n\n\n<p>使用相对引用比较多的场景就是移动分支。可以直接使用 <code>-f</code> 选项让分支指向另一个提交，达到强制修改分支的目的，例如:</p>\n<p>💯==<strong>git branch -f main HEAD~3</strong>==</p>\n<p>上面的命令会将 main 分支强制指向 HEAD 的第 3 级父提交。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/62427882a6119.png\" style=\"zoom:50%;\" />\n\n<p>可以发现main分支指向了是HEAD向后移动3级父提交记录上</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a3729f60c.png\" style=\"zoom:50%;\" />\n\n<p>合理使用git branch -f 与git checkout 可以实现对当前提交节点与分支的转换。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a5ae757e9.png\"></p>\n<hr>\n<h4 id=\"撤销变更\"><a href=\"#撤销变更\" class=\"headerlink\" title=\"撤销变更\"></a>撤销变更</h4><p>在 Git 里撤销变更的方法很多。和提交一样，撤销变更由底层部分（暂存区的独立文件或者片段）和上层部分（变更到底是通过哪种方式被撤销的）组成。我们这个应用主要关注的是后者。</p>\n<p>主要有两种方法用来撤销变更 —— 一是 <code>git reset</code>，还有就是 <code>git revert</code>。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a6fb59604.png\" style=\"zoom:50%;\" />\n\n<p>通过一下撤销变更的命令：</p>\n<p>💯==<strong>git reset HEAD~1</strong>==</p>\n<p>Git 把 main 分支移回到 C1；现在我们的本地代码库根本就不知道有 C2 这个提交了。但是在reset后， C2 所做的变更还在，但是处于未加入暂存区状态。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a76660edc.png\" style=\"zoom:50%;\" />\n\n<p>git reset 撤销的方式对大家一起使用的远端分支是无效的，为了撤销更改并分享给别人，我们需要使用：</p>\n<p>💯==<strong>git revert HEAD</strong>==</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a82f31d87.png\" style=\"zoom:50%;\" />\n\n<p>在我们要撤销的提交记录后面居然多了一个新提交！这是因为新提交记录 C2’ 引入了<strong>更改</strong> —— 这些更改刚好是用来撤销 C2 这个提交的。也就是说 C2’ 的状态与 C1 是相同的。revert 之后就可以把你的更改推送到远程仓库与别人分享啦。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242a9486b1f8.png\"></p>\n<p>刚才试了一下reset的作用，其实就是本地回退到上一个版本得话，可以在更改一些功能后，通过rebase或者merge指定遗弃分支进行合并或者完全放弃？🤔</p>\n<hr>\n<h3 id=\"Level-3-Git移动提交记录\"><a href=\"#Level-3-Git移动提交记录\" class=\"headerlink\" title=\"Level 3. Git移动提交记录\"></a>Level 3. Git移动提交记录</h3><h4 id=\"Git-Cherry-pick\"><a href=\"#Git-Cherry-pick\" class=\"headerlink\" title=\"Git Cherry-pick\"></a>Git Cherry-pick</h4><p>接下来要讨论的这个话题是“整理提交记录” —— 开发人员有时会说“我想要把这个提交放到这里, 那个提交放到刚才那个提交的后面”, 而接下来就讲的就是它的实现方式，非常清晰、灵活，还很生动。</p>\n<p>如果你想将一些提交复制到当前所在的位置（<code>HEAD</code>）下面的话， Cherry-pick 是最直接的方式了。命令为：</p>\n<p>💯==<strong>git cherry-pick &lt;commit_version&gt;</strong>==</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242aab507c99.png\" style=\"zoom:50%;\" />\n\n<p>这里有一个仓库, 我们想将 side 分支上的工作复制到 main 分支，rebase 可以解决这个问题，但是也可以通过 cherry-pick, 我们执行命令 git cherry-pick C2 C4</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ab6297234.png\" style=\"zoom:50%;\" />\n\n<p>通过cherry-pick可以直接选取我们要的提交记录在当前分支之下，感觉git的整理提交记录的思想在于维护一条提交的线(主干线)</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242abd0e399a.png\"></p>\n<hr>\n<h4 id=\"交互式rebase\"><a href=\"#交互式rebase\" class=\"headerlink\" title=\"交互式rebase\"></a>交互式rebase</h4><p>当你知道你所需要的提交记录（<strong>并且</strong>还知道这些提交记录的哈希值）时, 用 cherry-pick 再好不过了 —— 没有比这更简单的方式了。但是如果你不清楚你想要的提交记录的哈希值呢? 幸好 Git 帮你想到了这一点, 我们可以利用交互式的 rebase —— 如果你想从一系列的提交记录中找到想要的记录, 这就是最好的方法了。</p>\n<p>交互式 rebase 指的是使用带参数 <code>--interactive</code> 的 rebase 命令, 简写为 <code>-i</code></p>\n<p>如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。</p>\n<p>在实际使用时，所谓的 UI 窗口一般会在文本编辑器 —— 如 Vim —— 中打开一个文件。</p>\n<p>当 rebase UI界面打开时, 你能做3件事:</p>\n<ul>\n<li>调整提交记录的顺序（通过鼠标拖放来完成）</li>\n<li>删除你不想要的提交（通过切换 <code>pick</code> 的状态来完成，关闭就意味着你不想要这个提交记录）</li>\n<li>合并提交。</li>\n</ul>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242af2c739cb.png\" style=\"zoom:50%;\" />\n\n<p>输入交互式rebase命令后：</p>\n<p>💯==<strong>git rebase -i HEAD[~&lt;num&gt;|^]</strong>==</p>\n<p>通过rebase -i HEAD~4实现对后续提交内容进行调整顺序，删除omit提交与合并</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242b17d54c69.png\" style=\"zoom:50%;\" />\n\n<p>完全重新整理了commit的顺序，但是感觉需要以合理的机会使用，要不然真的会很艰难。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242b33615af6.png\"></p>\n<hr>\n<h3 id=\"Level-4-杂项\"><a href=\"#Level-4-杂项\" class=\"headerlink\" title=\"Level 4. 杂项\"></a>Level 4. 杂项</h3><h4 id=\"只取一个提交记录\"><a href=\"#只取一个提交记录\" class=\"headerlink\" title=\"只取一个提交记录\"></a>只取一个提交记录</h4><p>来看一个在开发中经常会遇到的情况：我正在解决某个特别棘手的 Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息。</p>\n<p>这些调试和打印语句都在它们各自的提交记录里。最后我终于找到了造成这个 Bug 的根本原因，解决掉以后觉得沾沾自喜！</p>\n<p>最后就差把 <code>bugFix</code> 分支里的工作合并回 <code>main</code> 分支了。你可以选择通过 fast-forward 快速合并到 <code>main</code> 分支上，但这样的话 <code>main</code> 分支就会包含我这些调试语句了。你肯定不想这样，应该还有更好的方式……</p>\n<p>实际我们只要让 Git 复制解决问题的那一个提交记录就可以了。跟之前我们在“整理提交记录”中学到的一样，我们可以使用</p>\n<ul>\n<li><code>git rebase -i</code></li>\n<li><code>git cherry-pick</code></li>\n</ul>\n<p>来达到目的。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242b98be1504.png\"></p>\n<hr>\n<h4 id=\"提交的技巧-1\"><a href=\"#提交的技巧-1\" class=\"headerlink\" title=\"提交的技巧 #1\"></a>提交的技巧 #1</h4><p>接下来这种情况也是很常见的：你之前在 newImage 分支上进行了一次提交，然后又基于它创建了 caption 分支，然后又提交了一次。</p>\n<p>此时你想对某个以前的提交记录进行一些小小的调整。比如设计师想修改一下 <code>newImage</code> 中图片的分辨率，尽管那个提交记录并不是最新的了。</p>\n<p>我们可以通过下面的方法来克服困难：</p>\n<ul>\n<li>先用 <code>git rebase -i</code> 将提交重新排序，然后把我们想要修改的提交记录挪到最前</li>\n<li>然后用 <code>git commit --amend</code> 来进行一些小修改</li>\n<li>接着再用 <code>git rebase -i</code> 来将他们调回原来的顺序</li>\n<li>最后我们把 main 移到修改的最前端（用你自己喜欢的方法），就大功告成啦！</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242dbc3cd20f.png\"></p>\n<hr>\n<h4 id=\"提交的技巧-2\"><a href=\"#提交的技巧-2\" class=\"headerlink\" title=\"提交的技巧 #2\"></a>提交的技巧 #2</h4><p>正如你在上一关所见到的，我们可以使用 <code>rebase -i</code> 对提交记录进行重新排序。只要把我们想要的提交记录挪到最前端，我们就可以很轻松的用 <code>--amend</code> 修改它，然后把它们重新排成我们想要的顺序。</p>\n<p>但这样做就唯一的问题就是要进行两次排序，而这有可能造成由 rebase 而导致的冲突。因此选择使用cherry-pick来实现上述问题。</p>\n<p>cherry-pick 可以将提交树上任何地方的提交记录取过来追加到 HEAD 上</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ddc84217c.png\"></p>\n<hr>\n<h4 id=\"Git-Tag\"><a href=\"#Git-Tag\" class=\"headerlink\" title=\"Git Tag\"></a>Git Tag</h4><p>分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。有没有什么可以永远指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢？</p>\n<p>Git 的 tag 可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。更难得的是，它们并不会随着新的提交而移动。你也不能切换到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。</p>\n<p>tag的命令是：</p>\n<p>💯==<strong>git tag &lt;tag_name&gt; &lt;commit_name&gt;</strong>==</p>\n<p><img src=\"C:\\Users\\14218\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220329183103581.png\" alt=\"image-20220329183103581\"></p>\n<hr>\n<h4 id=\"Git-Describe\"><a href=\"#Git-Describe\" class=\"headerlink\" title=\"Git Describe\"></a>Git Describe</h4><p>由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来<strong>描述</strong>离你最近的锚点（也就是标签），它就是 <code>git describe</code>！</p>\n<p>Git Describe 能帮你在提交历史中移动了多次以后找到方向；当你用 <code>git bisect</code>（一个查找产生 Bug 的提交记录的指令）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时， 可能会用到这个命令。</p>\n<p>git describe的语法是：</p>\n<p>💯==<strong>git describe &lt;ref&gt;</strong>==    </p>\n<p>ref 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（HEAD）.</p>\n<p>返回类型为💯==<strong>&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;</strong>==    </p>\n<p>tag 表示的是离 ref 最近的标签， numCommits 是表示这个 ref 与 tag 相差有多少个提交记录， hash 表示的是你所给定的 ref 所表示的提交记录哈希值的前几位。当 ref 提交记录上有某个标签时，则只输出标签名称。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e388a4335.png\"></p>\n<hr>\n<h3 id=\"Level-5-Git-高级话题-某些应用\"><a href=\"#Level-5-Git-高级话题-某些应用\" class=\"headerlink\" title=\"Level 5. Git 高级话题(某些应用)\"></a>Level 5. Git 高级话题(某些应用)</h3><h4 id=\"多分支rebase\"><a href=\"#多分支rebase\" class=\"headerlink\" title=\"多分支rebase\"></a>多分支rebase</h4><p>通过rebase实现多个分支的合并操作，其实通过rebase branch1 branch2 可以很快的实现，并且记住的是branch1是branch2的父分支的话就很容易实现了，每次rebase应该省略的是branch2的参数(如果不给的话)</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e564c9d33.png\"></p>\n<hr>\n<h4 id=\"两个父节点\"><a href=\"#两个父节点\" class=\"headerlink\" title=\"两个父节点\"></a>两个父节点</h4><p>操作符 <code>^</code> 与 <code>~</code> 符一样，后面也可以跟一个数字。</p>\n<p>但是该操作符后面的数字与 <code>~</code> 后面的不同，并不是用来指定向上返回几代，而是指定合并提交记录的某个父提交。还记得前面提到过的一个合并提交有两个父提交吧，所以遇到这样的节点时该选择哪条路径就不是很清晰了。</p>\n<p>Git 默认选择合并提交的“第一个”父提交，在操作符 <code>^</code> 后跟一个数字可以改变这一默认行为。</p>\n<p>例如，执行 git checkout main^2 的过程就是回到第二个父提交节点的意思。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e67ed88f1.png\" style=\"zoom:50%;\" />\n\n<p>并且git支持两个操作符的链式操作 git checkout main~^2~2</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e6cb0c441.png\" style=\"zoom:50%;\" />\n\n\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e85b0e9c3.png\"></p>\n<hr>\n<h4 id=\"纠缠不清的分支\"><a href=\"#纠缠不清的分支\" class=\"headerlink\" title=\"纠缠不清的分支\"></a>纠缠不清的分支</h4><p>实现这种不同分支梳理最好的方式是通过cherry-pick，如果方便知道commit的提交哈希值的话。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242e9658f176.png\"></p>\n<hr>\n<h3 id=\"Level-6-Push-amp-Pull-——-Git-远程仓库\"><a href=\"#Level-6-Push-amp-Pull-——-Git-远程仓库\" class=\"headerlink\" title=\"Level 6. Push &amp; Pull —— Git 远程仓库\"></a>Level 6. Push &amp; Pull —— Git 远程仓库</h3><h4 id=\"Git-Clone\"><a href=\"#Git-Clone\" class=\"headerlink\" title=\"Git Clone\"></a>Git Clone</h4><p>远程仓库并不复杂, 在如今的云计算盛行的世界很容易把远程仓库想象成一个富有魔力的东西, 但实际上它们只是你的仓库在另个一台计算机上的拷贝。你可以通过因特网与这台计算机通信 —— 也就是增加或是获取提交记录</p>\n<p>话虽如此, 远程仓库却有一系列强大的特性</p>\n<ul>\n<li>首先也是最重要的的点, 远程仓库是一个强大的备份。本地仓库也有恢复文件到指定版本的能力, 但所有的信息都是保存在本地的。有了远程仓库以后，即使丢失了本地所有数据, 你仍可以通过远程仓库拿回你丢失的数据。</li>\n<li>还有就是, 远程让代码社交化了! 既然你的项目被托管到别的地方了, 你的朋友可以更容易地为你的项目做贡献(或者拉取最新的变更)</li>\n</ul>\n<p>💯==<strong>git clone</strong>==</p>\n<p>通过git clone 可以从远端拉取仓库到本地</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ea37dc283.png\"></p>\n<hr>\n<h4 id=\"远端分支\"><a href=\"#远端分支\" class=\"headerlink\" title=\"远端分支\"></a>远端分支</h4><p>你可能注意到的第一个事就是在我们的本地仓库多了一个名为 <code>o/main</code> 的分支, 这种类型的分支就叫<strong>远程</strong>分支。由于远程分支的特性导致其拥有一些特殊属性。</p>\n<p>远程分支反映了远程仓库(在你上次和它通信时)的<strong>状态</strong>。这会有助于你理解本地的工作与公共工作的差别 —— 这是你与别人分享工作成果前至关重要的一步.</p>\n<p>远程分支有一个特别的属性，在你检出时自动进入分离 HEAD 状态。Git 这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作, （更新了远程分支之后）再用远程分享你的工作成果。</p>\n<p>o/main的意思就是&lt;remote name&gt;/&lt;branch name&gt;</p>\n<p>如果当前选择的是远端分支的话，进行commit操作是不会直接进行远端分支的更新，而是使本地处于分离HEAD的状态。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242eb32490c4.png\"></p>\n<hr>\n<h4 id=\"Git-Fetch\"><a href=\"#Git-Fetch\" class=\"headerlink\" title=\"Git Fetch\"></a>Git Fetch</h4><p>Git 远程仓库相当的操作实际可以归纳为两点：向远程仓库传输数据以及从远程仓库获取数据。既然我们能与远程仓库同步，那么就可以分享任何能被 Git 管理的更新（因此可以分享代码、文件、想法、情书等等）。</p>\n<p>如何从远程仓库获取数据 —— 命令如其名，它就是 git fetch 。</p>\n<p>💯==<strong>git fetch</strong>==</p>\n<p><strong>Git Fetch Do:</strong></p>\n<p>git fetch 完成了仅有的但是很重要的两步:</p>\n<ul>\n<li>从远程仓库下载本地仓库中缺失的提交记录</li>\n<li>更新远程分支指针(如 <code>o/main</code>)</li>\n</ul>\n<p>git fetch 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。</p>\n<p>如果你还记得上一节课程中我们说过的，远程分支反映了远程仓库在你<strong>最后一次与它通信时</strong>的状态，git fetch 就是你与远程仓库通信的方式了！</p>\n<p><strong>Git Fetch Not Do:</strong></p>\n<p>git fetch 并不会改变你本地仓库的状态。它不会更新你的 main 分支，也不会修改你磁盘上的文件。</p>\n<p>理解这一点很重要，因为许多开发人员误以为执行了 git fetch 以后，他们本地仓库就与远程仓库同步了。它可能已经将进行这一操作所需的所有数据都下载了下来，但是<strong>并没有</strong>修改你本地的文件。git fetch 就是单纯的下载资源的操作。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ecb8f2bac.png\"></p>\n<hr>\n<h4 id=\"Git-Pull\"><a href=\"#Git-Pull\" class=\"headerlink\" title=\"Git Pull\"></a>Git Pull</h4><p>其实有很多方法的 —— 当远程分支中有新的提交时，你可以像合并本地分支那样来合并远程分支。也就是说就是你可以执行以下命令:</p>\n<ul>\n<li><code>git cherry-pick o/main</code></li>\n<li><code>git rebase o/main</code></li>\n<li><code>git merge o/main</code></li>\n<li>等等</li>\n</ul>\n<p>实际上，由于先抓取更新再合并到本地分支这个流程很常用，因此 Git 提供了一个专门的命令来完成这两个操作。</p>\n<p>💯==<strong>git pull</strong>==</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ed89ae9c4.png\" style=\"zoom:50%;\" />\n\n<p>git pull 就是 git fetch 和 git merge的缩写</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ee13e8cad.png\"></p>\n<hr>\n<h4 id=\"模拟团队合作\"><a href=\"#模拟团队合作\" class=\"headerlink\" title=\"模拟团队合作\"></a>模拟团队合作</h4><p>在远端操作进行一定更新后，可以通过pull进行及时的拉去更新本地分支</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ee9fb29ea.png\"></p>\n<hr>\n<h4 id=\"Git-Push\"><a href=\"#Git-Push\" class=\"headerlink\" title=\"Git Push\"></a>Git Push</h4><p>传自己分享内容与下载他人的分享刚好相反，git push 负责将<strong>你的</strong>变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录。一旦 git push 完成, 你的朋友们就可以从这个远程仓库下载你分享的成果了！</p>\n<p>💯==<strong>git push</strong>==</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ef5af3f83.png\"></p>\n<hr>\n<h4 id=\"偏离的提交历史\"><a href=\"#偏离的提交历史\" class=\"headerlink\" title=\"偏离的提交历史\"></a>偏离的提交历史</h4><p>假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕，可以发布了。但是 —— 天啊！你的同事这周写了一堆代码，还改了许多你的功能中使用的 API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库了，因此你的工作就变成了基于项目<strong>旧版</strong>的代码，与远程仓库最新的代码不匹配了。</p>\n<p>这种情况下, <code>git push</code> 就不知道该如何操作了。如果你执行 <code>git push</code>，Git 应该让远程仓库回到星期一那天的状态吗？还是直接在新代码的基础上添加你的代码，亦或由于你的提交已经过时而直接忽略你的提交？</p>\n<p>因为这情况（历史偏离）有许多的不确定性，Git 是不会允许你 <code>push</code> 变更的。实际上它会强制你先合并远程最新的代码，然后才能分享你的工作。</p>\n<p>因此主要的解决办法就是先把远端的分支pull下来，然后再merge或者rebase自己的工作到远端分支，然后再合并分支到远端仓库</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242f10bed8b1.png\"></p>\n<hr>\n<h4 id=\"Locked-Main\"><a href=\"#Locked-Main\" class=\"headerlink\" title=\"Locked Main\"></a>Locked Main</h4><p>如果你是在一个大的合作团队中工作, 很可能是main被锁定了, 需要一些Pull Request流程来合并修改。如果你直接提交(commit)到本地main, 然后试图推送(push)修改, 你将会收到这样类似的信息:</p>\n<p><em>! [远程服务器拒绝] main -&gt; main (TF402455: 不允许推送(push)这个分支; 你必须使用pull request来更新这个分支.)</em></p>\n<p>就是在团队合作的时候，防止过多人频繁push自己的代码到远端仓库，因此需要走pr的审查流程。</p>\n<p>解决办法为：新建一个分支feature, 推送到远程服务器. 然后reset你的main分支和远程服务器保持一致, 否则下次你pull并且他人的提交和你冲突的时候就会有问题.</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242f48497d61.png\"></p>\n<hr>\n<h3 id=\"Level-7-关于-origin-和它的周边-——-Git-远程仓库高级操作\"><a href=\"#Level-7-关于-origin-和它的周边-——-Git-远程仓库高级操作\" class=\"headerlink\" title=\"Level 7. 关于 origin 和它的周边 —— Git 远程仓库高级操作\"></a>Level 7. 关于 origin 和它的周边 —— Git 远程仓库高级操作</h3><h4 id=\"推送主分支\"><a href=\"#推送主分支\" class=\"headerlink\" title=\"推送主分支\"></a>推送主分支</h4><p>在大型项目中开发人员通常会在（从 <code>main</code> 上分出来的）特性分支上工作，工作完成后只做一次集成。这跟前面课程的描述很相像（把 side 分支推送到远程仓库），不过本节我们会深入一些.</p>\n<p>但是有些开发人员只在 main 上做 push、pull —— 这样的话 main 总是最新的，始终与远程分支 (o/main) 保持一致。</p>\n<p>对于接下来这个工作流，我们集成了两个步骤：</p>\n<ul>\n<li>将特性分支集成到 <code>main</code> 上</li>\n<li>推送并更新远程分支</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242fc03cb835.png\"></p>\n<p>过程就是先 git pull –rebase 然后再rebase 合并分支</p>\n<hr>\n<h4 id=\"合并远端仓库\"><a href=\"#合并远端仓库\" class=\"headerlink\" title=\"合并远端仓库\"></a>合并远端仓库</h4><p>在开发社区里，有许多关于 merge 与 rebase 的讨论。以下是关于 rebase 的优缺点：</p>\n<p>优点:</p>\n<ul>\n<li>Rebase 使你的提交树变得很干净, 所有的提交都在一条线上</li>\n</ul>\n<p>缺点:</p>\n<ul>\n<li>Rebase 修改了提交树的历史</li>\n</ul>\n<p>比如, 提交 C1 可以被 rebase 到 C3 之后。这看起来 C1 中的工作是在 C3 之后进行的，但实际上是在 C3 之前。</p>\n<p>一些开发人员喜欢保留提交历史，因此更偏爱 merge。而其他人（比如我自己）可能更喜欢干净的提交树，于是偏爱 rebase。仁者见仁，智者见智。 </p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242fd476265d.png\"></p>\n<p>相对来说，更有细节，更能体现提交历史</p>\n<h4 id=\"远程追踪\"><a href=\"#远程追踪\" class=\"headerlink\" title=\"远程追踪\"></a>远程追踪</h4><p>Git 好像知道 <code>main</code> 与 <code>o/main</code> 是相关的。当然这些分支的名字是相似的，可能会让你觉得是依此将远程分支 main 和本地的 main 分支进行了关联。这种关联在以下两种情况下可以清楚地得到展示：</p>\n<ul>\n<li>pull 操作时, 提交记录会被先下载到 o/main 上，之后再合并到本地的 main 分支。隐含的合并目标由这个关联确定的。</li>\n<li>push 操作时, 我们把工作从 <code>main</code> 推到远程仓库中的 <code>main</code> 分支(同时会更新远程分支 <code>o/main</code>) 。这个推送的目的地也是由这种关联确定的！</li>\n</ul>\n<p>直接了当地讲，<code>main</code> 和 <code>o/main</code> 的关联关系就是由分支的“remote tracking”属性决定的。<code>main</code> 被设定为跟踪 <code>o/main</code> —— 这意味着为 <code>main</code> 分支指定了推送的目的地以及拉取后合并的目标。</p>\n<p>你可能想知道 <code>main</code> 分支上这个属性是怎么被设定的，你并没有用任何命令指定过这个属性呀！好吧, 当你克隆仓库的时候, Git 就自动帮你把这个属性设置好了。</p>\n<p>当你克隆时, Git 会为远程仓库中的每个分支在本地仓库中创建一个远程分支（比如 <code>o/main</code>）。然后再创建一个跟踪远程仓库中活动分支的本地分支，默认情况下这个本地分支会被命名为 <code>main</code>。</p>\n<p>克隆完成后，你会得到一个本地分支（如果没有这个本地分支的话，你的目录就是“空白”的），但是可以查看远程仓库中所有的分支（如果你好奇心很强的话）。这样做对于本地仓库和远程仓库来说，都是最佳选择。</p>\n<p>💯==<strong>git checkout -b totallyNotMain o/main</strong>==</p>\n<p>可以创建一个totallyNotMain来追踪远程分支o/main</p>\n<p>💯==<strong>git branch -u o/main foo</strong>==</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6242ff7627ed3.png\"></p>\n<hr>\n<h4 id=\"Git-Push的参数\"><a href=\"#Git-Push的参数\" class=\"headerlink\" title=\"Git Push的参数\"></a>Git Push的参数</h4><p>首先来看 <code>git push</code>。在远程跟踪课程中，你已经学到了 Git 是通过当前检出分支的属性来确定远程仓库以及要 push 的目的地的。这是未指定参数时的行为，我们可以为 push 指定参数，语法是：</p>\n<p>💯==<strong>git push &lt;remote&gt; &lt;place&gt;</strong>==</p>\n<p>把这个命令翻译过来就是：</p>\n<p><em>切到本地仓库中的“main”分支，获取所有的提交，再到远程仓库“origin”中找到“main”分支，将远程仓库中没有的提交记录都添加上去，搞定之后告诉我。</em></p>\n<p>我们通过“place”参数来告诉 Git 提交记录来自于 main, 要推送到远程仓库中的 main。它实际就是要同步的两个仓库的位置。</p>\n<p>需要注意的是，因为我们通过指定参数告诉了 Git 所有它需要的信息, 所以它就忽略了我们所检出的分支的属性！</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624300d69d378.png\"></p>\n<hr>\n<h4 id=\"Git-Push的参数2\"><a href=\"#Git-Push的参数2\" class=\"headerlink\" title=\"Git Push的参数2\"></a>Git Push的参数2</h4><p>，当为 git push 指定 place 参数为 <code>main</code> 时，我们同时指定了提交记录的来源和去向。</p>\n<p>你可能想问 —— 如果来源和去向分支的名称不同呢？比如你想把本地的 <code>foo</code> 分支推送到远程仓库中的 <code>bar</code> 分支。</p>\n<p>要同时为源和目的地指定 <code>&lt;place&gt;</code> 的话，只需要用冒号 <code>:</code> 将二者连起来就可以了：</p>\n<p>💯==<strong>git push origin &lt;source&gt;:&lt;destination&gt;</strong>==</p>\n<p>这个参数实际的值是个 refspec，“refspec” 是一个自造的词，意思是 Git 能识别的位置（比如分支 <code>foo</code> 或者 <code>HEAD~1</code>）</p>\n<p>一旦你指定了独立的来源和目的地，就可以组织出言简意赅的远程操作命令了.</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624301c9cddfe.png\"></p>\n<hr>\n<h4 id=\"Git-Fetch的参数\"><a href=\"#Git-Fetch的参数\" class=\"headerlink\" title=\"Git Fetch的参数\"></a>Git Fetch的参数</h4><p><code>git fetch</code> 的参数和 <code>git push</code> 极其相似。他们的概念是相同的，只是方向相反罢了（因为现在你是下载，而非上传）</p>\n<p>💯==<strong>git fetch &lt;remote&gt; &lt;place&gt;</strong>==</p>\n<p>Git 会到远程仓库的分支上，然后获取所有本地不存在的提交，放到本地的相应分支上。</p>\n<p>💯==<strong>git fetch origin &lt;source&gt;:&lt;destination&gt;</strong>==</p>\n<p>但是命令很不常用就是了</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624301c9cddfe.png\"></p>\n<hr>\n<h4 id=\"没有source的source\"><a href=\"#没有source的source\" class=\"headerlink\" title=\"没有source的source\"></a>没有source的source</h4><p>Git 有两种关于 <code>&lt;source&gt;</code> 的用法是比较诡异的，即你可以在 git push 或 git fetch 时不指定任何 <code>source</code>，方法就是仅保留冒号和 destination 部分，source 部分留空。</p>\n<ul>\n<li><code>git push origin :side</code></li>\n<li><code>git fetch origin :bugFix</code></li>\n</ul>\n<p>我们分别来看一下这两条命令的作用……</p>\n<p>如果 push 空 到远程仓库会如何呢？它会删除远程仓库中的分支！</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624313c20ceea.png\" style=\"zoom:50%;\" />\n\n<p>如果 fetch 空 到本地，会在本地创建一个新分支。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624314368592a.png\" style=\"zoom:50%;\" />\n\n\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/6243147a70f05.png\"></p>\n<hr>\n<h4 id=\"Git-Pull的参数\"><a href=\"#Git-Pull的参数\" class=\"headerlink\" title=\"Git Pull的参数\"></a>Git Pull的参数</h4><p> git pull 到头来就是 fetch 后跟 merge 的缩写。你可以理解为用同样的参数执行 git fetch，然后再 merge 你所抓取到的提交记录。</p>\n<p><code>git pull origin foo</code> 相当于：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch origin foo; git merge o&#x2F;foo</span><br></pre></td></tr></table></figure>\n<p>还有…</p>\n<p><code>git pull origin bar~1:bugFix</code> 相当于：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch origin bar~1:bugFix; git merge bugFix</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.jsdelivr.net/gh/hututu-tech/IMG-gongfeng@main/2022/03/29/624316d49f61c.png\"></p>\n<hr>\n<h2 id=\"Git操作实例\"><a href=\"#Git操作实例\" class=\"headerlink\" title=\"Git操作实例\"></a>Git操作实例</h2><blockquote>\n<p>在这一个月多的工作里，我也遇到了需要用到git的一些操作，在此总结如下情景：</p>\n</blockquote>\n<h3 id=\"先暂存当前工作而去完成另一个工作\"><a href=\"#先暂存当前工作而去完成另一个工作\" class=\"headerlink\" title=\"先暂存当前工作而去完成另一个工作\"></a>先暂存当前工作而去完成另一个工作</h3><blockquote>\n<p>遇到过这种情况：在做某个工作到一半还没完成的时候，突然被提醒先去做另外一个工作。这种情况下，现在没做完的工作咋办？</p>\n</blockquote>\n<p>首先，在看了上面的内容之后，不管如果我们一定要先进行 <code>git commit</code> 操作。</p>\n<p>因为只有在commit之后，当前工作才会成为一个结点。</p>\n<p>同时，为了唯一标识当前结点，我们可以采用新建分支或者新建tag的方式标记当前结点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag tag_name HEAD</span><br></pre></td></tr></table></figure>\n<p>在完成该操作后，我们就回到上一个结点，也就是远端所在结点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout HEAD^</span><br><span class=\"line\"></span><br><span class=\"line\">git branch -f master HEAD</span><br><span class=\"line\"></span><br><span class=\"line\">git checkout master</span><br></pre></td></tr></table></figure>\n<p>此后，我们便可以开始新的工作，以正常的方式进行新的操作（commit啊，push啊都可以）。</p>\n<p>当前工作完成之后，我们就可以通过 <code>git checkout tag_name</code> 回到之前没有完成的工作中去了！</p>\n<h3 id=\"更改两次提交的顺序\"><a href=\"#更改两次提交的顺序\" class=\"headerlink\" title=\"更改两次提交的顺序\"></a>更改两次提交的顺序</h3><blockquote>\n<p>这是今天遇到的一个情况：先完成了一个提交，之后去做另一个工作提交了一次。但这时被提示之前的提交有问题，需要修改。</p>\n<p>这个时候，后一次的提交没有问题，可以被点进主分支中。但由于它的父结点是前一次的提交，因此点不进去，怎么办呢？</p>\n</blockquote>\n<p>这个时候，我们就要考虑切换两个分支的顺序了。</p>\n<p>首先最重要的是，我们还是要加一个标签标记当前的位置，否则以后就找不到了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag tag_name HEAD</span><br></pre></td></tr></table></figure>\n<p>然后，我们回到上上一次的位置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout HEAD~2</span><br><span class=\"line\"></span><br><span class=\"line\">git branch -f master HEAD</span><br><span class=\"line\"></span><br><span class=\"line\">git checkout master</span><br></pre></td></tr></table></figure>\n<p>这个时候，我们只要通过 <code>cherry-pick</code> 操作把刚刚的两个操作反过来串联在一起就行了。</p>\n<p>当然，通过前面的学习，我们知道  <code>git rebase -i</code>也是可行的，在这里不再赘述。</p>\n"},{"title":"秋招知识储备","date":"2025-10-31T15:50:00.000Z","cover":"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20251031102636698-20251031-102637.png","desc":"暑期实习和秋招的知识储备，除了看JavaGuide等外，可以随时回来查缺补漏","_content":"\n# 写在前面\n> 暑期实习和秋招的知识储备，除了看JavaGuide等外，可以随时回来查缺补漏\n> 个人觉得**简历**最为重要，因为在面试中会被问到的问题基本都是围绕着自己简历展开的\n> 关注自己的简历都不用太去看面经了（看些通用的就行），应该关注自己的简历会被如何拷打\n\n> 面试的时候表现的积极点、聪明点，很多时候面试问的问题未必回答的出来，但要表现出有一种愿意主动思考的态度。很多时候一个优秀的面试官是会主动引导的，这里举个自己某次面试时遇到的例子。\n> 面试官：端口是哪一层协议的？\n> 我：我确实不太清楚，让我思考一下...我猜测可能是网络层或者传输层？\n> 面试官：TCP和UDP连接可以用同一个端口吗？\n> 这里其实就是暗示了，我知道TCP和UDP可以用同一个端口，这就说明了它们的端口不是一个概念，且已知tcp和udp是传输层的协议，所以端口也应该是传输层的概念。\n> 因此在面试的时候遇到不会的问题不必太担忧，大胆说出自己的思考，结合学过的知识去分析一下，其实也是很不错的能力。\n\n> 针对HR面和技术面准备不同的自我介绍。比如我在技术面的时候一般就会说：做了blabla什么项目，最后一带而过自己还参加过暑期支教活动和研究生班长；而HR面则重点介绍暑期支教活动和研究生班长经历，一带而过项目等等。\n\n\n\n# 个人面经\n\n暑期实习面经：https://wangwangwang.website/tags/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/\n\n秋招面经：https://wangwangwang.website/tags/%E7%A7%8B%E6%8B%9B/\n\n\n# 八股知识储备\n\n\n## 分布式锁\n\n分布式锁应当满足：\n\n- 互斥\n- 高可用：出问题，能够释放（超时机制）\n- 可重入（获取了锁之后，还可以再次获取）\n\n常见实现方案：Redis和ZooKeeper\n\n## 其他工具\n\n### 限流和熔断\n\n限流（Rate Limiting）是一种常用的技术手段，用于控制系统对资源的访问速率，确保系统的稳定性和可靠性\n\n熔断（Circuit Breaker）模式是一种用于处理分布式系统中因服务调用失败而可能导致系统雪崩效应的保护机制。它借用了电路中的“熔断器”概念，当电流过大时，熔断器会自动切断电路，以保护整个电路系统不被烧毁。在分布式系统中，熔断器用于监控服务调用的健康状况，并在检测到异常（如服务调用失败率过高、响应时间过长等）时，自动切断对该服务的调用，从而防止故障在系统中蔓延，保障系统的整体稳定性和可用性\n\n- 防止服务雪崩\n- 提升系统弹性\n\n### 限流算法\n\n漏桶算法：无法应对激增流量；请求被丢弃\n\n令牌桶算法：可以限制平均速率，以及处理激增的流量；可以动态调整生成令牌速率\n\n动态调整生成令牌速率的方法：\n\n`RedisRateLimiter`的令牌生成速率（`replenishRate`）和突发容量（`burstCapacity`）\n\n可以考虑使用nanos进行动态配置，同时实现动态路由加载\n\n**限流可以进化到降级**\n\n![image-20250312195240597](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250312195240597-20250312-195242.png)\n\n令牌桶算法添加令牌的方式是多样的：\n\n#### 传统线程驱动\n\n通过后台线程定期（如每秒）向令牌桶中添加固定数量的令牌，直到桶满为止。\n\n**优点**：\n\n- 实现简单，逻辑清晰。\n- 令牌生成速率恒定，适合需要严格控制平均速率的场景。\n\n**缺点**：\n\n- 需要维护额外线程，增加系统资源开销。\n- 实时性差，突发流量可能导致令牌补充不及时（如网页44提到的瞬时流量可能超过限速阈值\n\n#### 惰性计算\n\n在每次请求到来时，根据当前时间与上次请求的时间差动态计算应补充的令牌数，并更新桶内令牌。\n\n```java\n// 网页58中的令牌桶核心逻辑\nprivate void refillTokens() {\n    long now = System.nanoTime();\n    long duration = now - lastRefillTime;\n    long newTokens = duration * refillRate / 1_000_000_000; // 计算时间差对应的令牌数\n    tokens.updateAndGet(current -> Math.min(capacity, current + newTokens));\n    lastRefillTime = now;\n}\n```\n\n**优点**：\n\n- 无需独立线程，减少资源消耗。\n- 时间驱动更精确，适合高并发场景（如淘宝交易系统的动态限流）\n\n**缺点**：\n\n- 计算逻辑需保证线程安全（如使用原子操作或同步锁）。\n- 频繁的时间计算可能带来轻微性能损耗。\n\n#### RateLimiter的实现\n\n**核心原理**： 在每次请求到来时，根据**当前时间与上次令牌补充的时间差**，动态计算应补充的令牌数量。这种方式无需独立线程维护令牌桶，通过实时计算实现令牌生成。 **实现细节**：\n\n1. **时间差计算**：记录上次补充令牌的时间戳（如 `nextFreeTicketMicros`），通过当前时间差除以令牌生成间隔（`stableIntervalMicros`），得到应补充的令牌数。\n2. **令牌补充上限**：确保补充后令牌不超过桶的最大容量（`maxPermits`）。\n3. **原子性操作**：使用同步锁或原子变量保证线程安全。 **代码示例**（参考Guava的 `SmoothRateLimiter` 类）：\n\n```java\nprivate void resync(long nowMicros) {  \n    if (nowMicros > nextFreeTicketMicros) {  \n        double timeDiff = nowMicros - nextFreeTicketMicros;  \n        double newPermits = timeDiff / stableIntervalMicros;  \n        storedPermits = Math.min(maxPermits, storedPermits + newPermits);  \n        nextFreeTicketMicros = nowMicros;  \n    }  \n}  \n```\n\n**优点**：\n\n- 无需额外线程，资源消耗低。\n- 实时性强，精确控制突发流量。\n\n**适用场景**：高并发、分布式系统（如Guava RateLimiter的默认实现）\n\n| **方法** | **资源消耗** | **实时性** | **适用场景**              |\n| -------------- | ------------------ | ---------------- | ------------------------------- |\n| 惰性计算法     | 低                 | 高               | 高并发、分布式系统（如API网关） |\n| 定时补充法     | 中                 | 中               | 单机简单限流（如传统后台服务）  |\n\n### maven\n\n解决冲突？todo\n\n### docker和虚拟机的区别\n\n<img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/4ef8691d67eb1eb53217099d0a691eb5-20250302-153527.png\" alt=\"img\" style=\"zoom: 67%;\" />\n\n容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高。\n\n### Oauth 2.0\n\n一种新的授权机制，为第三方应用颁发一个有时效性的令牌Token，使得第三方应用能够通过该令牌获得相关的资源。\n\n令牌（token）与密码（password）的作用是一样的，都可以进入系统，但是有三点差异。\n\n（1）令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。\n\n（2）令牌可以被数据所有者撤销，会立即失效。以上例而言，屋主可以随时取消快递员的令牌。密码一般不允许被他人撤销。\n\n（3）令牌有权限范围（scope），比如只能进小区的二号门。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。\n\n授权层分离出两种角色：客户端和资源所有者。本质oauth的核心就是***向第三方应用颁发令牌***\n\n需要阅读：https://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html\n\n### nginx\n\nnginx正向代理和反向代理\n\nhttps://zhuanlan.zhihu.com/p/163948996\n\n- 正向代理是**客户端代理**，代理客户端，服务端不知道实际发起请求的客户端\n- 反向代理是**服务端代理**，代理服务端，客户端不知道实际提供服务的服务端.\n\n### cookie和localStorage\n\n![image-20250321152306879](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250321152306879-20250321-152307.png)\n\n**单点登录（SSO）**：用户登录百度主站（如 `www.baidu.com`）时，服务器生成一个认证Cookie，并设置其 `domain`属性为 `.baidu.com`。这使得所有子域名（如 `pan.baidu.com`）均可读取该Cookie，实现自动登录\n\n### 时间轮算法\n\n- 环形时间轮：时间轮由多个**槽（Slot）** 组成环形数组，每个槽对应一个时间间隔（如1秒）。例如，一个60槽的时间轮，每槽间隔1秒，可覆盖60秒内的任务\n- **指针（tick）**：指针周期性移动（如每秒移动一槽），触发当前槽内所有任务的执行\n- **任务链表**：每个槽挂载一个任务链表，存储需在该时间点触发的任务\n\n![image-20250321155727208](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250321155727208-20250321-155727.png)\n\n![img](https://static001.geekbang.org/infoq/71/71313f214caded7d34001de907131cfe.png)\n\n以两层时间轮为例，第一层时间轮周期为1秒，第二层时间轮周期为10秒。\n\n还是以上述3个任务为例，可以看到任务A和B分布在第一层时间轮上，而任务C分布在第二层时间轮的槽1处。当第一层时间轮转动时，任务A和任务B会被先后执行。1秒钟之后，第一层时间轮完成了一个周期转动。从新开始第0跳，这时第二层时间轮从槽0跳到了槽1处，将槽1处的任务，也就是任务C取出放入到第一层时间轮的槽位9处，当第一层时间轮转动到槽位9处，任务C就会被执行。这种将第二层的任务取出放入第一层中称为降级，它是为了保证任务被处理的时间精度。Kafka内部就是采用的这种多层时间轮机制。\n\n![img](https://static001.geekbang.org/infoq/da/daf543a1284837a0de12c29aee43c55b.png)\n\n应用场景：\n\n- redisson通过时间轮算法实现锁的自动续期\n\n### 权限模型\n\n在 RBAC（基于角色的访问控制）模型中，**资源（Resource）** 是系统中被标识、可被访问或操作的一切事物。其涵盖范围包括但不限于：\n\n**功能型资源**\n\n- **模块**：如商品管理、订单管理、财务管理等业务板块。\n- **页面**：如商品列表页、订单详情页等具体界面。\n- **按钮**：如“新增商品”“删除订单”等交互操作。\n- **字段**：如商品详情中的“价格”字段是否可编辑\n\n**数据型资源**\n\n- **实体数据**：如数据库中的某条订单记录、客户信息表。\n- **文件/路径**：如服务器上的文件目录或特定文档。\n- **API 接口**：如 `/api/orders` 路径对应的 RESTful 接口\n\nRBAC 模型中的权限管理需从两个维度进行切分：**功能权限**（操作权限）和**数据权限**（数据范围权限）。两者相辅相成，共同实现精细化控制\n\n1. **功能权限（操作权限）**\n\n**定义**：控制用户能否使用系统中的特定功能或执行操作，例如页面访问、按钮点击、API 调用等。\n\n2. **数据权限（范围权限）**\n\n**定义**：控制用户能访问哪些具体数据，例如某部门的数据、某区域的订单等。 **典型维度**：\n\n- **组织架构**：如上海分公司的员工只能访问分公司数据\n\n**总结**：\n\n- 功能权限解决“**能否操作**”的问题（如能否删除订单）。\n- 数据权限解决“**能操作哪些数据**”的问题（如只能删除自己创建的订单\n\n\n\n### 负载均衡算法\n\n**静态**：轮询、加权轮询、随机、哈希、**一致性哈希**。\n\n**动态**：最少连接、最少响应时间、最少负载、带权最少连接\n\n## MySQL\n\n单表数据量控制在500w以内\n\n### 回表\n\nMysql回表\n\n回表怎么解决\n\n回表返回的是一行还是一张表还是索引\n\n### 缓冲区\n\ninnodb中无论是查询还是写绝大部分都是在buffer pool中进行操作的，它相当于innodb的缓存区，可以通过show engine innodb status来查看buffer pool的使用情况；可以通过innodb_buffer_pool_size来设置buffer pool的大小，线上不要吝啬给几个G内存都是正常的，但无论给多大内存都会有不够的时候，innodb采用了变种的LRU算法对数据页进行淘汰\n\n参考文献：https://cloud.tencent.com/developer/article/1828772\n\n### 覆盖索引\n\n覆盖索引的好处：\n\n1. 避免InnoDB的回表\n2. 将随机IO变为顺序IO：覆盖索引的 B+ 树叶子节点中，索引键值按升序排列（例如联合索引 `(a, b)` 会先按 `a` 排序，再按 `b` 排序）。当执行范围查询（如 `WHERE a > 10 AND a < 20`）时，所需数据在索引中是连续存储的，磁盘可以一次性顺序读取多个相邻数据页，避免跳跃式寻址\n\n### InnoDB相比于MyISAM的优势\n\n事务支持和ACID特性\n\n行级锁\n\n索引结构的优化（数据和索引文件在一起）\n\n多版本并发控制（MVCC）\n\nredo log，支持崩溃后的安全恢复\n\n### 表级锁和行级锁\n\n表级锁：针对非索引字段加的锁\n\n行级锁：**针对索引字段加的锁**\n\n### 最左匹配原则\n\n使用联合索引的过程中，MySQL根据索引中的字段从左到右依次匹配查询条件\n\n如果匹配，就会使用索引\n\n最左匹配原则会一直向右匹配，直到遇到范围查询（如 >、<）为止。对于 >=、<=、BETWEEN 以及前缀匹配 LIKE 的范围查询，不会停止匹配\n\n### 索引失效\n\nhttps://mp.weixin.qq.com/s/mwME3qukHBFul57WQLkOYg\n\n- 不符合最左匹配原则\n- select *不会影响索引，但是会二次回表\n- 使用函数\n- 计算\n- 非前缀匹配\n- in的范围太大\n\n### SQL优化\n\nhttps://www.nowcoder.com/discuss/730039197121155072\n\nB+树不要超过三层：https://juejin.cn/post/7165689453124517896\n\n## 计算机网络\n\n### TCP/IP 四层模型\n\n应用层\n\n传输层\n\n网络层\n\n网络接口层\n\n#### 应用层\n\n提供两个终端设备上应用程序之间信息交换的服务，定义信息交换的格式\n\nhttp协议；smtp协议；pop3/imap协议；ftp协议；dns协议\n\n#### 传输层\n\n负责两台终端设备进程的通信提供通用的数据传输服务\n\ntcp协议\n\nudp协议\n\n#### 网络层\n\n负责分组交换网络上不同主机提供通信服务，负责路由和转发\n\nip协议\n\narp协议\n\nicmp协议\n\nnat协议\n\nospf/rip\n\n#### 网络接口层\n\n- 数据链路层：将网络层交下来的IP数据包组装成数据帧\n- 物理层：负责计算机节点之间比特流的透明传输\n\n### HTTP状态码\n\n![常见 HTTP 状态码](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/http-status-code-20250303-095853.png)\n\n**200 OK**：请求被成功处理。例如，发送一个查询用户数据的 HTTP 请求到服务端，服务端正确返回了用户数据。这个是我们平时最常见的一个 HTTP 状态码。\n\n**201 Created**：请求被成功处理并且在服务端创建了一个新的资源。例如，通过 POST 请求创建一个新的用户。\n\n**202 Accepted**：服务端已经接收到了请求，但是还未处理。例如，发送一个需要服务端花费较长时间处理的请求（如报告生成、Excel 导出），服务端接收了请求但尚未处理完毕。\n\n**204 No Content**：服务端已经成功处理了请求，但是没有返回任何内容。例如，发送请求删除一个用户，服务器成功处理了删除操作但没有返回任何内容。\n\n---\n\n**301 Moved Permanently**：资源被永久重定向了。比如你的网站的网址更换了。\n\n**302 Found**：资源被临时重定向了。比如你的网站的某些资源被暂时转移到另外一个网址。\n\n---\n\n**400 Bad Request**：发送的 HTTP 请求存在问题。比如请求参数不合法、请求方法错误。\n\n**401 Unauthorized**：未认证却请求需要认证之后才能访问的资源。\n\n**403 Forbidden**：直接拒绝 HTTP 请求，不处理。一般用来针对非法请求。\n\n**404 Not Found**：你请求的资源未在服务端找到。比如你请求某个用户的信息，服务端并没有找到指定的用户。\n\n---\n\n**500 Internal Server Error**：服务端出问题了（通常是服务端出 Bug 了）。比如你服务端处理请求的时候突然抛出异常，但是异常并未在服务端被正确处理。\n\n**502 Bad Gateway**：我们的网关将请求转发到服务端，但是服务端返回的却是一个错误的响应。\n\n### http和https的区别\n\nhttps是基于http，使用tcp作为底层协议，额外使用ssl/tls协议作为加密和安全认证。默认端口是443.\n\n### QUIC协议\n\nhttp3.0开始使用quic协议。\n\n1. 协议僵化：tcp协议升级困难，quic基于udp实现，可在用户态灵活迭代\n2. 队头阻塞\n3. 连接迁移问题：QUIC 使用 **Connection ID** 标识连接，网络切换时无缝迁移连接，无需重建\n4. QUIC 具有更高级别的加密 ，TCP 本身不做数据加密，依赖于 TLS\n\n### WebSocket\n\n基于TCP连接的全双工通信协议，客户端和服务器可以同时发送和接收数据\n\n应用层的协议，用于弥补http在持久化通信能力上的不足\n\n![image-20250303160210979](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250303160210979-20250303-160211.png)\n\n### tcp保障可靠性的7种方式\n\n1. 数据块传输\n2. 序列号\n3. 数据校验\n4. 流量控制\n5. 拥塞控制\n6. 确认机制\n7. 超时重传\n\n### 挥手过程中的状态\n\n| **状态**       | **触发方** | **阶段**                     | **持续时间**               |\n| -------------------- | ---------------- | ---------------------------------- | -------------------------------- |\n| **TIME_WAIT**  | 主动关闭方       | 发送最后一个 `ACK`后             | 固定 `2MSL`（约1-4分钟）       |\n| **CLOSE_WAIT** | 被动关闭方       | 收到 `FIN`但未发送自己的 `FIN` | 理论上应短暂（实际可能长期存在） |\n\n### tcp和udp的区别\n\n1. 是否面向连接：udp传输数据之前不需要先建立连接，tcp则是提供面向连接的服务（必须先建立连接，传输结束后也需要释放连接）\n2. 是否是可靠传输：udp收到udp报文后，不需要给出任何确认；tcp则通过各种机制保证数据的可靠传输（无差错、不丢失、不重复、按序到达）\n3. 是否有状态：和上面差不多，就是tcp会维护数据的状态\n4. 传输效率：udp高很多\n5. 传输形式：tcp面向字节流，udp则面向报文\n6. 首部开销：tcp（20-60字节），udp（8字节）\n7. tcp只能点对点，而udp可以一对一、一对多、多对一等等。\n\n|                        | TCP            | UDP        |\n| ---------------------- | -------------- | ---------- |\n| 是否面向连接           | 是             | 否         |\n| 是否可靠               | 是             | 否         |\n| 是否有状态             | 是             | 否         |\n| 传输效率               | 较慢           | 较快       |\n| 传输形式               | 字节流         | 数据报文段 |\n| 首部开销               | 20 ～ 60 bytes | 8 bytes    |\n| 是否提供广播或多播服务 | 否             | 是         |\n\n### SYN洪流攻击\n\nSYN Flood是最经典的DDos攻击\n\n利用了TCP的三次握手（SYN->SYN/ACK->ACK），进入半连接状态，使得资源耗尽\n\n预防手段：\n\n1. 增加半连接工作队列数量\n2. 回收最先创建的tcp半连接\n3. syn cookie\n\n## 操作系统\n\n### 进程和线程的区别\n\n1. 线程是进程划分为更小的运行单位，进程执行过程中可以产生多个线程\n2. 线程共享资源，可以互相影响；进程基本是独立的\n3. 线程执行开销小，进程则比较大\n\n### 线程间同步的方式\n\n1. 互斥锁\n2. 读写锁\n3. 信号量\n4. 屏障\n5. 事件（wait/notify）\n\n### 进程间通信方式\n\n1. 匿名管道（父子进程）/ 有名管道\n2. 信号量\n3. 共享内存\n4. 消息队列\n5. 套接字\n\n### 父子进程\n\n**子进程拷贝父进程数据的核心机制是写时复制（Copy-On-Write, COW）**。这一设计在Linux系统中通过 `fork()`系统调用实现，兼顾性能与资源利用率\n\n![image-20250315152502507](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250315152502507-20250315-152503.png)\n\n典型场景：Redis利用COW实现快照持久化，子进程直接读取父进程内存生成RDB文件\n\n![image-20250315185109713](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250315185109713-20250315-185110.png)\n\n### 银行家算法\n\nhttps://cloud.tencent.com/developer/article/2108439\n\n### 零拷贝机制\n\n**零拷贝（Zero-Copy）**是一种计算机系统优化技术，旨在减少或消除数据在内存中的冗余拷贝操作，从而降低CPU开销、提升数据传输效率。其核心思想是：**通过硬件或操作系统级优化，避免CPU参与数据在用户空间与内核空间之间的复制过程**，直接在内核态完成数据传输\n\n<img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250315212414718-20250315-212415.png\" alt=\"image-20250315212414718\" style=\"zoom:50%;\" />\n\n基本过程理解：https://www.bilibili.com/video/BV1RxcoeLE5x\n\nmmap：实现内核缓冲区和用户缓冲区之间的映射关系（避免CPU的拷贝过程）\n\n### cpu三级缓存\n\n**解决速度差异问题** CPU的执行速度远高于内存和磁盘，三级缓存通过**缩短数据访问路径**，减少CPU等待数据的时间，缓解“内存墙”问题。\n\n- **速度对比**：寄存器 > L1 > L2 > L3 > 内存 > 磁盘\n- **性能提升**：约95%的数据访问可通过缓存完成，仅5%需访问内存，极大减少延迟\n\n核心目的：CPU与内存速度差异大，缓存通过空间换时间减少访问延迟\n\n## Spring\n\n### 注解\n\n<img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250304221412002-20250304-221412.png\" alt=\"image-20250304221412002\" style=\"zoom:50%;\" />\n\n### Spring自动装配原理\n\nSpring 自动装配的核心目标是**通过约定大于配置的方式，自动加载符合条件的 Bean 到容器中**\n\n![image-20250309102948593](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250309102948593-20250309-102949.png)\n\n按需装配\n\n### BeanFactory 和 FactoryBean\n\n| **BeanFactory**                                                                                                                                  | **FactoryBean**                                                                                                                                               |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Spring 的核心接口**，是 IOC 容器的顶层设计，负责 Bean 的实例化、配置和管理。它是 Spring 工厂模式的实现，如 `ApplicationContext` 是其子接口。 | **特殊的 Bean**，本身是一个 Bean，但实现了工厂模式，用于创建其他 Bean 实例。例如 MyBatis 的 `SqlSessionFactoryBean` 和 Spring AOP 的 `ProxyFactoryBean`。 |\n| **角色**：IOC 容器的管理者，提供 Bean 的基础操作（如 `getBean`、`isSingleton`） 。                                                           | **角色**：Bean 的生产工厂，通过 `getObject()` 方法返回目标对象，而非自身实例。                                                                              |\n\n### Bean的生命周期\n\n![img](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/spring-bean-lifestyle-20250226-125000.png)\n\n### Bean加载问题\n\n**默认扫描范围**： Spring 默认仅扫描主配置类（如 `@SpringBootApplication` 标注的类）所在的包及其子包。若类位于其他包中，需通过 `@ComponentScan` 显式指定扫描路径\n\n```java\n@SpringBootApplication\n@ComponentScan(basePackages = \"com.example.custom.package\")\npublic class App { /*...*/ }\n```\n\n若配置了 `@ComponentScan` 的 `excludeFilters` 或 XML 的 `<context:exclude-filter>`，相关类可能被排除\n\n### Spring的循环依赖\n\nSpring使用三级缓存来解决循环依赖问题：\n\n1. 一级缓存singletonObjects：存储最终形态的Bean\n2. 二级缓存earylySingletonObjects：存储半成品Bean，即三级缓存ObjectFactory产生的对象。主要是为了AOP机制下， 每次产生新的代理对象\n3. 三级缓存singletonFactories：存放ObjectFactory，ObjectFactory的getObject()方法（最终调用的是getEarlyBeanReference()方法）可以生成原始 Bean 对象或者代理对象（如果 Bean 被 AOP 切面代理）\n\n创建Bean的具体流程如下：\n\n1. 先去一级缓存singletonObjects获取，存在就返回；\n2. 不存在，去二级缓存中获取\n3. 仍然不存在，就在三级缓存获取到对应的objectFactory（并调用对应的getObject()）方法\n\n具体解决循环依赖的方法如下：\n\n1. Spring创建A时，A依赖了B，但是B又依赖了A\n2. 由于A还没有初始化完成，因此在一二级缓存中没有A\n3. 那么就去三级缓存调用getObject()方法获取A的早期暴露对象，放入二级缓存中，并注入到B中去\n\n在AOP模式下存在的二级缓存：\n\n确保多个对早期引用的请求，也返回同一个代理对象\n\n### @Transactional\n\nSpring中事务管理最关键的三个接口：\n\n- PlatformTransactionManager：事务管理器，Spring事务策略的核心\n- TransactionDefinition：事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)\n- TransactionStatus：事务运行状态\n\n#### 事务传播行为\n\n解决业务层方法之间互相调用的事务问题\n\nPropagation_Required：外部有事务，加入外部；外部没有，则自己新建一个事务（互相影响）\n\nPropagation_requires_new：创建一个事务，把外部事务挂起（内部影响外部，外部不影响内部）\n\nPropagation_nested：内部不会影响外部，外部会影响外部\n\n#### 注解失效\n\n- 只能作用在public方法上，其他不生效\n- 当一个方法被标记@Transactional注解的时候，Spring 事务管理器只会在被其他类方法调用的时候生效，而不会在一个类中方法调用生效。\n\n#### 相关面试题\n\n> 1. 一个类的内部有A，B两个方法，其中B开启了事务，我在A中调用B，事务生效吗？\n> 2. 这种情况下如何让事务生效？\n\n在同一个类中，若方法A直接调用带有 `@Transactional`注解的方法B，**事务不会生效**。其核心原因在于Spring的事务管理基于AOP代理机制实现，而同类内部调用会绕过代理，直接通过目标对象执行，导致事务拦截失效。\n\n解决方法：\n\n- 拆分到不同的类\n- 自我注入：注入一个自己类对象\n\n  ```java\n  @Service  \n  public class MyService {  \n    \t// 需要开启循环依赖支持\n      @Autowired  \n      private MyService self;  \n  }\n  ```\n- 获取当前代理对象：((MyService) AopContext.currentProxy()).methodB();   或者获取代理Bean对象\n\n### Spring Cloud Gateway\n\n![img](https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/springcloud-gateway-%20demo.png)\n\n三个关键组件：\n\n- **Route 路由**：Spring Cloud Gateway最基本的单元，定义了请求的匹配规则和转发目标。通过配置路由，可以将请求映射到后端服务实例或者URL上。路由规则根据请求的路径、方法或者请求头等条件进行匹配（断言），指定转发的目标URL\n- **Predicate 断言**：用于匹配请求的目标，如果满足断言的条件，就会应用所配置的过滤器。内置多种断言方式，如Path（路径匹配）、Method（请求方法匹配）等\n- **Filter 过滤器**：对请求进行转换和处理，可以修改请求、响应和自定义逻辑。提供了多个内置的过滤器，如请求转发、请求重试、请求限流等。\n\n具体工作流程：\n\n![Spring Cloud Gateway 的工作流程](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/spring-cloud-gateway-workflow-20250315-144117.png)\n\n1. **路由判断**：客户端的请求到达网关后，先经过 Gateway Handler Mapping 处理，这里面会做断言（Predicate）判断，看下符合哪个路由规则，这个路由映射后端的某个服务。\n2. **请求过滤**：然后请求到达 Gateway Web Handler，这里面有很多过滤器，组成过滤器链（Filter Chain），这些过滤器可以对请求进行拦截和修改，比如添加请求头、参数校验等等，有点像净化污水。然后将请求转发到实际的后端服务。这些过滤器逻辑上可以称作 Pre-Filters，Pre 可以理解为“在...之前”。\n3. **服务处理**：后端服务会对请求进行处理。\n4. **响应过滤**：后端处理完结果后，返回给 Gateway 的过滤器再次做处理，逻辑上可以称作 Post-Filters，Post 可以理解为“在...之后”。\n5. **响应返回**：响应经过过滤处理后，返回给客户端。\n\n#### 内部调用\n\n微服务A和B在注册中心注册后，可通过内部服务名（如 `payment-service`）直接调用，无需经过网关\n\n**注册中心的健康检查**\n\n- **心跳检测**：服务实例定期向注册中心发送心跳（如Eureka默认30秒一次），若超时未收到心跳（Eureka默认90秒），则标记实例为不可用并剔除\n- **主动探针**：Nacos支持TCP/HTTP主动探针，实时检测服务健康状态\n\n**客户端的动态更新**\n\n- **本地缓存**：客户端（如Ribbon）会定期从注册中心拉取最新服务列表（默认30秒），并缓存到本地。当某节点挂掉时，客户端在下一次请求时会自动跳过该节点\n- **故障转移**：负载均衡器（如Ribbon）在调用失败时自动重试其他可用实例（默认不重试，需配置 `RetryPolicy`）\n\n#### 内部绕过鉴权\n\n其实内部也不需要再鉴权了\n\n内部请求的时候添加请求头：\n\n```java\n// 内部服务调用时添加请求头\nwebClient.get()\n    .uri(\"http://internal-service/api/data\")\n    .header(\"X-Internal\", \"true\")\n    .retrieve();\n```\n\n**结合IP白名单限制**\n\n- 网关配置：在网关过滤器中校验请求来源IP是否属于内部网络\n\n```java\n@Component\npublic class InternalIpFilter implements GlobalFilter {\n    @Override\n    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {\n        String clientIp = exchange.getRequest().getRemoteAddress().getAddress().getHostAddress();\n        // 判断是否是内部的请求\n      \tif (isInternalIp(clientIp) && exchange.getRequest().getHeaders().containsKey(\"X-Internal\")) {\n            return chain.filter(exchange);\n        }\n      \t// 外部就需要校验\n        return checkAuth(exchange, chain);\n    }\n}\n```\n\n**临时Token+请求头**\n\n内部服务调用时生成带时效和签名的Token（如JWT），网关验证Token有效性\n\n#### 服务发现\n\n| **注册中心**   | **一致性模型** | **功能扩展**  | **适用场景**            |\n| -------------------- | -------------------- | ------------------- | ----------------------------- |\n| **Eureka**     | AP                   | 服务注册与发现      | Spring Cloud 传统架构         |\n| **Consul**     | CA（最终一致）       | 多数据中心、KV 存储 | 混合云或复杂网络环境          |\n| **Nacos**      | AP/CP 可选           | 动态配置管理        | 云原生、多环境配置统一        |\n| **ZooKeeper**  | CP                   | 分布式协调          | 强一致性要求的金融或交易系统  |\n| **Etcd**       | CP                   | 键值存储            | Kubernetes 集群或分布式数据库 |\n| **Kubernetes** | 无独立模型           | 容器编排集成        | 已容器化的云原生应用          |\n\n### **总结**\n\n- **中小型项目**：优先选择 **Nacos**（功能全面）或 **Consul**（多数据中心）。\n- **强一致性需求**：选择 **ZooKeeper** 或 **Etcd**。\n- **云原生环境**：直接使用 **Kubernetes 原生服务发现**。\n- **历史系统迁移**：若原用 Eureka，可逐步过渡到 Nacos 以兼容 Spring Cloud 生态\n\n## Redis\n\n### 分布式\n\n主从复制：Redis集群（master负责写请求，slave负责读请求）\n\n<img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/1676964296594-1f216792-7828-4e11-bd01-d30c63a37f89-20250304-160612.png\" alt=\"img\" style=\"zoom: 50%;\" />\n\n### 延迟双删策略\n\n**延迟双删策略**是用于维护数据库（如 MySQL）与 Redis 缓存之间数据最终一致性的常见方案。其核心步骤为：\n\n1. **第一次删除缓存**：在更新数据库前，先删除 Redis 中的缓存数据，避免其他线程在数据库更新期间读取到旧数据。\n2. **更新数据库**：执行数据库的写入操作。\n3. **第二次延迟删除缓存**：在数据库更新完成后，延迟一段时间（如 1-5 秒），再次删除缓存。此步骤的目的是防止在数据库主从同步延迟期间，其他线程将旧数据重新写入缓存\n\n| **方案**                    | **一致性强度** | **复杂度** | **适用场景**           |\n| --------------------------------- | -------------------- | ---------------- | ---------------------------- |\n| **延迟双删**                | 最终一致性           | 低               | 高频更新、容忍短暂不一致     |\n| **先更新数据库再删缓存**    | 更高一致性           | 中               | 强一致性要求（如金融交易）   |\n| **Canal 监听 binlog**       | 最终一致性           | 高               | 无需侵入业务代码的大规模系统 |\n| **分布式锁（如 Redisson）** | 强一致性             | 高               | 对性能要求低、强一致性场景   |\n\n缓存和数据库一致性：https://mp.weixin.qq.com/s?__biz=MzIyOTYxNDI5OA==&mid=2247487312&idx=1&sn=fa19566f5729d6598155b5c676eee62d&chksm=e8beb8e5dfc931f3e35655da9da0b61c79f2843101c130cf38996446975014f958a6481aacf1&scene=178&cur_album_id=1699766580538032128#rd\n\n流行的解决方案：**订阅数据库变更日志，再操作缓存**。\n\n具体来讲就是，我们的业务应用在修改数据时，「只需」修改数据库，无需操作缓存。\n\n那什么时候操作缓存呢？这就和数据库的「变更日志」有关了。\n\n拿 MySQL 举例，当一条数据发生修改时，MySQL 就会产生一条变更日志（Binlog），我们可以订阅这个日志，拿到具体操作的数据，然后再根据这条数据，去删除对应的缓存。\n\n<img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/640-20250306-204147.jpg\" alt=\"图片\" style=\"zoom:50%;\" />\n\n整体流程如下：\n\n- **监听Binlog**：通过中间件（如Canal、Maxwell）模拟MySQL从库，实时捕获Binlog事件。\n- **数据转换**：将Binlog中的操作转换为Redis命令（如SET、DEL），保证缓存与数据库操作一致。\n- **异步处理**：通过消息队列（如Kafka、RocketMQ）解耦，实现削峰填谷和失败重试\n\n### k-v结构\n\nRedis 使用一个**全局哈希表**（`dict`）来存储所有键值对，哈希表的结构如下：\n\n- **哈希桶（Hash Bucket）**：通过哈希函数将键（Key）映射到哈希桶中，每个桶存储指向具体键值对的指针；\n- **哈希节点（`dictEntry`）**：每个节点包含键、值指针以及指向下一个节点的指针（用于解决哈希冲突）\n\n哈希表的调整：\n\n- **渐进式 Rehash**：当哈希表负载因子（元素数量 / 哈希表大小）超过阈值时，Redis 会启动渐进式 Rehash，逐步将数据从旧哈希表迁移到新哈希表，避免一次性迁移导致的性能抖动\n\n### 看门狗机制\n\n![image-20250321155521729](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250321155521729-20250321-155522.png)\n\n后台线程池：执行续期操作\n\n时间轮算法：异步原子地续期\n\n## Java\n\n### 多态的两种表现\n\n1. 编译时多态\n\n- 方法重载\n\n2. 运行时多态：运行时才能确定\n\n- 方法重写\n- 接口实现\n\n运行时多态的实现机制：\n\n- **动态绑定**：JVM 在运行时根据对象类型解析方法调用地址\n- **虚方法表（VTable）**：存储类的方法地址，子类重写方法会覆盖虚表中的父类方法指针\n\n### throw和throws\n\n```java\npublic void str2int(String str) throws Exception { //这里将得到的异常向外抛出，可以抛出多个\n    try {\n        System.out.println(Integer.parseInt(str));\n    } catch(NumberFormatException e) {\n        //TODO 这里可以做一些处理，处理完成后将异常报出，让外层可以得到异常信息\n        throw new Exception(\"格式化异常\");\n    }\n}\n```\n\n### Java性能分析\n\n使用top初步定位进程，之后通过jstack找到对应线程的堆栈信息\n\n- jconsole也是一个查看当前java进程运行情况，可以检测死锁。jconsole可以分析出来内存情况，以及能看到线程状态。结合运行前的heapdumppath，可以分析出当前堆内存占用情况，找到时哪一段对应变量造成的，从而定位问题\n- jstack：生成虚拟机当前时刻的线程快照。 用于生成 Java 进程在**某个时间点**的所有线程堆栈信息，帮助定位死锁、死循环、资源等待等问题\n\n### JVM内存分配\n\nJVM给对象分配内存有多种策略。\n\n1. 基于堆内存的常规分配：\n   - 指针碰撞\n   - 空闲列表\n2. 多线程分配优化：\n   - CAS+重试\n   - 线程本地分配缓冲TLAB\n3. 特殊场景：\n   - 栈上分配：通过**逃逸分析**确定对象生命周期不逃逸出方法（直接在栈帧中分配，结束后自动销毁，避免堆内存分配）\n\n逃逸分析：JVM在编译期或运行时的优化技术，主要用于分析对象的动态作用域，判断是否会被外部方法或线程访问。核心目的是减少堆内存分配、同步开销和对象生命周期管理成本。\n\n根据分析结果，会应用以下优化技术：\n\n- **栈上分配**：若对象未逃逸（仅在当前线程或方法内使用），JVM 可将对象分配在栈帧中，随方法结束自动销毁，无需垃圾回收\n- **标量替换**：若对象未逃逸且结构简单，JVM 会将其拆解为独立的标量（如 `int`、`double`）或字段，直接存储在栈或寄存器中\n- **同步消除**：若对象未逃逸且仅被单线程访问，JVM 会移除其同步锁（如 `synchronized` 块）\n\n### CPU空转问题\n\nCPU 空转通常由未合理阻塞的循环或锁竞争引起。JVM 通过自适应自旋锁和锁升级机制减少无效空转，开发者需结合以下策略：\n\n1. **代码层面**：用阻塞方法（如 `take()`）替代轮询，设置自旋超时，利用线程池控制并发。\n2. **工具定位**：通过 `jstack` 或 Arthas 定位高 CPU 线程，分析是否为自旋锁或死循环。\n3. **锁优化**：评估锁粒度，优先使用 `ReentrantLock` 替代 `synchronized`，结合条件变量减少竞争（如网页43的锁示例）。 例如，某压测场景中，通过火焰图定位到 `while(true)` 空循环，添加 `Thread.sleep(50)` 后 CPU 从 95% 降至正常水平\n\n### 线程池\n\n线程池参数，过期时间的意义，超出核心线程数的会被回收吗，非核心线程会被回收吗？怎么判断他要不要回收，怎么知道他过期了的。那我创建十个线程，1~10,核心数8个，9和10还在执行任务，1~8不执行了，这时候会怎么做。\n说说线程池的阻塞队列有什么用，为什么用阻塞队列不用普通队列，在并发情况下，往队列中加任务不会有线程安全问题吗。\n\nTODO\n\n### callable和runnable区别\n\n| **对比维度** | **Runnable**                                 | **Callable**                                                             |\n| ------------------ | -------------------------------------------------- | ------------------------------------------------------------------------------ |\n| **接口定义** | `public interface Runnable { void run(); }`      | `public interface Callable<V> { V call() throws Exception; }`                |\n| **返回值**   | **无返回值**（`void`）                     | **有返回值**（泛型类型 `V`）                                           |\n| **异常处理** | 无法抛出受检异常（必须内部 `try-catch` 处理）    | 允许抛出受检异常（通过 `Future.get()` 捕获 `ExecutionException` 获取原因） |\n| **执行方式** | 通过 `Thread` 或 `Executor.execute()` 直接执行 | 必须通过 `ExecutorService.submit()` 提交，返回 `Future` 对象               |\n| **任务管理** | 无状态追踪，无法取消任务或获取结果                 | 通过 `Future` 管理任务状态（取消、超时、结果查询）                           |\n| **泛型支持** | 不支持                                             | 支持（通过泛型指定返回值类型，如 `Callable<String>`）                        |\n\n### 反射\n\n反射的核心方法是invoke，通过调用jvm内部的native方法，完成动态方法调用\n\n#### 性能影响\n\n1. 动态解析和运行时开销：需要动态加载类、解析方法/字段的元数据，这些操作在直接调用中是由编译器完成的\n2. 方法调用的性能损失：反射调用（如 `method.invoke()`）无法享受 JIT 编译器的优化（如方法内联），导致执行速度比直接调用慢约 **10-30倍**\n\n优化方向：\n\n- 缓存反射元数据：将频繁使用的 `Method`、`Field` 对象缓存起来，避免重复解析\n- 使用高性能反射库：如**Spring的 `ReflectionUtils`**\n\n### 泛型机制\n\nJava的泛型是伪泛型，在编译期间所有泛型信息都会被擦除，也就是类型擦除。\n\n即使泛型擦除存在，但是使用泛型仍然存在一系列好处：\n\n- 可以在编译期间进行类型检查\n- 使用Object类型需要手动添加强制类型转换\n\n泛型可以增强代码的可读性和稳定性，编译器会对泛型参数进行检测（指定传入对象的类型）\n\n### 并发的同步\n\nSynchronized 关键字\n\nLock接口及其实现类\n\n原子类\n\n并发集合\n\n读写锁\n\n线程同步工具（CountdownLatch、Semaphore）\n\n### 并发编程的三个特性\n\n1. **原子性**\n\n一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。\n\n在 Java 中，可以借助 `synchronized`、各种 `Lock` 以及各种原子类实现原子性。\n\n`synchronized` 和各种 `Lock` 可以保证任一时刻只有一个线程访问该代码块，因此可以保障原子性。各种原子类是利用 CAS (compare and swap) 操作（可能也会用到 `volatile`或者 `final`关键字）来保证原子操作。\n\n2. **可见性**\n\n当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。\n\n在 Java 中，可以借助 `synchronized`、`volatile` 以及各种 `Lock` 实现可见性。\n\n如果我们将变量声明为 `volatile` ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。\n\n3. **有序性**\n\n在 Java 中，`volatile` 关键字可以禁止指令进行重排序优化。\n\n### AQS\n\n参考文献：https://mp.weixin.qq.com/s/jEx-4XhNGOFdCo4Nou5tqg\n\n抽象类，为同步器提供了通用的执行框架。定义了资源获取和释放的通用流程，具体的资源获取和释放则通过模版方法来实现。\n\n性能好的点在于：**CAS+线程阻塞/唤醒**\n\n**核心思想**：如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态\n\n### synchronized和Lock的区别\n\n| **维度**       | **synchronized**       | **Lock**                  |\n| -------------------- | ---------------------------- | ------------------------------- |\n| **锁释放**     | 自动释放（代码块结束或异常） | 手动释放（需 `unlock()`）     |\n| **公平性**     | 仅非公平锁                   | 支持公平锁与非公平锁            |\n| **中断响应**   | 不支持                       | 支持（`lockInterruptibly()`） |\n| **锁状态检测** | 无法判断                     | 可检测（`tryLock()`）         |\n| **性能**       | 低竞争场景优                 | 高竞争场景优                    |\n| **适用场景**   | 简单同步、快速开发           | 复杂逻辑、高并发优化            |\n\n从底层实现上：\n\n- synchronized是java的关键词，由jvm直接管理，通过字节码指令 `monitorenter`和 `monitorexit`实现（还有锁升级机制）\n- Lock是类，实现包括：\n  - 乐观锁，基于volatile变量和CAS算法实现\n  - `ReentrantLock` 通过 AQS 维护锁状态和等待队列，支持可重入性和公平性\n\n### Future和CompletableFuture\n\n应用为主\n\nCompletableFuture支持任务之间的并行调用，在等待A任务执行完之后执行另外的任务，也支持组合两个任务，等待两个任务同时执行完毕\n\n### ForkJoinPool\n\n![image-20250310163700719](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250310163700719-20250310-163702.png)\n\nCompletableFuture如果不自定义线程池，默认使用的全局线程池就是ForkJoinPool\n\n```java\npublic class MergeSortTask extends RecursiveAction {\n    private int[] array;\n    private int left, right;\n    private static final int THRESHOLD = 1000; // 拆分阈值\n\n    @Override\n    protected void compute() {\n        if (right - left <= THRESHOLD) {\n            Arrays.sort(array, left, right); // 小任务直接排序\n        } else {\n            int mid = (left + right) / 2;\n            invokeAll(\n                new MergeSortTask(array, left, mid),\n                new MergeSortTask(array, mid, right)\n            );\n            merge(array, left, mid, right); // 合并结果\n        }\n    }\n}\n// 使用方式\nForkJoinPool pool = new ForkJoinPool();\npool.invoke(new MergeSortTask(arr, 0, arr.length));\n```\n\n```java\nimport java.util.concurrent.ForkJoinPool;\nimport java.util.concurrent.RecursiveTask;\n\npublic class ForkJoinSumCalculator extends RecursiveTask<Long> {\n    private final long[] array;\n    private final int start;\n    private final int end;\n    private static final int THRESHOLD = 10_000; // 任务拆分阈值\n\n    public ForkJoinSumCalculator(long[] array) {\n        this(array, 0, array.length);\n    }\n\n    private ForkJoinSumCalculator(long[] array, int start, int end) {\n        this.array = array;\n        this.start = start;\n        this.end = end;\n    }\n\n    @Override\n    protected Long compute() {\n        int length = end - start;\n        // 如果任务足够小，直接计算\n        if (length <= THRESHOLD) {\n            return computeDirectly();\n        }\n        // 拆分任务：将大任务分为两个子任务\n        int mid = start + length / 2;\n        ForkJoinSumCalculator leftTask = new ForkJoinSumCalculator(array, start, mid);\n        ForkJoinSumCalculator rightTask = new ForkJoinSumCalculator(array, mid, end);\n\n        // 异步执行左半部分任务（fork）\n        leftTask.fork();\n\n        // 同步执行右半部分任务，并合并结果（join）\n        Long rightResult = rightTask.compute();\n        Long leftResult = leftTask.join();\n\n        return leftResult + rightResult;\n    }\n\n    // 直接计算区间和\n    private long computeDirectly() {\n        long sum = 0;\n        for (int i = start; i < end; i++) {\n            sum += array[i];\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        long[] array = new long[100_000];\n        for (int i = 0; i < array.length; i++) {\n            array[i] = i + 1; // 初始化数组为1~100000\n        }\n\n        // 创建ForkJoinPool并提交任务\n        ForkJoinPool pool = new ForkJoinPool();\n        Long result = pool.invoke(new ForkJoinSumCalculator(array));\n\n        System.out.println(\"计算结果: \" + result); // 应输出5000050000\n    }\n}\n```\n\n1. 避免饥饿：通过工作窃取机制，空闲线程主动从其他队列窃取任务，动态平衡负载（内部会为每一个线程简历一个工作队列）\n2. 合理设置任务拆分阈值（THRESHOLD）\n\n关键点：**分治策略** + **工作窃取**\n\n### Hash结构的数据解决哈希冲突的方法有哪些\n\n1. 开放定址法：哈希冲突发生时，按照特定的规则寻找下一个哈希地址\n2. 链地址法\n3. 再哈希法（使用备用哈希函数）\n4. 公共溢出区法\n\n### HashMap和HashTable的区别\n\n1. 线程安全性：HashMap线程不安全，HashTable线程安全（内部方法都通过synchronized关键词修饰）\n2. 效率：HashMap高于HashTable（为了保证线程安全，牺牲了性能）\n3. 对Null的支持：HashMap允许存在Null的key和value，而HashTable不允许\n4. 初始化容量：\n   - HashMap初始化大小为16，每次扩容两倍；如果设置了初始大小，就会设置为比初始大小大的2的幂次方\n   - HashTable初始大小为11，每次扩容2n+1；如果设置了初始大小，则直接使用初始大小\n5. 1.8后的HashMap存在链表转红黑树的过程\n6. HashMap对哈希值的高位和低位进行了扰动处理\n\n### 单例模式的破坏\n\n1. **反射绕过单例**\n\n```java\nClass<?> clazz = Singleton.class;\nConstructor<?> constructor = clazz.getDeclaredConstructor();\nconstructor.setAccessible(true);\nSingleton instance1 = (Singleton) constructor.newInstance();\nSingleton instance2 = (Singleton) constructor.newInstance();\nSystem.out.println(instance1 == instance2); // 输出 false\n```\n\n可以直接在构造函数中去进行实例检查：\n\n```java\nprivate Singleton() {\n    if (Inner.instance != null) {\n        throw new RuntimeException(\"禁止通过反射创建实例！\");\n    }\n}\n```\n\n注意懒汉式，还需要额外进行考虑，添加一个状态位：\n\n```java\nprivate static boolean flag = false;\nprivate Singleton() {\n    synchronized (Singleton.class) {\n        if (flag) throw new RuntimeException(\"禁止反射创建！\");\n        flag = true;\n      \tif (instance == null) {\n          ...\n\t\t\t\t}\n    }\n}\n```\n\n但是，状态位也可能会被反射更新。因此，懒汉式实现的单例模式是不可以防止被反射破坏的\n\n2. **序列化和反序列化对单例模式的破坏**\n\n单例类实现 `Serializable` 接口后，反序列化时会通过反射生成新对象，而非复用已有实例。\n\n解决方法：\n\n（1）枚举类会直接返回已有实例\n\n（2）添加readResolve()，返回已有实例。**`readResolve()` 是 Java 序列化机制中的一个特殊回调方法**，用于在反序列化过程中替换或控制最终返回的对象\n\n可以考虑实现单例模式的另外两种方案：\n\n1. **枚举单例** （最优方案）\n\n枚举类禁止创建反射单例（JVM禁止），也不需要依赖构造函数检查\n\n```java\npublic enum Singleton {\n    INSTANCE;\n    // 添加方法\n}\n```\n\n**优势**：无需手动防御反射，安全性最高\n\n2. 静态内部类\n\n```java\npublic class Singleton {\n    private static class Holder {\n        private static final Singleton INSTANCE = new Singleton();\n    }\n    private Singleton() {}\n  \n    public static Singleton getInstance() {\n        return Holder.INSTANCE;\n    }\n}\n```\n\n**原理**：静态内部类在首次调用 `getInstance()` 时才加载，JVM保证类加载过程的线程安全性\n\n### 新版本Java\n\nJava24发布了，最重要的一个特性：**虚拟线程的同步而不固定平台线程**\n\n优化了虚拟线程与 `synchronized` 的工作机制。虚拟线程在 `synchronized` 方法和代码块中阻塞时，通常能够释放其占用的操作系统线程（平台线程），避免了对平台线程的长时间占用，从而提升应用程序的并发能力。这种机制避免了“固定 (Pinning)”——即虚拟线程长时间占用平台线程，阻止其服务于其他虚拟线程的情况。\n\n现有的使用 `synchronized` 的 Java 代码无需修改即可受益于虚拟线程的扩展能力。例如，一个 I/O 密集型的应用程序，如果使用传统的平台线程，可能会因为线程阻塞而导致并发能力下降。而使用虚拟线程，即使在 `synchronized` 块中发生阻塞，也不会固定平台线程，从而允许平台线程继续服务于其他虚拟线程，提高整体的并发性能。\n\n**核心**：虚拟线程在被synchronized阻塞的时候，会释放掉所占用的平台线程\n\n**提前类加载和链接**：缓存已经加载和链接过的类，减少重复工作的开销（无侵入）\n\n### Spring Task\n\n`ScheduledThreadPoolExecutor` 是 JDK 自带的定时调度器，基于一个 **延时队列（DelayedWorkQueue）** 来管理任务：\n\n- 提交任务时，会计算出**下次执行的时间戳**，丢进延时队列。\n- 一个专门的工作线程会不断从队列里取“到期的任务”，放到线程池里去执行。\n- 如果是周期任务（fixedRate/fixedDelay），执行完毕后会**重新计算下次时间**，再放回队列\n\n默认使用`ThreadPoolTaskScheduler` 的线程池大小 = 1，也就是单线程顺序执行。因此，可以自己配置一个线程池：\n\n- **扫描 @Scheduled 注解** → 注册成定时任务。\n- **交给 TaskScheduler（默认 ThreadPoolTaskScheduler）** 管理。\n- **底层依赖 JDK 的 ScheduledThreadPoolExecutor**（基于延时队列实现）。\n- 周期任务 / Cron 任务：每次执行完毕后算出下一次执行时间，再丢回调度队列\n\n\n\n## Linux\n\nhtop查看内存占用情况，PID等信息\n\n![image-20250305125116718](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250305125116718-20250305-125117.png)\n\n### 处理大文件\n\n> Linux读取大文件进行文本替换\n\n**使用 `sed` 命令（流式处理，内存友好）**\n\n- **适用场景**：全局或局部替换文本，支持正则表达式。\n- **优势**：逐行处理文件，无需加载整个文件到内存。\n\n```shell\n# 替换文件中所有 \"old_text\" 为 \"new_text\"（直接修改原文件）\nsed -i 's/old_text/new_text/g' large_file.txt\n\n# 仅替换第 100 到 200 行的内容\nsed -i '100,200s/old_text/new_text/g' large_file.txt\n```\n\n![image-20250321125123282](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250321125123282-20250321-125126.png)\n\n## 数据结构\n\n### 红黑树\n\n1. 每个节点非黑即红，黑色代表平衡，红色代表不平衡；\n2. 根节点总是黑色的\n3. 每个叶子节点都是黑色的空节点（NIL 节点）。这里指的是红黑树都会有一个空的叶子节点，是红黑树自己的规则；\n4. 如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；\n5. 从任意节点到它的叶子节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。\n\n\n\n## Etcd\n\n### 备份过程数据的一致性\n\n原因在于它不是简单去拷贝数据文件，而是通过 **Raft 一致性和 etcd 的 MVCC 存储机制** 来保证\n\n- etcd 集群所有写入必须经过 **Raft 共识** 才能提交。\n- 当执行 `etcdctl snapshot save` 时，etcd 会选定一个**一致的 Raft 提交点**（commit index），以该时刻为快照边界\n- etcd 底层使用 **boltdb** 存储，并且有 **MVCC（多版本并发控制）索引层**\n\n综上，一致性保障来源于两方面：\n\n**Raft 共识 → 确保提交点一致**；\n\n**MVCC 快照 → 确保读取的是某个固定 revision 的全局状态**\n\n **MVCC 在这里的作用**就是：保证 `snapshot save` 读出的所有数据属于同一个 revision，不会前后混杂\n\n### Raft 而非 Paxos\n\n**Paxos**：理论优雅，但工程实现复杂，难以理解和维护；\n\n**Raft**：在保证相同一致性语义的前提下，更直观、更易实现和维护\n\n一句话总结：Raft 更工程友好，理解和实现成本更低，维护更容易\n\n\n\n### Etcd VS Zookeeper\n\nZookeeper的问题：\n\n**Watch 机制不足**\n\n- 触发一次就失效，需要重新注册；\n- 客户端多时容易引发“惊群效应”\n\n**一致性协议复杂**\n\n- ZAB 没有 Raft 那么直观，理解和验证成本高\n\n\n\n\n\n\n\n\n\n# 场景题\n\n## 算法\n\n智力题pdf： [场景题.pdf](场景题.pdf) \n\n### 最大的100个数字\n\n> 有很多个没有排序过的数字，想要找到其中最大的100个数字，怎么实现，时间复杂度是多少？\n\n1. 最小堆法：\n\n将前100个数构建为**最小堆**\n\n后续每个数，如果大于堆顶，那么就替换并且更新结构；否则就不需要\n\n建堆O(100)，后续每次处理为O(nlog100) = O(n)\n\n时间复杂度为：O（n）\n\n2. 快速选择算法：分区，找到第100大的元素。此时左边就是需要的\n\n平均O（n），最坏情况（n^2）\n\n3. 分治法（数据量过大的时候）：\n\n   将数据分成若干块（每块100万个），每块使用上述两种方法找到最大的100个数\n\n   合并top100，再次筛选\n\n   时间复杂度为O(n + mlogm + 100m)，m是块数\n\n### 大数据量的状态\n\n> 有一台16G内存的电脑，要保存2的32次方个qq号的状态，怎么设计，大概占多少内存空间？\n\n都用1位表示状态：\n\n2^32 * 1 / 8 =536,870,912 字节 = 512MB\n\n布隆过滤器近似计算\n\n### 查找高频词\n\n> 在内容安全工作中，常用高频词查找的需要。\n> 你需要在最多不超过 10^7 的单词中查找其中出现次数最多的 100 个，即 TOP100。\n> 为了简单起见，所有单词都已经被提取出来，每个单词由小写字母 a-z 组成，长度不超过 20 个字母。\n> 你需要使用尽可能小的内存空间和尽可能快的算法来找出这 100 个单词。\n> 样例1:\n> [输入]\n> 5\n> splunk\n> elastic\n> splunk\n> clickhouse\n> elastic\n\n先存储（用map或者trie？长度20的话，20*26=520 ）；用map也可以\n\n然后用最大的100个数字的方法\n\n### 统计10G电话号码\n\n> 10G的11位电话号码文件，2G内存，如何获取重复率最高的电话号码\n\n1. **哈希分片**：\n   - 将10G文件按电话号码的哈希值（如**取模**运算）分割为多个小文件，确保相同电话号码一定落入同一文件。例如，哈希函数设为 `hash(phone) % 1000`，生成1000个子文件，每个文件约10MB（假设电话号码均匀分布）\n2. 逐文件统计频率：\n   - 逐个读取子文件，在内存中统计每个文件的电话号码出现次数\n   - 记录当前文件的**最高频率号码**及其次数\n3. 全局汇总：\n   - 合并所有子文件的统计结果，计算全局最高频率\n   - 读取所有临时结果文件，使用**最小堆**或**外部排序**合并数据\n\n哈希分片 or bitmap（本题不适用） 是一种很重要的思想方法\n\n### 3次失败登陆锁定15分钟\n\n```java\npublic Result login(String username, String password) {\n    // 1. 检查是否已锁定\n    if (redis.exists(\"lock:\" + username)) {\n        return Result.error(\"账户已锁定，请15分钟后重试\");\n    }\n  \n    // 2. 验证用户名密码\n    User user = userService.findByUsername(username);\n    if (user != null && password.equals(user.getPassword())) {\n        // 登录成功：重置失败次数\n        redis.delete(\"login_fail:\" + username);\n        return Result.success();\n    } else {\n        // 3. 登录失败：递增失败次数\n        long count = redis.incr(\"login_fail:\" + username);\n        redis.expire(\"login_fail:\" + username, 900); // 15分钟滑动窗口\n      \n        // 4. 判断是否触发锁定\n        if (count >= 3) {\n            redis.setex(\"lock:\" + username, 900, \"locked\"); // 锁定15分钟\n            return Result.error(\"连续失败3次，账户已锁定\");\n        }\n        return Result.error(\"用户名或密码错误\");\n    }\n}\n```\n\n| **方案**          | **优点**                 | **缺点**                  | **适用场景**       |\n| ----------------------- | ------------------------------ | ------------------------------- | ------------------------ |\n| **纯数据库实现**  | 无需额外中间件，数据持久化可靠 | 高并发下性能瓶颈，锁竞争严重    | 低并发、数据一致性要求高 |\n| **Redis+数据库**  | 高性能，自动过期，易于扩展     | 依赖Redis可用性，需处理缓存穿透 | 中高并发，实时性要求高   |\n| **分布式锁+计数** | 支持分布式部署，强一致性       | 实现复杂，运维成本高            | 大型系统，多节点协同     |\n\n### 秒杀场景\n\n**数据库层面的解决方案**\n\n乐观锁：在商品表中增加 `version`字段，每次更新库存时校验版本号是否一致\n\n唯一索引+条件更新：\n\n创建用户购买记录表，对 `(uid, goods_id)`添加唯一索引，防止重复购买\n\n**redis实现分布式锁**\n\n在锁内执行库存预减和订单生成逻辑\n\n```java\n// 加锁示例（Redisson实现）\nRLock lock = redissonClient.getLock(\"lock:product_1\");\nlock.lock(10, TimeUnit.SECONDS);\ntry {\n    int stock = redis.get(\"product_stock_1\");\n    if (stock > 0) {\n        redis.decr(\"product_stock_1\");\n        // 异步生成订单\n        sendToMQ(order);\n    }\n} finally {\n    lock.unlock();\n}\n```\n\n**原子性初始化** 使用Redis的 `SET`命令结合 `NX`（不存在时设置）选项，确保库存仅被初始化一次。例如：\n\n```sh\nSET product:stock 50 NX  # 仅当键不存在时设置库存为50\n```\n\n**Lua脚本实现原子操作** 通过Lua脚本在Redis服务端**原子性校验并扣减库存**，避免并发下的数据不一致。脚本逻辑如下\n\n```lua\n-- KEYS[1]: 库存键（如product:stock）\n-- ARGV[1]: 扣减数量（如1）\nlocal stock = tonumber(redis.call('get', KEYS[1]))\nif stock >= tonumber(ARGV[1]) then\n    return redis.call('decrby', KEYS[1], ARGV[1])\nelse\n    return -1  -- 库存不足\nend\n```\n\n![image-20250321155154531](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250321155154531-20250321-155154.png)\n\n### 多线程任务场景\n\n> 开一个线程池，5个核心线程，10个任务，保证10个任务执行完，再执行主线程的一些任务\n\n```java\nThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 10, 10, TimeUnit.SECONDS,\n        new ArrayBlockingQueue<>(5));\n\n// 10个执行完才能够执行其他的\nCountDownLatch countDownLatch = new CountDownLatch(10);\n\n// 10个任务\nRandom random = new Random();\nfor (int i = 0; i < 10; ++i) {\n    int finalI = i + 1;\n    threadPoolExecutor.submit(() -> {\n        try {\n            System.out.println(\"任务\" + finalI);\n            Thread.sleep(random.nextInt(500) + 1000);\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        } finally {\n            countDownLatch.countDown();\n        }\n\n    });\n}\ncountDownLatch.await();\nSystem.out.println(\"所有任务已完成\");\nthreadPoolExecutor.shutdown();\n```\n\n### 生产者-消费者模型\n\n2个生产者和4个消费者的模型。生产者负责读取文件数据，消费者负责消费文件并输出\n\n阻塞队列可以\n\n### 并查集的删除\n\n在处理某些人之间具有关系的数据结构中，常常用到并查集。例如：a和b认识，b和c认识，那么a和c就可以连接上，可以用并查集来存储这种关系。但是现在需要考虑a和b绝交了，在这种情形下如何用并查集来处理，确认某两个人之间是否还能连接\n\n可以反向处理，将删除等价为增加\n\n### 查询问题\n\n> 场景1：查全校人的姓名，选出top10出现率的名字\n> 场景2：如果查询范围变成全国呢？\n> 场景3：如果空间有限，不让用多级索引呢？用什么数据结构节省空间？\n> 场景4：DNS服务器解析域名对应的IP地址的时候，怎么快速查找到对应的IP地址同时节省存储空间？\n\n### 称盐问题\n\n> 140g的盐 各有一个2g和一个7g的砝码 只能用三次天平，如何称出50g 和 90 g\n\n第一次平分，70+70，第二次继续对一份70克平分，35+35，第三次左边2g砝码，右边7克砝码，调整35克盐以达到平衡，这样左边有20克盐，右边15克盐。把20克盐加到一份70克中即可\n\n### 烧绳子\n\n> 一根绳子烧完要1小时，如何计时15分钟，30分钟和45分钟\n\n## SQL代码\n\n```sql\nwith basic_query as (\nselect \ndistinct products.product_id,\ncategory,\nname as product_name,\nsum(quantity) over (partition by products.product_id) as total_sales\nfrom\nproducts inner join orders on products.product_id = orders.product_id\n)\nselect \nproduct_name,\ntotal_sales,\nrank() over (partition by category order by total_sales desc) as category_rank\nfrom basic_query;\n```\n\n```sql\nSELECT \n    date1, \n    date2,\n    CASE \n        WHEN DATE(date1) = DATE(date2) THEN 'Same Day'\n        ELSE 'Different Day'\n    END AS IsSameDay\nFROM \n    your_table;\n```\n\n# HR面\n\n1 你觉得你有哪些缺点和优点？\n\n缺点：在面对一些比较重要的任务和紧迫的DDL的压制下，由于我本身的执行力非常强，所以这种时候我会试图去尽快把一件事情做完。这种时候，我往往做到了高效完成任务，但容易忽视前期的一些调研准备工作，使得自己在真正去做这件事情的时候会遇到一些波折，导致出现一些小规模的返工。\n\n所以现在在做事情前我一般会通过几种方法去改进自己：\n\n首先，我现在习惯于一般会给自己列一个计划，尽量按照计划去做事。\n\n另一方，其实这也是一个认知的问题。我现在逐渐意识到准备本身也是做事情的一部分，通过预先调研往往能保证事情在执行阶段更加顺利。相当于说工欲善其事，必先利其器\n\n最后，我也会让自己去相信自己的能力，告诉自己我有能力去在期限内完成，更重要的其实在于每一个细节的达成。\n\n2 你怎么评价你面试的这家公司？\n\n3 你在校期间，有没有哪段时间或者某件事情让你受挫？\n\n去年此时，我发现自己体脂率很高，并且感觉不太健康了\n\n另一方面，之前的论文没有中，需要在两个月内完成一篇期刊，\n\n下定决心开始早起，作息从2点睡11点起更改到12点睡8点起。每天抽一个小时去运动一下，然后开始蹲图书馆\n\n4 在校期间遇到最有挑战的事情是什么？\n\n5 目前手上有 offer 吗？\n\n6  自我介绍\n\n7  职业规划\n\n8 报学校专业是怎么考虑的？\n\n9  工作城市\n\n10 你是独生子女吗？\n\n11 那你有男/女 朋友吗？\n\n12  你们出来面试都了解过哪些企业？\n\n13  到后期你们每个人手上有好几个offer，哪些因素决定你们选择这家公司?\n\n14  你更倾向哪种公司？有什么特别的点？\n\n15  你大学有没有特别难忘的经历或者项目分享一下的?\n\n16  团队合作中遇到什么问题？\n\n17  对互联网加班有什么看法？\n\n18  那你现在的技术薄弱点在哪里，怎么去突破？\n\n19  你的兴趣爱好有哪些？\n\n20 现在进度最快的公司是哪家？\n\n21 拿到哪几家offer，是否谈过薪资等\n","source":"_posts/2025/面试-知识储备.md","raw":"---\ntitle: 秋招知识储备\ndate: 2025-10-31 23:50:00\ncover: https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20251031102636698-20251031-102637.png\ndesc: 暑期实习和秋招的知识储备，除了看JavaGuide等外，可以随时回来查缺补漏\ntag: 秋招\n---\n\n# 写在前面\n> 暑期实习和秋招的知识储备，除了看JavaGuide等外，可以随时回来查缺补漏\n> 个人觉得**简历**最为重要，因为在面试中会被问到的问题基本都是围绕着自己简历展开的\n> 关注自己的简历都不用太去看面经了（看些通用的就行），应该关注自己的简历会被如何拷打\n\n> 面试的时候表现的积极点、聪明点，很多时候面试问的问题未必回答的出来，但要表现出有一种愿意主动思考的态度。很多时候一个优秀的面试官是会主动引导的，这里举个自己某次面试时遇到的例子。\n> 面试官：端口是哪一层协议的？\n> 我：我确实不太清楚，让我思考一下...我猜测可能是网络层或者传输层？\n> 面试官：TCP和UDP连接可以用同一个端口吗？\n> 这里其实就是暗示了，我知道TCP和UDP可以用同一个端口，这就说明了它们的端口不是一个概念，且已知tcp和udp是传输层的协议，所以端口也应该是传输层的概念。\n> 因此在面试的时候遇到不会的问题不必太担忧，大胆说出自己的思考，结合学过的知识去分析一下，其实也是很不错的能力。\n\n> 针对HR面和技术面准备不同的自我介绍。比如我在技术面的时候一般就会说：做了blabla什么项目，最后一带而过自己还参加过暑期支教活动和研究生班长；而HR面则重点介绍暑期支教活动和研究生班长经历，一带而过项目等等。\n\n\n\n# 个人面经\n\n暑期实习面经：https://wangwangwang.website/tags/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/\n\n秋招面经：https://wangwangwang.website/tags/%E7%A7%8B%E6%8B%9B/\n\n\n# 八股知识储备\n\n\n## 分布式锁\n\n分布式锁应当满足：\n\n- 互斥\n- 高可用：出问题，能够释放（超时机制）\n- 可重入（获取了锁之后，还可以再次获取）\n\n常见实现方案：Redis和ZooKeeper\n\n## 其他工具\n\n### 限流和熔断\n\n限流（Rate Limiting）是一种常用的技术手段，用于控制系统对资源的访问速率，确保系统的稳定性和可靠性\n\n熔断（Circuit Breaker）模式是一种用于处理分布式系统中因服务调用失败而可能导致系统雪崩效应的保护机制。它借用了电路中的“熔断器”概念，当电流过大时，熔断器会自动切断电路，以保护整个电路系统不被烧毁。在分布式系统中，熔断器用于监控服务调用的健康状况，并在检测到异常（如服务调用失败率过高、响应时间过长等）时，自动切断对该服务的调用，从而防止故障在系统中蔓延，保障系统的整体稳定性和可用性\n\n- 防止服务雪崩\n- 提升系统弹性\n\n### 限流算法\n\n漏桶算法：无法应对激增流量；请求被丢弃\n\n令牌桶算法：可以限制平均速率，以及处理激增的流量；可以动态调整生成令牌速率\n\n动态调整生成令牌速率的方法：\n\n`RedisRateLimiter`的令牌生成速率（`replenishRate`）和突发容量（`burstCapacity`）\n\n可以考虑使用nanos进行动态配置，同时实现动态路由加载\n\n**限流可以进化到降级**\n\n![image-20250312195240597](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250312195240597-20250312-195242.png)\n\n令牌桶算法添加令牌的方式是多样的：\n\n#### 传统线程驱动\n\n通过后台线程定期（如每秒）向令牌桶中添加固定数量的令牌，直到桶满为止。\n\n**优点**：\n\n- 实现简单，逻辑清晰。\n- 令牌生成速率恒定，适合需要严格控制平均速率的场景。\n\n**缺点**：\n\n- 需要维护额外线程，增加系统资源开销。\n- 实时性差，突发流量可能导致令牌补充不及时（如网页44提到的瞬时流量可能超过限速阈值\n\n#### 惰性计算\n\n在每次请求到来时，根据当前时间与上次请求的时间差动态计算应补充的令牌数，并更新桶内令牌。\n\n```java\n// 网页58中的令牌桶核心逻辑\nprivate void refillTokens() {\n    long now = System.nanoTime();\n    long duration = now - lastRefillTime;\n    long newTokens = duration * refillRate / 1_000_000_000; // 计算时间差对应的令牌数\n    tokens.updateAndGet(current -> Math.min(capacity, current + newTokens));\n    lastRefillTime = now;\n}\n```\n\n**优点**：\n\n- 无需独立线程，减少资源消耗。\n- 时间驱动更精确，适合高并发场景（如淘宝交易系统的动态限流）\n\n**缺点**：\n\n- 计算逻辑需保证线程安全（如使用原子操作或同步锁）。\n- 频繁的时间计算可能带来轻微性能损耗。\n\n#### RateLimiter的实现\n\n**核心原理**： 在每次请求到来时，根据**当前时间与上次令牌补充的时间差**，动态计算应补充的令牌数量。这种方式无需独立线程维护令牌桶，通过实时计算实现令牌生成。 **实现细节**：\n\n1. **时间差计算**：记录上次补充令牌的时间戳（如 `nextFreeTicketMicros`），通过当前时间差除以令牌生成间隔（`stableIntervalMicros`），得到应补充的令牌数。\n2. **令牌补充上限**：确保补充后令牌不超过桶的最大容量（`maxPermits`）。\n3. **原子性操作**：使用同步锁或原子变量保证线程安全。 **代码示例**（参考Guava的 `SmoothRateLimiter` 类）：\n\n```java\nprivate void resync(long nowMicros) {  \n    if (nowMicros > nextFreeTicketMicros) {  \n        double timeDiff = nowMicros - nextFreeTicketMicros;  \n        double newPermits = timeDiff / stableIntervalMicros;  \n        storedPermits = Math.min(maxPermits, storedPermits + newPermits);  \n        nextFreeTicketMicros = nowMicros;  \n    }  \n}  \n```\n\n**优点**：\n\n- 无需额外线程，资源消耗低。\n- 实时性强，精确控制突发流量。\n\n**适用场景**：高并发、分布式系统（如Guava RateLimiter的默认实现）\n\n| **方法** | **资源消耗** | **实时性** | **适用场景**              |\n| -------------- | ------------------ | ---------------- | ------------------------------- |\n| 惰性计算法     | 低                 | 高               | 高并发、分布式系统（如API网关） |\n| 定时补充法     | 中                 | 中               | 单机简单限流（如传统后台服务）  |\n\n### maven\n\n解决冲突？todo\n\n### docker和虚拟机的区别\n\n<img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/4ef8691d67eb1eb53217099d0a691eb5-20250302-153527.png\" alt=\"img\" style=\"zoom: 67%;\" />\n\n容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高。\n\n### Oauth 2.0\n\n一种新的授权机制，为第三方应用颁发一个有时效性的令牌Token，使得第三方应用能够通过该令牌获得相关的资源。\n\n令牌（token）与密码（password）的作用是一样的，都可以进入系统，但是有三点差异。\n\n（1）令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。\n\n（2）令牌可以被数据所有者撤销，会立即失效。以上例而言，屋主可以随时取消快递员的令牌。密码一般不允许被他人撤销。\n\n（3）令牌有权限范围（scope），比如只能进小区的二号门。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。\n\n授权层分离出两种角色：客户端和资源所有者。本质oauth的核心就是***向第三方应用颁发令牌***\n\n需要阅读：https://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html\n\n### nginx\n\nnginx正向代理和反向代理\n\nhttps://zhuanlan.zhihu.com/p/163948996\n\n- 正向代理是**客户端代理**，代理客户端，服务端不知道实际发起请求的客户端\n- 反向代理是**服务端代理**，代理服务端，客户端不知道实际提供服务的服务端.\n\n### cookie和localStorage\n\n![image-20250321152306879](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250321152306879-20250321-152307.png)\n\n**单点登录（SSO）**：用户登录百度主站（如 `www.baidu.com`）时，服务器生成一个认证Cookie，并设置其 `domain`属性为 `.baidu.com`。这使得所有子域名（如 `pan.baidu.com`）均可读取该Cookie，实现自动登录\n\n### 时间轮算法\n\n- 环形时间轮：时间轮由多个**槽（Slot）** 组成环形数组，每个槽对应一个时间间隔（如1秒）。例如，一个60槽的时间轮，每槽间隔1秒，可覆盖60秒内的任务\n- **指针（tick）**：指针周期性移动（如每秒移动一槽），触发当前槽内所有任务的执行\n- **任务链表**：每个槽挂载一个任务链表，存储需在该时间点触发的任务\n\n![image-20250321155727208](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250321155727208-20250321-155727.png)\n\n![img](https://static001.geekbang.org/infoq/71/71313f214caded7d34001de907131cfe.png)\n\n以两层时间轮为例，第一层时间轮周期为1秒，第二层时间轮周期为10秒。\n\n还是以上述3个任务为例，可以看到任务A和B分布在第一层时间轮上，而任务C分布在第二层时间轮的槽1处。当第一层时间轮转动时，任务A和任务B会被先后执行。1秒钟之后，第一层时间轮完成了一个周期转动。从新开始第0跳，这时第二层时间轮从槽0跳到了槽1处，将槽1处的任务，也就是任务C取出放入到第一层时间轮的槽位9处，当第一层时间轮转动到槽位9处，任务C就会被执行。这种将第二层的任务取出放入第一层中称为降级，它是为了保证任务被处理的时间精度。Kafka内部就是采用的这种多层时间轮机制。\n\n![img](https://static001.geekbang.org/infoq/da/daf543a1284837a0de12c29aee43c55b.png)\n\n应用场景：\n\n- redisson通过时间轮算法实现锁的自动续期\n\n### 权限模型\n\n在 RBAC（基于角色的访问控制）模型中，**资源（Resource）** 是系统中被标识、可被访问或操作的一切事物。其涵盖范围包括但不限于：\n\n**功能型资源**\n\n- **模块**：如商品管理、订单管理、财务管理等业务板块。\n- **页面**：如商品列表页、订单详情页等具体界面。\n- **按钮**：如“新增商品”“删除订单”等交互操作。\n- **字段**：如商品详情中的“价格”字段是否可编辑\n\n**数据型资源**\n\n- **实体数据**：如数据库中的某条订单记录、客户信息表。\n- **文件/路径**：如服务器上的文件目录或特定文档。\n- **API 接口**：如 `/api/orders` 路径对应的 RESTful 接口\n\nRBAC 模型中的权限管理需从两个维度进行切分：**功能权限**（操作权限）和**数据权限**（数据范围权限）。两者相辅相成，共同实现精细化控制\n\n1. **功能权限（操作权限）**\n\n**定义**：控制用户能否使用系统中的特定功能或执行操作，例如页面访问、按钮点击、API 调用等。\n\n2. **数据权限（范围权限）**\n\n**定义**：控制用户能访问哪些具体数据，例如某部门的数据、某区域的订单等。 **典型维度**：\n\n- **组织架构**：如上海分公司的员工只能访问分公司数据\n\n**总结**：\n\n- 功能权限解决“**能否操作**”的问题（如能否删除订单）。\n- 数据权限解决“**能操作哪些数据**”的问题（如只能删除自己创建的订单\n\n\n\n### 负载均衡算法\n\n**静态**：轮询、加权轮询、随机、哈希、**一致性哈希**。\n\n**动态**：最少连接、最少响应时间、最少负载、带权最少连接\n\n## MySQL\n\n单表数据量控制在500w以内\n\n### 回表\n\nMysql回表\n\n回表怎么解决\n\n回表返回的是一行还是一张表还是索引\n\n### 缓冲区\n\ninnodb中无论是查询还是写绝大部分都是在buffer pool中进行操作的，它相当于innodb的缓存区，可以通过show engine innodb status来查看buffer pool的使用情况；可以通过innodb_buffer_pool_size来设置buffer pool的大小，线上不要吝啬给几个G内存都是正常的，但无论给多大内存都会有不够的时候，innodb采用了变种的LRU算法对数据页进行淘汰\n\n参考文献：https://cloud.tencent.com/developer/article/1828772\n\n### 覆盖索引\n\n覆盖索引的好处：\n\n1. 避免InnoDB的回表\n2. 将随机IO变为顺序IO：覆盖索引的 B+ 树叶子节点中，索引键值按升序排列（例如联合索引 `(a, b)` 会先按 `a` 排序，再按 `b` 排序）。当执行范围查询（如 `WHERE a > 10 AND a < 20`）时，所需数据在索引中是连续存储的，磁盘可以一次性顺序读取多个相邻数据页，避免跳跃式寻址\n\n### InnoDB相比于MyISAM的优势\n\n事务支持和ACID特性\n\n行级锁\n\n索引结构的优化（数据和索引文件在一起）\n\n多版本并发控制（MVCC）\n\nredo log，支持崩溃后的安全恢复\n\n### 表级锁和行级锁\n\n表级锁：针对非索引字段加的锁\n\n行级锁：**针对索引字段加的锁**\n\n### 最左匹配原则\n\n使用联合索引的过程中，MySQL根据索引中的字段从左到右依次匹配查询条件\n\n如果匹配，就会使用索引\n\n最左匹配原则会一直向右匹配，直到遇到范围查询（如 >、<）为止。对于 >=、<=、BETWEEN 以及前缀匹配 LIKE 的范围查询，不会停止匹配\n\n### 索引失效\n\nhttps://mp.weixin.qq.com/s/mwME3qukHBFul57WQLkOYg\n\n- 不符合最左匹配原则\n- select *不会影响索引，但是会二次回表\n- 使用函数\n- 计算\n- 非前缀匹配\n- in的范围太大\n\n### SQL优化\n\nhttps://www.nowcoder.com/discuss/730039197121155072\n\nB+树不要超过三层：https://juejin.cn/post/7165689453124517896\n\n## 计算机网络\n\n### TCP/IP 四层模型\n\n应用层\n\n传输层\n\n网络层\n\n网络接口层\n\n#### 应用层\n\n提供两个终端设备上应用程序之间信息交换的服务，定义信息交换的格式\n\nhttp协议；smtp协议；pop3/imap协议；ftp协议；dns协议\n\n#### 传输层\n\n负责两台终端设备进程的通信提供通用的数据传输服务\n\ntcp协议\n\nudp协议\n\n#### 网络层\n\n负责分组交换网络上不同主机提供通信服务，负责路由和转发\n\nip协议\n\narp协议\n\nicmp协议\n\nnat协议\n\nospf/rip\n\n#### 网络接口层\n\n- 数据链路层：将网络层交下来的IP数据包组装成数据帧\n- 物理层：负责计算机节点之间比特流的透明传输\n\n### HTTP状态码\n\n![常见 HTTP 状态码](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/http-status-code-20250303-095853.png)\n\n**200 OK**：请求被成功处理。例如，发送一个查询用户数据的 HTTP 请求到服务端，服务端正确返回了用户数据。这个是我们平时最常见的一个 HTTP 状态码。\n\n**201 Created**：请求被成功处理并且在服务端创建了一个新的资源。例如，通过 POST 请求创建一个新的用户。\n\n**202 Accepted**：服务端已经接收到了请求，但是还未处理。例如，发送一个需要服务端花费较长时间处理的请求（如报告生成、Excel 导出），服务端接收了请求但尚未处理完毕。\n\n**204 No Content**：服务端已经成功处理了请求，但是没有返回任何内容。例如，发送请求删除一个用户，服务器成功处理了删除操作但没有返回任何内容。\n\n---\n\n**301 Moved Permanently**：资源被永久重定向了。比如你的网站的网址更换了。\n\n**302 Found**：资源被临时重定向了。比如你的网站的某些资源被暂时转移到另外一个网址。\n\n---\n\n**400 Bad Request**：发送的 HTTP 请求存在问题。比如请求参数不合法、请求方法错误。\n\n**401 Unauthorized**：未认证却请求需要认证之后才能访问的资源。\n\n**403 Forbidden**：直接拒绝 HTTP 请求，不处理。一般用来针对非法请求。\n\n**404 Not Found**：你请求的资源未在服务端找到。比如你请求某个用户的信息，服务端并没有找到指定的用户。\n\n---\n\n**500 Internal Server Error**：服务端出问题了（通常是服务端出 Bug 了）。比如你服务端处理请求的时候突然抛出异常，但是异常并未在服务端被正确处理。\n\n**502 Bad Gateway**：我们的网关将请求转发到服务端，但是服务端返回的却是一个错误的响应。\n\n### http和https的区别\n\nhttps是基于http，使用tcp作为底层协议，额外使用ssl/tls协议作为加密和安全认证。默认端口是443.\n\n### QUIC协议\n\nhttp3.0开始使用quic协议。\n\n1. 协议僵化：tcp协议升级困难，quic基于udp实现，可在用户态灵活迭代\n2. 队头阻塞\n3. 连接迁移问题：QUIC 使用 **Connection ID** 标识连接，网络切换时无缝迁移连接，无需重建\n4. QUIC 具有更高级别的加密 ，TCP 本身不做数据加密，依赖于 TLS\n\n### WebSocket\n\n基于TCP连接的全双工通信协议，客户端和服务器可以同时发送和接收数据\n\n应用层的协议，用于弥补http在持久化通信能力上的不足\n\n![image-20250303160210979](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250303160210979-20250303-160211.png)\n\n### tcp保障可靠性的7种方式\n\n1. 数据块传输\n2. 序列号\n3. 数据校验\n4. 流量控制\n5. 拥塞控制\n6. 确认机制\n7. 超时重传\n\n### 挥手过程中的状态\n\n| **状态**       | **触发方** | **阶段**                     | **持续时间**               |\n| -------------------- | ---------------- | ---------------------------------- | -------------------------------- |\n| **TIME_WAIT**  | 主动关闭方       | 发送最后一个 `ACK`后             | 固定 `2MSL`（约1-4分钟）       |\n| **CLOSE_WAIT** | 被动关闭方       | 收到 `FIN`但未发送自己的 `FIN` | 理论上应短暂（实际可能长期存在） |\n\n### tcp和udp的区别\n\n1. 是否面向连接：udp传输数据之前不需要先建立连接，tcp则是提供面向连接的服务（必须先建立连接，传输结束后也需要释放连接）\n2. 是否是可靠传输：udp收到udp报文后，不需要给出任何确认；tcp则通过各种机制保证数据的可靠传输（无差错、不丢失、不重复、按序到达）\n3. 是否有状态：和上面差不多，就是tcp会维护数据的状态\n4. 传输效率：udp高很多\n5. 传输形式：tcp面向字节流，udp则面向报文\n6. 首部开销：tcp（20-60字节），udp（8字节）\n7. tcp只能点对点，而udp可以一对一、一对多、多对一等等。\n\n|                        | TCP            | UDP        |\n| ---------------------- | -------------- | ---------- |\n| 是否面向连接           | 是             | 否         |\n| 是否可靠               | 是             | 否         |\n| 是否有状态             | 是             | 否         |\n| 传输效率               | 较慢           | 较快       |\n| 传输形式               | 字节流         | 数据报文段 |\n| 首部开销               | 20 ～ 60 bytes | 8 bytes    |\n| 是否提供广播或多播服务 | 否             | 是         |\n\n### SYN洪流攻击\n\nSYN Flood是最经典的DDos攻击\n\n利用了TCP的三次握手（SYN->SYN/ACK->ACK），进入半连接状态，使得资源耗尽\n\n预防手段：\n\n1. 增加半连接工作队列数量\n2. 回收最先创建的tcp半连接\n3. syn cookie\n\n## 操作系统\n\n### 进程和线程的区别\n\n1. 线程是进程划分为更小的运行单位，进程执行过程中可以产生多个线程\n2. 线程共享资源，可以互相影响；进程基本是独立的\n3. 线程执行开销小，进程则比较大\n\n### 线程间同步的方式\n\n1. 互斥锁\n2. 读写锁\n3. 信号量\n4. 屏障\n5. 事件（wait/notify）\n\n### 进程间通信方式\n\n1. 匿名管道（父子进程）/ 有名管道\n2. 信号量\n3. 共享内存\n4. 消息队列\n5. 套接字\n\n### 父子进程\n\n**子进程拷贝父进程数据的核心机制是写时复制（Copy-On-Write, COW）**。这一设计在Linux系统中通过 `fork()`系统调用实现，兼顾性能与资源利用率\n\n![image-20250315152502507](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250315152502507-20250315-152503.png)\n\n典型场景：Redis利用COW实现快照持久化，子进程直接读取父进程内存生成RDB文件\n\n![image-20250315185109713](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250315185109713-20250315-185110.png)\n\n### 银行家算法\n\nhttps://cloud.tencent.com/developer/article/2108439\n\n### 零拷贝机制\n\n**零拷贝（Zero-Copy）**是一种计算机系统优化技术，旨在减少或消除数据在内存中的冗余拷贝操作，从而降低CPU开销、提升数据传输效率。其核心思想是：**通过硬件或操作系统级优化，避免CPU参与数据在用户空间与内核空间之间的复制过程**，直接在内核态完成数据传输\n\n<img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250315212414718-20250315-212415.png\" alt=\"image-20250315212414718\" style=\"zoom:50%;\" />\n\n基本过程理解：https://www.bilibili.com/video/BV1RxcoeLE5x\n\nmmap：实现内核缓冲区和用户缓冲区之间的映射关系（避免CPU的拷贝过程）\n\n### cpu三级缓存\n\n**解决速度差异问题** CPU的执行速度远高于内存和磁盘，三级缓存通过**缩短数据访问路径**，减少CPU等待数据的时间，缓解“内存墙”问题。\n\n- **速度对比**：寄存器 > L1 > L2 > L3 > 内存 > 磁盘\n- **性能提升**：约95%的数据访问可通过缓存完成，仅5%需访问内存，极大减少延迟\n\n核心目的：CPU与内存速度差异大，缓存通过空间换时间减少访问延迟\n\n## Spring\n\n### 注解\n\n<img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250304221412002-20250304-221412.png\" alt=\"image-20250304221412002\" style=\"zoom:50%;\" />\n\n### Spring自动装配原理\n\nSpring 自动装配的核心目标是**通过约定大于配置的方式，自动加载符合条件的 Bean 到容器中**\n\n![image-20250309102948593](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250309102948593-20250309-102949.png)\n\n按需装配\n\n### BeanFactory 和 FactoryBean\n\n| **BeanFactory**                                                                                                                                  | **FactoryBean**                                                                                                                                               |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Spring 的核心接口**，是 IOC 容器的顶层设计，负责 Bean 的实例化、配置和管理。它是 Spring 工厂模式的实现，如 `ApplicationContext` 是其子接口。 | **特殊的 Bean**，本身是一个 Bean，但实现了工厂模式，用于创建其他 Bean 实例。例如 MyBatis 的 `SqlSessionFactoryBean` 和 Spring AOP 的 `ProxyFactoryBean`。 |\n| **角色**：IOC 容器的管理者，提供 Bean 的基础操作（如 `getBean`、`isSingleton`） 。                                                           | **角色**：Bean 的生产工厂，通过 `getObject()` 方法返回目标对象，而非自身实例。                                                                              |\n\n### Bean的生命周期\n\n![img](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/spring-bean-lifestyle-20250226-125000.png)\n\n### Bean加载问题\n\n**默认扫描范围**： Spring 默认仅扫描主配置类（如 `@SpringBootApplication` 标注的类）所在的包及其子包。若类位于其他包中，需通过 `@ComponentScan` 显式指定扫描路径\n\n```java\n@SpringBootApplication\n@ComponentScan(basePackages = \"com.example.custom.package\")\npublic class App { /*...*/ }\n```\n\n若配置了 `@ComponentScan` 的 `excludeFilters` 或 XML 的 `<context:exclude-filter>`，相关类可能被排除\n\n### Spring的循环依赖\n\nSpring使用三级缓存来解决循环依赖问题：\n\n1. 一级缓存singletonObjects：存储最终形态的Bean\n2. 二级缓存earylySingletonObjects：存储半成品Bean，即三级缓存ObjectFactory产生的对象。主要是为了AOP机制下， 每次产生新的代理对象\n3. 三级缓存singletonFactories：存放ObjectFactory，ObjectFactory的getObject()方法（最终调用的是getEarlyBeanReference()方法）可以生成原始 Bean 对象或者代理对象（如果 Bean 被 AOP 切面代理）\n\n创建Bean的具体流程如下：\n\n1. 先去一级缓存singletonObjects获取，存在就返回；\n2. 不存在，去二级缓存中获取\n3. 仍然不存在，就在三级缓存获取到对应的objectFactory（并调用对应的getObject()）方法\n\n具体解决循环依赖的方法如下：\n\n1. Spring创建A时，A依赖了B，但是B又依赖了A\n2. 由于A还没有初始化完成，因此在一二级缓存中没有A\n3. 那么就去三级缓存调用getObject()方法获取A的早期暴露对象，放入二级缓存中，并注入到B中去\n\n在AOP模式下存在的二级缓存：\n\n确保多个对早期引用的请求，也返回同一个代理对象\n\n### @Transactional\n\nSpring中事务管理最关键的三个接口：\n\n- PlatformTransactionManager：事务管理器，Spring事务策略的核心\n- TransactionDefinition：事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)\n- TransactionStatus：事务运行状态\n\n#### 事务传播行为\n\n解决业务层方法之间互相调用的事务问题\n\nPropagation_Required：外部有事务，加入外部；外部没有，则自己新建一个事务（互相影响）\n\nPropagation_requires_new：创建一个事务，把外部事务挂起（内部影响外部，外部不影响内部）\n\nPropagation_nested：内部不会影响外部，外部会影响外部\n\n#### 注解失效\n\n- 只能作用在public方法上，其他不生效\n- 当一个方法被标记@Transactional注解的时候，Spring 事务管理器只会在被其他类方法调用的时候生效，而不会在一个类中方法调用生效。\n\n#### 相关面试题\n\n> 1. 一个类的内部有A，B两个方法，其中B开启了事务，我在A中调用B，事务生效吗？\n> 2. 这种情况下如何让事务生效？\n\n在同一个类中，若方法A直接调用带有 `@Transactional`注解的方法B，**事务不会生效**。其核心原因在于Spring的事务管理基于AOP代理机制实现，而同类内部调用会绕过代理，直接通过目标对象执行，导致事务拦截失效。\n\n解决方法：\n\n- 拆分到不同的类\n- 自我注入：注入一个自己类对象\n\n  ```java\n  @Service  \n  public class MyService {  \n    \t// 需要开启循环依赖支持\n      @Autowired  \n      private MyService self;  \n  }\n  ```\n- 获取当前代理对象：((MyService) AopContext.currentProxy()).methodB();   或者获取代理Bean对象\n\n### Spring Cloud Gateway\n\n![img](https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/springcloud-gateway-%20demo.png)\n\n三个关键组件：\n\n- **Route 路由**：Spring Cloud Gateway最基本的单元，定义了请求的匹配规则和转发目标。通过配置路由，可以将请求映射到后端服务实例或者URL上。路由规则根据请求的路径、方法或者请求头等条件进行匹配（断言），指定转发的目标URL\n- **Predicate 断言**：用于匹配请求的目标，如果满足断言的条件，就会应用所配置的过滤器。内置多种断言方式，如Path（路径匹配）、Method（请求方法匹配）等\n- **Filter 过滤器**：对请求进行转换和处理，可以修改请求、响应和自定义逻辑。提供了多个内置的过滤器，如请求转发、请求重试、请求限流等。\n\n具体工作流程：\n\n![Spring Cloud Gateway 的工作流程](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/spring-cloud-gateway-workflow-20250315-144117.png)\n\n1. **路由判断**：客户端的请求到达网关后，先经过 Gateway Handler Mapping 处理，这里面会做断言（Predicate）判断，看下符合哪个路由规则，这个路由映射后端的某个服务。\n2. **请求过滤**：然后请求到达 Gateway Web Handler，这里面有很多过滤器，组成过滤器链（Filter Chain），这些过滤器可以对请求进行拦截和修改，比如添加请求头、参数校验等等，有点像净化污水。然后将请求转发到实际的后端服务。这些过滤器逻辑上可以称作 Pre-Filters，Pre 可以理解为“在...之前”。\n3. **服务处理**：后端服务会对请求进行处理。\n4. **响应过滤**：后端处理完结果后，返回给 Gateway 的过滤器再次做处理，逻辑上可以称作 Post-Filters，Post 可以理解为“在...之后”。\n5. **响应返回**：响应经过过滤处理后，返回给客户端。\n\n#### 内部调用\n\n微服务A和B在注册中心注册后，可通过内部服务名（如 `payment-service`）直接调用，无需经过网关\n\n**注册中心的健康检查**\n\n- **心跳检测**：服务实例定期向注册中心发送心跳（如Eureka默认30秒一次），若超时未收到心跳（Eureka默认90秒），则标记实例为不可用并剔除\n- **主动探针**：Nacos支持TCP/HTTP主动探针，实时检测服务健康状态\n\n**客户端的动态更新**\n\n- **本地缓存**：客户端（如Ribbon）会定期从注册中心拉取最新服务列表（默认30秒），并缓存到本地。当某节点挂掉时，客户端在下一次请求时会自动跳过该节点\n- **故障转移**：负载均衡器（如Ribbon）在调用失败时自动重试其他可用实例（默认不重试，需配置 `RetryPolicy`）\n\n#### 内部绕过鉴权\n\n其实内部也不需要再鉴权了\n\n内部请求的时候添加请求头：\n\n```java\n// 内部服务调用时添加请求头\nwebClient.get()\n    .uri(\"http://internal-service/api/data\")\n    .header(\"X-Internal\", \"true\")\n    .retrieve();\n```\n\n**结合IP白名单限制**\n\n- 网关配置：在网关过滤器中校验请求来源IP是否属于内部网络\n\n```java\n@Component\npublic class InternalIpFilter implements GlobalFilter {\n    @Override\n    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {\n        String clientIp = exchange.getRequest().getRemoteAddress().getAddress().getHostAddress();\n        // 判断是否是内部的请求\n      \tif (isInternalIp(clientIp) && exchange.getRequest().getHeaders().containsKey(\"X-Internal\")) {\n            return chain.filter(exchange);\n        }\n      \t// 外部就需要校验\n        return checkAuth(exchange, chain);\n    }\n}\n```\n\n**临时Token+请求头**\n\n内部服务调用时生成带时效和签名的Token（如JWT），网关验证Token有效性\n\n#### 服务发现\n\n| **注册中心**   | **一致性模型** | **功能扩展**  | **适用场景**            |\n| -------------------- | -------------------- | ------------------- | ----------------------------- |\n| **Eureka**     | AP                   | 服务注册与发现      | Spring Cloud 传统架构         |\n| **Consul**     | CA（最终一致）       | 多数据中心、KV 存储 | 混合云或复杂网络环境          |\n| **Nacos**      | AP/CP 可选           | 动态配置管理        | 云原生、多环境配置统一        |\n| **ZooKeeper**  | CP                   | 分布式协调          | 强一致性要求的金融或交易系统  |\n| **Etcd**       | CP                   | 键值存储            | Kubernetes 集群或分布式数据库 |\n| **Kubernetes** | 无独立模型           | 容器编排集成        | 已容器化的云原生应用          |\n\n### **总结**\n\n- **中小型项目**：优先选择 **Nacos**（功能全面）或 **Consul**（多数据中心）。\n- **强一致性需求**：选择 **ZooKeeper** 或 **Etcd**。\n- **云原生环境**：直接使用 **Kubernetes 原生服务发现**。\n- **历史系统迁移**：若原用 Eureka，可逐步过渡到 Nacos 以兼容 Spring Cloud 生态\n\n## Redis\n\n### 分布式\n\n主从复制：Redis集群（master负责写请求，slave负责读请求）\n\n<img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/1676964296594-1f216792-7828-4e11-bd01-d30c63a37f89-20250304-160612.png\" alt=\"img\" style=\"zoom: 50%;\" />\n\n### 延迟双删策略\n\n**延迟双删策略**是用于维护数据库（如 MySQL）与 Redis 缓存之间数据最终一致性的常见方案。其核心步骤为：\n\n1. **第一次删除缓存**：在更新数据库前，先删除 Redis 中的缓存数据，避免其他线程在数据库更新期间读取到旧数据。\n2. **更新数据库**：执行数据库的写入操作。\n3. **第二次延迟删除缓存**：在数据库更新完成后，延迟一段时间（如 1-5 秒），再次删除缓存。此步骤的目的是防止在数据库主从同步延迟期间，其他线程将旧数据重新写入缓存\n\n| **方案**                    | **一致性强度** | **复杂度** | **适用场景**           |\n| --------------------------------- | -------------------- | ---------------- | ---------------------------- |\n| **延迟双删**                | 最终一致性           | 低               | 高频更新、容忍短暂不一致     |\n| **先更新数据库再删缓存**    | 更高一致性           | 中               | 强一致性要求（如金融交易）   |\n| **Canal 监听 binlog**       | 最终一致性           | 高               | 无需侵入业务代码的大规模系统 |\n| **分布式锁（如 Redisson）** | 强一致性             | 高               | 对性能要求低、强一致性场景   |\n\n缓存和数据库一致性：https://mp.weixin.qq.com/s?__biz=MzIyOTYxNDI5OA==&mid=2247487312&idx=1&sn=fa19566f5729d6598155b5c676eee62d&chksm=e8beb8e5dfc931f3e35655da9da0b61c79f2843101c130cf38996446975014f958a6481aacf1&scene=178&cur_album_id=1699766580538032128#rd\n\n流行的解决方案：**订阅数据库变更日志，再操作缓存**。\n\n具体来讲就是，我们的业务应用在修改数据时，「只需」修改数据库，无需操作缓存。\n\n那什么时候操作缓存呢？这就和数据库的「变更日志」有关了。\n\n拿 MySQL 举例，当一条数据发生修改时，MySQL 就会产生一条变更日志（Binlog），我们可以订阅这个日志，拿到具体操作的数据，然后再根据这条数据，去删除对应的缓存。\n\n<img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/640-20250306-204147.jpg\" alt=\"图片\" style=\"zoom:50%;\" />\n\n整体流程如下：\n\n- **监听Binlog**：通过中间件（如Canal、Maxwell）模拟MySQL从库，实时捕获Binlog事件。\n- **数据转换**：将Binlog中的操作转换为Redis命令（如SET、DEL），保证缓存与数据库操作一致。\n- **异步处理**：通过消息队列（如Kafka、RocketMQ）解耦，实现削峰填谷和失败重试\n\n### k-v结构\n\nRedis 使用一个**全局哈希表**（`dict`）来存储所有键值对，哈希表的结构如下：\n\n- **哈希桶（Hash Bucket）**：通过哈希函数将键（Key）映射到哈希桶中，每个桶存储指向具体键值对的指针；\n- **哈希节点（`dictEntry`）**：每个节点包含键、值指针以及指向下一个节点的指针（用于解决哈希冲突）\n\n哈希表的调整：\n\n- **渐进式 Rehash**：当哈希表负载因子（元素数量 / 哈希表大小）超过阈值时，Redis 会启动渐进式 Rehash，逐步将数据从旧哈希表迁移到新哈希表，避免一次性迁移导致的性能抖动\n\n### 看门狗机制\n\n![image-20250321155521729](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250321155521729-20250321-155522.png)\n\n后台线程池：执行续期操作\n\n时间轮算法：异步原子地续期\n\n## Java\n\n### 多态的两种表现\n\n1. 编译时多态\n\n- 方法重载\n\n2. 运行时多态：运行时才能确定\n\n- 方法重写\n- 接口实现\n\n运行时多态的实现机制：\n\n- **动态绑定**：JVM 在运行时根据对象类型解析方法调用地址\n- **虚方法表（VTable）**：存储类的方法地址，子类重写方法会覆盖虚表中的父类方法指针\n\n### throw和throws\n\n```java\npublic void str2int(String str) throws Exception { //这里将得到的异常向外抛出，可以抛出多个\n    try {\n        System.out.println(Integer.parseInt(str));\n    } catch(NumberFormatException e) {\n        //TODO 这里可以做一些处理，处理完成后将异常报出，让外层可以得到异常信息\n        throw new Exception(\"格式化异常\");\n    }\n}\n```\n\n### Java性能分析\n\n使用top初步定位进程，之后通过jstack找到对应线程的堆栈信息\n\n- jconsole也是一个查看当前java进程运行情况，可以检测死锁。jconsole可以分析出来内存情况，以及能看到线程状态。结合运行前的heapdumppath，可以分析出当前堆内存占用情况，找到时哪一段对应变量造成的，从而定位问题\n- jstack：生成虚拟机当前时刻的线程快照。 用于生成 Java 进程在**某个时间点**的所有线程堆栈信息，帮助定位死锁、死循环、资源等待等问题\n\n### JVM内存分配\n\nJVM给对象分配内存有多种策略。\n\n1. 基于堆内存的常规分配：\n   - 指针碰撞\n   - 空闲列表\n2. 多线程分配优化：\n   - CAS+重试\n   - 线程本地分配缓冲TLAB\n3. 特殊场景：\n   - 栈上分配：通过**逃逸分析**确定对象生命周期不逃逸出方法（直接在栈帧中分配，结束后自动销毁，避免堆内存分配）\n\n逃逸分析：JVM在编译期或运行时的优化技术，主要用于分析对象的动态作用域，判断是否会被外部方法或线程访问。核心目的是减少堆内存分配、同步开销和对象生命周期管理成本。\n\n根据分析结果，会应用以下优化技术：\n\n- **栈上分配**：若对象未逃逸（仅在当前线程或方法内使用），JVM 可将对象分配在栈帧中，随方法结束自动销毁，无需垃圾回收\n- **标量替换**：若对象未逃逸且结构简单，JVM 会将其拆解为独立的标量（如 `int`、`double`）或字段，直接存储在栈或寄存器中\n- **同步消除**：若对象未逃逸且仅被单线程访问，JVM 会移除其同步锁（如 `synchronized` 块）\n\n### CPU空转问题\n\nCPU 空转通常由未合理阻塞的循环或锁竞争引起。JVM 通过自适应自旋锁和锁升级机制减少无效空转，开发者需结合以下策略：\n\n1. **代码层面**：用阻塞方法（如 `take()`）替代轮询，设置自旋超时，利用线程池控制并发。\n2. **工具定位**：通过 `jstack` 或 Arthas 定位高 CPU 线程，分析是否为自旋锁或死循环。\n3. **锁优化**：评估锁粒度，优先使用 `ReentrantLock` 替代 `synchronized`，结合条件变量减少竞争（如网页43的锁示例）。 例如，某压测场景中，通过火焰图定位到 `while(true)` 空循环，添加 `Thread.sleep(50)` 后 CPU 从 95% 降至正常水平\n\n### 线程池\n\n线程池参数，过期时间的意义，超出核心线程数的会被回收吗，非核心线程会被回收吗？怎么判断他要不要回收，怎么知道他过期了的。那我创建十个线程，1~10,核心数8个，9和10还在执行任务，1~8不执行了，这时候会怎么做。\n说说线程池的阻塞队列有什么用，为什么用阻塞队列不用普通队列，在并发情况下，往队列中加任务不会有线程安全问题吗。\n\nTODO\n\n### callable和runnable区别\n\n| **对比维度** | **Runnable**                                 | **Callable**                                                             |\n| ------------------ | -------------------------------------------------- | ------------------------------------------------------------------------------ |\n| **接口定义** | `public interface Runnable { void run(); }`      | `public interface Callable<V> { V call() throws Exception; }`                |\n| **返回值**   | **无返回值**（`void`）                     | **有返回值**（泛型类型 `V`）                                           |\n| **异常处理** | 无法抛出受检异常（必须内部 `try-catch` 处理）    | 允许抛出受检异常（通过 `Future.get()` 捕获 `ExecutionException` 获取原因） |\n| **执行方式** | 通过 `Thread` 或 `Executor.execute()` 直接执行 | 必须通过 `ExecutorService.submit()` 提交，返回 `Future` 对象               |\n| **任务管理** | 无状态追踪，无法取消任务或获取结果                 | 通过 `Future` 管理任务状态（取消、超时、结果查询）                           |\n| **泛型支持** | 不支持                                             | 支持（通过泛型指定返回值类型，如 `Callable<String>`）                        |\n\n### 反射\n\n反射的核心方法是invoke，通过调用jvm内部的native方法，完成动态方法调用\n\n#### 性能影响\n\n1. 动态解析和运行时开销：需要动态加载类、解析方法/字段的元数据，这些操作在直接调用中是由编译器完成的\n2. 方法调用的性能损失：反射调用（如 `method.invoke()`）无法享受 JIT 编译器的优化（如方法内联），导致执行速度比直接调用慢约 **10-30倍**\n\n优化方向：\n\n- 缓存反射元数据：将频繁使用的 `Method`、`Field` 对象缓存起来，避免重复解析\n- 使用高性能反射库：如**Spring的 `ReflectionUtils`**\n\n### 泛型机制\n\nJava的泛型是伪泛型，在编译期间所有泛型信息都会被擦除，也就是类型擦除。\n\n即使泛型擦除存在，但是使用泛型仍然存在一系列好处：\n\n- 可以在编译期间进行类型检查\n- 使用Object类型需要手动添加强制类型转换\n\n泛型可以增强代码的可读性和稳定性，编译器会对泛型参数进行检测（指定传入对象的类型）\n\n### 并发的同步\n\nSynchronized 关键字\n\nLock接口及其实现类\n\n原子类\n\n并发集合\n\n读写锁\n\n线程同步工具（CountdownLatch、Semaphore）\n\n### 并发编程的三个特性\n\n1. **原子性**\n\n一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。\n\n在 Java 中，可以借助 `synchronized`、各种 `Lock` 以及各种原子类实现原子性。\n\n`synchronized` 和各种 `Lock` 可以保证任一时刻只有一个线程访问该代码块，因此可以保障原子性。各种原子类是利用 CAS (compare and swap) 操作（可能也会用到 `volatile`或者 `final`关键字）来保证原子操作。\n\n2. **可见性**\n\n当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。\n\n在 Java 中，可以借助 `synchronized`、`volatile` 以及各种 `Lock` 实现可见性。\n\n如果我们将变量声明为 `volatile` ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。\n\n3. **有序性**\n\n在 Java 中，`volatile` 关键字可以禁止指令进行重排序优化。\n\n### AQS\n\n参考文献：https://mp.weixin.qq.com/s/jEx-4XhNGOFdCo4Nou5tqg\n\n抽象类，为同步器提供了通用的执行框架。定义了资源获取和释放的通用流程，具体的资源获取和释放则通过模版方法来实现。\n\n性能好的点在于：**CAS+线程阻塞/唤醒**\n\n**核心思想**：如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态\n\n### synchronized和Lock的区别\n\n| **维度**       | **synchronized**       | **Lock**                  |\n| -------------------- | ---------------------------- | ------------------------------- |\n| **锁释放**     | 自动释放（代码块结束或异常） | 手动释放（需 `unlock()`）     |\n| **公平性**     | 仅非公平锁                   | 支持公平锁与非公平锁            |\n| **中断响应**   | 不支持                       | 支持（`lockInterruptibly()`） |\n| **锁状态检测** | 无法判断                     | 可检测（`tryLock()`）         |\n| **性能**       | 低竞争场景优                 | 高竞争场景优                    |\n| **适用场景**   | 简单同步、快速开发           | 复杂逻辑、高并发优化            |\n\n从底层实现上：\n\n- synchronized是java的关键词，由jvm直接管理，通过字节码指令 `monitorenter`和 `monitorexit`实现（还有锁升级机制）\n- Lock是类，实现包括：\n  - 乐观锁，基于volatile变量和CAS算法实现\n  - `ReentrantLock` 通过 AQS 维护锁状态和等待队列，支持可重入性和公平性\n\n### Future和CompletableFuture\n\n应用为主\n\nCompletableFuture支持任务之间的并行调用，在等待A任务执行完之后执行另外的任务，也支持组合两个任务，等待两个任务同时执行完毕\n\n### ForkJoinPool\n\n![image-20250310163700719](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250310163700719-20250310-163702.png)\n\nCompletableFuture如果不自定义线程池，默认使用的全局线程池就是ForkJoinPool\n\n```java\npublic class MergeSortTask extends RecursiveAction {\n    private int[] array;\n    private int left, right;\n    private static final int THRESHOLD = 1000; // 拆分阈值\n\n    @Override\n    protected void compute() {\n        if (right - left <= THRESHOLD) {\n            Arrays.sort(array, left, right); // 小任务直接排序\n        } else {\n            int mid = (left + right) / 2;\n            invokeAll(\n                new MergeSortTask(array, left, mid),\n                new MergeSortTask(array, mid, right)\n            );\n            merge(array, left, mid, right); // 合并结果\n        }\n    }\n}\n// 使用方式\nForkJoinPool pool = new ForkJoinPool();\npool.invoke(new MergeSortTask(arr, 0, arr.length));\n```\n\n```java\nimport java.util.concurrent.ForkJoinPool;\nimport java.util.concurrent.RecursiveTask;\n\npublic class ForkJoinSumCalculator extends RecursiveTask<Long> {\n    private final long[] array;\n    private final int start;\n    private final int end;\n    private static final int THRESHOLD = 10_000; // 任务拆分阈值\n\n    public ForkJoinSumCalculator(long[] array) {\n        this(array, 0, array.length);\n    }\n\n    private ForkJoinSumCalculator(long[] array, int start, int end) {\n        this.array = array;\n        this.start = start;\n        this.end = end;\n    }\n\n    @Override\n    protected Long compute() {\n        int length = end - start;\n        // 如果任务足够小，直接计算\n        if (length <= THRESHOLD) {\n            return computeDirectly();\n        }\n        // 拆分任务：将大任务分为两个子任务\n        int mid = start + length / 2;\n        ForkJoinSumCalculator leftTask = new ForkJoinSumCalculator(array, start, mid);\n        ForkJoinSumCalculator rightTask = new ForkJoinSumCalculator(array, mid, end);\n\n        // 异步执行左半部分任务（fork）\n        leftTask.fork();\n\n        // 同步执行右半部分任务，并合并结果（join）\n        Long rightResult = rightTask.compute();\n        Long leftResult = leftTask.join();\n\n        return leftResult + rightResult;\n    }\n\n    // 直接计算区间和\n    private long computeDirectly() {\n        long sum = 0;\n        for (int i = start; i < end; i++) {\n            sum += array[i];\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        long[] array = new long[100_000];\n        for (int i = 0; i < array.length; i++) {\n            array[i] = i + 1; // 初始化数组为1~100000\n        }\n\n        // 创建ForkJoinPool并提交任务\n        ForkJoinPool pool = new ForkJoinPool();\n        Long result = pool.invoke(new ForkJoinSumCalculator(array));\n\n        System.out.println(\"计算结果: \" + result); // 应输出5000050000\n    }\n}\n```\n\n1. 避免饥饿：通过工作窃取机制，空闲线程主动从其他队列窃取任务，动态平衡负载（内部会为每一个线程简历一个工作队列）\n2. 合理设置任务拆分阈值（THRESHOLD）\n\n关键点：**分治策略** + **工作窃取**\n\n### Hash结构的数据解决哈希冲突的方法有哪些\n\n1. 开放定址法：哈希冲突发生时，按照特定的规则寻找下一个哈希地址\n2. 链地址法\n3. 再哈希法（使用备用哈希函数）\n4. 公共溢出区法\n\n### HashMap和HashTable的区别\n\n1. 线程安全性：HashMap线程不安全，HashTable线程安全（内部方法都通过synchronized关键词修饰）\n2. 效率：HashMap高于HashTable（为了保证线程安全，牺牲了性能）\n3. 对Null的支持：HashMap允许存在Null的key和value，而HashTable不允许\n4. 初始化容量：\n   - HashMap初始化大小为16，每次扩容两倍；如果设置了初始大小，就会设置为比初始大小大的2的幂次方\n   - HashTable初始大小为11，每次扩容2n+1；如果设置了初始大小，则直接使用初始大小\n5. 1.8后的HashMap存在链表转红黑树的过程\n6. HashMap对哈希值的高位和低位进行了扰动处理\n\n### 单例模式的破坏\n\n1. **反射绕过单例**\n\n```java\nClass<?> clazz = Singleton.class;\nConstructor<?> constructor = clazz.getDeclaredConstructor();\nconstructor.setAccessible(true);\nSingleton instance1 = (Singleton) constructor.newInstance();\nSingleton instance2 = (Singleton) constructor.newInstance();\nSystem.out.println(instance1 == instance2); // 输出 false\n```\n\n可以直接在构造函数中去进行实例检查：\n\n```java\nprivate Singleton() {\n    if (Inner.instance != null) {\n        throw new RuntimeException(\"禁止通过反射创建实例！\");\n    }\n}\n```\n\n注意懒汉式，还需要额外进行考虑，添加一个状态位：\n\n```java\nprivate static boolean flag = false;\nprivate Singleton() {\n    synchronized (Singleton.class) {\n        if (flag) throw new RuntimeException(\"禁止反射创建！\");\n        flag = true;\n      \tif (instance == null) {\n          ...\n\t\t\t\t}\n    }\n}\n```\n\n但是，状态位也可能会被反射更新。因此，懒汉式实现的单例模式是不可以防止被反射破坏的\n\n2. **序列化和反序列化对单例模式的破坏**\n\n单例类实现 `Serializable` 接口后，反序列化时会通过反射生成新对象，而非复用已有实例。\n\n解决方法：\n\n（1）枚举类会直接返回已有实例\n\n（2）添加readResolve()，返回已有实例。**`readResolve()` 是 Java 序列化机制中的一个特殊回调方法**，用于在反序列化过程中替换或控制最终返回的对象\n\n可以考虑实现单例模式的另外两种方案：\n\n1. **枚举单例** （最优方案）\n\n枚举类禁止创建反射单例（JVM禁止），也不需要依赖构造函数检查\n\n```java\npublic enum Singleton {\n    INSTANCE;\n    // 添加方法\n}\n```\n\n**优势**：无需手动防御反射，安全性最高\n\n2. 静态内部类\n\n```java\npublic class Singleton {\n    private static class Holder {\n        private static final Singleton INSTANCE = new Singleton();\n    }\n    private Singleton() {}\n  \n    public static Singleton getInstance() {\n        return Holder.INSTANCE;\n    }\n}\n```\n\n**原理**：静态内部类在首次调用 `getInstance()` 时才加载，JVM保证类加载过程的线程安全性\n\n### 新版本Java\n\nJava24发布了，最重要的一个特性：**虚拟线程的同步而不固定平台线程**\n\n优化了虚拟线程与 `synchronized` 的工作机制。虚拟线程在 `synchronized` 方法和代码块中阻塞时，通常能够释放其占用的操作系统线程（平台线程），避免了对平台线程的长时间占用，从而提升应用程序的并发能力。这种机制避免了“固定 (Pinning)”——即虚拟线程长时间占用平台线程，阻止其服务于其他虚拟线程的情况。\n\n现有的使用 `synchronized` 的 Java 代码无需修改即可受益于虚拟线程的扩展能力。例如，一个 I/O 密集型的应用程序，如果使用传统的平台线程，可能会因为线程阻塞而导致并发能力下降。而使用虚拟线程，即使在 `synchronized` 块中发生阻塞，也不会固定平台线程，从而允许平台线程继续服务于其他虚拟线程，提高整体的并发性能。\n\n**核心**：虚拟线程在被synchronized阻塞的时候，会释放掉所占用的平台线程\n\n**提前类加载和链接**：缓存已经加载和链接过的类，减少重复工作的开销（无侵入）\n\n### Spring Task\n\n`ScheduledThreadPoolExecutor` 是 JDK 自带的定时调度器，基于一个 **延时队列（DelayedWorkQueue）** 来管理任务：\n\n- 提交任务时，会计算出**下次执行的时间戳**，丢进延时队列。\n- 一个专门的工作线程会不断从队列里取“到期的任务”，放到线程池里去执行。\n- 如果是周期任务（fixedRate/fixedDelay），执行完毕后会**重新计算下次时间**，再放回队列\n\n默认使用`ThreadPoolTaskScheduler` 的线程池大小 = 1，也就是单线程顺序执行。因此，可以自己配置一个线程池：\n\n- **扫描 @Scheduled 注解** → 注册成定时任务。\n- **交给 TaskScheduler（默认 ThreadPoolTaskScheduler）** 管理。\n- **底层依赖 JDK 的 ScheduledThreadPoolExecutor**（基于延时队列实现）。\n- 周期任务 / Cron 任务：每次执行完毕后算出下一次执行时间，再丢回调度队列\n\n\n\n## Linux\n\nhtop查看内存占用情况，PID等信息\n\n![image-20250305125116718](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250305125116718-20250305-125117.png)\n\n### 处理大文件\n\n> Linux读取大文件进行文本替换\n\n**使用 `sed` 命令（流式处理，内存友好）**\n\n- **适用场景**：全局或局部替换文本，支持正则表达式。\n- **优势**：逐行处理文件，无需加载整个文件到内存。\n\n```shell\n# 替换文件中所有 \"old_text\" 为 \"new_text\"（直接修改原文件）\nsed -i 's/old_text/new_text/g' large_file.txt\n\n# 仅替换第 100 到 200 行的内容\nsed -i '100,200s/old_text/new_text/g' large_file.txt\n```\n\n![image-20250321125123282](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250321125123282-20250321-125126.png)\n\n## 数据结构\n\n### 红黑树\n\n1. 每个节点非黑即红，黑色代表平衡，红色代表不平衡；\n2. 根节点总是黑色的\n3. 每个叶子节点都是黑色的空节点（NIL 节点）。这里指的是红黑树都会有一个空的叶子节点，是红黑树自己的规则；\n4. 如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；\n5. 从任意节点到它的叶子节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。\n\n\n\n## Etcd\n\n### 备份过程数据的一致性\n\n原因在于它不是简单去拷贝数据文件，而是通过 **Raft 一致性和 etcd 的 MVCC 存储机制** 来保证\n\n- etcd 集群所有写入必须经过 **Raft 共识** 才能提交。\n- 当执行 `etcdctl snapshot save` 时，etcd 会选定一个**一致的 Raft 提交点**（commit index），以该时刻为快照边界\n- etcd 底层使用 **boltdb** 存储，并且有 **MVCC（多版本并发控制）索引层**\n\n综上，一致性保障来源于两方面：\n\n**Raft 共识 → 确保提交点一致**；\n\n**MVCC 快照 → 确保读取的是某个固定 revision 的全局状态**\n\n **MVCC 在这里的作用**就是：保证 `snapshot save` 读出的所有数据属于同一个 revision，不会前后混杂\n\n### Raft 而非 Paxos\n\n**Paxos**：理论优雅，但工程实现复杂，难以理解和维护；\n\n**Raft**：在保证相同一致性语义的前提下，更直观、更易实现和维护\n\n一句话总结：Raft 更工程友好，理解和实现成本更低，维护更容易\n\n\n\n### Etcd VS Zookeeper\n\nZookeeper的问题：\n\n**Watch 机制不足**\n\n- 触发一次就失效，需要重新注册；\n- 客户端多时容易引发“惊群效应”\n\n**一致性协议复杂**\n\n- ZAB 没有 Raft 那么直观，理解和验证成本高\n\n\n\n\n\n\n\n\n\n# 场景题\n\n## 算法\n\n智力题pdf： [场景题.pdf](场景题.pdf) \n\n### 最大的100个数字\n\n> 有很多个没有排序过的数字，想要找到其中最大的100个数字，怎么实现，时间复杂度是多少？\n\n1. 最小堆法：\n\n将前100个数构建为**最小堆**\n\n后续每个数，如果大于堆顶，那么就替换并且更新结构；否则就不需要\n\n建堆O(100)，后续每次处理为O(nlog100) = O(n)\n\n时间复杂度为：O（n）\n\n2. 快速选择算法：分区，找到第100大的元素。此时左边就是需要的\n\n平均O（n），最坏情况（n^2）\n\n3. 分治法（数据量过大的时候）：\n\n   将数据分成若干块（每块100万个），每块使用上述两种方法找到最大的100个数\n\n   合并top100，再次筛选\n\n   时间复杂度为O(n + mlogm + 100m)，m是块数\n\n### 大数据量的状态\n\n> 有一台16G内存的电脑，要保存2的32次方个qq号的状态，怎么设计，大概占多少内存空间？\n\n都用1位表示状态：\n\n2^32 * 1 / 8 =536,870,912 字节 = 512MB\n\n布隆过滤器近似计算\n\n### 查找高频词\n\n> 在内容安全工作中，常用高频词查找的需要。\n> 你需要在最多不超过 10^7 的单词中查找其中出现次数最多的 100 个，即 TOP100。\n> 为了简单起见，所有单词都已经被提取出来，每个单词由小写字母 a-z 组成，长度不超过 20 个字母。\n> 你需要使用尽可能小的内存空间和尽可能快的算法来找出这 100 个单词。\n> 样例1:\n> [输入]\n> 5\n> splunk\n> elastic\n> splunk\n> clickhouse\n> elastic\n\n先存储（用map或者trie？长度20的话，20*26=520 ）；用map也可以\n\n然后用最大的100个数字的方法\n\n### 统计10G电话号码\n\n> 10G的11位电话号码文件，2G内存，如何获取重复率最高的电话号码\n\n1. **哈希分片**：\n   - 将10G文件按电话号码的哈希值（如**取模**运算）分割为多个小文件，确保相同电话号码一定落入同一文件。例如，哈希函数设为 `hash(phone) % 1000`，生成1000个子文件，每个文件约10MB（假设电话号码均匀分布）\n2. 逐文件统计频率：\n   - 逐个读取子文件，在内存中统计每个文件的电话号码出现次数\n   - 记录当前文件的**最高频率号码**及其次数\n3. 全局汇总：\n   - 合并所有子文件的统计结果，计算全局最高频率\n   - 读取所有临时结果文件，使用**最小堆**或**外部排序**合并数据\n\n哈希分片 or bitmap（本题不适用） 是一种很重要的思想方法\n\n### 3次失败登陆锁定15分钟\n\n```java\npublic Result login(String username, String password) {\n    // 1. 检查是否已锁定\n    if (redis.exists(\"lock:\" + username)) {\n        return Result.error(\"账户已锁定，请15分钟后重试\");\n    }\n  \n    // 2. 验证用户名密码\n    User user = userService.findByUsername(username);\n    if (user != null && password.equals(user.getPassword())) {\n        // 登录成功：重置失败次数\n        redis.delete(\"login_fail:\" + username);\n        return Result.success();\n    } else {\n        // 3. 登录失败：递增失败次数\n        long count = redis.incr(\"login_fail:\" + username);\n        redis.expire(\"login_fail:\" + username, 900); // 15分钟滑动窗口\n      \n        // 4. 判断是否触发锁定\n        if (count >= 3) {\n            redis.setex(\"lock:\" + username, 900, \"locked\"); // 锁定15分钟\n            return Result.error(\"连续失败3次，账户已锁定\");\n        }\n        return Result.error(\"用户名或密码错误\");\n    }\n}\n```\n\n| **方案**          | **优点**                 | **缺点**                  | **适用场景**       |\n| ----------------------- | ------------------------------ | ------------------------------- | ------------------------ |\n| **纯数据库实现**  | 无需额外中间件，数据持久化可靠 | 高并发下性能瓶颈，锁竞争严重    | 低并发、数据一致性要求高 |\n| **Redis+数据库**  | 高性能，自动过期，易于扩展     | 依赖Redis可用性，需处理缓存穿透 | 中高并发，实时性要求高   |\n| **分布式锁+计数** | 支持分布式部署，强一致性       | 实现复杂，运维成本高            | 大型系统，多节点协同     |\n\n### 秒杀场景\n\n**数据库层面的解决方案**\n\n乐观锁：在商品表中增加 `version`字段，每次更新库存时校验版本号是否一致\n\n唯一索引+条件更新：\n\n创建用户购买记录表，对 `(uid, goods_id)`添加唯一索引，防止重复购买\n\n**redis实现分布式锁**\n\n在锁内执行库存预减和订单生成逻辑\n\n```java\n// 加锁示例（Redisson实现）\nRLock lock = redissonClient.getLock(\"lock:product_1\");\nlock.lock(10, TimeUnit.SECONDS);\ntry {\n    int stock = redis.get(\"product_stock_1\");\n    if (stock > 0) {\n        redis.decr(\"product_stock_1\");\n        // 异步生成订单\n        sendToMQ(order);\n    }\n} finally {\n    lock.unlock();\n}\n```\n\n**原子性初始化** 使用Redis的 `SET`命令结合 `NX`（不存在时设置）选项，确保库存仅被初始化一次。例如：\n\n```sh\nSET product:stock 50 NX  # 仅当键不存在时设置库存为50\n```\n\n**Lua脚本实现原子操作** 通过Lua脚本在Redis服务端**原子性校验并扣减库存**，避免并发下的数据不一致。脚本逻辑如下\n\n```lua\n-- KEYS[1]: 库存键（如product:stock）\n-- ARGV[1]: 扣减数量（如1）\nlocal stock = tonumber(redis.call('get', KEYS[1]))\nif stock >= tonumber(ARGV[1]) then\n    return redis.call('decrby', KEYS[1], ARGV[1])\nelse\n    return -1  -- 库存不足\nend\n```\n\n![image-20250321155154531](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250321155154531-20250321-155154.png)\n\n### 多线程任务场景\n\n> 开一个线程池，5个核心线程，10个任务，保证10个任务执行完，再执行主线程的一些任务\n\n```java\nThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 10, 10, TimeUnit.SECONDS,\n        new ArrayBlockingQueue<>(5));\n\n// 10个执行完才能够执行其他的\nCountDownLatch countDownLatch = new CountDownLatch(10);\n\n// 10个任务\nRandom random = new Random();\nfor (int i = 0; i < 10; ++i) {\n    int finalI = i + 1;\n    threadPoolExecutor.submit(() -> {\n        try {\n            System.out.println(\"任务\" + finalI);\n            Thread.sleep(random.nextInt(500) + 1000);\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        } finally {\n            countDownLatch.countDown();\n        }\n\n    });\n}\ncountDownLatch.await();\nSystem.out.println(\"所有任务已完成\");\nthreadPoolExecutor.shutdown();\n```\n\n### 生产者-消费者模型\n\n2个生产者和4个消费者的模型。生产者负责读取文件数据，消费者负责消费文件并输出\n\n阻塞队列可以\n\n### 并查集的删除\n\n在处理某些人之间具有关系的数据结构中，常常用到并查集。例如：a和b认识，b和c认识，那么a和c就可以连接上，可以用并查集来存储这种关系。但是现在需要考虑a和b绝交了，在这种情形下如何用并查集来处理，确认某两个人之间是否还能连接\n\n可以反向处理，将删除等价为增加\n\n### 查询问题\n\n> 场景1：查全校人的姓名，选出top10出现率的名字\n> 场景2：如果查询范围变成全国呢？\n> 场景3：如果空间有限，不让用多级索引呢？用什么数据结构节省空间？\n> 场景4：DNS服务器解析域名对应的IP地址的时候，怎么快速查找到对应的IP地址同时节省存储空间？\n\n### 称盐问题\n\n> 140g的盐 各有一个2g和一个7g的砝码 只能用三次天平，如何称出50g 和 90 g\n\n第一次平分，70+70，第二次继续对一份70克平分，35+35，第三次左边2g砝码，右边7克砝码，调整35克盐以达到平衡，这样左边有20克盐，右边15克盐。把20克盐加到一份70克中即可\n\n### 烧绳子\n\n> 一根绳子烧完要1小时，如何计时15分钟，30分钟和45分钟\n\n## SQL代码\n\n```sql\nwith basic_query as (\nselect \ndistinct products.product_id,\ncategory,\nname as product_name,\nsum(quantity) over (partition by products.product_id) as total_sales\nfrom\nproducts inner join orders on products.product_id = orders.product_id\n)\nselect \nproduct_name,\ntotal_sales,\nrank() over (partition by category order by total_sales desc) as category_rank\nfrom basic_query;\n```\n\n```sql\nSELECT \n    date1, \n    date2,\n    CASE \n        WHEN DATE(date1) = DATE(date2) THEN 'Same Day'\n        ELSE 'Different Day'\n    END AS IsSameDay\nFROM \n    your_table;\n```\n\n# HR面\n\n1 你觉得你有哪些缺点和优点？\n\n缺点：在面对一些比较重要的任务和紧迫的DDL的压制下，由于我本身的执行力非常强，所以这种时候我会试图去尽快把一件事情做完。这种时候，我往往做到了高效完成任务，但容易忽视前期的一些调研准备工作，使得自己在真正去做这件事情的时候会遇到一些波折，导致出现一些小规模的返工。\n\n所以现在在做事情前我一般会通过几种方法去改进自己：\n\n首先，我现在习惯于一般会给自己列一个计划，尽量按照计划去做事。\n\n另一方，其实这也是一个认知的问题。我现在逐渐意识到准备本身也是做事情的一部分，通过预先调研往往能保证事情在执行阶段更加顺利。相当于说工欲善其事，必先利其器\n\n最后，我也会让自己去相信自己的能力，告诉自己我有能力去在期限内完成，更重要的其实在于每一个细节的达成。\n\n2 你怎么评价你面试的这家公司？\n\n3 你在校期间，有没有哪段时间或者某件事情让你受挫？\n\n去年此时，我发现自己体脂率很高，并且感觉不太健康了\n\n另一方面，之前的论文没有中，需要在两个月内完成一篇期刊，\n\n下定决心开始早起，作息从2点睡11点起更改到12点睡8点起。每天抽一个小时去运动一下，然后开始蹲图书馆\n\n4 在校期间遇到最有挑战的事情是什么？\n\n5 目前手上有 offer 吗？\n\n6  自我介绍\n\n7  职业规划\n\n8 报学校专业是怎么考虑的？\n\n9  工作城市\n\n10 你是独生子女吗？\n\n11 那你有男/女 朋友吗？\n\n12  你们出来面试都了解过哪些企业？\n\n13  到后期你们每个人手上有好几个offer，哪些因素决定你们选择这家公司?\n\n14  你更倾向哪种公司？有什么特别的点？\n\n15  你大学有没有特别难忘的经历或者项目分享一下的?\n\n16  团队合作中遇到什么问题？\n\n17  对互联网加班有什么看法？\n\n18  那你现在的技术薄弱点在哪里，怎么去突破？\n\n19  你的兴趣爱好有哪些？\n\n20 现在进度最快的公司是哪家？\n\n21 拿到哪几家offer，是否谈过薪资等\n","slug":"2025/面试-知识储备","published":1,"updated":"2025-11-01T09:55:02.328Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmhg4qvnb001lf5fa5spj0pn5","content":"<h1 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h1><blockquote>\n<p>暑期实习和秋招的知识储备，除了看JavaGuide等外，可以随时回来查缺补漏<br>个人觉得<strong>简历</strong>最为重要，因为在面试中会被问到的问题基本都是围绕着自己简历展开的<br>关注自己的简历都不用太去看面经了（看些通用的就行），应该关注自己的简历会被如何拷打</p>\n</blockquote>\n<blockquote>\n<p>面试的时候表现的积极点、聪明点，很多时候面试问的问题未必回答的出来，但要表现出有一种愿意主动思考的态度。很多时候一个优秀的面试官是会主动引导的，这里举个自己某次面试时遇到的例子。<br>面试官：端口是哪一层协议的？<br>我：我确实不太清楚，让我思考一下…我猜测可能是网络层或者传输层？<br>面试官：TCP和UDP连接可以用同一个端口吗？<br>这里其实就是暗示了，我知道TCP和UDP可以用同一个端口，这就说明了它们的端口不是一个概念，且已知tcp和udp是传输层的协议，所以端口也应该是传输层的概念。<br>因此在面试的时候遇到不会的问题不必太担忧，大胆说出自己的思考，结合学过的知识去分析一下，其实也是很不错的能力。</p>\n</blockquote>\n<blockquote>\n<p>针对HR面和技术面准备不同的自我介绍。比如我在技术面的时候一般就会说：做了blabla什么项目，最后一带而过自己还参加过暑期支教活动和研究生班长；而HR面则重点介绍暑期支教活动和研究生班长经历，一带而过项目等等。</p>\n</blockquote>\n<h1 id=\"个人面经\"><a href=\"#个人面经\" class=\"headerlink\" title=\"个人面经\"></a>个人面经</h1><p>暑期实习面经：<a href=\"https://wangwangwang.website/tags/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/\">https://wangwangwang.website/tags/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/</a></p>\n<p>秋招面经：<a href=\"https://wangwangwang.website/tags/%E7%A7%8B%E6%8B%9B/\">https://wangwangwang.website/tags/%E7%A7%8B%E6%8B%9B/</a></p>\n<h1 id=\"八股知识储备\"><a href=\"#八股知识储备\" class=\"headerlink\" title=\"八股知识储备\"></a>八股知识储备</h1><h2 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h2><p>分布式锁应当满足：</p>\n<ul>\n<li>互斥</li>\n<li>高可用：出问题，能够释放（超时机制）</li>\n<li>可重入（获取了锁之后，还可以再次获取）</li>\n</ul>\n<p>常见实现方案：Redis和ZooKeeper</p>\n<h2 id=\"其他工具\"><a href=\"#其他工具\" class=\"headerlink\" title=\"其他工具\"></a>其他工具</h2><h3 id=\"限流和熔断\"><a href=\"#限流和熔断\" class=\"headerlink\" title=\"限流和熔断\"></a>限流和熔断</h3><p>限流（Rate Limiting）是一种常用的技术手段，用于控制系统对资源的访问速率，确保系统的稳定性和可靠性</p>\n<p>熔断（Circuit Breaker）模式是一种用于处理分布式系统中因服务调用失败而可能导致系统雪崩效应的保护机制。它借用了电路中的“熔断器”概念，当电流过大时，熔断器会自动切断电路，以保护整个电路系统不被烧毁。在分布式系统中，熔断器用于监控服务调用的健康状况，并在检测到异常（如服务调用失败率过高、响应时间过长等）时，自动切断对该服务的调用，从而防止故障在系统中蔓延，保障系统的整体稳定性和可用性</p>\n<ul>\n<li>防止服务雪崩</li>\n<li>提升系统弹性</li>\n</ul>\n<h3 id=\"限流算法\"><a href=\"#限流算法\" class=\"headerlink\" title=\"限流算法\"></a>限流算法</h3><p>漏桶算法：无法应对激增流量；请求被丢弃</p>\n<p>令牌桶算法：可以限制平均速率，以及处理激增的流量；可以动态调整生成令牌速率</p>\n<p>动态调整生成令牌速率的方法：</p>\n<p><code>RedisRateLimiter</code>的令牌生成速率（<code>replenishRate</code>）和突发容量（<code>burstCapacity</code>）</p>\n<p>可以考虑使用nanos进行动态配置，同时实现动态路由加载</p>\n<p><strong>限流可以进化到降级</strong></p>\n<p><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250312195240597-20250312-195242.png\" alt=\"image-20250312195240597\"></p>\n<p>令牌桶算法添加令牌的方式是多样的：</p>\n<h4 id=\"传统线程驱动\"><a href=\"#传统线程驱动\" class=\"headerlink\" title=\"传统线程驱动\"></a>传统线程驱动</h4><p>通过后台线程定期（如每秒）向令牌桶中添加固定数量的令牌，直到桶满为止。</p>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>实现简单，逻辑清晰。</li>\n<li>令牌生成速率恒定，适合需要严格控制平均速率的场景。</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>需要维护额外线程，增加系统资源开销。</li>\n<li>实时性差，突发流量可能导致令牌补充不及时（如网页44提到的瞬时流量可能超过限速阈值</li>\n</ul>\n<h4 id=\"惰性计算\"><a href=\"#惰性计算\" class=\"headerlink\" title=\"惰性计算\"></a>惰性计算</h4><p>在每次请求到来时，根据当前时间与上次请求的时间差动态计算应补充的令牌数，并更新桶内令牌。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 网页58中的令牌桶核心逻辑</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">refillTokens</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> now = System.nanoTime();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> duration = now - lastRefillTime;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> newTokens = duration * refillRate / <span class=\"number\">1_000_000_000</span>; <span class=\"comment\">// 计算时间差对应的令牌数</span></span><br><span class=\"line\">    tokens.updateAndGet(current -&gt; Math.min(capacity, current + newTokens));</span><br><span class=\"line\">    lastRefillTime = now;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>无需独立线程，减少资源消耗。</li>\n<li>时间驱动更精确，适合高并发场景（如淘宝交易系统的动态限流）</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>计算逻辑需保证线程安全（如使用原子操作或同步锁）。</li>\n<li>频繁的时间计算可能带来轻微性能损耗。</li>\n</ul>\n<h4 id=\"RateLimiter的实现\"><a href=\"#RateLimiter的实现\" class=\"headerlink\" title=\"RateLimiter的实现\"></a>RateLimiter的实现</h4><p><strong>核心原理</strong>： 在每次请求到来时，根据<strong>当前时间与上次令牌补充的时间差</strong>，动态计算应补充的令牌数量。这种方式无需独立线程维护令牌桶，通过实时计算实现令牌生成。 <strong>实现细节</strong>：</p>\n<ol>\n<li><strong>时间差计算</strong>：记录上次补充令牌的时间戳（如 <code>nextFreeTicketMicros</code>），通过当前时间差除以令牌生成间隔（<code>stableIntervalMicros</code>），得到应补充的令牌数。</li>\n<li><strong>令牌补充上限</strong>：确保补充后令牌不超过桶的最大容量（<code>maxPermits</code>）。</li>\n<li><strong>原子性操作</strong>：使用同步锁或原子变量保证线程安全。 <strong>代码示例</strong>（参考Guava的 <code>SmoothRateLimiter</code> 类）：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">resync</span><span class=\"params\">(<span class=\"keyword\">long</span> nowMicros)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nowMicros &gt; nextFreeTicketMicros) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">double</span> timeDiff = nowMicros - nextFreeTicketMicros;  </span><br><span class=\"line\">        <span class=\"keyword\">double</span> newPermits = timeDiff / stableIntervalMicros;  </span><br><span class=\"line\">        storedPermits = Math.min(maxPermits, storedPermits + newPermits);  </span><br><span class=\"line\">        nextFreeTicketMicros = nowMicros;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>无需额外线程，资源消耗低。</li>\n<li>实时性强，精确控制突发流量。</li>\n</ul>\n<p><strong>适用场景</strong>：高并发、分布式系统（如Guava RateLimiter的默认实现）</p>\n<table>\n<thead>\n<tr>\n<th><strong>方法</strong></th>\n<th><strong>资源消耗</strong></th>\n<th><strong>实时性</strong></th>\n<th><strong>适用场景</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>惰性计算法</td>\n<td>低</td>\n<td>高</td>\n<td>高并发、分布式系统（如API网关）</td>\n</tr>\n<tr>\n<td>定时补充法</td>\n<td>中</td>\n<td>中</td>\n<td>单机简单限流（如传统后台服务）</td>\n</tr>\n</tbody></table>\n<h3 id=\"maven\"><a href=\"#maven\" class=\"headerlink\" title=\"maven\"></a>maven</h3><p>解决冲突？todo</p>\n<h3 id=\"docker和虚拟机的区别\"><a href=\"#docker和虚拟机的区别\" class=\"headerlink\" title=\"docker和虚拟机的区别\"></a>docker和虚拟机的区别</h3><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/4ef8691d67eb1eb53217099d0a691eb5-20250302-153527.png\" alt=\"img\" style=\"zoom: 67%;\" />\n\n<p>容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高。</p>\n<h3 id=\"Oauth-2-0\"><a href=\"#Oauth-2-0\" class=\"headerlink\" title=\"Oauth 2.0\"></a>Oauth 2.0</h3><p>一种新的授权机制，为第三方应用颁发一个有时效性的令牌Token，使得第三方应用能够通过该令牌获得相关的资源。</p>\n<p>令牌（token）与密码（password）的作用是一样的，都可以进入系统，但是有三点差异。</p>\n<p>（1）令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。</p>\n<p>（2）令牌可以被数据所有者撤销，会立即失效。以上例而言，屋主可以随时取消快递员的令牌。密码一般不允许被他人撤销。</p>\n<p>（3）令牌有权限范围（scope），比如只能进小区的二号门。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。</p>\n<p>授权层分离出两种角色：客户端和资源所有者。本质oauth的核心就是**<em>向第三方应用颁发令牌**</em></p>\n<p>需要阅读：<a href=\"https://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html\">https://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html</a></p>\n<h3 id=\"nginx\"><a href=\"#nginx\" class=\"headerlink\" title=\"nginx\"></a>nginx</h3><p>nginx正向代理和反向代理</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/163948996\">https://zhuanlan.zhihu.com/p/163948996</a></p>\n<ul>\n<li>正向代理是<strong>客户端代理</strong>，代理客户端，服务端不知道实际发起请求的客户端</li>\n<li>反向代理是<strong>服务端代理</strong>，代理服务端，客户端不知道实际提供服务的服务端.</li>\n</ul>\n<h3 id=\"cookie和localStorage\"><a href=\"#cookie和localStorage\" class=\"headerlink\" title=\"cookie和localStorage\"></a>cookie和localStorage</h3><p><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250321152306879-20250321-152307.png\" alt=\"image-20250321152306879\"></p>\n<p><strong>单点登录（SSO）</strong>：用户登录百度主站（如 <code>www.baidu.com</code>）时，服务器生成一个认证Cookie，并设置其 <code>domain</code>属性为 <code>.baidu.com</code>。这使得所有子域名（如 <code>pan.baidu.com</code>）均可读取该Cookie，实现自动登录</p>\n<h3 id=\"时间轮算法\"><a href=\"#时间轮算法\" class=\"headerlink\" title=\"时间轮算法\"></a>时间轮算法</h3><ul>\n<li>环形时间轮：时间轮由多个<strong>槽（Slot）</strong> 组成环形数组，每个槽对应一个时间间隔（如1秒）。例如，一个60槽的时间轮，每槽间隔1秒，可覆盖60秒内的任务</li>\n<li><strong>指针（tick）</strong>：指针周期性移动（如每秒移动一槽），触发当前槽内所有任务的执行</li>\n<li><strong>任务链表</strong>：每个槽挂载一个任务链表，存储需在该时间点触发的任务</li>\n</ul>\n<p><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250321155727208-20250321-155727.png\" alt=\"image-20250321155727208\"></p>\n<p><img src=\"https://static001.geekbang.org/infoq/71/71313f214caded7d34001de907131cfe.png\" alt=\"img\"></p>\n<p>以两层时间轮为例，第一层时间轮周期为1秒，第二层时间轮周期为10秒。</p>\n<p>还是以上述3个任务为例，可以看到任务A和B分布在第一层时间轮上，而任务C分布在第二层时间轮的槽1处。当第一层时间轮转动时，任务A和任务B会被先后执行。1秒钟之后，第一层时间轮完成了一个周期转动。从新开始第0跳，这时第二层时间轮从槽0跳到了槽1处，将槽1处的任务，也就是任务C取出放入到第一层时间轮的槽位9处，当第一层时间轮转动到槽位9处，任务C就会被执行。这种将第二层的任务取出放入第一层中称为降级，它是为了保证任务被处理的时间精度。Kafka内部就是采用的这种多层时间轮机制。</p>\n<p><img src=\"https://static001.geekbang.org/infoq/da/daf543a1284837a0de12c29aee43c55b.png\" alt=\"img\"></p>\n<p>应用场景：</p>\n<ul>\n<li>redisson通过时间轮算法实现锁的自动续期</li>\n</ul>\n<h3 id=\"权限模型\"><a href=\"#权限模型\" class=\"headerlink\" title=\"权限模型\"></a>权限模型</h3><p>在 RBAC（基于角色的访问控制）模型中，<strong>资源（Resource）</strong> 是系统中被标识、可被访问或操作的一切事物。其涵盖范围包括但不限于：</p>\n<p><strong>功能型资源</strong></p>\n<ul>\n<li><strong>模块</strong>：如商品管理、订单管理、财务管理等业务板块。</li>\n<li><strong>页面</strong>：如商品列表页、订单详情页等具体界面。</li>\n<li><strong>按钮</strong>：如“新增商品”“删除订单”等交互操作。</li>\n<li><strong>字段</strong>：如商品详情中的“价格”字段是否可编辑</li>\n</ul>\n<p><strong>数据型资源</strong></p>\n<ul>\n<li><strong>实体数据</strong>：如数据库中的某条订单记录、客户信息表。</li>\n<li><strong>文件/路径</strong>：如服务器上的文件目录或特定文档。</li>\n<li><strong>API 接口</strong>：如 <code>/api/orders</code> 路径对应的 RESTful 接口</li>\n</ul>\n<p>RBAC 模型中的权限管理需从两个维度进行切分：<strong>功能权限</strong>（操作权限）和<strong>数据权限</strong>（数据范围权限）。两者相辅相成，共同实现精细化控制</p>\n<ol>\n<li><strong>功能权限（操作权限）</strong></li>\n</ol>\n<p><strong>定义</strong>：控制用户能否使用系统中的特定功能或执行操作，例如页面访问、按钮点击、API 调用等。</p>\n<ol start=\"2\">\n<li><strong>数据权限（范围权限）</strong></li>\n</ol>\n<p><strong>定义</strong>：控制用户能访问哪些具体数据，例如某部门的数据、某区域的订单等。 <strong>典型维度</strong>：</p>\n<ul>\n<li><strong>组织架构</strong>：如上海分公司的员工只能访问分公司数据</li>\n</ul>\n<p><strong>总结</strong>：</p>\n<ul>\n<li>功能权限解决“<strong>能否操作</strong>”的问题（如能否删除订单）。</li>\n<li>数据权限解决“<strong>能操作哪些数据</strong>”的问题（如只能删除自己创建的订单</li>\n</ul>\n<h3 id=\"负载均衡算法\"><a href=\"#负载均衡算法\" class=\"headerlink\" title=\"负载均衡算法\"></a>负载均衡算法</h3><p><strong>静态</strong>：轮询、加权轮询、随机、哈希、<strong>一致性哈希</strong>。</p>\n<p><strong>动态</strong>：最少连接、最少响应时间、最少负载、带权最少连接</p>\n<h2 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h2><p>单表数据量控制在500w以内</p>\n<h3 id=\"回表\"><a href=\"#回表\" class=\"headerlink\" title=\"回表\"></a>回表</h3><p>Mysql回表</p>\n<p>回表怎么解决</p>\n<p>回表返回的是一行还是一张表还是索引</p>\n<h3 id=\"缓冲区\"><a href=\"#缓冲区\" class=\"headerlink\" title=\"缓冲区\"></a>缓冲区</h3><p>innodb中无论是查询还是写绝大部分都是在buffer pool中进行操作的，它相当于innodb的缓存区，可以通过show engine innodb status来查看buffer pool的使用情况；可以通过innodb_buffer_pool_size来设置buffer pool的大小，线上不要吝啬给几个G内存都是正常的，但无论给多大内存都会有不够的时候，innodb采用了变种的LRU算法对数据页进行淘汰</p>\n<p>参考文献：<a href=\"https://cloud.tencent.com/developer/article/1828772\">https://cloud.tencent.com/developer/article/1828772</a></p>\n<h3 id=\"覆盖索引\"><a href=\"#覆盖索引\" class=\"headerlink\" title=\"覆盖索引\"></a>覆盖索引</h3><p>覆盖索引的好处：</p>\n<ol>\n<li>避免InnoDB的回表</li>\n<li>将随机IO变为顺序IO：覆盖索引的 B+ 树叶子节点中，索引键值按升序排列（例如联合索引 <code>(a, b)</code> 会先按 <code>a</code> 排序，再按 <code>b</code> 排序）。当执行范围查询（如 <code>WHERE a &gt; 10 AND a &lt; 20</code>）时，所需数据在索引中是连续存储的，磁盘可以一次性顺序读取多个相邻数据页，避免跳跃式寻址</li>\n</ol>\n<h3 id=\"InnoDB相比于MyISAM的优势\"><a href=\"#InnoDB相比于MyISAM的优势\" class=\"headerlink\" title=\"InnoDB相比于MyISAM的优势\"></a>InnoDB相比于MyISAM的优势</h3><p>事务支持和ACID特性</p>\n<p>行级锁</p>\n<p>索引结构的优化（数据和索引文件在一起）</p>\n<p>多版本并发控制（MVCC）</p>\n<p>redo log，支持崩溃后的安全恢复</p>\n<h3 id=\"表级锁和行级锁\"><a href=\"#表级锁和行级锁\" class=\"headerlink\" title=\"表级锁和行级锁\"></a>表级锁和行级锁</h3><p>表级锁：针对非索引字段加的锁</p>\n<p>行级锁：<strong>针对索引字段加的锁</strong></p>\n<h3 id=\"最左匹配原则\"><a href=\"#最左匹配原则\" class=\"headerlink\" title=\"最左匹配原则\"></a>最左匹配原则</h3><p>使用联合索引的过程中，MySQL根据索引中的字段从左到右依次匹配查询条件</p>\n<p>如果匹配，就会使用索引</p>\n<p>最左匹配原则会一直向右匹配，直到遇到范围查询（如 &gt;、&lt;）为止。对于 &gt;=、&lt;=、BETWEEN 以及前缀匹配 LIKE 的范围查询，不会停止匹配</p>\n<h3 id=\"索引失效\"><a href=\"#索引失效\" class=\"headerlink\" title=\"索引失效\"></a>索引失效</h3><p><a href=\"https://mp.weixin.qq.com/s/mwME3qukHBFul57WQLkOYg\">https://mp.weixin.qq.com/s/mwME3qukHBFul57WQLkOYg</a></p>\n<ul>\n<li>不符合最左匹配原则</li>\n<li>select *不会影响索引，但是会二次回表</li>\n<li>使用函数</li>\n<li>计算</li>\n<li>非前缀匹配</li>\n<li>in的范围太大</li>\n</ul>\n<h3 id=\"SQL优化\"><a href=\"#SQL优化\" class=\"headerlink\" title=\"SQL优化\"></a>SQL优化</h3><p><a href=\"https://www.nowcoder.com/discuss/730039197121155072\">https://www.nowcoder.com/discuss/730039197121155072</a></p>\n<p>B+树不要超过三层：<a href=\"https://juejin.cn/post/7165689453124517896\">https://juejin.cn/post/7165689453124517896</a></p>\n<h2 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h2><h3 id=\"TCP-IP-四层模型\"><a href=\"#TCP-IP-四层模型\" class=\"headerlink\" title=\"TCP/IP 四层模型\"></a>TCP/IP 四层模型</h3><p>应用层</p>\n<p>传输层</p>\n<p>网络层</p>\n<p>网络接口层</p>\n<h4 id=\"应用层\"><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a>应用层</h4><p>提供两个终端设备上应用程序之间信息交换的服务，定义信息交换的格式</p>\n<p>http协议；smtp协议；pop3/imap协议；ftp协议；dns协议</p>\n<h4 id=\"传输层\"><a href=\"#传输层\" class=\"headerlink\" title=\"传输层\"></a>传输层</h4><p>负责两台终端设备进程的通信提供通用的数据传输服务</p>\n<p>tcp协议</p>\n<p>udp协议</p>\n<h4 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h4><p>负责分组交换网络上不同主机提供通信服务，负责路由和转发</p>\n<p>ip协议</p>\n<p>arp协议</p>\n<p>icmp协议</p>\n<p>nat协议</p>\n<p>ospf/rip</p>\n<h4 id=\"网络接口层\"><a href=\"#网络接口层\" class=\"headerlink\" title=\"网络接口层\"></a>网络接口层</h4><ul>\n<li>数据链路层：将网络层交下来的IP数据包组装成数据帧</li>\n<li>物理层：负责计算机节点之间比特流的透明传输</li>\n</ul>\n<h3 id=\"HTTP状态码\"><a href=\"#HTTP状态码\" class=\"headerlink\" title=\"HTTP状态码\"></a>HTTP状态码</h3><p><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/http-status-code-20250303-095853.png\" alt=\"常见 HTTP 状态码\"></p>\n<p><strong>200 OK</strong>：请求被成功处理。例如，发送一个查询用户数据的 HTTP 请求到服务端，服务端正确返回了用户数据。这个是我们平时最常见的一个 HTTP 状态码。</p>\n<p><strong>201 Created</strong>：请求被成功处理并且在服务端创建了一个新的资源。例如，通过 POST 请求创建一个新的用户。</p>\n<p><strong>202 Accepted</strong>：服务端已经接收到了请求，但是还未处理。例如，发送一个需要服务端花费较长时间处理的请求（如报告生成、Excel 导出），服务端接收了请求但尚未处理完毕。</p>\n<p><strong>204 No Content</strong>：服务端已经成功处理了请求，但是没有返回任何内容。例如，发送请求删除一个用户，服务器成功处理了删除操作但没有返回任何内容。</p>\n<hr>\n<p><strong>301 Moved Permanently</strong>：资源被永久重定向了。比如你的网站的网址更换了。</p>\n<p><strong>302 Found</strong>：资源被临时重定向了。比如你的网站的某些资源被暂时转移到另外一个网址。</p>\n<hr>\n<p><strong>400 Bad Request</strong>：发送的 HTTP 请求存在问题。比如请求参数不合法、请求方法错误。</p>\n<p><strong>401 Unauthorized</strong>：未认证却请求需要认证之后才能访问的资源。</p>\n<p><strong>403 Forbidden</strong>：直接拒绝 HTTP 请求，不处理。一般用来针对非法请求。</p>\n<p><strong>404 Not Found</strong>：你请求的资源未在服务端找到。比如你请求某个用户的信息，服务端并没有找到指定的用户。</p>\n<hr>\n<p><strong>500 Internal Server Error</strong>：服务端出问题了（通常是服务端出 Bug 了）。比如你服务端处理请求的时候突然抛出异常，但是异常并未在服务端被正确处理。</p>\n<p><strong>502 Bad Gateway</strong>：我们的网关将请求转发到服务端，但是服务端返回的却是一个错误的响应。</p>\n<h3 id=\"http和https的区别\"><a href=\"#http和https的区别\" class=\"headerlink\" title=\"http和https的区别\"></a>http和https的区别</h3><p>https是基于http，使用tcp作为底层协议，额外使用ssl/tls协议作为加密和安全认证。默认端口是443.</p>\n<h3 id=\"QUIC协议\"><a href=\"#QUIC协议\" class=\"headerlink\" title=\"QUIC协议\"></a>QUIC协议</h3><p>http3.0开始使用quic协议。</p>\n<ol>\n<li>协议僵化：tcp协议升级困难，quic基于udp实现，可在用户态灵活迭代</li>\n<li>队头阻塞</li>\n<li>连接迁移问题：QUIC 使用 <strong>Connection ID</strong> 标识连接，网络切换时无缝迁移连接，无需重建</li>\n<li>QUIC 具有更高级别的加密 ，TCP 本身不做数据加密，依赖于 TLS</li>\n</ol>\n<h3 id=\"WebSocket\"><a href=\"#WebSocket\" class=\"headerlink\" title=\"WebSocket\"></a>WebSocket</h3><p>基于TCP连接的全双工通信协议，客户端和服务器可以同时发送和接收数据</p>\n<p>应用层的协议，用于弥补http在持久化通信能力上的不足</p>\n<p><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250303160210979-20250303-160211.png\" alt=\"image-20250303160210979\"></p>\n<h3 id=\"tcp保障可靠性的7种方式\"><a href=\"#tcp保障可靠性的7种方式\" class=\"headerlink\" title=\"tcp保障可靠性的7种方式\"></a>tcp保障可靠性的7种方式</h3><ol>\n<li>数据块传输</li>\n<li>序列号</li>\n<li>数据校验</li>\n<li>流量控制</li>\n<li>拥塞控制</li>\n<li>确认机制</li>\n<li>超时重传</li>\n</ol>\n<h3 id=\"挥手过程中的状态\"><a href=\"#挥手过程中的状态\" class=\"headerlink\" title=\"挥手过程中的状态\"></a>挥手过程中的状态</h3><table>\n<thead>\n<tr>\n<th><strong>状态</strong></th>\n<th><strong>触发方</strong></th>\n<th><strong>阶段</strong></th>\n<th><strong>持续时间</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>TIME_WAIT</strong></td>\n<td>主动关闭方</td>\n<td>发送最后一个 <code>ACK</code>后</td>\n<td>固定 <code>2MSL</code>（约1-4分钟）</td>\n</tr>\n<tr>\n<td><strong>CLOSE_WAIT</strong></td>\n<td>被动关闭方</td>\n<td>收到 <code>FIN</code>但未发送自己的 <code>FIN</code></td>\n<td>理论上应短暂（实际可能长期存在）</td>\n</tr>\n</tbody></table>\n<h3 id=\"tcp和udp的区别\"><a href=\"#tcp和udp的区别\" class=\"headerlink\" title=\"tcp和udp的区别\"></a>tcp和udp的区别</h3><ol>\n<li>是否面向连接：udp传输数据之前不需要先建立连接，tcp则是提供面向连接的服务（必须先建立连接，传输结束后也需要释放连接）</li>\n<li>是否是可靠传输：udp收到udp报文后，不需要给出任何确认；tcp则通过各种机制保证数据的可靠传输（无差错、不丢失、不重复、按序到达）</li>\n<li>是否有状态：和上面差不多，就是tcp会维护数据的状态</li>\n<li>传输效率：udp高很多</li>\n<li>传输形式：tcp面向字节流，udp则面向报文</li>\n<li>首部开销：tcp（20-60字节），udp（8字节）</li>\n<li>tcp只能点对点，而udp可以一对一、一对多、多对一等等。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>TCP</th>\n<th>UDP</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>是否面向连接</td>\n<td>是</td>\n<td>否</td>\n</tr>\n<tr>\n<td>是否可靠</td>\n<td>是</td>\n<td>否</td>\n</tr>\n<tr>\n<td>是否有状态</td>\n<td>是</td>\n<td>否</td>\n</tr>\n<tr>\n<td>传输效率</td>\n<td>较慢</td>\n<td>较快</td>\n</tr>\n<tr>\n<td>传输形式</td>\n<td>字节流</td>\n<td>数据报文段</td>\n</tr>\n<tr>\n<td>首部开销</td>\n<td>20 ～ 60 bytes</td>\n<td>8 bytes</td>\n</tr>\n<tr>\n<td>是否提供广播或多播服务</td>\n<td>否</td>\n<td>是</td>\n</tr>\n</tbody></table>\n<h3 id=\"SYN洪流攻击\"><a href=\"#SYN洪流攻击\" class=\"headerlink\" title=\"SYN洪流攻击\"></a>SYN洪流攻击</h3><p>SYN Flood是最经典的DDos攻击</p>\n<p>利用了TCP的三次握手（SYN-&gt;SYN/ACK-&gt;ACK），进入半连接状态，使得资源耗尽</p>\n<p>预防手段：</p>\n<ol>\n<li>增加半连接工作队列数量</li>\n<li>回收最先创建的tcp半连接</li>\n<li>syn cookie</li>\n</ol>\n<h2 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h2><h3 id=\"进程和线程的区别\"><a href=\"#进程和线程的区别\" class=\"headerlink\" title=\"进程和线程的区别\"></a>进程和线程的区别</h3><ol>\n<li>线程是进程划分为更小的运行单位，进程执行过程中可以产生多个线程</li>\n<li>线程共享资源，可以互相影响；进程基本是独立的</li>\n<li>线程执行开销小，进程则比较大</li>\n</ol>\n<h3 id=\"线程间同步的方式\"><a href=\"#线程间同步的方式\" class=\"headerlink\" title=\"线程间同步的方式\"></a>线程间同步的方式</h3><ol>\n<li>互斥锁</li>\n<li>读写锁</li>\n<li>信号量</li>\n<li>屏障</li>\n<li>事件（wait/notify）</li>\n</ol>\n<h3 id=\"进程间通信方式\"><a href=\"#进程间通信方式\" class=\"headerlink\" title=\"进程间通信方式\"></a>进程间通信方式</h3><ol>\n<li>匿名管道（父子进程）/ 有名管道</li>\n<li>信号量</li>\n<li>共享内存</li>\n<li>消息队列</li>\n<li>套接字</li>\n</ol>\n<h3 id=\"父子进程\"><a href=\"#父子进程\" class=\"headerlink\" title=\"父子进程\"></a>父子进程</h3><p><strong>子进程拷贝父进程数据的核心机制是写时复制（Copy-On-Write, COW）</strong>。这一设计在Linux系统中通过 <code>fork()</code>系统调用实现，兼顾性能与资源利用率</p>\n<p><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250315152502507-20250315-152503.png\" alt=\"image-20250315152502507\"></p>\n<p>典型场景：Redis利用COW实现快照持久化，子进程直接读取父进程内存生成RDB文件</p>\n<p><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250315185109713-20250315-185110.png\" alt=\"image-20250315185109713\"></p>\n<h3 id=\"银行家算法\"><a href=\"#银行家算法\" class=\"headerlink\" title=\"银行家算法\"></a>银行家算法</h3><p><a href=\"https://cloud.tencent.com/developer/article/2108439\">https://cloud.tencent.com/developer/article/2108439</a></p>\n<h3 id=\"零拷贝机制\"><a href=\"#零拷贝机制\" class=\"headerlink\" title=\"零拷贝机制\"></a>零拷贝机制</h3><p><strong>零拷贝（Zero-Copy）</strong>是一种计算机系统优化技术，旨在减少或消除数据在内存中的冗余拷贝操作，从而降低CPU开销、提升数据传输效率。其核心思想是：<strong>通过硬件或操作系统级优化，避免CPU参与数据在用户空间与内核空间之间的复制过程</strong>，直接在内核态完成数据传输</p>\n<img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250315212414718-20250315-212415.png\" alt=\"image-20250315212414718\" style=\"zoom:50%;\" />\n\n<p>基本过程理解：<a href=\"https://www.bilibili.com/video/BV1RxcoeLE5x\">https://www.bilibili.com/video/BV1RxcoeLE5x</a></p>\n<p>mmap：实现内核缓冲区和用户缓冲区之间的映射关系（避免CPU的拷贝过程）</p>\n<h3 id=\"cpu三级缓存\"><a href=\"#cpu三级缓存\" class=\"headerlink\" title=\"cpu三级缓存\"></a>cpu三级缓存</h3><p><strong>解决速度差异问题</strong> CPU的执行速度远高于内存和磁盘，三级缓存通过<strong>缩短数据访问路径</strong>，减少CPU等待数据的时间，缓解“内存墙”问题。</p>\n<ul>\n<li><strong>速度对比</strong>：寄存器 &gt; L1 &gt; L2 &gt; L3 &gt; 内存 &gt; 磁盘</li>\n<li><strong>性能提升</strong>：约95%的数据访问可通过缓存完成，仅5%需访问内存，极大减少延迟</li>\n</ul>\n<p>核心目的：CPU与内存速度差异大，缓存通过空间换时间减少访问延迟</p>\n<h2 id=\"Spring\"><a href=\"#Spring\" class=\"headerlink\" title=\"Spring\"></a>Spring</h2><h3 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h3><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250304221412002-20250304-221412.png\" alt=\"image-20250304221412002\" style=\"zoom:50%;\" />\n\n<h3 id=\"Spring自动装配原理\"><a href=\"#Spring自动装配原理\" class=\"headerlink\" title=\"Spring自动装配原理\"></a>Spring自动装配原理</h3><p>Spring 自动装配的核心目标是<strong>通过约定大于配置的方式，自动加载符合条件的 Bean 到容器中</strong></p>\n<p><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250309102948593-20250309-102949.png\" alt=\"image-20250309102948593\"></p>\n<p>按需装配</p>\n<h3 id=\"BeanFactory-和-FactoryBean\"><a href=\"#BeanFactory-和-FactoryBean\" class=\"headerlink\" title=\"BeanFactory 和 FactoryBean\"></a>BeanFactory 和 FactoryBean</h3><table>\n<thead>\n<tr>\n<th><strong>BeanFactory</strong></th>\n<th><strong>FactoryBean</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Spring 的核心接口</strong>，是 IOC 容器的顶层设计，负责 Bean 的实例化、配置和管理。它是 Spring 工厂模式的实现，如 <code>ApplicationContext</code> 是其子接口。</td>\n<td><strong>特殊的 Bean</strong>，本身是一个 Bean，但实现了工厂模式，用于创建其他 Bean 实例。例如 MyBatis 的 <code>SqlSessionFactoryBean</code> 和 Spring AOP 的 <code>ProxyFactoryBean</code>。</td>\n</tr>\n<tr>\n<td><strong>角色</strong>：IOC 容器的管理者，提供 Bean 的基础操作（如 <code>getBean</code>、<code>isSingleton</code>） 。</td>\n<td><strong>角色</strong>：Bean 的生产工厂，通过 <code>getObject()</code> 方法返回目标对象，而非自身实例。</td>\n</tr>\n</tbody></table>\n<h3 id=\"Bean的生命周期\"><a href=\"#Bean的生命周期\" class=\"headerlink\" title=\"Bean的生命周期\"></a>Bean的生命周期</h3><p><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/spring-bean-lifestyle-20250226-125000.png\" alt=\"img\"></p>\n<h3 id=\"Bean加载问题\"><a href=\"#Bean加载问题\" class=\"headerlink\" title=\"Bean加载问题\"></a>Bean加载问题</h3><p><strong>默认扫描范围</strong>： Spring 默认仅扫描主配置类（如 <code>@SpringBootApplication</code> 标注的类）所在的包及其子包。若类位于其他包中，需通过 <code>@ComponentScan</code> 显式指定扫描路径</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(basePackages = &quot;com.example.custom.package&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> </span>&#123; <span class=\"comment\">/*...*/</span> &#125;</span><br></pre></td></tr></table></figure>\n<p>若配置了 <code>@ComponentScan</code> 的 <code>excludeFilters</code> 或 XML 的 <code>&lt;context:exclude-filter&gt;</code>，相关类可能被排除</p>\n<h3 id=\"Spring的循环依赖\"><a href=\"#Spring的循环依赖\" class=\"headerlink\" title=\"Spring的循环依赖\"></a>Spring的循环依赖</h3><p>Spring使用三级缓存来解决循环依赖问题：</p>\n<ol>\n<li>一级缓存singletonObjects：存储最终形态的Bean</li>\n<li>二级缓存earylySingletonObjects：存储半成品Bean，即三级缓存ObjectFactory产生的对象。主要是为了AOP机制下， 每次产生新的代理对象</li>\n<li>三级缓存singletonFactories：存放ObjectFactory，ObjectFactory的getObject()方法（最终调用的是getEarlyBeanReference()方法）可以生成原始 Bean 对象或者代理对象（如果 Bean 被 AOP 切面代理）</li>\n</ol>\n<p>创建Bean的具体流程如下：</p>\n<ol>\n<li>先去一级缓存singletonObjects获取，存在就返回；</li>\n<li>不存在，去二级缓存中获取</li>\n<li>仍然不存在，就在三级缓存获取到对应的objectFactory（并调用对应的getObject()）方法</li>\n</ol>\n<p>具体解决循环依赖的方法如下：</p>\n<ol>\n<li>Spring创建A时，A依赖了B，但是B又依赖了A</li>\n<li>由于A还没有初始化完成，因此在一二级缓存中没有A</li>\n<li>那么就去三级缓存调用getObject()方法获取A的早期暴露对象，放入二级缓存中，并注入到B中去</li>\n</ol>\n<p>在AOP模式下存在的二级缓存：</p>\n<p>确保多个对早期引用的请求，也返回同一个代理对象</p>\n<h3 id=\"Transactional\"><a href=\"#Transactional\" class=\"headerlink\" title=\"@Transactional\"></a>@Transactional</h3><p>Spring中事务管理最关键的三个接口：</p>\n<ul>\n<li>PlatformTransactionManager：事务管理器，Spring事务策略的核心</li>\n<li>TransactionDefinition：事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)</li>\n<li>TransactionStatus：事务运行状态</li>\n</ul>\n<h4 id=\"事务传播行为\"><a href=\"#事务传播行为\" class=\"headerlink\" title=\"事务传播行为\"></a>事务传播行为</h4><p>解决业务层方法之间互相调用的事务问题</p>\n<p>Propagation_Required：外部有事务，加入外部；外部没有，则自己新建一个事务（互相影响）</p>\n<p>Propagation_requires_new：创建一个事务，把外部事务挂起（内部影响外部，外部不影响内部）</p>\n<p>Propagation_nested：内部不会影响外部，外部会影响外部</p>\n<h4 id=\"注解失效\"><a href=\"#注解失效\" class=\"headerlink\" title=\"注解失效\"></a>注解失效</h4><ul>\n<li>只能作用在public方法上，其他不生效</li>\n<li>当一个方法被标记@Transactional注解的时候，Spring 事务管理器只会在被其他类方法调用的时候生效，而不会在一个类中方法调用生效。</li>\n</ul>\n<h4 id=\"相关面试题\"><a href=\"#相关面试题\" class=\"headerlink\" title=\"相关面试题\"></a>相关面试题</h4><blockquote>\n<ol>\n<li>一个类的内部有A，B两个方法，其中B开启了事务，我在A中调用B，事务生效吗？</li>\n<li>这种情况下如何让事务生效？</li>\n</ol>\n</blockquote>\n<p>在同一个类中，若方法A直接调用带有 <code>@Transactional</code>注解的方法B，<strong>事务不会生效</strong>。其核心原因在于Spring的事务管理基于AOP代理机制实现，而同类内部调用会绕过代理，直接通过目标对象执行，导致事务拦截失效。</p>\n<p>解决方法：</p>\n<ul>\n<li><p>拆分到不同的类</p>\n</li>\n<li><p>自我注入：注入一个自己类对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyService</span> </span>&#123;  </span><br><span class=\"line\">  \t<span class=\"comment\">// 需要开启循环依赖支持</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span>  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> MyService self;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>获取当前代理对象：((MyService) AopContext.currentProxy()).methodB();   或者获取代理Bean对象</p>\n</li>\n</ul>\n<h3 id=\"Spring-Cloud-Gateway\"><a href=\"#Spring-Cloud-Gateway\" class=\"headerlink\" title=\"Spring Cloud Gateway\"></a>Spring Cloud Gateway</h3><p><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/springcloud-gateway-%20demo.png\" alt=\"img\"></p>\n<p>三个关键组件：</p>\n<ul>\n<li><strong>Route 路由</strong>：Spring Cloud Gateway最基本的单元，定义了请求的匹配规则和转发目标。通过配置路由，可以将请求映射到后端服务实例或者URL上。路由规则根据请求的路径、方法或者请求头等条件进行匹配（断言），指定转发的目标URL</li>\n<li><strong>Predicate 断言</strong>：用于匹配请求的目标，如果满足断言的条件，就会应用所配置的过滤器。内置多种断言方式，如Path（路径匹配）、Method（请求方法匹配）等</li>\n<li><strong>Filter 过滤器</strong>：对请求进行转换和处理，可以修改请求、响应和自定义逻辑。提供了多个内置的过滤器，如请求转发、请求重试、请求限流等。</li>\n</ul>\n<p>具体工作流程：</p>\n<p><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/spring-cloud-gateway-workflow-20250315-144117.png\" alt=\"Spring Cloud Gateway 的工作流程\"></p>\n<ol>\n<li><strong>路由判断</strong>：客户端的请求到达网关后，先经过 Gateway Handler Mapping 处理，这里面会做断言（Predicate）判断，看下符合哪个路由规则，这个路由映射后端的某个服务。</li>\n<li><strong>请求过滤</strong>：然后请求到达 Gateway Web Handler，这里面有很多过滤器，组成过滤器链（Filter Chain），这些过滤器可以对请求进行拦截和修改，比如添加请求头、参数校验等等，有点像净化污水。然后将请求转发到实际的后端服务。这些过滤器逻辑上可以称作 Pre-Filters，Pre 可以理解为“在…之前”。</li>\n<li><strong>服务处理</strong>：后端服务会对请求进行处理。</li>\n<li><strong>响应过滤</strong>：后端处理完结果后，返回给 Gateway 的过滤器再次做处理，逻辑上可以称作 Post-Filters，Post 可以理解为“在…之后”。</li>\n<li><strong>响应返回</strong>：响应经过过滤处理后，返回给客户端。</li>\n</ol>\n<h4 id=\"内部调用\"><a href=\"#内部调用\" class=\"headerlink\" title=\"内部调用\"></a>内部调用</h4><p>微服务A和B在注册中心注册后，可通过内部服务名（如 <code>payment-service</code>）直接调用，无需经过网关</p>\n<p><strong>注册中心的健康检查</strong></p>\n<ul>\n<li><strong>心跳检测</strong>：服务实例定期向注册中心发送心跳（如Eureka默认30秒一次），若超时未收到心跳（Eureka默认90秒），则标记实例为不可用并剔除</li>\n<li><strong>主动探针</strong>：Nacos支持TCP/HTTP主动探针，实时检测服务健康状态</li>\n</ul>\n<p><strong>客户端的动态更新</strong></p>\n<ul>\n<li><strong>本地缓存</strong>：客户端（如Ribbon）会定期从注册中心拉取最新服务列表（默认30秒），并缓存到本地。当某节点挂掉时，客户端在下一次请求时会自动跳过该节点</li>\n<li><strong>故障转移</strong>：负载均衡器（如Ribbon）在调用失败时自动重试其他可用实例（默认不重试，需配置 <code>RetryPolicy</code>）</li>\n</ul>\n<h4 id=\"内部绕过鉴权\"><a href=\"#内部绕过鉴权\" class=\"headerlink\" title=\"内部绕过鉴权\"></a>内部绕过鉴权</h4><p>其实内部也不需要再鉴权了</p>\n<p>内部请求的时候添加请求头：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 内部服务调用时添加请求头</span></span><br><span class=\"line\">webClient.get()</span><br><span class=\"line\">    .uri(<span class=\"string\">&quot;http://internal-service/api/data&quot;</span>)</span><br><span class=\"line\">    .header(<span class=\"string\">&quot;X-Internal&quot;</span>, <span class=\"string\">&quot;true&quot;</span>)</span><br><span class=\"line\">    .retrieve();</span><br></pre></td></tr></table></figure>\n<p><strong>结合IP白名单限制</strong></p>\n<ul>\n<li>网关配置：在网关过滤器中校验请求来源IP是否属于内部网络</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InternalIpFilter</span> <span class=\"keyword\">implements</span> <span class=\"title\">GlobalFilter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Mono&lt;Void&gt; <span class=\"title\">filter</span><span class=\"params\">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class=\"line\">        String clientIp = exchange.getRequest().getRemoteAddress().getAddress().getHostAddress();</span><br><span class=\"line\">        <span class=\"comment\">// 判断是否是内部的请求</span></span><br><span class=\"line\">      \t<span class=\"keyword\">if</span> (isInternalIp(clientIp) &amp;&amp; exchange.getRequest().getHeaders().containsKey(<span class=\"string\">&quot;X-Internal&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> chain.filter(exchange);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      \t<span class=\"comment\">// 外部就需要校验</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> checkAuth(exchange, chain);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>临时Token+请求头</strong></p>\n<p>内部服务调用时生成带时效和签名的Token（如JWT），网关验证Token有效性</p>\n<h4 id=\"服务发现\"><a href=\"#服务发现\" class=\"headerlink\" title=\"服务发现\"></a>服务发现</h4><table>\n<thead>\n<tr>\n<th><strong>注册中心</strong></th>\n<th><strong>一致性模型</strong></th>\n<th><strong>功能扩展</strong></th>\n<th><strong>适用场景</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Eureka</strong></td>\n<td>AP</td>\n<td>服务注册与发现</td>\n<td>Spring Cloud 传统架构</td>\n</tr>\n<tr>\n<td><strong>Consul</strong></td>\n<td>CA（最终一致）</td>\n<td>多数据中心、KV 存储</td>\n<td>混合云或复杂网络环境</td>\n</tr>\n<tr>\n<td><strong>Nacos</strong></td>\n<td>AP/CP 可选</td>\n<td>动态配置管理</td>\n<td>云原生、多环境配置统一</td>\n</tr>\n<tr>\n<td><strong>ZooKeeper</strong></td>\n<td>CP</td>\n<td>分布式协调</td>\n<td>强一致性要求的金融或交易系统</td>\n</tr>\n<tr>\n<td><strong>Etcd</strong></td>\n<td>CP</td>\n<td>键值存储</td>\n<td>Kubernetes 集群或分布式数据库</td>\n</tr>\n<tr>\n<td><strong>Kubernetes</strong></td>\n<td>无独立模型</td>\n<td>容器编排集成</td>\n<td>已容器化的云原生应用</td>\n</tr>\n</tbody></table>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><ul>\n<li><strong>中小型项目</strong>：优先选择 <strong>Nacos</strong>（功能全面）或 <strong>Consul</strong>（多数据中心）。</li>\n<li><strong>强一致性需求</strong>：选择 <strong>ZooKeeper</strong> 或 <strong>Etcd</strong>。</li>\n<li><strong>云原生环境</strong>：直接使用 <strong>Kubernetes 原生服务发现</strong>。</li>\n<li><strong>历史系统迁移</strong>：若原用 Eureka，可逐步过渡到 Nacos 以兼容 Spring Cloud 生态</li>\n</ul>\n<h2 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h2><h3 id=\"分布式\"><a href=\"#分布式\" class=\"headerlink\" title=\"分布式\"></a>分布式</h3><p>主从复制：Redis集群（master负责写请求，slave负责读请求）</p>\n<img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/1676964296594-1f216792-7828-4e11-bd01-d30c63a37f89-20250304-160612.png\" alt=\"img\" style=\"zoom: 50%;\" />\n\n<h3 id=\"延迟双删策略\"><a href=\"#延迟双删策略\" class=\"headerlink\" title=\"延迟双删策略\"></a>延迟双删策略</h3><p><strong>延迟双删策略</strong>是用于维护数据库（如 MySQL）与 Redis 缓存之间数据最终一致性的常见方案。其核心步骤为：</p>\n<ol>\n<li><strong>第一次删除缓存</strong>：在更新数据库前，先删除 Redis 中的缓存数据，避免其他线程在数据库更新期间读取到旧数据。</li>\n<li><strong>更新数据库</strong>：执行数据库的写入操作。</li>\n<li><strong>第二次延迟删除缓存</strong>：在数据库更新完成后，延迟一段时间（如 1-5 秒），再次删除缓存。此步骤的目的是防止在数据库主从同步延迟期间，其他线程将旧数据重新写入缓存</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th><strong>方案</strong></th>\n<th><strong>一致性强度</strong></th>\n<th><strong>复杂度</strong></th>\n<th><strong>适用场景</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>延迟双删</strong></td>\n<td>最终一致性</td>\n<td>低</td>\n<td>高频更新、容忍短暂不一致</td>\n</tr>\n<tr>\n<td><strong>先更新数据库再删缓存</strong></td>\n<td>更高一致性</td>\n<td>中</td>\n<td>强一致性要求（如金融交易）</td>\n</tr>\n<tr>\n<td><strong>Canal 监听 binlog</strong></td>\n<td>最终一致性</td>\n<td>高</td>\n<td>无需侵入业务代码的大规模系统</td>\n</tr>\n<tr>\n<td><strong>分布式锁（如 Redisson）</strong></td>\n<td>强一致性</td>\n<td>高</td>\n<td>对性能要求低、强一致性场景</td>\n</tr>\n</tbody></table>\n<p>缓存和数据库一致性：<a href=\"https://mp.weixin.qq.com/s?__biz=MzIyOTYxNDI5OA==&amp;mid=2247487312&amp;idx=1&amp;sn=fa19566f5729d6598155b5c676eee62d&amp;chksm=e8beb8e5dfc931f3e35655da9da0b61c79f2843101c130cf38996446975014f958a6481aacf1&amp;scene=178&amp;cur_album_id=1699766580538032128#rd\">https://mp.weixin.qq.com/s?__biz=MzIyOTYxNDI5OA==&amp;mid=2247487312&amp;idx=1&amp;sn=fa19566f5729d6598155b5c676eee62d&amp;chksm=e8beb8e5dfc931f3e35655da9da0b61c79f2843101c130cf38996446975014f958a6481aacf1&amp;scene=178&amp;cur_album_id=1699766580538032128#rd</a></p>\n<p>流行的解决方案：<strong>订阅数据库变更日志，再操作缓存</strong>。</p>\n<p>具体来讲就是，我们的业务应用在修改数据时，「只需」修改数据库，无需操作缓存。</p>\n<p>那什么时候操作缓存呢？这就和数据库的「变更日志」有关了。</p>\n<p>拿 MySQL 举例，当一条数据发生修改时，MySQL 就会产生一条变更日志（Binlog），我们可以订阅这个日志，拿到具体操作的数据，然后再根据这条数据，去删除对应的缓存。</p>\n<img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/640-20250306-204147.jpg\" alt=\"图片\" style=\"zoom:50%;\" />\n\n<p>整体流程如下：</p>\n<ul>\n<li><strong>监听Binlog</strong>：通过中间件（如Canal、Maxwell）模拟MySQL从库，实时捕获Binlog事件。</li>\n<li><strong>数据转换</strong>：将Binlog中的操作转换为Redis命令（如SET、DEL），保证缓存与数据库操作一致。</li>\n<li><strong>异步处理</strong>：通过消息队列（如Kafka、RocketMQ）解耦，实现削峰填谷和失败重试</li>\n</ul>\n<h3 id=\"k-v结构\"><a href=\"#k-v结构\" class=\"headerlink\" title=\"k-v结构\"></a>k-v结构</h3><p>Redis 使用一个<strong>全局哈希表</strong>（<code>dict</code>）来存储所有键值对，哈希表的结构如下：</p>\n<ul>\n<li><strong>哈希桶（Hash Bucket）</strong>：通过哈希函数将键（Key）映射到哈希桶中，每个桶存储指向具体键值对的指针；</li>\n<li><strong>哈希节点（<code>dictEntry</code>）</strong>：每个节点包含键、值指针以及指向下一个节点的指针（用于解决哈希冲突）</li>\n</ul>\n<p>哈希表的调整：</p>\n<ul>\n<li><strong>渐进式 Rehash</strong>：当哈希表负载因子（元素数量 / 哈希表大小）超过阈值时，Redis 会启动渐进式 Rehash，逐步将数据从旧哈希表迁移到新哈希表，避免一次性迁移导致的性能抖动</li>\n</ul>\n<h3 id=\"看门狗机制\"><a href=\"#看门狗机制\" class=\"headerlink\" title=\"看门狗机制\"></a>看门狗机制</h3><p><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250321155521729-20250321-155522.png\" alt=\"image-20250321155521729\"></p>\n<p>后台线程池：执行续期操作</p>\n<p>时间轮算法：异步原子地续期</p>\n<h2 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h2><h3 id=\"多态的两种表现\"><a href=\"#多态的两种表现\" class=\"headerlink\" title=\"多态的两种表现\"></a>多态的两种表现</h3><ol>\n<li>编译时多态</li>\n</ol>\n<ul>\n<li>方法重载</li>\n</ul>\n<ol start=\"2\">\n<li>运行时多态：运行时才能确定</li>\n</ol>\n<ul>\n<li>方法重写</li>\n<li>接口实现</li>\n</ul>\n<p>运行时多态的实现机制：</p>\n<ul>\n<li><strong>动态绑定</strong>：JVM 在运行时根据对象类型解析方法调用地址</li>\n<li><strong>虚方法表（VTable）</strong>：存储类的方法地址，子类重写方法会覆盖虚表中的父类方法指针</li>\n</ul>\n<h3 id=\"throw和throws\"><a href=\"#throw和throws\" class=\"headerlink\" title=\"throw和throws\"></a>throw和throws</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">str2int</span><span class=\"params\">(String str)</span> <span class=\"keyword\">throws</span> Exception </span>&#123; <span class=\"comment\">//这里将得到的异常向外抛出，可以抛出多个</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        System.out.println(Integer.parseInt(str));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(NumberFormatException e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//TODO 这里可以做一些处理，处理完成后将异常报出，让外层可以得到异常信息</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">&quot;格式化异常&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Java性能分析\"><a href=\"#Java性能分析\" class=\"headerlink\" title=\"Java性能分析\"></a>Java性能分析</h3><p>使用top初步定位进程，之后通过jstack找到对应线程的堆栈信息</p>\n<ul>\n<li>jconsole也是一个查看当前java进程运行情况，可以检测死锁。jconsole可以分析出来内存情况，以及能看到线程状态。结合运行前的heapdumppath，可以分析出当前堆内存占用情况，找到时哪一段对应变量造成的，从而定位问题</li>\n<li>jstack：生成虚拟机当前时刻的线程快照。 用于生成 Java 进程在<strong>某个时间点</strong>的所有线程堆栈信息，帮助定位死锁、死循环、资源等待等问题</li>\n</ul>\n<h3 id=\"JVM内存分配\"><a href=\"#JVM内存分配\" class=\"headerlink\" title=\"JVM内存分配\"></a>JVM内存分配</h3><p>JVM给对象分配内存有多种策略。</p>\n<ol>\n<li>基于堆内存的常规分配：<ul>\n<li>指针碰撞</li>\n<li>空闲列表</li>\n</ul>\n</li>\n<li>多线程分配优化：<ul>\n<li>CAS+重试</li>\n<li>线程本地分配缓冲TLAB</li>\n</ul>\n</li>\n<li>特殊场景：<ul>\n<li>栈上分配：通过<strong>逃逸分析</strong>确定对象生命周期不逃逸出方法（直接在栈帧中分配，结束后自动销毁，避免堆内存分配）</li>\n</ul>\n</li>\n</ol>\n<p>逃逸分析：JVM在编译期或运行时的优化技术，主要用于分析对象的动态作用域，判断是否会被外部方法或线程访问。核心目的是减少堆内存分配、同步开销和对象生命周期管理成本。</p>\n<p>根据分析结果，会应用以下优化技术：</p>\n<ul>\n<li><strong>栈上分配</strong>：若对象未逃逸（仅在当前线程或方法内使用），JVM 可将对象分配在栈帧中，随方法结束自动销毁，无需垃圾回收</li>\n<li><strong>标量替换</strong>：若对象未逃逸且结构简单，JVM 会将其拆解为独立的标量（如 <code>int</code>、<code>double</code>）或字段，直接存储在栈或寄存器中</li>\n<li><strong>同步消除</strong>：若对象未逃逸且仅被单线程访问，JVM 会移除其同步锁（如 <code>synchronized</code> 块）</li>\n</ul>\n<h3 id=\"CPU空转问题\"><a href=\"#CPU空转问题\" class=\"headerlink\" title=\"CPU空转问题\"></a>CPU空转问题</h3><p>CPU 空转通常由未合理阻塞的循环或锁竞争引起。JVM 通过自适应自旋锁和锁升级机制减少无效空转，开发者需结合以下策略：</p>\n<ol>\n<li><strong>代码层面</strong>：用阻塞方法（如 <code>take()</code>）替代轮询，设置自旋超时，利用线程池控制并发。</li>\n<li><strong>工具定位</strong>：通过 <code>jstack</code> 或 Arthas 定位高 CPU 线程，分析是否为自旋锁或死循环。</li>\n<li><strong>锁优化</strong>：评估锁粒度，优先使用 <code>ReentrantLock</code> 替代 <code>synchronized</code>，结合条件变量减少竞争（如网页43的锁示例）。 例如，某压测场景中，通过火焰图定位到 <code>while(true)</code> 空循环，添加 <code>Thread.sleep(50)</code> 后 CPU 从 95% 降至正常水平</li>\n</ol>\n<h3 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h3><p>线程池参数，过期时间的意义，超出核心线程数的会被回收吗，非核心线程会被回收吗？怎么判断他要不要回收，怎么知道他过期了的。那我创建十个线程，1<del>10,核心数8个，9和10还在执行任务，1</del>8不执行了，这时候会怎么做。<br>说说线程池的阻塞队列有什么用，为什么用阻塞队列不用普通队列，在并发情况下，往队列中加任务不会有线程安全问题吗。</p>\n<p>TODO</p>\n<h3 id=\"callable和runnable区别\"><a href=\"#callable和runnable区别\" class=\"headerlink\" title=\"callable和runnable区别\"></a>callable和runnable区别</h3><table>\n<thead>\n<tr>\n<th><strong>对比维度</strong></th>\n<th><strong>Runnable</strong></th>\n<th><strong>Callable</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>接口定义</strong></td>\n<td><code>public interface Runnable &#123; void run(); &#125;</code></td>\n<td><code>public interface Callable&lt;V&gt; &#123; V call() throws Exception; &#125;</code></td>\n</tr>\n<tr>\n<td><strong>返回值</strong></td>\n<td><strong>无返回值</strong>（<code>void</code>）</td>\n<td><strong>有返回值</strong>（泛型类型 <code>V</code>）</td>\n</tr>\n<tr>\n<td><strong>异常处理</strong></td>\n<td>无法抛出受检异常（必须内部 <code>try-catch</code> 处理）</td>\n<td>允许抛出受检异常（通过 <code>Future.get()</code> 捕获 <code>ExecutionException</code> 获取原因）</td>\n</tr>\n<tr>\n<td><strong>执行方式</strong></td>\n<td>通过 <code>Thread</code> 或 <code>Executor.execute()</code> 直接执行</td>\n<td>必须通过 <code>ExecutorService.submit()</code> 提交，返回 <code>Future</code> 对象</td>\n</tr>\n<tr>\n<td><strong>任务管理</strong></td>\n<td>无状态追踪，无法取消任务或获取结果</td>\n<td>通过 <code>Future</code> 管理任务状态（取消、超时、结果查询）</td>\n</tr>\n<tr>\n<td><strong>泛型支持</strong></td>\n<td>不支持</td>\n<td>支持（通过泛型指定返回值类型，如 <code>Callable&lt;String&gt;</code>）</td>\n</tr>\n</tbody></table>\n<h3 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h3><p>反射的核心方法是invoke，通过调用jvm内部的native方法，完成动态方法调用</p>\n<h4 id=\"性能影响\"><a href=\"#性能影响\" class=\"headerlink\" title=\"性能影响\"></a>性能影响</h4><ol>\n<li>动态解析和运行时开销：需要动态加载类、解析方法/字段的元数据，这些操作在直接调用中是由编译器完成的</li>\n<li>方法调用的性能损失：反射调用（如 <code>method.invoke()</code>）无法享受 JIT 编译器的优化（如方法内联），导致执行速度比直接调用慢约 <strong>10-30倍</strong></li>\n</ol>\n<p>优化方向：</p>\n<ul>\n<li>缓存反射元数据：将频繁使用的 <code>Method</code>、<code>Field</code> 对象缓存起来，避免重复解析</li>\n<li>使用高性能反射库：如<strong>Spring的 <code>ReflectionUtils</code></strong></li>\n</ul>\n<h3 id=\"泛型机制\"><a href=\"#泛型机制\" class=\"headerlink\" title=\"泛型机制\"></a>泛型机制</h3><p>Java的泛型是伪泛型，在编译期间所有泛型信息都会被擦除，也就是类型擦除。</p>\n<p>即使泛型擦除存在，但是使用泛型仍然存在一系列好处：</p>\n<ul>\n<li>可以在编译期间进行类型检查</li>\n<li>使用Object类型需要手动添加强制类型转换</li>\n</ul>\n<p>泛型可以增强代码的可读性和稳定性，编译器会对泛型参数进行检测（指定传入对象的类型）</p>\n<h3 id=\"并发的同步\"><a href=\"#并发的同步\" class=\"headerlink\" title=\"并发的同步\"></a>并发的同步</h3><p>Synchronized 关键字</p>\n<p>Lock接口及其实现类</p>\n<p>原子类</p>\n<p>并发集合</p>\n<p>读写锁</p>\n<p>线程同步工具（CountdownLatch、Semaphore）</p>\n<h3 id=\"并发编程的三个特性\"><a href=\"#并发编程的三个特性\" class=\"headerlink\" title=\"并发编程的三个特性\"></a>并发编程的三个特性</h3><ol>\n<li><strong>原子性</strong></li>\n</ol>\n<p>一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。</p>\n<p>在 Java 中，可以借助 <code>synchronized</code>、各种 <code>Lock</code> 以及各种原子类实现原子性。</p>\n<p><code>synchronized</code> 和各种 <code>Lock</code> 可以保证任一时刻只有一个线程访问该代码块，因此可以保障原子性。各种原子类是利用 CAS (compare and swap) 操作（可能也会用到 <code>volatile</code>或者 <code>final</code>关键字）来保证原子操作。</p>\n<ol start=\"2\">\n<li><strong>可见性</strong></li>\n</ol>\n<p>当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。</p>\n<p>在 Java 中，可以借助 <code>synchronized</code>、<code>volatile</code> 以及各种 <code>Lock</code> 实现可见性。</p>\n<p>如果我们将变量声明为 <code>volatile</code> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>\n<ol start=\"3\">\n<li><strong>有序性</strong></li>\n</ol>\n<p>在 Java 中，<code>volatile</code> 关键字可以禁止指令进行重排序优化。</p>\n<h3 id=\"AQS\"><a href=\"#AQS\" class=\"headerlink\" title=\"AQS\"></a>AQS</h3><p>参考文献：<a href=\"https://mp.weixin.qq.com/s/jEx-4XhNGOFdCo4Nou5tqg\">https://mp.weixin.qq.com/s/jEx-4XhNGOFdCo4Nou5tqg</a></p>\n<p>抽象类，为同步器提供了通用的执行框架。定义了资源获取和释放的通用流程，具体的资源获取和释放则通过模版方法来实现。</p>\n<p>性能好的点在于：<strong>CAS+线程阻塞/唤醒</strong></p>\n<p><strong>核心思想</strong>：如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态</p>\n<h3 id=\"synchronized和Lock的区别\"><a href=\"#synchronized和Lock的区别\" class=\"headerlink\" title=\"synchronized和Lock的区别\"></a>synchronized和Lock的区别</h3><table>\n<thead>\n<tr>\n<th><strong>维度</strong></th>\n<th><strong>synchronized</strong></th>\n<th><strong>Lock</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>锁释放</strong></td>\n<td>自动释放（代码块结束或异常）</td>\n<td>手动释放（需 <code>unlock()</code>）</td>\n</tr>\n<tr>\n<td><strong>公平性</strong></td>\n<td>仅非公平锁</td>\n<td>支持公平锁与非公平锁</td>\n</tr>\n<tr>\n<td><strong>中断响应</strong></td>\n<td>不支持</td>\n<td>支持（<code>lockInterruptibly()</code>）</td>\n</tr>\n<tr>\n<td><strong>锁状态检测</strong></td>\n<td>无法判断</td>\n<td>可检测（<code>tryLock()</code>）</td>\n</tr>\n<tr>\n<td><strong>性能</strong></td>\n<td>低竞争场景优</td>\n<td>高竞争场景优</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>简单同步、快速开发</td>\n<td>复杂逻辑、高并发优化</td>\n</tr>\n</tbody></table>\n<p>从底层实现上：</p>\n<ul>\n<li>synchronized是java的关键词，由jvm直接管理，通过字节码指令 <code>monitorenter</code>和 <code>monitorexit</code>实现（还有锁升级机制）</li>\n<li>Lock是类，实现包括：<ul>\n<li>乐观锁，基于volatile变量和CAS算法实现</li>\n<li><code>ReentrantLock</code> 通过 AQS 维护锁状态和等待队列，支持可重入性和公平性</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Future和CompletableFuture\"><a href=\"#Future和CompletableFuture\" class=\"headerlink\" title=\"Future和CompletableFuture\"></a>Future和CompletableFuture</h3><p>应用为主</p>\n<p>CompletableFuture支持任务之间的并行调用，在等待A任务执行完之后执行另外的任务，也支持组合两个任务，等待两个任务同时执行完毕</p>\n<h3 id=\"ForkJoinPool\"><a href=\"#ForkJoinPool\" class=\"headerlink\" title=\"ForkJoinPool\"></a>ForkJoinPool</h3><p><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250310163700719-20250310-163702.png\" alt=\"image-20250310163700719\"></p>\n<p>CompletableFuture如果不自定义线程池，默认使用的全局线程池就是ForkJoinPool</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MergeSortTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">RecursiveAction</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] array;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> left, right;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> THRESHOLD = <span class=\"number\">1000</span>; <span class=\"comment\">// 拆分阈值</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">compute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (right - left &lt;= THRESHOLD) &#123;</span><br><span class=\"line\">            Arrays.sort(array, left, right); <span class=\"comment\">// 小任务直接排序</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> mid = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            invokeAll(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> MergeSortTask(array, left, mid),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> MergeSortTask(array, mid, right)</span><br><span class=\"line\">            );</span><br><span class=\"line\">            merge(array, left, mid, right); <span class=\"comment\">// 合并结果</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用方式</span></span><br><span class=\"line\">ForkJoinPool pool = <span class=\"keyword\">new</span> ForkJoinPool();</span><br><span class=\"line\">pool.invoke(<span class=\"keyword\">new</span> MergeSortTask(arr, <span class=\"number\">0</span>, arr.length));</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.RecursiveTask;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ForkJoinSumCalculator</span> <span class=\"keyword\">extends</span> <span class=\"title\">RecursiveTask</span>&lt;<span class=\"title\">Long</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span>[] array;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> start;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> end;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> THRESHOLD = <span class=\"number\">10_000</span>; <span class=\"comment\">// 任务拆分阈值</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ForkJoinSumCalculator</span><span class=\"params\">(<span class=\"keyword\">long</span>[] array)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(array, <span class=\"number\">0</span>, array.length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">ForkJoinSumCalculator</span><span class=\"params\">(<span class=\"keyword\">long</span>[] array, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.array = array;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.start = start;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.end = end;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Long <span class=\"title\">compute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = end - start;</span><br><span class=\"line\">        <span class=\"comment\">// 如果任务足够小，直接计算</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (length &lt;= THRESHOLD) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> computeDirectly();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 拆分任务：将大任务分为两个子任务</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = start + length / <span class=\"number\">2</span>;</span><br><span class=\"line\">        ForkJoinSumCalculator leftTask = <span class=\"keyword\">new</span> ForkJoinSumCalculator(array, start, mid);</span><br><span class=\"line\">        ForkJoinSumCalculator rightTask = <span class=\"keyword\">new</span> ForkJoinSumCalculator(array, mid, end);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 异步执行左半部分任务（fork）</span></span><br><span class=\"line\">        leftTask.fork();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 同步执行右半部分任务，并合并结果（join）</span></span><br><span class=\"line\">        Long rightResult = rightTask.compute();</span><br><span class=\"line\">        Long leftResult = leftTask.join();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> leftResult + rightResult;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 直接计算区间和</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">long</span> <span class=\"title\">computeDirectly</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class=\"line\">            sum += array[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span>[] array = <span class=\"keyword\">new</span> <span class=\"keyword\">long</span>[<span class=\"number\">100_000</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">            array[i] = i + <span class=\"number\">1</span>; <span class=\"comment\">// 初始化数组为1~100000</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建ForkJoinPool并提交任务</span></span><br><span class=\"line\">        ForkJoinPool pool = <span class=\"keyword\">new</span> ForkJoinPool();</span><br><span class=\"line\">        Long result = pool.invoke(<span class=\"keyword\">new</span> ForkJoinSumCalculator(array));</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;计算结果: &quot;</span> + result); <span class=\"comment\">// 应输出5000050000</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>避免饥饿：通过工作窃取机制，空闲线程主动从其他队列窃取任务，动态平衡负载（内部会为每一个线程简历一个工作队列）</li>\n<li>合理设置任务拆分阈值（THRESHOLD）</li>\n</ol>\n<p>关键点：<strong>分治策略</strong> + <strong>工作窃取</strong></p>\n<h3 id=\"Hash结构的数据解决哈希冲突的方法有哪些\"><a href=\"#Hash结构的数据解决哈希冲突的方法有哪些\" class=\"headerlink\" title=\"Hash结构的数据解决哈希冲突的方法有哪些\"></a>Hash结构的数据解决哈希冲突的方法有哪些</h3><ol>\n<li>开放定址法：哈希冲突发生时，按照特定的规则寻找下一个哈希地址</li>\n<li>链地址法</li>\n<li>再哈希法（使用备用哈希函数）</li>\n<li>公共溢出区法</li>\n</ol>\n<h3 id=\"HashMap和HashTable的区别\"><a href=\"#HashMap和HashTable的区别\" class=\"headerlink\" title=\"HashMap和HashTable的区别\"></a>HashMap和HashTable的区别</h3><ol>\n<li>线程安全性：HashMap线程不安全，HashTable线程安全（内部方法都通过synchronized关键词修饰）</li>\n<li>效率：HashMap高于HashTable（为了保证线程安全，牺牲了性能）</li>\n<li>对Null的支持：HashMap允许存在Null的key和value，而HashTable不允许</li>\n<li>初始化容量：<ul>\n<li>HashMap初始化大小为16，每次扩容两倍；如果设置了初始大小，就会设置为比初始大小大的2的幂次方</li>\n<li>HashTable初始大小为11，每次扩容2n+1；如果设置了初始大小，则直接使用初始大小</li>\n</ul>\n</li>\n<li>1.8后的HashMap存在链表转红黑树的过程</li>\n<li>HashMap对哈希值的高位和低位进行了扰动处理</li>\n</ol>\n<h3 id=\"单例模式的破坏\"><a href=\"#单例模式的破坏\" class=\"headerlink\" title=\"单例模式的破坏\"></a>单例模式的破坏</h3><ol>\n<li><strong>反射绕过单例</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class&lt;?&gt; clazz = Singleton.class;</span><br><span class=\"line\">Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor();</span><br><span class=\"line\">constructor.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">Singleton instance1 = (Singleton) constructor.newInstance();</span><br><span class=\"line\">Singleton instance2 = (Singleton) constructor.newInstance();</span><br><span class=\"line\">System.out.println(instance1 == instance2); <span class=\"comment\">// 输出 false</span></span><br></pre></td></tr></table></figure>\n<p>可以直接在构造函数中去进行实例检查：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Inner.instance != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;禁止通过反射创建实例！&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意懒汉式，还需要额外进行考虑，添加一个状态位：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flag) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;禁止反射创建！&quot;</span>);</span><br><span class=\"line\">        flag = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      \t<span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          ...</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是，状态位也可能会被反射更新。因此，懒汉式实现的单例模式是不可以防止被反射破坏的</p>\n<ol start=\"2\">\n<li><strong>序列化和反序列化对单例模式的破坏</strong></li>\n</ol>\n<p>单例类实现 <code>Serializable</code> 接口后，反序列化时会通过反射生成新对象，而非复用已有实例。</p>\n<p>解决方法：</p>\n<p>（1）枚举类会直接返回已有实例</p>\n<p>（2）添加readResolve()，返回已有实例。**<code>readResolve()</code> 是 Java 序列化机制中的一个特殊回调方法**，用于在反序列化过程中替换或控制最终返回的对象</p>\n<p>可以考虑实现单例模式的另外两种方案：</p>\n<ol>\n<li><strong>枚举单例</strong> （最优方案）</li>\n</ol>\n<p>枚举类禁止创建反射单例（JVM禁止），也不需要依赖构造函数检查</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    INSTANCE;</span><br><span class=\"line\">    <span class=\"comment\">// 添加方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>优势</strong>：无需手动防御反射，安全性最高</p>\n<ol start=\"2\">\n<li>静态内部类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Holder</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Holder.INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>原理</strong>：静态内部类在首次调用 <code>getInstance()</code> 时才加载，JVM保证类加载过程的线程安全性</p>\n<h3 id=\"新版本Java\"><a href=\"#新版本Java\" class=\"headerlink\" title=\"新版本Java\"></a>新版本Java</h3><p>Java24发布了，最重要的一个特性：<strong>虚拟线程的同步而不固定平台线程</strong></p>\n<p>优化了虚拟线程与 <code>synchronized</code> 的工作机制。虚拟线程在 <code>synchronized</code> 方法和代码块中阻塞时，通常能够释放其占用的操作系统线程（平台线程），避免了对平台线程的长时间占用，从而提升应用程序的并发能力。这种机制避免了“固定 (Pinning)”——即虚拟线程长时间占用平台线程，阻止其服务于其他虚拟线程的情况。</p>\n<p>现有的使用 <code>synchronized</code> 的 Java 代码无需修改即可受益于虚拟线程的扩展能力。例如，一个 I/O 密集型的应用程序，如果使用传统的平台线程，可能会因为线程阻塞而导致并发能力下降。而使用虚拟线程，即使在 <code>synchronized</code> 块中发生阻塞，也不会固定平台线程，从而允许平台线程继续服务于其他虚拟线程，提高整体的并发性能。</p>\n<p><strong>核心</strong>：虚拟线程在被synchronized阻塞的时候，会释放掉所占用的平台线程</p>\n<p><strong>提前类加载和链接</strong>：缓存已经加载和链接过的类，减少重复工作的开销（无侵入）</p>\n<h3 id=\"Spring-Task\"><a href=\"#Spring-Task\" class=\"headerlink\" title=\"Spring Task\"></a>Spring Task</h3><p><code>ScheduledThreadPoolExecutor</code> 是 JDK 自带的定时调度器，基于一个 <strong>延时队列（DelayedWorkQueue）</strong> 来管理任务：</p>\n<ul>\n<li>提交任务时，会计算出<strong>下次执行的时间戳</strong>，丢进延时队列。</li>\n<li>一个专门的工作线程会不断从队列里取“到期的任务”，放到线程池里去执行。</li>\n<li>如果是周期任务（fixedRate/fixedDelay），执行完毕后会<strong>重新计算下次时间</strong>，再放回队列</li>\n</ul>\n<p>默认使用<code>ThreadPoolTaskScheduler</code> 的线程池大小 = 1，也就是单线程顺序执行。因此，可以自己配置一个线程池：</p>\n<ul>\n<li><strong>扫描 @Scheduled 注解</strong> → 注册成定时任务。</li>\n<li><strong>交给 TaskScheduler（默认 ThreadPoolTaskScheduler）</strong> 管理。</li>\n<li><strong>底层依赖 JDK 的 ScheduledThreadPoolExecutor</strong>（基于延时队列实现）。</li>\n<li>周期任务 / Cron 任务：每次执行完毕后算出下一次执行时间，再丢回调度队列</li>\n</ul>\n<h2 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h2><p>htop查看内存占用情况，PID等信息</p>\n<p><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250305125116718-20250305-125117.png\" alt=\"image-20250305125116718\"></p>\n<h3 id=\"处理大文件\"><a href=\"#处理大文件\" class=\"headerlink\" title=\"处理大文件\"></a>处理大文件</h3><blockquote>\n<p>Linux读取大文件进行文本替换</p>\n</blockquote>\n<p><strong>使用 <code>sed</code> 命令（流式处理，内存友好）</strong></p>\n<ul>\n<li><strong>适用场景</strong>：全局或局部替换文本，支持正则表达式。</li>\n<li><strong>优势</strong>：逐行处理文件，无需加载整个文件到内存。</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 替换文件中所有 <span class=\"string\">&quot;old_text&quot;</span> 为 <span class=\"string\">&quot;new_text&quot;</span>（直接修改原文件）</span></span><br><span class=\"line\">sed -i &#x27;s/old_text/new_text/g&#x27; large_file.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 仅替换第 100 到 200 行的内容</span></span><br><span class=\"line\">sed -i &#x27;100,200s/old_text/new_text/g&#x27; large_file.txt</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250321125123282-20250321-125126.png\" alt=\"image-20250321125123282\"></p>\n<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><h3 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h3><ol>\n<li>每个节点非黑即红，黑色代表平衡，红色代表不平衡；</li>\n<li>根节点总是黑色的</li>\n<li>每个叶子节点都是黑色的空节点（NIL 节点）。这里指的是红黑树都会有一个空的叶子节点，是红黑树自己的规则；</li>\n<li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</li>\n<li>从任意节点到它的叶子节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</li>\n</ol>\n<h2 id=\"Etcd\"><a href=\"#Etcd\" class=\"headerlink\" title=\"Etcd\"></a>Etcd</h2><h3 id=\"备份过程数据的一致性\"><a href=\"#备份过程数据的一致性\" class=\"headerlink\" title=\"备份过程数据的一致性\"></a>备份过程数据的一致性</h3><p>原因在于它不是简单去拷贝数据文件，而是通过 <strong>Raft 一致性和 etcd 的 MVCC 存储机制</strong> 来保证</p>\n<ul>\n<li>etcd 集群所有写入必须经过 <strong>Raft 共识</strong> 才能提交。</li>\n<li>当执行 <code>etcdctl snapshot save</code> 时，etcd 会选定一个<strong>一致的 Raft 提交点</strong>（commit index），以该时刻为快照边界</li>\n<li>etcd 底层使用 <strong>boltdb</strong> 存储，并且有 <strong>MVCC（多版本并发控制）索引层</strong></li>\n</ul>\n<p>综上，一致性保障来源于两方面：</p>\n<p><strong>Raft 共识 → 确保提交点一致</strong>；</p>\n<p><strong>MVCC 快照 → 确保读取的是某个固定 revision 的全局状态</strong></p>\n<p> <strong>MVCC 在这里的作用</strong>就是：保证 <code>snapshot save</code> 读出的所有数据属于同一个 revision，不会前后混杂</p>\n<h3 id=\"Raft-而非-Paxos\"><a href=\"#Raft-而非-Paxos\" class=\"headerlink\" title=\"Raft 而非 Paxos\"></a>Raft 而非 Paxos</h3><p><strong>Paxos</strong>：理论优雅，但工程实现复杂，难以理解和维护；</p>\n<p><strong>Raft</strong>：在保证相同一致性语义的前提下，更直观、更易实现和维护</p>\n<p>一句话总结：Raft 更工程友好，理解和实现成本更低，维护更容易</p>\n<h3 id=\"Etcd-VS-Zookeeper\"><a href=\"#Etcd-VS-Zookeeper\" class=\"headerlink\" title=\"Etcd VS Zookeeper\"></a>Etcd VS Zookeeper</h3><p>Zookeeper的问题：</p>\n<p><strong>Watch 机制不足</strong></p>\n<ul>\n<li>触发一次就失效，需要重新注册；</li>\n<li>客户端多时容易引发“惊群效应”</li>\n</ul>\n<p><strong>一致性协议复杂</strong></p>\n<ul>\n<li>ZAB 没有 Raft 那么直观，理解和验证成本高</li>\n</ul>\n<h1 id=\"场景题\"><a href=\"#场景题\" class=\"headerlink\" title=\"场景题\"></a>场景题</h1><h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><p>智力题pdf： <a href=\"%E5%9C%BA%E6%99%AF%E9%A2%98.pdf\">场景题.pdf</a> </p>\n<h3 id=\"最大的100个数字\"><a href=\"#最大的100个数字\" class=\"headerlink\" title=\"最大的100个数字\"></a>最大的100个数字</h3><blockquote>\n<p>有很多个没有排序过的数字，想要找到其中最大的100个数字，怎么实现，时间复杂度是多少？</p>\n</blockquote>\n<ol>\n<li>最小堆法：</li>\n</ol>\n<p>将前100个数构建为<strong>最小堆</strong></p>\n<p>后续每个数，如果大于堆顶，那么就替换并且更新结构；否则就不需要</p>\n<p>建堆O(100)，后续每次处理为O(nlog100) = O(n)</p>\n<p>时间复杂度为：O（n）</p>\n<ol start=\"2\">\n<li>快速选择算法：分区，找到第100大的元素。此时左边就是需要的</li>\n</ol>\n<p>平均O（n），最坏情况（n^2）</p>\n<ol start=\"3\">\n<li><p>分治法（数据量过大的时候）：</p>\n<p>将数据分成若干块（每块100万个），每块使用上述两种方法找到最大的100个数</p>\n<p>合并top100，再次筛选</p>\n<p>时间复杂度为O(n + mlogm + 100m)，m是块数</p>\n</li>\n</ol>\n<h3 id=\"大数据量的状态\"><a href=\"#大数据量的状态\" class=\"headerlink\" title=\"大数据量的状态\"></a>大数据量的状态</h3><blockquote>\n<p>有一台16G内存的电脑，要保存2的32次方个qq号的状态，怎么设计，大概占多少内存空间？</p>\n</blockquote>\n<p>都用1位表示状态：</p>\n<p>2^32 * 1 / 8 =536,870,912 字节 = 512MB</p>\n<p>布隆过滤器近似计算</p>\n<h3 id=\"查找高频词\"><a href=\"#查找高频词\" class=\"headerlink\" title=\"查找高频词\"></a>查找高频词</h3><blockquote>\n<p>在内容安全工作中，常用高频词查找的需要。<br>你需要在最多不超过 10^7 的单词中查找其中出现次数最多的 100 个，即 TOP100。<br>为了简单起见，所有单词都已经被提取出来，每个单词由小写字母 a-z 组成，长度不超过 20 个字母。<br>你需要使用尽可能小的内存空间和尽可能快的算法来找出这 100 个单词。<br>样例1:<br>[输入]<br>5<br>splunk<br>elastic<br>splunk<br>clickhouse<br>elastic</p>\n</blockquote>\n<p>先存储（用map或者trie？长度20的话，20*26=520 ）；用map也可以</p>\n<p>然后用最大的100个数字的方法</p>\n<h3 id=\"统计10G电话号码\"><a href=\"#统计10G电话号码\" class=\"headerlink\" title=\"统计10G电话号码\"></a>统计10G电话号码</h3><blockquote>\n<p>10G的11位电话号码文件，2G内存，如何获取重复率最高的电话号码</p>\n</blockquote>\n<ol>\n<li><strong>哈希分片</strong>：<ul>\n<li>将10G文件按电话号码的哈希值（如<strong>取模</strong>运算）分割为多个小文件，确保相同电话号码一定落入同一文件。例如，哈希函数设为 <code>hash(phone) % 1000</code>，生成1000个子文件，每个文件约10MB（假设电话号码均匀分布）</li>\n</ul>\n</li>\n<li>逐文件统计频率：<ul>\n<li>逐个读取子文件，在内存中统计每个文件的电话号码出现次数</li>\n<li>记录当前文件的<strong>最高频率号码</strong>及其次数</li>\n</ul>\n</li>\n<li>全局汇总：<ul>\n<li>合并所有子文件的统计结果，计算全局最高频率</li>\n<li>读取所有临时结果文件，使用<strong>最小堆</strong>或<strong>外部排序</strong>合并数据</li>\n</ul>\n</li>\n</ol>\n<p>哈希分片 or bitmap（本题不适用） 是一种很重要的思想方法</p>\n<h3 id=\"3次失败登陆锁定15分钟\"><a href=\"#3次失败登陆锁定15分钟\" class=\"headerlink\" title=\"3次失败登陆锁定15分钟\"></a>3次失败登陆锁定15分钟</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Result <span class=\"title\">login</span><span class=\"params\">(String username, String password)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 检查是否已锁定</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (redis.exists(<span class=\"string\">&quot;lock:&quot;</span> + username)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Result.error(<span class=\"string\">&quot;账户已锁定，请15分钟后重试&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 2. 验证用户名密码</span></span><br><span class=\"line\">    User user = userService.findByUsername(username);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (user != <span class=\"keyword\">null</span> &amp;&amp; password.equals(user.getPassword())) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 登录成功：重置失败次数</span></span><br><span class=\"line\">        redis.delete(<span class=\"string\">&quot;login_fail:&quot;</span> + username);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Result.success();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 3. 登录失败：递增失败次数</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> count = redis.incr(<span class=\"string\">&quot;login_fail:&quot;</span> + username);</span><br><span class=\"line\">        redis.expire(<span class=\"string\">&quot;login_fail:&quot;</span> + username, <span class=\"number\">900</span>); <span class=\"comment\">// 15分钟滑动窗口</span></span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"comment\">// 4. 判断是否触发锁定</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (count &gt;= <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">            redis.setex(<span class=\"string\">&quot;lock:&quot;</span> + username, <span class=\"number\">900</span>, <span class=\"string\">&quot;locked&quot;</span>); <span class=\"comment\">// 锁定15分钟</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> Result.error(<span class=\"string\">&quot;连续失败3次，账户已锁定&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Result.error(<span class=\"string\">&quot;用户名或密码错误&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th><strong>方案</strong></th>\n<th><strong>优点</strong></th>\n<th><strong>缺点</strong></th>\n<th><strong>适用场景</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>纯数据库实现</strong></td>\n<td>无需额外中间件，数据持久化可靠</td>\n<td>高并发下性能瓶颈，锁竞争严重</td>\n<td>低并发、数据一致性要求高</td>\n</tr>\n<tr>\n<td><strong>Redis+数据库</strong></td>\n<td>高性能，自动过期，易于扩展</td>\n<td>依赖Redis可用性，需处理缓存穿透</td>\n<td>中高并发，实时性要求高</td>\n</tr>\n<tr>\n<td><strong>分布式锁+计数</strong></td>\n<td>支持分布式部署，强一致性</td>\n<td>实现复杂，运维成本高</td>\n<td>大型系统，多节点协同</td>\n</tr>\n</tbody></table>\n<h3 id=\"秒杀场景\"><a href=\"#秒杀场景\" class=\"headerlink\" title=\"秒杀场景\"></a>秒杀场景</h3><p><strong>数据库层面的解决方案</strong></p>\n<p>乐观锁：在商品表中增加 <code>version</code>字段，每次更新库存时校验版本号是否一致</p>\n<p>唯一索引+条件更新：</p>\n<p>创建用户购买记录表，对 <code>(uid, goods_id)</code>添加唯一索引，防止重复购买</p>\n<p><strong>redis实现分布式锁</strong></p>\n<p>在锁内执行库存预减和订单生成逻辑</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 加锁示例（Redisson实现）</span></span><br><span class=\"line\">RLock lock = redissonClient.getLock(<span class=\"string\">&quot;lock:product_1&quot;</span>);</span><br><span class=\"line\">lock.lock(<span class=\"number\">10</span>, TimeUnit.SECONDS);</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> stock = redis.get(<span class=\"string\">&quot;product_stock_1&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (stock &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        redis.decr(<span class=\"string\">&quot;product_stock_1&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 异步生成订单</span></span><br><span class=\"line\">        sendToMQ(order);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    lock.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>原子性初始化</strong> 使用Redis的 <code>SET</code>命令结合 <code>NX</code>（不存在时设置）选项，确保库存仅被初始化一次。例如：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET product:stock 50 NX  <span class=\"comment\"># 仅当键不存在时设置库存为50</span></span><br></pre></td></tr></table></figure>\n<p><strong>Lua脚本实现原子操作</strong> 通过Lua脚本在Redis服务端<strong>原子性校验并扣减库存</strong>，避免并发下的数据不一致。脚本逻辑如下</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- KEYS[1]: 库存键（如product:stock）</span></span><br><span class=\"line\"><span class=\"comment\">-- ARGV[1]: 扣减数量（如1）</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> stock = <span class=\"built_in\">tonumber</span>(redis.call(<span class=\"string\">&#x27;get&#x27;</span>, KEYS[<span class=\"number\">1</span>]))</span><br><span class=\"line\"><span class=\"keyword\">if</span> stock &gt;= <span class=\"built_in\">tonumber</span>(ARGV[<span class=\"number\">1</span>]) <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> redis.call(<span class=\"string\">&#x27;decrby&#x27;</span>, KEYS[<span class=\"number\">1</span>], ARGV[<span class=\"number\">1</span>])</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>  <span class=\"comment\">-- 库存不足</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250321155154531-20250321-155154.png\" alt=\"image-20250321155154531\"></p>\n<h3 id=\"多线程任务场景\"><a href=\"#多线程任务场景\" class=\"headerlink\" title=\"多线程任务场景\"></a>多线程任务场景</h3><blockquote>\n<p>开一个线程池，5个核心线程，10个任务，保证10个任务执行完，再执行主线程的一些任务</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadPoolExecutor threadPoolExecutor = <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">10</span>, TimeUnit.SECONDS,</span><br><span class=\"line\">        <span class=\"keyword\">new</span> ArrayBlockingQueue&lt;&gt;(<span class=\"number\">5</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 10个执行完才能够执行其他的</span></span><br><span class=\"line\">CountDownLatch countDownLatch = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 10个任务</span></span><br><span class=\"line\">Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; ++i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> finalI = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">    threadPoolExecutor.submit(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;任务&quot;</span> + finalI);</span><br><span class=\"line\">            Thread.sleep(random.nextInt(<span class=\"number\">500</span>) + <span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            countDownLatch.countDown();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">countDownLatch.await();</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;所有任务已完成&quot;</span>);</span><br><span class=\"line\">threadPoolExecutor.shutdown();</span><br></pre></td></tr></table></figure>\n<h3 id=\"生产者-消费者模型\"><a href=\"#生产者-消费者模型\" class=\"headerlink\" title=\"生产者-消费者模型\"></a>生产者-消费者模型</h3><p>2个生产者和4个消费者的模型。生产者负责读取文件数据，消费者负责消费文件并输出</p>\n<p>阻塞队列可以</p>\n<h3 id=\"并查集的删除\"><a href=\"#并查集的删除\" class=\"headerlink\" title=\"并查集的删除\"></a>并查集的删除</h3><p>在处理某些人之间具有关系的数据结构中，常常用到并查集。例如：a和b认识，b和c认识，那么a和c就可以连接上，可以用并查集来存储这种关系。但是现在需要考虑a和b绝交了，在这种情形下如何用并查集来处理，确认某两个人之间是否还能连接</p>\n<p>可以反向处理，将删除等价为增加</p>\n<h3 id=\"查询问题\"><a href=\"#查询问题\" class=\"headerlink\" title=\"查询问题\"></a>查询问题</h3><blockquote>\n<p>场景1：查全校人的姓名，选出top10出现率的名字<br>场景2：如果查询范围变成全国呢？<br>场景3：如果空间有限，不让用多级索引呢？用什么数据结构节省空间？<br>场景4：DNS服务器解析域名对应的IP地址的时候，怎么快速查找到对应的IP地址同时节省存储空间？</p>\n</blockquote>\n<h3 id=\"称盐问题\"><a href=\"#称盐问题\" class=\"headerlink\" title=\"称盐问题\"></a>称盐问题</h3><blockquote>\n<p>140g的盐 各有一个2g和一个7g的砝码 只能用三次天平，如何称出50g 和 90 g</p>\n</blockquote>\n<p>第一次平分，70+70，第二次继续对一份70克平分，35+35，第三次左边2g砝码，右边7克砝码，调整35克盐以达到平衡，这样左边有20克盐，右边15克盐。把20克盐加到一份70克中即可</p>\n<h3 id=\"烧绳子\"><a href=\"#烧绳子\" class=\"headerlink\" title=\"烧绳子\"></a>烧绳子</h3><blockquote>\n<p>一根绳子烧完要1小时，如何计时15分钟，30分钟和45分钟</p>\n</blockquote>\n<h2 id=\"SQL代码\"><a href=\"#SQL代码\" class=\"headerlink\" title=\"SQL代码\"></a>SQL代码</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> basic_query <span class=\"keyword\">as</span> (</span><br><span class=\"line\"><span class=\"keyword\">select</span> </span><br><span class=\"line\"><span class=\"keyword\">distinct</span> products.product_id,</span><br><span class=\"line\">category,</span><br><span class=\"line\">name <span class=\"keyword\">as</span> product_name,</span><br><span class=\"line\"><span class=\"built_in\">sum</span>(quantity) <span class=\"keyword\">over</span> (<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> products.product_id) <span class=\"keyword\">as</span> total_sales</span><br><span class=\"line\"><span class=\"keyword\">from</span></span><br><span class=\"line\">products <span class=\"keyword\">inner</span> <span class=\"keyword\">join</span> orders <span class=\"keyword\">on</span> products.product_id <span class=\"operator\">=</span> orders.product_id</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">select</span> </span><br><span class=\"line\">product_name,</span><br><span class=\"line\">total_sales,</span><br><span class=\"line\"><span class=\"built_in\">rank</span>() <span class=\"keyword\">over</span> (<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> category <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> total_sales <span class=\"keyword\">desc</span>) <span class=\"keyword\">as</span> category_rank</span><br><span class=\"line\"><span class=\"keyword\">from</span> basic_query;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> </span><br><span class=\"line\">    date1, </span><br><span class=\"line\">    date2,</span><br><span class=\"line\">    <span class=\"keyword\">CASE</span> </span><br><span class=\"line\">        <span class=\"keyword\">WHEN</span> <span class=\"type\">DATE</span>(date1) <span class=\"operator\">=</span> <span class=\"type\">DATE</span>(date2) <span class=\"keyword\">THEN</span> <span class=\"string\">&#x27;Same Day&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">ELSE</span> <span class=\"string\">&#x27;Different Day&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">END</span> <span class=\"keyword\">AS</span> IsSameDay</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> </span><br><span class=\"line\">    your_table;</span><br></pre></td></tr></table></figure>\n<h1 id=\"HR面\"><a href=\"#HR面\" class=\"headerlink\" title=\"HR面\"></a>HR面</h1><p>1 你觉得你有哪些缺点和优点？</p>\n<p>缺点：在面对一些比较重要的任务和紧迫的DDL的压制下，由于我本身的执行力非常强，所以这种时候我会试图去尽快把一件事情做完。这种时候，我往往做到了高效完成任务，但容易忽视前期的一些调研准备工作，使得自己在真正去做这件事情的时候会遇到一些波折，导致出现一些小规模的返工。</p>\n<p>所以现在在做事情前我一般会通过几种方法去改进自己：</p>\n<p>首先，我现在习惯于一般会给自己列一个计划，尽量按照计划去做事。</p>\n<p>另一方，其实这也是一个认知的问题。我现在逐渐意识到准备本身也是做事情的一部分，通过预先调研往往能保证事情在执行阶段更加顺利。相当于说工欲善其事，必先利其器</p>\n<p>最后，我也会让自己去相信自己的能力，告诉自己我有能力去在期限内完成，更重要的其实在于每一个细节的达成。</p>\n<p>2 你怎么评价你面试的这家公司？</p>\n<p>3 你在校期间，有没有哪段时间或者某件事情让你受挫？</p>\n<p>去年此时，我发现自己体脂率很高，并且感觉不太健康了</p>\n<p>另一方面，之前的论文没有中，需要在两个月内完成一篇期刊，</p>\n<p>下定决心开始早起，作息从2点睡11点起更改到12点睡8点起。每天抽一个小时去运动一下，然后开始蹲图书馆</p>\n<p>4 在校期间遇到最有挑战的事情是什么？</p>\n<p>5 目前手上有 offer 吗？</p>\n<p>6  自我介绍</p>\n<p>7  职业规划</p>\n<p>8 报学校专业是怎么考虑的？</p>\n<p>9  工作城市</p>\n<p>10 你是独生子女吗？</p>\n<p>11 那你有男/女 朋友吗？</p>\n<p>12  你们出来面试都了解过哪些企业？</p>\n<p>13  到后期你们每个人手上有好几个offer，哪些因素决定你们选择这家公司?</p>\n<p>14  你更倾向哪种公司？有什么特别的点？</p>\n<p>15  你大学有没有特别难忘的经历或者项目分享一下的?</p>\n<p>16  团队合作中遇到什么问题？</p>\n<p>17  对互联网加班有什么看法？</p>\n<p>18  那你现在的技术薄弱点在哪里，怎么去突破？</p>\n<p>19  你的兴趣爱好有哪些？</p>\n<p>20 现在进度最快的公司是哪家？</p>\n<p>21 拿到哪几家offer，是否谈过薪资等</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"我的大佬朋友们","link_list":[{"name":"Manxin","link":"https://manxin521.site/","avatar":"https://jerryc.me/image/avatar.png","descr":"人们说活着是为了快乐，可快乐又是为了什么呢"},{"name":"Letian","link":"https://letian.website/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"求知若饥，虚心若愚"}]}]}},"excerpt":"","more":"<h1 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h1><blockquote>\n<p>暑期实习和秋招的知识储备，除了看JavaGuide等外，可以随时回来查缺补漏<br>个人觉得<strong>简历</strong>最为重要，因为在面试中会被问到的问题基本都是围绕着自己简历展开的<br>关注自己的简历都不用太去看面经了（看些通用的就行），应该关注自己的简历会被如何拷打</p>\n</blockquote>\n<blockquote>\n<p>面试的时候表现的积极点、聪明点，很多时候面试问的问题未必回答的出来，但要表现出有一种愿意主动思考的态度。很多时候一个优秀的面试官是会主动引导的，这里举个自己某次面试时遇到的例子。<br>面试官：端口是哪一层协议的？<br>我：我确实不太清楚，让我思考一下…我猜测可能是网络层或者传输层？<br>面试官：TCP和UDP连接可以用同一个端口吗？<br>这里其实就是暗示了，我知道TCP和UDP可以用同一个端口，这就说明了它们的端口不是一个概念，且已知tcp和udp是传输层的协议，所以端口也应该是传输层的概念。<br>因此在面试的时候遇到不会的问题不必太担忧，大胆说出自己的思考，结合学过的知识去分析一下，其实也是很不错的能力。</p>\n</blockquote>\n<blockquote>\n<p>针对HR面和技术面准备不同的自我介绍。比如我在技术面的时候一般就会说：做了blabla什么项目，最后一带而过自己还参加过暑期支教活动和研究生班长；而HR面则重点介绍暑期支教活动和研究生班长经历，一带而过项目等等。</p>\n</blockquote>\n<h1 id=\"个人面经\"><a href=\"#个人面经\" class=\"headerlink\" title=\"个人面经\"></a>个人面经</h1><p>暑期实习面经：<a href=\"https://wangwangwang.website/tags/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/\">https://wangwangwang.website/tags/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/</a></p>\n<p>秋招面经：<a href=\"https://wangwangwang.website/tags/%E7%A7%8B%E6%8B%9B/\">https://wangwangwang.website/tags/%E7%A7%8B%E6%8B%9B/</a></p>\n<h1 id=\"八股知识储备\"><a href=\"#八股知识储备\" class=\"headerlink\" title=\"八股知识储备\"></a>八股知识储备</h1><h2 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h2><p>分布式锁应当满足：</p>\n<ul>\n<li>互斥</li>\n<li>高可用：出问题，能够释放（超时机制）</li>\n<li>可重入（获取了锁之后，还可以再次获取）</li>\n</ul>\n<p>常见实现方案：Redis和ZooKeeper</p>\n<h2 id=\"其他工具\"><a href=\"#其他工具\" class=\"headerlink\" title=\"其他工具\"></a>其他工具</h2><h3 id=\"限流和熔断\"><a href=\"#限流和熔断\" class=\"headerlink\" title=\"限流和熔断\"></a>限流和熔断</h3><p>限流（Rate Limiting）是一种常用的技术手段，用于控制系统对资源的访问速率，确保系统的稳定性和可靠性</p>\n<p>熔断（Circuit Breaker）模式是一种用于处理分布式系统中因服务调用失败而可能导致系统雪崩效应的保护机制。它借用了电路中的“熔断器”概念，当电流过大时，熔断器会自动切断电路，以保护整个电路系统不被烧毁。在分布式系统中，熔断器用于监控服务调用的健康状况，并在检测到异常（如服务调用失败率过高、响应时间过长等）时，自动切断对该服务的调用，从而防止故障在系统中蔓延，保障系统的整体稳定性和可用性</p>\n<ul>\n<li>防止服务雪崩</li>\n<li>提升系统弹性</li>\n</ul>\n<h3 id=\"限流算法\"><a href=\"#限流算法\" class=\"headerlink\" title=\"限流算法\"></a>限流算法</h3><p>漏桶算法：无法应对激增流量；请求被丢弃</p>\n<p>令牌桶算法：可以限制平均速率，以及处理激增的流量；可以动态调整生成令牌速率</p>\n<p>动态调整生成令牌速率的方法：</p>\n<p><code>RedisRateLimiter</code>的令牌生成速率（<code>replenishRate</code>）和突发容量（<code>burstCapacity</code>）</p>\n<p>可以考虑使用nanos进行动态配置，同时实现动态路由加载</p>\n<p><strong>限流可以进化到降级</strong></p>\n<p><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250312195240597-20250312-195242.png\" alt=\"image-20250312195240597\"></p>\n<p>令牌桶算法添加令牌的方式是多样的：</p>\n<h4 id=\"传统线程驱动\"><a href=\"#传统线程驱动\" class=\"headerlink\" title=\"传统线程驱动\"></a>传统线程驱动</h4><p>通过后台线程定期（如每秒）向令牌桶中添加固定数量的令牌，直到桶满为止。</p>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>实现简单，逻辑清晰。</li>\n<li>令牌生成速率恒定，适合需要严格控制平均速率的场景。</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>需要维护额外线程，增加系统资源开销。</li>\n<li>实时性差，突发流量可能导致令牌补充不及时（如网页44提到的瞬时流量可能超过限速阈值</li>\n</ul>\n<h4 id=\"惰性计算\"><a href=\"#惰性计算\" class=\"headerlink\" title=\"惰性计算\"></a>惰性计算</h4><p>在每次请求到来时，根据当前时间与上次请求的时间差动态计算应补充的令牌数，并更新桶内令牌。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 网页58中的令牌桶核心逻辑</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">refillTokens</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> now = System.nanoTime();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> duration = now - lastRefillTime;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> newTokens = duration * refillRate / <span class=\"number\">1_000_000_000</span>; <span class=\"comment\">// 计算时间差对应的令牌数</span></span><br><span class=\"line\">    tokens.updateAndGet(current -&gt; Math.min(capacity, current + newTokens));</span><br><span class=\"line\">    lastRefillTime = now;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>无需独立线程，减少资源消耗。</li>\n<li>时间驱动更精确，适合高并发场景（如淘宝交易系统的动态限流）</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>计算逻辑需保证线程安全（如使用原子操作或同步锁）。</li>\n<li>频繁的时间计算可能带来轻微性能损耗。</li>\n</ul>\n<h4 id=\"RateLimiter的实现\"><a href=\"#RateLimiter的实现\" class=\"headerlink\" title=\"RateLimiter的实现\"></a>RateLimiter的实现</h4><p><strong>核心原理</strong>： 在每次请求到来时，根据<strong>当前时间与上次令牌补充的时间差</strong>，动态计算应补充的令牌数量。这种方式无需独立线程维护令牌桶，通过实时计算实现令牌生成。 <strong>实现细节</strong>：</p>\n<ol>\n<li><strong>时间差计算</strong>：记录上次补充令牌的时间戳（如 <code>nextFreeTicketMicros</code>），通过当前时间差除以令牌生成间隔（<code>stableIntervalMicros</code>），得到应补充的令牌数。</li>\n<li><strong>令牌补充上限</strong>：确保补充后令牌不超过桶的最大容量（<code>maxPermits</code>）。</li>\n<li><strong>原子性操作</strong>：使用同步锁或原子变量保证线程安全。 <strong>代码示例</strong>（参考Guava的 <code>SmoothRateLimiter</code> 类）：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">resync</span><span class=\"params\">(<span class=\"keyword\">long</span> nowMicros)</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nowMicros &gt; nextFreeTicketMicros) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">double</span> timeDiff = nowMicros - nextFreeTicketMicros;  </span><br><span class=\"line\">        <span class=\"keyword\">double</span> newPermits = timeDiff / stableIntervalMicros;  </span><br><span class=\"line\">        storedPermits = Math.min(maxPermits, storedPermits + newPermits);  </span><br><span class=\"line\">        nextFreeTicketMicros = nowMicros;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>无需额外线程，资源消耗低。</li>\n<li>实时性强，精确控制突发流量。</li>\n</ul>\n<p><strong>适用场景</strong>：高并发、分布式系统（如Guava RateLimiter的默认实现）</p>\n<table>\n<thead>\n<tr>\n<th><strong>方法</strong></th>\n<th><strong>资源消耗</strong></th>\n<th><strong>实时性</strong></th>\n<th><strong>适用场景</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>惰性计算法</td>\n<td>低</td>\n<td>高</td>\n<td>高并发、分布式系统（如API网关）</td>\n</tr>\n<tr>\n<td>定时补充法</td>\n<td>中</td>\n<td>中</td>\n<td>单机简单限流（如传统后台服务）</td>\n</tr>\n</tbody></table>\n<h3 id=\"maven\"><a href=\"#maven\" class=\"headerlink\" title=\"maven\"></a>maven</h3><p>解决冲突？todo</p>\n<h3 id=\"docker和虚拟机的区别\"><a href=\"#docker和虚拟机的区别\" class=\"headerlink\" title=\"docker和虚拟机的区别\"></a>docker和虚拟机的区别</h3><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/4ef8691d67eb1eb53217099d0a691eb5-20250302-153527.png\" alt=\"img\" style=\"zoom: 67%;\" />\n\n<p>容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高。</p>\n<h3 id=\"Oauth-2-0\"><a href=\"#Oauth-2-0\" class=\"headerlink\" title=\"Oauth 2.0\"></a>Oauth 2.0</h3><p>一种新的授权机制，为第三方应用颁发一个有时效性的令牌Token，使得第三方应用能够通过该令牌获得相关的资源。</p>\n<p>令牌（token）与密码（password）的作用是一样的，都可以进入系统，但是有三点差异。</p>\n<p>（1）令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。</p>\n<p>（2）令牌可以被数据所有者撤销，会立即失效。以上例而言，屋主可以随时取消快递员的令牌。密码一般不允许被他人撤销。</p>\n<p>（3）令牌有权限范围（scope），比如只能进小区的二号门。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。</p>\n<p>授权层分离出两种角色：客户端和资源所有者。本质oauth的核心就是**<em>向第三方应用颁发令牌**</em></p>\n<p>需要阅读：<a href=\"https://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html\">https://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html</a></p>\n<h3 id=\"nginx\"><a href=\"#nginx\" class=\"headerlink\" title=\"nginx\"></a>nginx</h3><p>nginx正向代理和反向代理</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/163948996\">https://zhuanlan.zhihu.com/p/163948996</a></p>\n<ul>\n<li>正向代理是<strong>客户端代理</strong>，代理客户端，服务端不知道实际发起请求的客户端</li>\n<li>反向代理是<strong>服务端代理</strong>，代理服务端，客户端不知道实际提供服务的服务端.</li>\n</ul>\n<h3 id=\"cookie和localStorage\"><a href=\"#cookie和localStorage\" class=\"headerlink\" title=\"cookie和localStorage\"></a>cookie和localStorage</h3><p><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250321152306879-20250321-152307.png\" alt=\"image-20250321152306879\"></p>\n<p><strong>单点登录（SSO）</strong>：用户登录百度主站（如 <code>www.baidu.com</code>）时，服务器生成一个认证Cookie，并设置其 <code>domain</code>属性为 <code>.baidu.com</code>。这使得所有子域名（如 <code>pan.baidu.com</code>）均可读取该Cookie，实现自动登录</p>\n<h3 id=\"时间轮算法\"><a href=\"#时间轮算法\" class=\"headerlink\" title=\"时间轮算法\"></a>时间轮算法</h3><ul>\n<li>环形时间轮：时间轮由多个<strong>槽（Slot）</strong> 组成环形数组，每个槽对应一个时间间隔（如1秒）。例如，一个60槽的时间轮，每槽间隔1秒，可覆盖60秒内的任务</li>\n<li><strong>指针（tick）</strong>：指针周期性移动（如每秒移动一槽），触发当前槽内所有任务的执行</li>\n<li><strong>任务链表</strong>：每个槽挂载一个任务链表，存储需在该时间点触发的任务</li>\n</ul>\n<p><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250321155727208-20250321-155727.png\" alt=\"image-20250321155727208\"></p>\n<p><img src=\"https://static001.geekbang.org/infoq/71/71313f214caded7d34001de907131cfe.png\" alt=\"img\"></p>\n<p>以两层时间轮为例，第一层时间轮周期为1秒，第二层时间轮周期为10秒。</p>\n<p>还是以上述3个任务为例，可以看到任务A和B分布在第一层时间轮上，而任务C分布在第二层时间轮的槽1处。当第一层时间轮转动时，任务A和任务B会被先后执行。1秒钟之后，第一层时间轮完成了一个周期转动。从新开始第0跳，这时第二层时间轮从槽0跳到了槽1处，将槽1处的任务，也就是任务C取出放入到第一层时间轮的槽位9处，当第一层时间轮转动到槽位9处，任务C就会被执行。这种将第二层的任务取出放入第一层中称为降级，它是为了保证任务被处理的时间精度。Kafka内部就是采用的这种多层时间轮机制。</p>\n<p><img src=\"https://static001.geekbang.org/infoq/da/daf543a1284837a0de12c29aee43c55b.png\" alt=\"img\"></p>\n<p>应用场景：</p>\n<ul>\n<li>redisson通过时间轮算法实现锁的自动续期</li>\n</ul>\n<h3 id=\"权限模型\"><a href=\"#权限模型\" class=\"headerlink\" title=\"权限模型\"></a>权限模型</h3><p>在 RBAC（基于角色的访问控制）模型中，<strong>资源（Resource）</strong> 是系统中被标识、可被访问或操作的一切事物。其涵盖范围包括但不限于：</p>\n<p><strong>功能型资源</strong></p>\n<ul>\n<li><strong>模块</strong>：如商品管理、订单管理、财务管理等业务板块。</li>\n<li><strong>页面</strong>：如商品列表页、订单详情页等具体界面。</li>\n<li><strong>按钮</strong>：如“新增商品”“删除订单”等交互操作。</li>\n<li><strong>字段</strong>：如商品详情中的“价格”字段是否可编辑</li>\n</ul>\n<p><strong>数据型资源</strong></p>\n<ul>\n<li><strong>实体数据</strong>：如数据库中的某条订单记录、客户信息表。</li>\n<li><strong>文件/路径</strong>：如服务器上的文件目录或特定文档。</li>\n<li><strong>API 接口</strong>：如 <code>/api/orders</code> 路径对应的 RESTful 接口</li>\n</ul>\n<p>RBAC 模型中的权限管理需从两个维度进行切分：<strong>功能权限</strong>（操作权限）和<strong>数据权限</strong>（数据范围权限）。两者相辅相成，共同实现精细化控制</p>\n<ol>\n<li><strong>功能权限（操作权限）</strong></li>\n</ol>\n<p><strong>定义</strong>：控制用户能否使用系统中的特定功能或执行操作，例如页面访问、按钮点击、API 调用等。</p>\n<ol start=\"2\">\n<li><strong>数据权限（范围权限）</strong></li>\n</ol>\n<p><strong>定义</strong>：控制用户能访问哪些具体数据，例如某部门的数据、某区域的订单等。 <strong>典型维度</strong>：</p>\n<ul>\n<li><strong>组织架构</strong>：如上海分公司的员工只能访问分公司数据</li>\n</ul>\n<p><strong>总结</strong>：</p>\n<ul>\n<li>功能权限解决“<strong>能否操作</strong>”的问题（如能否删除订单）。</li>\n<li>数据权限解决“<strong>能操作哪些数据</strong>”的问题（如只能删除自己创建的订单</li>\n</ul>\n<h3 id=\"负载均衡算法\"><a href=\"#负载均衡算法\" class=\"headerlink\" title=\"负载均衡算法\"></a>负载均衡算法</h3><p><strong>静态</strong>：轮询、加权轮询、随机、哈希、<strong>一致性哈希</strong>。</p>\n<p><strong>动态</strong>：最少连接、最少响应时间、最少负载、带权最少连接</p>\n<h2 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h2><p>单表数据量控制在500w以内</p>\n<h3 id=\"回表\"><a href=\"#回表\" class=\"headerlink\" title=\"回表\"></a>回表</h3><p>Mysql回表</p>\n<p>回表怎么解决</p>\n<p>回表返回的是一行还是一张表还是索引</p>\n<h3 id=\"缓冲区\"><a href=\"#缓冲区\" class=\"headerlink\" title=\"缓冲区\"></a>缓冲区</h3><p>innodb中无论是查询还是写绝大部分都是在buffer pool中进行操作的，它相当于innodb的缓存区，可以通过show engine innodb status来查看buffer pool的使用情况；可以通过innodb_buffer_pool_size来设置buffer pool的大小，线上不要吝啬给几个G内存都是正常的，但无论给多大内存都会有不够的时候，innodb采用了变种的LRU算法对数据页进行淘汰</p>\n<p>参考文献：<a href=\"https://cloud.tencent.com/developer/article/1828772\">https://cloud.tencent.com/developer/article/1828772</a></p>\n<h3 id=\"覆盖索引\"><a href=\"#覆盖索引\" class=\"headerlink\" title=\"覆盖索引\"></a>覆盖索引</h3><p>覆盖索引的好处：</p>\n<ol>\n<li>避免InnoDB的回表</li>\n<li>将随机IO变为顺序IO：覆盖索引的 B+ 树叶子节点中，索引键值按升序排列（例如联合索引 <code>(a, b)</code> 会先按 <code>a</code> 排序，再按 <code>b</code> 排序）。当执行范围查询（如 <code>WHERE a &gt; 10 AND a &lt; 20</code>）时，所需数据在索引中是连续存储的，磁盘可以一次性顺序读取多个相邻数据页，避免跳跃式寻址</li>\n</ol>\n<h3 id=\"InnoDB相比于MyISAM的优势\"><a href=\"#InnoDB相比于MyISAM的优势\" class=\"headerlink\" title=\"InnoDB相比于MyISAM的优势\"></a>InnoDB相比于MyISAM的优势</h3><p>事务支持和ACID特性</p>\n<p>行级锁</p>\n<p>索引结构的优化（数据和索引文件在一起）</p>\n<p>多版本并发控制（MVCC）</p>\n<p>redo log，支持崩溃后的安全恢复</p>\n<h3 id=\"表级锁和行级锁\"><a href=\"#表级锁和行级锁\" class=\"headerlink\" title=\"表级锁和行级锁\"></a>表级锁和行级锁</h3><p>表级锁：针对非索引字段加的锁</p>\n<p>行级锁：<strong>针对索引字段加的锁</strong></p>\n<h3 id=\"最左匹配原则\"><a href=\"#最左匹配原则\" class=\"headerlink\" title=\"最左匹配原则\"></a>最左匹配原则</h3><p>使用联合索引的过程中，MySQL根据索引中的字段从左到右依次匹配查询条件</p>\n<p>如果匹配，就会使用索引</p>\n<p>最左匹配原则会一直向右匹配，直到遇到范围查询（如 &gt;、&lt;）为止。对于 &gt;=、&lt;=、BETWEEN 以及前缀匹配 LIKE 的范围查询，不会停止匹配</p>\n<h3 id=\"索引失效\"><a href=\"#索引失效\" class=\"headerlink\" title=\"索引失效\"></a>索引失效</h3><p><a href=\"https://mp.weixin.qq.com/s/mwME3qukHBFul57WQLkOYg\">https://mp.weixin.qq.com/s/mwME3qukHBFul57WQLkOYg</a></p>\n<ul>\n<li>不符合最左匹配原则</li>\n<li>select *不会影响索引，但是会二次回表</li>\n<li>使用函数</li>\n<li>计算</li>\n<li>非前缀匹配</li>\n<li>in的范围太大</li>\n</ul>\n<h3 id=\"SQL优化\"><a href=\"#SQL优化\" class=\"headerlink\" title=\"SQL优化\"></a>SQL优化</h3><p><a href=\"https://www.nowcoder.com/discuss/730039197121155072\">https://www.nowcoder.com/discuss/730039197121155072</a></p>\n<p>B+树不要超过三层：<a href=\"https://juejin.cn/post/7165689453124517896\">https://juejin.cn/post/7165689453124517896</a></p>\n<h2 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h2><h3 id=\"TCP-IP-四层模型\"><a href=\"#TCP-IP-四层模型\" class=\"headerlink\" title=\"TCP/IP 四层模型\"></a>TCP/IP 四层模型</h3><p>应用层</p>\n<p>传输层</p>\n<p>网络层</p>\n<p>网络接口层</p>\n<h4 id=\"应用层\"><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a>应用层</h4><p>提供两个终端设备上应用程序之间信息交换的服务，定义信息交换的格式</p>\n<p>http协议；smtp协议；pop3/imap协议；ftp协议；dns协议</p>\n<h4 id=\"传输层\"><a href=\"#传输层\" class=\"headerlink\" title=\"传输层\"></a>传输层</h4><p>负责两台终端设备进程的通信提供通用的数据传输服务</p>\n<p>tcp协议</p>\n<p>udp协议</p>\n<h4 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h4><p>负责分组交换网络上不同主机提供通信服务，负责路由和转发</p>\n<p>ip协议</p>\n<p>arp协议</p>\n<p>icmp协议</p>\n<p>nat协议</p>\n<p>ospf/rip</p>\n<h4 id=\"网络接口层\"><a href=\"#网络接口层\" class=\"headerlink\" title=\"网络接口层\"></a>网络接口层</h4><ul>\n<li>数据链路层：将网络层交下来的IP数据包组装成数据帧</li>\n<li>物理层：负责计算机节点之间比特流的透明传输</li>\n</ul>\n<h3 id=\"HTTP状态码\"><a href=\"#HTTP状态码\" class=\"headerlink\" title=\"HTTP状态码\"></a>HTTP状态码</h3><p><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/http-status-code-20250303-095853.png\" alt=\"常见 HTTP 状态码\"></p>\n<p><strong>200 OK</strong>：请求被成功处理。例如，发送一个查询用户数据的 HTTP 请求到服务端，服务端正确返回了用户数据。这个是我们平时最常见的一个 HTTP 状态码。</p>\n<p><strong>201 Created</strong>：请求被成功处理并且在服务端创建了一个新的资源。例如，通过 POST 请求创建一个新的用户。</p>\n<p><strong>202 Accepted</strong>：服务端已经接收到了请求，但是还未处理。例如，发送一个需要服务端花费较长时间处理的请求（如报告生成、Excel 导出），服务端接收了请求但尚未处理完毕。</p>\n<p><strong>204 No Content</strong>：服务端已经成功处理了请求，但是没有返回任何内容。例如，发送请求删除一个用户，服务器成功处理了删除操作但没有返回任何内容。</p>\n<hr>\n<p><strong>301 Moved Permanently</strong>：资源被永久重定向了。比如你的网站的网址更换了。</p>\n<p><strong>302 Found</strong>：资源被临时重定向了。比如你的网站的某些资源被暂时转移到另外一个网址。</p>\n<hr>\n<p><strong>400 Bad Request</strong>：发送的 HTTP 请求存在问题。比如请求参数不合法、请求方法错误。</p>\n<p><strong>401 Unauthorized</strong>：未认证却请求需要认证之后才能访问的资源。</p>\n<p><strong>403 Forbidden</strong>：直接拒绝 HTTP 请求，不处理。一般用来针对非法请求。</p>\n<p><strong>404 Not Found</strong>：你请求的资源未在服务端找到。比如你请求某个用户的信息，服务端并没有找到指定的用户。</p>\n<hr>\n<p><strong>500 Internal Server Error</strong>：服务端出问题了（通常是服务端出 Bug 了）。比如你服务端处理请求的时候突然抛出异常，但是异常并未在服务端被正确处理。</p>\n<p><strong>502 Bad Gateway</strong>：我们的网关将请求转发到服务端，但是服务端返回的却是一个错误的响应。</p>\n<h3 id=\"http和https的区别\"><a href=\"#http和https的区别\" class=\"headerlink\" title=\"http和https的区别\"></a>http和https的区别</h3><p>https是基于http，使用tcp作为底层协议，额外使用ssl/tls协议作为加密和安全认证。默认端口是443.</p>\n<h3 id=\"QUIC协议\"><a href=\"#QUIC协议\" class=\"headerlink\" title=\"QUIC协议\"></a>QUIC协议</h3><p>http3.0开始使用quic协议。</p>\n<ol>\n<li>协议僵化：tcp协议升级困难，quic基于udp实现，可在用户态灵活迭代</li>\n<li>队头阻塞</li>\n<li>连接迁移问题：QUIC 使用 <strong>Connection ID</strong> 标识连接，网络切换时无缝迁移连接，无需重建</li>\n<li>QUIC 具有更高级别的加密 ，TCP 本身不做数据加密，依赖于 TLS</li>\n</ol>\n<h3 id=\"WebSocket\"><a href=\"#WebSocket\" class=\"headerlink\" title=\"WebSocket\"></a>WebSocket</h3><p>基于TCP连接的全双工通信协议，客户端和服务器可以同时发送和接收数据</p>\n<p>应用层的协议，用于弥补http在持久化通信能力上的不足</p>\n<p><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250303160210979-20250303-160211.png\" alt=\"image-20250303160210979\"></p>\n<h3 id=\"tcp保障可靠性的7种方式\"><a href=\"#tcp保障可靠性的7种方式\" class=\"headerlink\" title=\"tcp保障可靠性的7种方式\"></a>tcp保障可靠性的7种方式</h3><ol>\n<li>数据块传输</li>\n<li>序列号</li>\n<li>数据校验</li>\n<li>流量控制</li>\n<li>拥塞控制</li>\n<li>确认机制</li>\n<li>超时重传</li>\n</ol>\n<h3 id=\"挥手过程中的状态\"><a href=\"#挥手过程中的状态\" class=\"headerlink\" title=\"挥手过程中的状态\"></a>挥手过程中的状态</h3><table>\n<thead>\n<tr>\n<th><strong>状态</strong></th>\n<th><strong>触发方</strong></th>\n<th><strong>阶段</strong></th>\n<th><strong>持续时间</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>TIME_WAIT</strong></td>\n<td>主动关闭方</td>\n<td>发送最后一个 <code>ACK</code>后</td>\n<td>固定 <code>2MSL</code>（约1-4分钟）</td>\n</tr>\n<tr>\n<td><strong>CLOSE_WAIT</strong></td>\n<td>被动关闭方</td>\n<td>收到 <code>FIN</code>但未发送自己的 <code>FIN</code></td>\n<td>理论上应短暂（实际可能长期存在）</td>\n</tr>\n</tbody></table>\n<h3 id=\"tcp和udp的区别\"><a href=\"#tcp和udp的区别\" class=\"headerlink\" title=\"tcp和udp的区别\"></a>tcp和udp的区别</h3><ol>\n<li>是否面向连接：udp传输数据之前不需要先建立连接，tcp则是提供面向连接的服务（必须先建立连接，传输结束后也需要释放连接）</li>\n<li>是否是可靠传输：udp收到udp报文后，不需要给出任何确认；tcp则通过各种机制保证数据的可靠传输（无差错、不丢失、不重复、按序到达）</li>\n<li>是否有状态：和上面差不多，就是tcp会维护数据的状态</li>\n<li>传输效率：udp高很多</li>\n<li>传输形式：tcp面向字节流，udp则面向报文</li>\n<li>首部开销：tcp（20-60字节），udp（8字节）</li>\n<li>tcp只能点对点，而udp可以一对一、一对多、多对一等等。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>TCP</th>\n<th>UDP</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>是否面向连接</td>\n<td>是</td>\n<td>否</td>\n</tr>\n<tr>\n<td>是否可靠</td>\n<td>是</td>\n<td>否</td>\n</tr>\n<tr>\n<td>是否有状态</td>\n<td>是</td>\n<td>否</td>\n</tr>\n<tr>\n<td>传输效率</td>\n<td>较慢</td>\n<td>较快</td>\n</tr>\n<tr>\n<td>传输形式</td>\n<td>字节流</td>\n<td>数据报文段</td>\n</tr>\n<tr>\n<td>首部开销</td>\n<td>20 ～ 60 bytes</td>\n<td>8 bytes</td>\n</tr>\n<tr>\n<td>是否提供广播或多播服务</td>\n<td>否</td>\n<td>是</td>\n</tr>\n</tbody></table>\n<h3 id=\"SYN洪流攻击\"><a href=\"#SYN洪流攻击\" class=\"headerlink\" title=\"SYN洪流攻击\"></a>SYN洪流攻击</h3><p>SYN Flood是最经典的DDos攻击</p>\n<p>利用了TCP的三次握手（SYN-&gt;SYN/ACK-&gt;ACK），进入半连接状态，使得资源耗尽</p>\n<p>预防手段：</p>\n<ol>\n<li>增加半连接工作队列数量</li>\n<li>回收最先创建的tcp半连接</li>\n<li>syn cookie</li>\n</ol>\n<h2 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h2><h3 id=\"进程和线程的区别\"><a href=\"#进程和线程的区别\" class=\"headerlink\" title=\"进程和线程的区别\"></a>进程和线程的区别</h3><ol>\n<li>线程是进程划分为更小的运行单位，进程执行过程中可以产生多个线程</li>\n<li>线程共享资源，可以互相影响；进程基本是独立的</li>\n<li>线程执行开销小，进程则比较大</li>\n</ol>\n<h3 id=\"线程间同步的方式\"><a href=\"#线程间同步的方式\" class=\"headerlink\" title=\"线程间同步的方式\"></a>线程间同步的方式</h3><ol>\n<li>互斥锁</li>\n<li>读写锁</li>\n<li>信号量</li>\n<li>屏障</li>\n<li>事件（wait/notify）</li>\n</ol>\n<h3 id=\"进程间通信方式\"><a href=\"#进程间通信方式\" class=\"headerlink\" title=\"进程间通信方式\"></a>进程间通信方式</h3><ol>\n<li>匿名管道（父子进程）/ 有名管道</li>\n<li>信号量</li>\n<li>共享内存</li>\n<li>消息队列</li>\n<li>套接字</li>\n</ol>\n<h3 id=\"父子进程\"><a href=\"#父子进程\" class=\"headerlink\" title=\"父子进程\"></a>父子进程</h3><p><strong>子进程拷贝父进程数据的核心机制是写时复制（Copy-On-Write, COW）</strong>。这一设计在Linux系统中通过 <code>fork()</code>系统调用实现，兼顾性能与资源利用率</p>\n<p><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250315152502507-20250315-152503.png\" alt=\"image-20250315152502507\"></p>\n<p>典型场景：Redis利用COW实现快照持久化，子进程直接读取父进程内存生成RDB文件</p>\n<p><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250315185109713-20250315-185110.png\" alt=\"image-20250315185109713\"></p>\n<h3 id=\"银行家算法\"><a href=\"#银行家算法\" class=\"headerlink\" title=\"银行家算法\"></a>银行家算法</h3><p><a href=\"https://cloud.tencent.com/developer/article/2108439\">https://cloud.tencent.com/developer/article/2108439</a></p>\n<h3 id=\"零拷贝机制\"><a href=\"#零拷贝机制\" class=\"headerlink\" title=\"零拷贝机制\"></a>零拷贝机制</h3><p><strong>零拷贝（Zero-Copy）</strong>是一种计算机系统优化技术，旨在减少或消除数据在内存中的冗余拷贝操作，从而降低CPU开销、提升数据传输效率。其核心思想是：<strong>通过硬件或操作系统级优化，避免CPU参与数据在用户空间与内核空间之间的复制过程</strong>，直接在内核态完成数据传输</p>\n<img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250315212414718-20250315-212415.png\" alt=\"image-20250315212414718\" style=\"zoom:50%;\" />\n\n<p>基本过程理解：<a href=\"https://www.bilibili.com/video/BV1RxcoeLE5x\">https://www.bilibili.com/video/BV1RxcoeLE5x</a></p>\n<p>mmap：实现内核缓冲区和用户缓冲区之间的映射关系（避免CPU的拷贝过程）</p>\n<h3 id=\"cpu三级缓存\"><a href=\"#cpu三级缓存\" class=\"headerlink\" title=\"cpu三级缓存\"></a>cpu三级缓存</h3><p><strong>解决速度差异问题</strong> CPU的执行速度远高于内存和磁盘，三级缓存通过<strong>缩短数据访问路径</strong>，减少CPU等待数据的时间，缓解“内存墙”问题。</p>\n<ul>\n<li><strong>速度对比</strong>：寄存器 &gt; L1 &gt; L2 &gt; L3 &gt; 内存 &gt; 磁盘</li>\n<li><strong>性能提升</strong>：约95%的数据访问可通过缓存完成，仅5%需访问内存，极大减少延迟</li>\n</ul>\n<p>核心目的：CPU与内存速度差异大，缓存通过空间换时间减少访问延迟</p>\n<h2 id=\"Spring\"><a href=\"#Spring\" class=\"headerlink\" title=\"Spring\"></a>Spring</h2><h3 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h3><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250304221412002-20250304-221412.png\" alt=\"image-20250304221412002\" style=\"zoom:50%;\" />\n\n<h3 id=\"Spring自动装配原理\"><a href=\"#Spring自动装配原理\" class=\"headerlink\" title=\"Spring自动装配原理\"></a>Spring自动装配原理</h3><p>Spring 自动装配的核心目标是<strong>通过约定大于配置的方式，自动加载符合条件的 Bean 到容器中</strong></p>\n<p><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250309102948593-20250309-102949.png\" alt=\"image-20250309102948593\"></p>\n<p>按需装配</p>\n<h3 id=\"BeanFactory-和-FactoryBean\"><a href=\"#BeanFactory-和-FactoryBean\" class=\"headerlink\" title=\"BeanFactory 和 FactoryBean\"></a>BeanFactory 和 FactoryBean</h3><table>\n<thead>\n<tr>\n<th><strong>BeanFactory</strong></th>\n<th><strong>FactoryBean</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Spring 的核心接口</strong>，是 IOC 容器的顶层设计，负责 Bean 的实例化、配置和管理。它是 Spring 工厂模式的实现，如 <code>ApplicationContext</code> 是其子接口。</td>\n<td><strong>特殊的 Bean</strong>，本身是一个 Bean，但实现了工厂模式，用于创建其他 Bean 实例。例如 MyBatis 的 <code>SqlSessionFactoryBean</code> 和 Spring AOP 的 <code>ProxyFactoryBean</code>。</td>\n</tr>\n<tr>\n<td><strong>角色</strong>：IOC 容器的管理者，提供 Bean 的基础操作（如 <code>getBean</code>、<code>isSingleton</code>） 。</td>\n<td><strong>角色</strong>：Bean 的生产工厂，通过 <code>getObject()</code> 方法返回目标对象，而非自身实例。</td>\n</tr>\n</tbody></table>\n<h3 id=\"Bean的生命周期\"><a href=\"#Bean的生命周期\" class=\"headerlink\" title=\"Bean的生命周期\"></a>Bean的生命周期</h3><p><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/spring-bean-lifestyle-20250226-125000.png\" alt=\"img\"></p>\n<h3 id=\"Bean加载问题\"><a href=\"#Bean加载问题\" class=\"headerlink\" title=\"Bean加载问题\"></a>Bean加载问题</h3><p><strong>默认扫描范围</strong>： Spring 默认仅扫描主配置类（如 <code>@SpringBootApplication</code> 标注的类）所在的包及其子包。若类位于其他包中，需通过 <code>@ComponentScan</code> 显式指定扫描路径</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(basePackages = &quot;com.example.custom.package&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> </span>&#123; <span class=\"comment\">/*...*/</span> &#125;</span><br></pre></td></tr></table></figure>\n<p>若配置了 <code>@ComponentScan</code> 的 <code>excludeFilters</code> 或 XML 的 <code>&lt;context:exclude-filter&gt;</code>，相关类可能被排除</p>\n<h3 id=\"Spring的循环依赖\"><a href=\"#Spring的循环依赖\" class=\"headerlink\" title=\"Spring的循环依赖\"></a>Spring的循环依赖</h3><p>Spring使用三级缓存来解决循环依赖问题：</p>\n<ol>\n<li>一级缓存singletonObjects：存储最终形态的Bean</li>\n<li>二级缓存earylySingletonObjects：存储半成品Bean，即三级缓存ObjectFactory产生的对象。主要是为了AOP机制下， 每次产生新的代理对象</li>\n<li>三级缓存singletonFactories：存放ObjectFactory，ObjectFactory的getObject()方法（最终调用的是getEarlyBeanReference()方法）可以生成原始 Bean 对象或者代理对象（如果 Bean 被 AOP 切面代理）</li>\n</ol>\n<p>创建Bean的具体流程如下：</p>\n<ol>\n<li>先去一级缓存singletonObjects获取，存在就返回；</li>\n<li>不存在，去二级缓存中获取</li>\n<li>仍然不存在，就在三级缓存获取到对应的objectFactory（并调用对应的getObject()）方法</li>\n</ol>\n<p>具体解决循环依赖的方法如下：</p>\n<ol>\n<li>Spring创建A时，A依赖了B，但是B又依赖了A</li>\n<li>由于A还没有初始化完成，因此在一二级缓存中没有A</li>\n<li>那么就去三级缓存调用getObject()方法获取A的早期暴露对象，放入二级缓存中，并注入到B中去</li>\n</ol>\n<p>在AOP模式下存在的二级缓存：</p>\n<p>确保多个对早期引用的请求，也返回同一个代理对象</p>\n<h3 id=\"Transactional\"><a href=\"#Transactional\" class=\"headerlink\" title=\"@Transactional\"></a>@Transactional</h3><p>Spring中事务管理最关键的三个接口：</p>\n<ul>\n<li>PlatformTransactionManager：事务管理器，Spring事务策略的核心</li>\n<li>TransactionDefinition：事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)</li>\n<li>TransactionStatus：事务运行状态</li>\n</ul>\n<h4 id=\"事务传播行为\"><a href=\"#事务传播行为\" class=\"headerlink\" title=\"事务传播行为\"></a>事务传播行为</h4><p>解决业务层方法之间互相调用的事务问题</p>\n<p>Propagation_Required：外部有事务，加入外部；外部没有，则自己新建一个事务（互相影响）</p>\n<p>Propagation_requires_new：创建一个事务，把外部事务挂起（内部影响外部，外部不影响内部）</p>\n<p>Propagation_nested：内部不会影响外部，外部会影响外部</p>\n<h4 id=\"注解失效\"><a href=\"#注解失效\" class=\"headerlink\" title=\"注解失效\"></a>注解失效</h4><ul>\n<li>只能作用在public方法上，其他不生效</li>\n<li>当一个方法被标记@Transactional注解的时候，Spring 事务管理器只会在被其他类方法调用的时候生效，而不会在一个类中方法调用生效。</li>\n</ul>\n<h4 id=\"相关面试题\"><a href=\"#相关面试题\" class=\"headerlink\" title=\"相关面试题\"></a>相关面试题</h4><blockquote>\n<ol>\n<li>一个类的内部有A，B两个方法，其中B开启了事务，我在A中调用B，事务生效吗？</li>\n<li>这种情况下如何让事务生效？</li>\n</ol>\n</blockquote>\n<p>在同一个类中，若方法A直接调用带有 <code>@Transactional</code>注解的方法B，<strong>事务不会生效</strong>。其核心原因在于Spring的事务管理基于AOP代理机制实现，而同类内部调用会绕过代理，直接通过目标对象执行，导致事务拦截失效。</p>\n<p>解决方法：</p>\n<ul>\n<li><p>拆分到不同的类</p>\n</li>\n<li><p>自我注入：注入一个自己类对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyService</span> </span>&#123;  </span><br><span class=\"line\">  \t<span class=\"comment\">// 需要开启循环依赖支持</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span>  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> MyService self;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>获取当前代理对象：((MyService) AopContext.currentProxy()).methodB();   或者获取代理Bean对象</p>\n</li>\n</ul>\n<h3 id=\"Spring-Cloud-Gateway\"><a href=\"#Spring-Cloud-Gateway\" class=\"headerlink\" title=\"Spring Cloud Gateway\"></a>Spring Cloud Gateway</h3><p><img src=\"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/springcloud-gateway-%20demo.png\" alt=\"img\"></p>\n<p>三个关键组件：</p>\n<ul>\n<li><strong>Route 路由</strong>：Spring Cloud Gateway最基本的单元，定义了请求的匹配规则和转发目标。通过配置路由，可以将请求映射到后端服务实例或者URL上。路由规则根据请求的路径、方法或者请求头等条件进行匹配（断言），指定转发的目标URL</li>\n<li><strong>Predicate 断言</strong>：用于匹配请求的目标，如果满足断言的条件，就会应用所配置的过滤器。内置多种断言方式，如Path（路径匹配）、Method（请求方法匹配）等</li>\n<li><strong>Filter 过滤器</strong>：对请求进行转换和处理，可以修改请求、响应和自定义逻辑。提供了多个内置的过滤器，如请求转发、请求重试、请求限流等。</li>\n</ul>\n<p>具体工作流程：</p>\n<p><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/spring-cloud-gateway-workflow-20250315-144117.png\" alt=\"Spring Cloud Gateway 的工作流程\"></p>\n<ol>\n<li><strong>路由判断</strong>：客户端的请求到达网关后，先经过 Gateway Handler Mapping 处理，这里面会做断言（Predicate）判断，看下符合哪个路由规则，这个路由映射后端的某个服务。</li>\n<li><strong>请求过滤</strong>：然后请求到达 Gateway Web Handler，这里面有很多过滤器，组成过滤器链（Filter Chain），这些过滤器可以对请求进行拦截和修改，比如添加请求头、参数校验等等，有点像净化污水。然后将请求转发到实际的后端服务。这些过滤器逻辑上可以称作 Pre-Filters，Pre 可以理解为“在…之前”。</li>\n<li><strong>服务处理</strong>：后端服务会对请求进行处理。</li>\n<li><strong>响应过滤</strong>：后端处理完结果后，返回给 Gateway 的过滤器再次做处理，逻辑上可以称作 Post-Filters，Post 可以理解为“在…之后”。</li>\n<li><strong>响应返回</strong>：响应经过过滤处理后，返回给客户端。</li>\n</ol>\n<h4 id=\"内部调用\"><a href=\"#内部调用\" class=\"headerlink\" title=\"内部调用\"></a>内部调用</h4><p>微服务A和B在注册中心注册后，可通过内部服务名（如 <code>payment-service</code>）直接调用，无需经过网关</p>\n<p><strong>注册中心的健康检查</strong></p>\n<ul>\n<li><strong>心跳检测</strong>：服务实例定期向注册中心发送心跳（如Eureka默认30秒一次），若超时未收到心跳（Eureka默认90秒），则标记实例为不可用并剔除</li>\n<li><strong>主动探针</strong>：Nacos支持TCP/HTTP主动探针，实时检测服务健康状态</li>\n</ul>\n<p><strong>客户端的动态更新</strong></p>\n<ul>\n<li><strong>本地缓存</strong>：客户端（如Ribbon）会定期从注册中心拉取最新服务列表（默认30秒），并缓存到本地。当某节点挂掉时，客户端在下一次请求时会自动跳过该节点</li>\n<li><strong>故障转移</strong>：负载均衡器（如Ribbon）在调用失败时自动重试其他可用实例（默认不重试，需配置 <code>RetryPolicy</code>）</li>\n</ul>\n<h4 id=\"内部绕过鉴权\"><a href=\"#内部绕过鉴权\" class=\"headerlink\" title=\"内部绕过鉴权\"></a>内部绕过鉴权</h4><p>其实内部也不需要再鉴权了</p>\n<p>内部请求的时候添加请求头：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 内部服务调用时添加请求头</span></span><br><span class=\"line\">webClient.get()</span><br><span class=\"line\">    .uri(<span class=\"string\">&quot;http://internal-service/api/data&quot;</span>)</span><br><span class=\"line\">    .header(<span class=\"string\">&quot;X-Internal&quot;</span>, <span class=\"string\">&quot;true&quot;</span>)</span><br><span class=\"line\">    .retrieve();</span><br></pre></td></tr></table></figure>\n<p><strong>结合IP白名单限制</strong></p>\n<ul>\n<li>网关配置：在网关过滤器中校验请求来源IP是否属于内部网络</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InternalIpFilter</span> <span class=\"keyword\">implements</span> <span class=\"title\">GlobalFilter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Mono&lt;Void&gt; <span class=\"title\">filter</span><span class=\"params\">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class=\"line\">        String clientIp = exchange.getRequest().getRemoteAddress().getAddress().getHostAddress();</span><br><span class=\"line\">        <span class=\"comment\">// 判断是否是内部的请求</span></span><br><span class=\"line\">      \t<span class=\"keyword\">if</span> (isInternalIp(clientIp) &amp;&amp; exchange.getRequest().getHeaders().containsKey(<span class=\"string\">&quot;X-Internal&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> chain.filter(exchange);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      \t<span class=\"comment\">// 外部就需要校验</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> checkAuth(exchange, chain);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>临时Token+请求头</strong></p>\n<p>内部服务调用时生成带时效和签名的Token（如JWT），网关验证Token有效性</p>\n<h4 id=\"服务发现\"><a href=\"#服务发现\" class=\"headerlink\" title=\"服务发现\"></a>服务发现</h4><table>\n<thead>\n<tr>\n<th><strong>注册中心</strong></th>\n<th><strong>一致性模型</strong></th>\n<th><strong>功能扩展</strong></th>\n<th><strong>适用场景</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Eureka</strong></td>\n<td>AP</td>\n<td>服务注册与发现</td>\n<td>Spring Cloud 传统架构</td>\n</tr>\n<tr>\n<td><strong>Consul</strong></td>\n<td>CA（最终一致）</td>\n<td>多数据中心、KV 存储</td>\n<td>混合云或复杂网络环境</td>\n</tr>\n<tr>\n<td><strong>Nacos</strong></td>\n<td>AP/CP 可选</td>\n<td>动态配置管理</td>\n<td>云原生、多环境配置统一</td>\n</tr>\n<tr>\n<td><strong>ZooKeeper</strong></td>\n<td>CP</td>\n<td>分布式协调</td>\n<td>强一致性要求的金融或交易系统</td>\n</tr>\n<tr>\n<td><strong>Etcd</strong></td>\n<td>CP</td>\n<td>键值存储</td>\n<td>Kubernetes 集群或分布式数据库</td>\n</tr>\n<tr>\n<td><strong>Kubernetes</strong></td>\n<td>无独立模型</td>\n<td>容器编排集成</td>\n<td>已容器化的云原生应用</td>\n</tr>\n</tbody></table>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><ul>\n<li><strong>中小型项目</strong>：优先选择 <strong>Nacos</strong>（功能全面）或 <strong>Consul</strong>（多数据中心）。</li>\n<li><strong>强一致性需求</strong>：选择 <strong>ZooKeeper</strong> 或 <strong>Etcd</strong>。</li>\n<li><strong>云原生环境</strong>：直接使用 <strong>Kubernetes 原生服务发现</strong>。</li>\n<li><strong>历史系统迁移</strong>：若原用 Eureka，可逐步过渡到 Nacos 以兼容 Spring Cloud 生态</li>\n</ul>\n<h2 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h2><h3 id=\"分布式\"><a href=\"#分布式\" class=\"headerlink\" title=\"分布式\"></a>分布式</h3><p>主从复制：Redis集群（master负责写请求，slave负责读请求）</p>\n<img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/1676964296594-1f216792-7828-4e11-bd01-d30c63a37f89-20250304-160612.png\" alt=\"img\" style=\"zoom: 50%;\" />\n\n<h3 id=\"延迟双删策略\"><a href=\"#延迟双删策略\" class=\"headerlink\" title=\"延迟双删策略\"></a>延迟双删策略</h3><p><strong>延迟双删策略</strong>是用于维护数据库（如 MySQL）与 Redis 缓存之间数据最终一致性的常见方案。其核心步骤为：</p>\n<ol>\n<li><strong>第一次删除缓存</strong>：在更新数据库前，先删除 Redis 中的缓存数据，避免其他线程在数据库更新期间读取到旧数据。</li>\n<li><strong>更新数据库</strong>：执行数据库的写入操作。</li>\n<li><strong>第二次延迟删除缓存</strong>：在数据库更新完成后，延迟一段时间（如 1-5 秒），再次删除缓存。此步骤的目的是防止在数据库主从同步延迟期间，其他线程将旧数据重新写入缓存</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th><strong>方案</strong></th>\n<th><strong>一致性强度</strong></th>\n<th><strong>复杂度</strong></th>\n<th><strong>适用场景</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>延迟双删</strong></td>\n<td>最终一致性</td>\n<td>低</td>\n<td>高频更新、容忍短暂不一致</td>\n</tr>\n<tr>\n<td><strong>先更新数据库再删缓存</strong></td>\n<td>更高一致性</td>\n<td>中</td>\n<td>强一致性要求（如金融交易）</td>\n</tr>\n<tr>\n<td><strong>Canal 监听 binlog</strong></td>\n<td>最终一致性</td>\n<td>高</td>\n<td>无需侵入业务代码的大规模系统</td>\n</tr>\n<tr>\n<td><strong>分布式锁（如 Redisson）</strong></td>\n<td>强一致性</td>\n<td>高</td>\n<td>对性能要求低、强一致性场景</td>\n</tr>\n</tbody></table>\n<p>缓存和数据库一致性：<a href=\"https://mp.weixin.qq.com/s?__biz=MzIyOTYxNDI5OA==&amp;mid=2247487312&amp;idx=1&amp;sn=fa19566f5729d6598155b5c676eee62d&amp;chksm=e8beb8e5dfc931f3e35655da9da0b61c79f2843101c130cf38996446975014f958a6481aacf1&amp;scene=178&amp;cur_album_id=1699766580538032128#rd\">https://mp.weixin.qq.com/s?__biz=MzIyOTYxNDI5OA==&amp;mid=2247487312&amp;idx=1&amp;sn=fa19566f5729d6598155b5c676eee62d&amp;chksm=e8beb8e5dfc931f3e35655da9da0b61c79f2843101c130cf38996446975014f958a6481aacf1&amp;scene=178&amp;cur_album_id=1699766580538032128#rd</a></p>\n<p>流行的解决方案：<strong>订阅数据库变更日志，再操作缓存</strong>。</p>\n<p>具体来讲就是，我们的业务应用在修改数据时，「只需」修改数据库，无需操作缓存。</p>\n<p>那什么时候操作缓存呢？这就和数据库的「变更日志」有关了。</p>\n<p>拿 MySQL 举例，当一条数据发生修改时，MySQL 就会产生一条变更日志（Binlog），我们可以订阅这个日志，拿到具体操作的数据，然后再根据这条数据，去删除对应的缓存。</p>\n<img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/640-20250306-204147.jpg\" alt=\"图片\" style=\"zoom:50%;\" />\n\n<p>整体流程如下：</p>\n<ul>\n<li><strong>监听Binlog</strong>：通过中间件（如Canal、Maxwell）模拟MySQL从库，实时捕获Binlog事件。</li>\n<li><strong>数据转换</strong>：将Binlog中的操作转换为Redis命令（如SET、DEL），保证缓存与数据库操作一致。</li>\n<li><strong>异步处理</strong>：通过消息队列（如Kafka、RocketMQ）解耦，实现削峰填谷和失败重试</li>\n</ul>\n<h3 id=\"k-v结构\"><a href=\"#k-v结构\" class=\"headerlink\" title=\"k-v结构\"></a>k-v结构</h3><p>Redis 使用一个<strong>全局哈希表</strong>（<code>dict</code>）来存储所有键值对，哈希表的结构如下：</p>\n<ul>\n<li><strong>哈希桶（Hash Bucket）</strong>：通过哈希函数将键（Key）映射到哈希桶中，每个桶存储指向具体键值对的指针；</li>\n<li><strong>哈希节点（<code>dictEntry</code>）</strong>：每个节点包含键、值指针以及指向下一个节点的指针（用于解决哈希冲突）</li>\n</ul>\n<p>哈希表的调整：</p>\n<ul>\n<li><strong>渐进式 Rehash</strong>：当哈希表负载因子（元素数量 / 哈希表大小）超过阈值时，Redis 会启动渐进式 Rehash，逐步将数据从旧哈希表迁移到新哈希表，避免一次性迁移导致的性能抖动</li>\n</ul>\n<h3 id=\"看门狗机制\"><a href=\"#看门狗机制\" class=\"headerlink\" title=\"看门狗机制\"></a>看门狗机制</h3><p><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250321155521729-20250321-155522.png\" alt=\"image-20250321155521729\"></p>\n<p>后台线程池：执行续期操作</p>\n<p>时间轮算法：异步原子地续期</p>\n<h2 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h2><h3 id=\"多态的两种表现\"><a href=\"#多态的两种表现\" class=\"headerlink\" title=\"多态的两种表现\"></a>多态的两种表现</h3><ol>\n<li>编译时多态</li>\n</ol>\n<ul>\n<li>方法重载</li>\n</ul>\n<ol start=\"2\">\n<li>运行时多态：运行时才能确定</li>\n</ol>\n<ul>\n<li>方法重写</li>\n<li>接口实现</li>\n</ul>\n<p>运行时多态的实现机制：</p>\n<ul>\n<li><strong>动态绑定</strong>：JVM 在运行时根据对象类型解析方法调用地址</li>\n<li><strong>虚方法表（VTable）</strong>：存储类的方法地址，子类重写方法会覆盖虚表中的父类方法指针</li>\n</ul>\n<h3 id=\"throw和throws\"><a href=\"#throw和throws\" class=\"headerlink\" title=\"throw和throws\"></a>throw和throws</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">str2int</span><span class=\"params\">(String str)</span> <span class=\"keyword\">throws</span> Exception </span>&#123; <span class=\"comment\">//这里将得到的异常向外抛出，可以抛出多个</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        System.out.println(Integer.parseInt(str));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(NumberFormatException e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//TODO 这里可以做一些处理，处理完成后将异常报出，让外层可以得到异常信息</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">&quot;格式化异常&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Java性能分析\"><a href=\"#Java性能分析\" class=\"headerlink\" title=\"Java性能分析\"></a>Java性能分析</h3><p>使用top初步定位进程，之后通过jstack找到对应线程的堆栈信息</p>\n<ul>\n<li>jconsole也是一个查看当前java进程运行情况，可以检测死锁。jconsole可以分析出来内存情况，以及能看到线程状态。结合运行前的heapdumppath，可以分析出当前堆内存占用情况，找到时哪一段对应变量造成的，从而定位问题</li>\n<li>jstack：生成虚拟机当前时刻的线程快照。 用于生成 Java 进程在<strong>某个时间点</strong>的所有线程堆栈信息，帮助定位死锁、死循环、资源等待等问题</li>\n</ul>\n<h3 id=\"JVM内存分配\"><a href=\"#JVM内存分配\" class=\"headerlink\" title=\"JVM内存分配\"></a>JVM内存分配</h3><p>JVM给对象分配内存有多种策略。</p>\n<ol>\n<li>基于堆内存的常规分配：<ul>\n<li>指针碰撞</li>\n<li>空闲列表</li>\n</ul>\n</li>\n<li>多线程分配优化：<ul>\n<li>CAS+重试</li>\n<li>线程本地分配缓冲TLAB</li>\n</ul>\n</li>\n<li>特殊场景：<ul>\n<li>栈上分配：通过<strong>逃逸分析</strong>确定对象生命周期不逃逸出方法（直接在栈帧中分配，结束后自动销毁，避免堆内存分配）</li>\n</ul>\n</li>\n</ol>\n<p>逃逸分析：JVM在编译期或运行时的优化技术，主要用于分析对象的动态作用域，判断是否会被外部方法或线程访问。核心目的是减少堆内存分配、同步开销和对象生命周期管理成本。</p>\n<p>根据分析结果，会应用以下优化技术：</p>\n<ul>\n<li><strong>栈上分配</strong>：若对象未逃逸（仅在当前线程或方法内使用），JVM 可将对象分配在栈帧中，随方法结束自动销毁，无需垃圾回收</li>\n<li><strong>标量替换</strong>：若对象未逃逸且结构简单，JVM 会将其拆解为独立的标量（如 <code>int</code>、<code>double</code>）或字段，直接存储在栈或寄存器中</li>\n<li><strong>同步消除</strong>：若对象未逃逸且仅被单线程访问，JVM 会移除其同步锁（如 <code>synchronized</code> 块）</li>\n</ul>\n<h3 id=\"CPU空转问题\"><a href=\"#CPU空转问题\" class=\"headerlink\" title=\"CPU空转问题\"></a>CPU空转问题</h3><p>CPU 空转通常由未合理阻塞的循环或锁竞争引起。JVM 通过自适应自旋锁和锁升级机制减少无效空转，开发者需结合以下策略：</p>\n<ol>\n<li><strong>代码层面</strong>：用阻塞方法（如 <code>take()</code>）替代轮询，设置自旋超时，利用线程池控制并发。</li>\n<li><strong>工具定位</strong>：通过 <code>jstack</code> 或 Arthas 定位高 CPU 线程，分析是否为自旋锁或死循环。</li>\n<li><strong>锁优化</strong>：评估锁粒度，优先使用 <code>ReentrantLock</code> 替代 <code>synchronized</code>，结合条件变量减少竞争（如网页43的锁示例）。 例如，某压测场景中，通过火焰图定位到 <code>while(true)</code> 空循环，添加 <code>Thread.sleep(50)</code> 后 CPU 从 95% 降至正常水平</li>\n</ol>\n<h3 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h3><p>线程池参数，过期时间的意义，超出核心线程数的会被回收吗，非核心线程会被回收吗？怎么判断他要不要回收，怎么知道他过期了的。那我创建十个线程，1<del>10,核心数8个，9和10还在执行任务，1</del>8不执行了，这时候会怎么做。<br>说说线程池的阻塞队列有什么用，为什么用阻塞队列不用普通队列，在并发情况下，往队列中加任务不会有线程安全问题吗。</p>\n<p>TODO</p>\n<h3 id=\"callable和runnable区别\"><a href=\"#callable和runnable区别\" class=\"headerlink\" title=\"callable和runnable区别\"></a>callable和runnable区别</h3><table>\n<thead>\n<tr>\n<th><strong>对比维度</strong></th>\n<th><strong>Runnable</strong></th>\n<th><strong>Callable</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>接口定义</strong></td>\n<td><code>public interface Runnable &#123; void run(); &#125;</code></td>\n<td><code>public interface Callable&lt;V&gt; &#123; V call() throws Exception; &#125;</code></td>\n</tr>\n<tr>\n<td><strong>返回值</strong></td>\n<td><strong>无返回值</strong>（<code>void</code>）</td>\n<td><strong>有返回值</strong>（泛型类型 <code>V</code>）</td>\n</tr>\n<tr>\n<td><strong>异常处理</strong></td>\n<td>无法抛出受检异常（必须内部 <code>try-catch</code> 处理）</td>\n<td>允许抛出受检异常（通过 <code>Future.get()</code> 捕获 <code>ExecutionException</code> 获取原因）</td>\n</tr>\n<tr>\n<td><strong>执行方式</strong></td>\n<td>通过 <code>Thread</code> 或 <code>Executor.execute()</code> 直接执行</td>\n<td>必须通过 <code>ExecutorService.submit()</code> 提交，返回 <code>Future</code> 对象</td>\n</tr>\n<tr>\n<td><strong>任务管理</strong></td>\n<td>无状态追踪，无法取消任务或获取结果</td>\n<td>通过 <code>Future</code> 管理任务状态（取消、超时、结果查询）</td>\n</tr>\n<tr>\n<td><strong>泛型支持</strong></td>\n<td>不支持</td>\n<td>支持（通过泛型指定返回值类型，如 <code>Callable&lt;String&gt;</code>）</td>\n</tr>\n</tbody></table>\n<h3 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h3><p>反射的核心方法是invoke，通过调用jvm内部的native方法，完成动态方法调用</p>\n<h4 id=\"性能影响\"><a href=\"#性能影响\" class=\"headerlink\" title=\"性能影响\"></a>性能影响</h4><ol>\n<li>动态解析和运行时开销：需要动态加载类、解析方法/字段的元数据，这些操作在直接调用中是由编译器完成的</li>\n<li>方法调用的性能损失：反射调用（如 <code>method.invoke()</code>）无法享受 JIT 编译器的优化（如方法内联），导致执行速度比直接调用慢约 <strong>10-30倍</strong></li>\n</ol>\n<p>优化方向：</p>\n<ul>\n<li>缓存反射元数据：将频繁使用的 <code>Method</code>、<code>Field</code> 对象缓存起来，避免重复解析</li>\n<li>使用高性能反射库：如<strong>Spring的 <code>ReflectionUtils</code></strong></li>\n</ul>\n<h3 id=\"泛型机制\"><a href=\"#泛型机制\" class=\"headerlink\" title=\"泛型机制\"></a>泛型机制</h3><p>Java的泛型是伪泛型，在编译期间所有泛型信息都会被擦除，也就是类型擦除。</p>\n<p>即使泛型擦除存在，但是使用泛型仍然存在一系列好处：</p>\n<ul>\n<li>可以在编译期间进行类型检查</li>\n<li>使用Object类型需要手动添加强制类型转换</li>\n</ul>\n<p>泛型可以增强代码的可读性和稳定性，编译器会对泛型参数进行检测（指定传入对象的类型）</p>\n<h3 id=\"并发的同步\"><a href=\"#并发的同步\" class=\"headerlink\" title=\"并发的同步\"></a>并发的同步</h3><p>Synchronized 关键字</p>\n<p>Lock接口及其实现类</p>\n<p>原子类</p>\n<p>并发集合</p>\n<p>读写锁</p>\n<p>线程同步工具（CountdownLatch、Semaphore）</p>\n<h3 id=\"并发编程的三个特性\"><a href=\"#并发编程的三个特性\" class=\"headerlink\" title=\"并发编程的三个特性\"></a>并发编程的三个特性</h3><ol>\n<li><strong>原子性</strong></li>\n</ol>\n<p>一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。</p>\n<p>在 Java 中，可以借助 <code>synchronized</code>、各种 <code>Lock</code> 以及各种原子类实现原子性。</p>\n<p><code>synchronized</code> 和各种 <code>Lock</code> 可以保证任一时刻只有一个线程访问该代码块，因此可以保障原子性。各种原子类是利用 CAS (compare and swap) 操作（可能也会用到 <code>volatile</code>或者 <code>final</code>关键字）来保证原子操作。</p>\n<ol start=\"2\">\n<li><strong>可见性</strong></li>\n</ol>\n<p>当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。</p>\n<p>在 Java 中，可以借助 <code>synchronized</code>、<code>volatile</code> 以及各种 <code>Lock</code> 实现可见性。</p>\n<p>如果我们将变量声明为 <code>volatile</code> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>\n<ol start=\"3\">\n<li><strong>有序性</strong></li>\n</ol>\n<p>在 Java 中，<code>volatile</code> 关键字可以禁止指令进行重排序优化。</p>\n<h3 id=\"AQS\"><a href=\"#AQS\" class=\"headerlink\" title=\"AQS\"></a>AQS</h3><p>参考文献：<a href=\"https://mp.weixin.qq.com/s/jEx-4XhNGOFdCo4Nou5tqg\">https://mp.weixin.qq.com/s/jEx-4XhNGOFdCo4Nou5tqg</a></p>\n<p>抽象类，为同步器提供了通用的执行框架。定义了资源获取和释放的通用流程，具体的资源获取和释放则通过模版方法来实现。</p>\n<p>性能好的点在于：<strong>CAS+线程阻塞/唤醒</strong></p>\n<p><strong>核心思想</strong>：如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态</p>\n<h3 id=\"synchronized和Lock的区别\"><a href=\"#synchronized和Lock的区别\" class=\"headerlink\" title=\"synchronized和Lock的区别\"></a>synchronized和Lock的区别</h3><table>\n<thead>\n<tr>\n<th><strong>维度</strong></th>\n<th><strong>synchronized</strong></th>\n<th><strong>Lock</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>锁释放</strong></td>\n<td>自动释放（代码块结束或异常）</td>\n<td>手动释放（需 <code>unlock()</code>）</td>\n</tr>\n<tr>\n<td><strong>公平性</strong></td>\n<td>仅非公平锁</td>\n<td>支持公平锁与非公平锁</td>\n</tr>\n<tr>\n<td><strong>中断响应</strong></td>\n<td>不支持</td>\n<td>支持（<code>lockInterruptibly()</code>）</td>\n</tr>\n<tr>\n<td><strong>锁状态检测</strong></td>\n<td>无法判断</td>\n<td>可检测（<code>tryLock()</code>）</td>\n</tr>\n<tr>\n<td><strong>性能</strong></td>\n<td>低竞争场景优</td>\n<td>高竞争场景优</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>简单同步、快速开发</td>\n<td>复杂逻辑、高并发优化</td>\n</tr>\n</tbody></table>\n<p>从底层实现上：</p>\n<ul>\n<li>synchronized是java的关键词，由jvm直接管理，通过字节码指令 <code>monitorenter</code>和 <code>monitorexit</code>实现（还有锁升级机制）</li>\n<li>Lock是类，实现包括：<ul>\n<li>乐观锁，基于volatile变量和CAS算法实现</li>\n<li><code>ReentrantLock</code> 通过 AQS 维护锁状态和等待队列，支持可重入性和公平性</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Future和CompletableFuture\"><a href=\"#Future和CompletableFuture\" class=\"headerlink\" title=\"Future和CompletableFuture\"></a>Future和CompletableFuture</h3><p>应用为主</p>\n<p>CompletableFuture支持任务之间的并行调用，在等待A任务执行完之后执行另外的任务，也支持组合两个任务，等待两个任务同时执行完毕</p>\n<h3 id=\"ForkJoinPool\"><a href=\"#ForkJoinPool\" class=\"headerlink\" title=\"ForkJoinPool\"></a>ForkJoinPool</h3><p><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250310163700719-20250310-163702.png\" alt=\"image-20250310163700719\"></p>\n<p>CompletableFuture如果不自定义线程池，默认使用的全局线程池就是ForkJoinPool</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MergeSortTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">RecursiveAction</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] array;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> left, right;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> THRESHOLD = <span class=\"number\">1000</span>; <span class=\"comment\">// 拆分阈值</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">compute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (right - left &lt;= THRESHOLD) &#123;</span><br><span class=\"line\">            Arrays.sort(array, left, right); <span class=\"comment\">// 小任务直接排序</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> mid = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            invokeAll(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> MergeSortTask(array, left, mid),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> MergeSortTask(array, mid, right)</span><br><span class=\"line\">            );</span><br><span class=\"line\">            merge(array, left, mid, right); <span class=\"comment\">// 合并结果</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用方式</span></span><br><span class=\"line\">ForkJoinPool pool = <span class=\"keyword\">new</span> ForkJoinPool();</span><br><span class=\"line\">pool.invoke(<span class=\"keyword\">new</span> MergeSortTask(arr, <span class=\"number\">0</span>, arr.length));</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.RecursiveTask;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ForkJoinSumCalculator</span> <span class=\"keyword\">extends</span> <span class=\"title\">RecursiveTask</span>&lt;<span class=\"title\">Long</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span>[] array;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> start;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> end;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> THRESHOLD = <span class=\"number\">10_000</span>; <span class=\"comment\">// 任务拆分阈值</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ForkJoinSumCalculator</span><span class=\"params\">(<span class=\"keyword\">long</span>[] array)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(array, <span class=\"number\">0</span>, array.length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">ForkJoinSumCalculator</span><span class=\"params\">(<span class=\"keyword\">long</span>[] array, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.array = array;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.start = start;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.end = end;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Long <span class=\"title\">compute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = end - start;</span><br><span class=\"line\">        <span class=\"comment\">// 如果任务足够小，直接计算</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (length &lt;= THRESHOLD) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> computeDirectly();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 拆分任务：将大任务分为两个子任务</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = start + length / <span class=\"number\">2</span>;</span><br><span class=\"line\">        ForkJoinSumCalculator leftTask = <span class=\"keyword\">new</span> ForkJoinSumCalculator(array, start, mid);</span><br><span class=\"line\">        ForkJoinSumCalculator rightTask = <span class=\"keyword\">new</span> ForkJoinSumCalculator(array, mid, end);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 异步执行左半部分任务（fork）</span></span><br><span class=\"line\">        leftTask.fork();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 同步执行右半部分任务，并合并结果（join）</span></span><br><span class=\"line\">        Long rightResult = rightTask.compute();</span><br><span class=\"line\">        Long leftResult = leftTask.join();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> leftResult + rightResult;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 直接计算区间和</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">long</span> <span class=\"title\">computeDirectly</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class=\"line\">            sum += array[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span>[] array = <span class=\"keyword\">new</span> <span class=\"keyword\">long</span>[<span class=\"number\">100_000</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">            array[i] = i + <span class=\"number\">1</span>; <span class=\"comment\">// 初始化数组为1~100000</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建ForkJoinPool并提交任务</span></span><br><span class=\"line\">        ForkJoinPool pool = <span class=\"keyword\">new</span> ForkJoinPool();</span><br><span class=\"line\">        Long result = pool.invoke(<span class=\"keyword\">new</span> ForkJoinSumCalculator(array));</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;计算结果: &quot;</span> + result); <span class=\"comment\">// 应输出5000050000</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>避免饥饿：通过工作窃取机制，空闲线程主动从其他队列窃取任务，动态平衡负载（内部会为每一个线程简历一个工作队列）</li>\n<li>合理设置任务拆分阈值（THRESHOLD）</li>\n</ol>\n<p>关键点：<strong>分治策略</strong> + <strong>工作窃取</strong></p>\n<h3 id=\"Hash结构的数据解决哈希冲突的方法有哪些\"><a href=\"#Hash结构的数据解决哈希冲突的方法有哪些\" class=\"headerlink\" title=\"Hash结构的数据解决哈希冲突的方法有哪些\"></a>Hash结构的数据解决哈希冲突的方法有哪些</h3><ol>\n<li>开放定址法：哈希冲突发生时，按照特定的规则寻找下一个哈希地址</li>\n<li>链地址法</li>\n<li>再哈希法（使用备用哈希函数）</li>\n<li>公共溢出区法</li>\n</ol>\n<h3 id=\"HashMap和HashTable的区别\"><a href=\"#HashMap和HashTable的区别\" class=\"headerlink\" title=\"HashMap和HashTable的区别\"></a>HashMap和HashTable的区别</h3><ol>\n<li>线程安全性：HashMap线程不安全，HashTable线程安全（内部方法都通过synchronized关键词修饰）</li>\n<li>效率：HashMap高于HashTable（为了保证线程安全，牺牲了性能）</li>\n<li>对Null的支持：HashMap允许存在Null的key和value，而HashTable不允许</li>\n<li>初始化容量：<ul>\n<li>HashMap初始化大小为16，每次扩容两倍；如果设置了初始大小，就会设置为比初始大小大的2的幂次方</li>\n<li>HashTable初始大小为11，每次扩容2n+1；如果设置了初始大小，则直接使用初始大小</li>\n</ul>\n</li>\n<li>1.8后的HashMap存在链表转红黑树的过程</li>\n<li>HashMap对哈希值的高位和低位进行了扰动处理</li>\n</ol>\n<h3 id=\"单例模式的破坏\"><a href=\"#单例模式的破坏\" class=\"headerlink\" title=\"单例模式的破坏\"></a>单例模式的破坏</h3><ol>\n<li><strong>反射绕过单例</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class&lt;?&gt; clazz = Singleton.class;</span><br><span class=\"line\">Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor();</span><br><span class=\"line\">constructor.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">Singleton instance1 = (Singleton) constructor.newInstance();</span><br><span class=\"line\">Singleton instance2 = (Singleton) constructor.newInstance();</span><br><span class=\"line\">System.out.println(instance1 == instance2); <span class=\"comment\">// 输出 false</span></span><br></pre></td></tr></table></figure>\n<p>可以直接在构造函数中去进行实例检查：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Inner.instance != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;禁止通过反射创建实例！&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意懒汉式，还需要额外进行考虑，添加一个状态位：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flag) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;禁止反射创建！&quot;</span>);</span><br><span class=\"line\">        flag = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      \t<span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          ...</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是，状态位也可能会被反射更新。因此，懒汉式实现的单例模式是不可以防止被反射破坏的</p>\n<ol start=\"2\">\n<li><strong>序列化和反序列化对单例模式的破坏</strong></li>\n</ol>\n<p>单例类实现 <code>Serializable</code> 接口后，反序列化时会通过反射生成新对象，而非复用已有实例。</p>\n<p>解决方法：</p>\n<p>（1）枚举类会直接返回已有实例</p>\n<p>（2）添加readResolve()，返回已有实例。**<code>readResolve()</code> 是 Java 序列化机制中的一个特殊回调方法**，用于在反序列化过程中替换或控制最终返回的对象</p>\n<p>可以考虑实现单例模式的另外两种方案：</p>\n<ol>\n<li><strong>枚举单例</strong> （最优方案）</li>\n</ol>\n<p>枚举类禁止创建反射单例（JVM禁止），也不需要依赖构造函数检查</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    INSTANCE;</span><br><span class=\"line\">    <span class=\"comment\">// 添加方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>优势</strong>：无需手动防御反射，安全性最高</p>\n<ol start=\"2\">\n<li>静态内部类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Holder</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Holder.INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>原理</strong>：静态内部类在首次调用 <code>getInstance()</code> 时才加载，JVM保证类加载过程的线程安全性</p>\n<h3 id=\"新版本Java\"><a href=\"#新版本Java\" class=\"headerlink\" title=\"新版本Java\"></a>新版本Java</h3><p>Java24发布了，最重要的一个特性：<strong>虚拟线程的同步而不固定平台线程</strong></p>\n<p>优化了虚拟线程与 <code>synchronized</code> 的工作机制。虚拟线程在 <code>synchronized</code> 方法和代码块中阻塞时，通常能够释放其占用的操作系统线程（平台线程），避免了对平台线程的长时间占用，从而提升应用程序的并发能力。这种机制避免了“固定 (Pinning)”——即虚拟线程长时间占用平台线程，阻止其服务于其他虚拟线程的情况。</p>\n<p>现有的使用 <code>synchronized</code> 的 Java 代码无需修改即可受益于虚拟线程的扩展能力。例如，一个 I/O 密集型的应用程序，如果使用传统的平台线程，可能会因为线程阻塞而导致并发能力下降。而使用虚拟线程，即使在 <code>synchronized</code> 块中发生阻塞，也不会固定平台线程，从而允许平台线程继续服务于其他虚拟线程，提高整体的并发性能。</p>\n<p><strong>核心</strong>：虚拟线程在被synchronized阻塞的时候，会释放掉所占用的平台线程</p>\n<p><strong>提前类加载和链接</strong>：缓存已经加载和链接过的类，减少重复工作的开销（无侵入）</p>\n<h3 id=\"Spring-Task\"><a href=\"#Spring-Task\" class=\"headerlink\" title=\"Spring Task\"></a>Spring Task</h3><p><code>ScheduledThreadPoolExecutor</code> 是 JDK 自带的定时调度器，基于一个 <strong>延时队列（DelayedWorkQueue）</strong> 来管理任务：</p>\n<ul>\n<li>提交任务时，会计算出<strong>下次执行的时间戳</strong>，丢进延时队列。</li>\n<li>一个专门的工作线程会不断从队列里取“到期的任务”，放到线程池里去执行。</li>\n<li>如果是周期任务（fixedRate/fixedDelay），执行完毕后会<strong>重新计算下次时间</strong>，再放回队列</li>\n</ul>\n<p>默认使用<code>ThreadPoolTaskScheduler</code> 的线程池大小 = 1，也就是单线程顺序执行。因此，可以自己配置一个线程池：</p>\n<ul>\n<li><strong>扫描 @Scheduled 注解</strong> → 注册成定时任务。</li>\n<li><strong>交给 TaskScheduler（默认 ThreadPoolTaskScheduler）</strong> 管理。</li>\n<li><strong>底层依赖 JDK 的 ScheduledThreadPoolExecutor</strong>（基于延时队列实现）。</li>\n<li>周期任务 / Cron 任务：每次执行完毕后算出下一次执行时间，再丢回调度队列</li>\n</ul>\n<h2 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h2><p>htop查看内存占用情况，PID等信息</p>\n<p><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250305125116718-20250305-125117.png\" alt=\"image-20250305125116718\"></p>\n<h3 id=\"处理大文件\"><a href=\"#处理大文件\" class=\"headerlink\" title=\"处理大文件\"></a>处理大文件</h3><blockquote>\n<p>Linux读取大文件进行文本替换</p>\n</blockquote>\n<p><strong>使用 <code>sed</code> 命令（流式处理，内存友好）</strong></p>\n<ul>\n<li><strong>适用场景</strong>：全局或局部替换文本，支持正则表达式。</li>\n<li><strong>优势</strong>：逐行处理文件，无需加载整个文件到内存。</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 替换文件中所有 <span class=\"string\">&quot;old_text&quot;</span> 为 <span class=\"string\">&quot;new_text&quot;</span>（直接修改原文件）</span></span><br><span class=\"line\">sed -i &#x27;s/old_text/new_text/g&#x27; large_file.txt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 仅替换第 100 到 200 行的内容</span></span><br><span class=\"line\">sed -i &#x27;100,200s/old_text/new_text/g&#x27; large_file.txt</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250321125123282-20250321-125126.png\" alt=\"image-20250321125123282\"></p>\n<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><h3 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h3><ol>\n<li>每个节点非黑即红，黑色代表平衡，红色代表不平衡；</li>\n<li>根节点总是黑色的</li>\n<li>每个叶子节点都是黑色的空节点（NIL 节点）。这里指的是红黑树都会有一个空的叶子节点，是红黑树自己的规则；</li>\n<li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</li>\n<li>从任意节点到它的叶子节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</li>\n</ol>\n<h2 id=\"Etcd\"><a href=\"#Etcd\" class=\"headerlink\" title=\"Etcd\"></a>Etcd</h2><h3 id=\"备份过程数据的一致性\"><a href=\"#备份过程数据的一致性\" class=\"headerlink\" title=\"备份过程数据的一致性\"></a>备份过程数据的一致性</h3><p>原因在于它不是简单去拷贝数据文件，而是通过 <strong>Raft 一致性和 etcd 的 MVCC 存储机制</strong> 来保证</p>\n<ul>\n<li>etcd 集群所有写入必须经过 <strong>Raft 共识</strong> 才能提交。</li>\n<li>当执行 <code>etcdctl snapshot save</code> 时，etcd 会选定一个<strong>一致的 Raft 提交点</strong>（commit index），以该时刻为快照边界</li>\n<li>etcd 底层使用 <strong>boltdb</strong> 存储，并且有 <strong>MVCC（多版本并发控制）索引层</strong></li>\n</ul>\n<p>综上，一致性保障来源于两方面：</p>\n<p><strong>Raft 共识 → 确保提交点一致</strong>；</p>\n<p><strong>MVCC 快照 → 确保读取的是某个固定 revision 的全局状态</strong></p>\n<p> <strong>MVCC 在这里的作用</strong>就是：保证 <code>snapshot save</code> 读出的所有数据属于同一个 revision，不会前后混杂</p>\n<h3 id=\"Raft-而非-Paxos\"><a href=\"#Raft-而非-Paxos\" class=\"headerlink\" title=\"Raft 而非 Paxos\"></a>Raft 而非 Paxos</h3><p><strong>Paxos</strong>：理论优雅，但工程实现复杂，难以理解和维护；</p>\n<p><strong>Raft</strong>：在保证相同一致性语义的前提下，更直观、更易实现和维护</p>\n<p>一句话总结：Raft 更工程友好，理解和实现成本更低，维护更容易</p>\n<h3 id=\"Etcd-VS-Zookeeper\"><a href=\"#Etcd-VS-Zookeeper\" class=\"headerlink\" title=\"Etcd VS Zookeeper\"></a>Etcd VS Zookeeper</h3><p>Zookeeper的问题：</p>\n<p><strong>Watch 机制不足</strong></p>\n<ul>\n<li>触发一次就失效，需要重新注册；</li>\n<li>客户端多时容易引发“惊群效应”</li>\n</ul>\n<p><strong>一致性协议复杂</strong></p>\n<ul>\n<li>ZAB 没有 Raft 那么直观，理解和验证成本高</li>\n</ul>\n<h1 id=\"场景题\"><a href=\"#场景题\" class=\"headerlink\" title=\"场景题\"></a>场景题</h1><h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><p>智力题pdf： <a href=\"%E5%9C%BA%E6%99%AF%E9%A2%98.pdf\">场景题.pdf</a> </p>\n<h3 id=\"最大的100个数字\"><a href=\"#最大的100个数字\" class=\"headerlink\" title=\"最大的100个数字\"></a>最大的100个数字</h3><blockquote>\n<p>有很多个没有排序过的数字，想要找到其中最大的100个数字，怎么实现，时间复杂度是多少？</p>\n</blockquote>\n<ol>\n<li>最小堆法：</li>\n</ol>\n<p>将前100个数构建为<strong>最小堆</strong></p>\n<p>后续每个数，如果大于堆顶，那么就替换并且更新结构；否则就不需要</p>\n<p>建堆O(100)，后续每次处理为O(nlog100) = O(n)</p>\n<p>时间复杂度为：O（n）</p>\n<ol start=\"2\">\n<li>快速选择算法：分区，找到第100大的元素。此时左边就是需要的</li>\n</ol>\n<p>平均O（n），最坏情况（n^2）</p>\n<ol start=\"3\">\n<li><p>分治法（数据量过大的时候）：</p>\n<p>将数据分成若干块（每块100万个），每块使用上述两种方法找到最大的100个数</p>\n<p>合并top100，再次筛选</p>\n<p>时间复杂度为O(n + mlogm + 100m)，m是块数</p>\n</li>\n</ol>\n<h3 id=\"大数据量的状态\"><a href=\"#大数据量的状态\" class=\"headerlink\" title=\"大数据量的状态\"></a>大数据量的状态</h3><blockquote>\n<p>有一台16G内存的电脑，要保存2的32次方个qq号的状态，怎么设计，大概占多少内存空间？</p>\n</blockquote>\n<p>都用1位表示状态：</p>\n<p>2^32 * 1 / 8 =536,870,912 字节 = 512MB</p>\n<p>布隆过滤器近似计算</p>\n<h3 id=\"查找高频词\"><a href=\"#查找高频词\" class=\"headerlink\" title=\"查找高频词\"></a>查找高频词</h3><blockquote>\n<p>在内容安全工作中，常用高频词查找的需要。<br>你需要在最多不超过 10^7 的单词中查找其中出现次数最多的 100 个，即 TOP100。<br>为了简单起见，所有单词都已经被提取出来，每个单词由小写字母 a-z 组成，长度不超过 20 个字母。<br>你需要使用尽可能小的内存空间和尽可能快的算法来找出这 100 个单词。<br>样例1:<br>[输入]<br>5<br>splunk<br>elastic<br>splunk<br>clickhouse<br>elastic</p>\n</blockquote>\n<p>先存储（用map或者trie？长度20的话，20*26=520 ）；用map也可以</p>\n<p>然后用最大的100个数字的方法</p>\n<h3 id=\"统计10G电话号码\"><a href=\"#统计10G电话号码\" class=\"headerlink\" title=\"统计10G电话号码\"></a>统计10G电话号码</h3><blockquote>\n<p>10G的11位电话号码文件，2G内存，如何获取重复率最高的电话号码</p>\n</blockquote>\n<ol>\n<li><strong>哈希分片</strong>：<ul>\n<li>将10G文件按电话号码的哈希值（如<strong>取模</strong>运算）分割为多个小文件，确保相同电话号码一定落入同一文件。例如，哈希函数设为 <code>hash(phone) % 1000</code>，生成1000个子文件，每个文件约10MB（假设电话号码均匀分布）</li>\n</ul>\n</li>\n<li>逐文件统计频率：<ul>\n<li>逐个读取子文件，在内存中统计每个文件的电话号码出现次数</li>\n<li>记录当前文件的<strong>最高频率号码</strong>及其次数</li>\n</ul>\n</li>\n<li>全局汇总：<ul>\n<li>合并所有子文件的统计结果，计算全局最高频率</li>\n<li>读取所有临时结果文件，使用<strong>最小堆</strong>或<strong>外部排序</strong>合并数据</li>\n</ul>\n</li>\n</ol>\n<p>哈希分片 or bitmap（本题不适用） 是一种很重要的思想方法</p>\n<h3 id=\"3次失败登陆锁定15分钟\"><a href=\"#3次失败登陆锁定15分钟\" class=\"headerlink\" title=\"3次失败登陆锁定15分钟\"></a>3次失败登陆锁定15分钟</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Result <span class=\"title\">login</span><span class=\"params\">(String username, String password)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 检查是否已锁定</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (redis.exists(<span class=\"string\">&quot;lock:&quot;</span> + username)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Result.error(<span class=\"string\">&quot;账户已锁定，请15分钟后重试&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 2. 验证用户名密码</span></span><br><span class=\"line\">    User user = userService.findByUsername(username);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (user != <span class=\"keyword\">null</span> &amp;&amp; password.equals(user.getPassword())) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 登录成功：重置失败次数</span></span><br><span class=\"line\">        redis.delete(<span class=\"string\">&quot;login_fail:&quot;</span> + username);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Result.success();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 3. 登录失败：递增失败次数</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> count = redis.incr(<span class=\"string\">&quot;login_fail:&quot;</span> + username);</span><br><span class=\"line\">        redis.expire(<span class=\"string\">&quot;login_fail:&quot;</span> + username, <span class=\"number\">900</span>); <span class=\"comment\">// 15分钟滑动窗口</span></span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"comment\">// 4. 判断是否触发锁定</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (count &gt;= <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">            redis.setex(<span class=\"string\">&quot;lock:&quot;</span> + username, <span class=\"number\">900</span>, <span class=\"string\">&quot;locked&quot;</span>); <span class=\"comment\">// 锁定15分钟</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> Result.error(<span class=\"string\">&quot;连续失败3次，账户已锁定&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Result.error(<span class=\"string\">&quot;用户名或密码错误&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th><strong>方案</strong></th>\n<th><strong>优点</strong></th>\n<th><strong>缺点</strong></th>\n<th><strong>适用场景</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>纯数据库实现</strong></td>\n<td>无需额外中间件，数据持久化可靠</td>\n<td>高并发下性能瓶颈，锁竞争严重</td>\n<td>低并发、数据一致性要求高</td>\n</tr>\n<tr>\n<td><strong>Redis+数据库</strong></td>\n<td>高性能，自动过期，易于扩展</td>\n<td>依赖Redis可用性，需处理缓存穿透</td>\n<td>中高并发，实时性要求高</td>\n</tr>\n<tr>\n<td><strong>分布式锁+计数</strong></td>\n<td>支持分布式部署，强一致性</td>\n<td>实现复杂，运维成本高</td>\n<td>大型系统，多节点协同</td>\n</tr>\n</tbody></table>\n<h3 id=\"秒杀场景\"><a href=\"#秒杀场景\" class=\"headerlink\" title=\"秒杀场景\"></a>秒杀场景</h3><p><strong>数据库层面的解决方案</strong></p>\n<p>乐观锁：在商品表中增加 <code>version</code>字段，每次更新库存时校验版本号是否一致</p>\n<p>唯一索引+条件更新：</p>\n<p>创建用户购买记录表，对 <code>(uid, goods_id)</code>添加唯一索引，防止重复购买</p>\n<p><strong>redis实现分布式锁</strong></p>\n<p>在锁内执行库存预减和订单生成逻辑</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 加锁示例（Redisson实现）</span></span><br><span class=\"line\">RLock lock = redissonClient.getLock(<span class=\"string\">&quot;lock:product_1&quot;</span>);</span><br><span class=\"line\">lock.lock(<span class=\"number\">10</span>, TimeUnit.SECONDS);</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> stock = redis.get(<span class=\"string\">&quot;product_stock_1&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (stock &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        redis.decr(<span class=\"string\">&quot;product_stock_1&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 异步生成订单</span></span><br><span class=\"line\">        sendToMQ(order);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    lock.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>原子性初始化</strong> 使用Redis的 <code>SET</code>命令结合 <code>NX</code>（不存在时设置）选项，确保库存仅被初始化一次。例如：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET product:stock 50 NX  <span class=\"comment\"># 仅当键不存在时设置库存为50</span></span><br></pre></td></tr></table></figure>\n<p><strong>Lua脚本实现原子操作</strong> 通过Lua脚本在Redis服务端<strong>原子性校验并扣减库存</strong>，避免并发下的数据不一致。脚本逻辑如下</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- KEYS[1]: 库存键（如product:stock）</span></span><br><span class=\"line\"><span class=\"comment\">-- ARGV[1]: 扣减数量（如1）</span></span><br><span class=\"line\"><span class=\"keyword\">local</span> stock = <span class=\"built_in\">tonumber</span>(redis.call(<span class=\"string\">&#x27;get&#x27;</span>, KEYS[<span class=\"number\">1</span>]))</span><br><span class=\"line\"><span class=\"keyword\">if</span> stock &gt;= <span class=\"built_in\">tonumber</span>(ARGV[<span class=\"number\">1</span>]) <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> redis.call(<span class=\"string\">&#x27;decrby&#x27;</span>, KEYS[<span class=\"number\">1</span>], ARGV[<span class=\"number\">1</span>])</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>  <span class=\"comment\">-- 库存不足</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250321155154531-20250321-155154.png\" alt=\"image-20250321155154531\"></p>\n<h3 id=\"多线程任务场景\"><a href=\"#多线程任务场景\" class=\"headerlink\" title=\"多线程任务场景\"></a>多线程任务场景</h3><blockquote>\n<p>开一个线程池，5个核心线程，10个任务，保证10个任务执行完，再执行主线程的一些任务</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadPoolExecutor threadPoolExecutor = <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">10</span>, TimeUnit.SECONDS,</span><br><span class=\"line\">        <span class=\"keyword\">new</span> ArrayBlockingQueue&lt;&gt;(<span class=\"number\">5</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 10个执行完才能够执行其他的</span></span><br><span class=\"line\">CountDownLatch countDownLatch = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 10个任务</span></span><br><span class=\"line\">Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; ++i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> finalI = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">    threadPoolExecutor.submit(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;任务&quot;</span> + finalI);</span><br><span class=\"line\">            Thread.sleep(random.nextInt(<span class=\"number\">500</span>) + <span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            countDownLatch.countDown();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">countDownLatch.await();</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;所有任务已完成&quot;</span>);</span><br><span class=\"line\">threadPoolExecutor.shutdown();</span><br></pre></td></tr></table></figure>\n<h3 id=\"生产者-消费者模型\"><a href=\"#生产者-消费者模型\" class=\"headerlink\" title=\"生产者-消费者模型\"></a>生产者-消费者模型</h3><p>2个生产者和4个消费者的模型。生产者负责读取文件数据，消费者负责消费文件并输出</p>\n<p>阻塞队列可以</p>\n<h3 id=\"并查集的删除\"><a href=\"#并查集的删除\" class=\"headerlink\" title=\"并查集的删除\"></a>并查集的删除</h3><p>在处理某些人之间具有关系的数据结构中，常常用到并查集。例如：a和b认识，b和c认识，那么a和c就可以连接上，可以用并查集来存储这种关系。但是现在需要考虑a和b绝交了，在这种情形下如何用并查集来处理，确认某两个人之间是否还能连接</p>\n<p>可以反向处理，将删除等价为增加</p>\n<h3 id=\"查询问题\"><a href=\"#查询问题\" class=\"headerlink\" title=\"查询问题\"></a>查询问题</h3><blockquote>\n<p>场景1：查全校人的姓名，选出top10出现率的名字<br>场景2：如果查询范围变成全国呢？<br>场景3：如果空间有限，不让用多级索引呢？用什么数据结构节省空间？<br>场景4：DNS服务器解析域名对应的IP地址的时候，怎么快速查找到对应的IP地址同时节省存储空间？</p>\n</blockquote>\n<h3 id=\"称盐问题\"><a href=\"#称盐问题\" class=\"headerlink\" title=\"称盐问题\"></a>称盐问题</h3><blockquote>\n<p>140g的盐 各有一个2g和一个7g的砝码 只能用三次天平，如何称出50g 和 90 g</p>\n</blockquote>\n<p>第一次平分，70+70，第二次继续对一份70克平分，35+35，第三次左边2g砝码，右边7克砝码，调整35克盐以达到平衡，这样左边有20克盐，右边15克盐。把20克盐加到一份70克中即可</p>\n<h3 id=\"烧绳子\"><a href=\"#烧绳子\" class=\"headerlink\" title=\"烧绳子\"></a>烧绳子</h3><blockquote>\n<p>一根绳子烧完要1小时，如何计时15分钟，30分钟和45分钟</p>\n</blockquote>\n<h2 id=\"SQL代码\"><a href=\"#SQL代码\" class=\"headerlink\" title=\"SQL代码\"></a>SQL代码</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> basic_query <span class=\"keyword\">as</span> (</span><br><span class=\"line\"><span class=\"keyword\">select</span> </span><br><span class=\"line\"><span class=\"keyword\">distinct</span> products.product_id,</span><br><span class=\"line\">category,</span><br><span class=\"line\">name <span class=\"keyword\">as</span> product_name,</span><br><span class=\"line\"><span class=\"built_in\">sum</span>(quantity) <span class=\"keyword\">over</span> (<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> products.product_id) <span class=\"keyword\">as</span> total_sales</span><br><span class=\"line\"><span class=\"keyword\">from</span></span><br><span class=\"line\">products <span class=\"keyword\">inner</span> <span class=\"keyword\">join</span> orders <span class=\"keyword\">on</span> products.product_id <span class=\"operator\">=</span> orders.product_id</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">select</span> </span><br><span class=\"line\">product_name,</span><br><span class=\"line\">total_sales,</span><br><span class=\"line\"><span class=\"built_in\">rank</span>() <span class=\"keyword\">over</span> (<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> category <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> total_sales <span class=\"keyword\">desc</span>) <span class=\"keyword\">as</span> category_rank</span><br><span class=\"line\"><span class=\"keyword\">from</span> basic_query;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> </span><br><span class=\"line\">    date1, </span><br><span class=\"line\">    date2,</span><br><span class=\"line\">    <span class=\"keyword\">CASE</span> </span><br><span class=\"line\">        <span class=\"keyword\">WHEN</span> <span class=\"type\">DATE</span>(date1) <span class=\"operator\">=</span> <span class=\"type\">DATE</span>(date2) <span class=\"keyword\">THEN</span> <span class=\"string\">&#x27;Same Day&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">ELSE</span> <span class=\"string\">&#x27;Different Day&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">END</span> <span class=\"keyword\">AS</span> IsSameDay</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> </span><br><span class=\"line\">    your_table;</span><br></pre></td></tr></table></figure>\n<h1 id=\"HR面\"><a href=\"#HR面\" class=\"headerlink\" title=\"HR面\"></a>HR面</h1><p>1 你觉得你有哪些缺点和优点？</p>\n<p>缺点：在面对一些比较重要的任务和紧迫的DDL的压制下，由于我本身的执行力非常强，所以这种时候我会试图去尽快把一件事情做完。这种时候，我往往做到了高效完成任务，但容易忽视前期的一些调研准备工作，使得自己在真正去做这件事情的时候会遇到一些波折，导致出现一些小规模的返工。</p>\n<p>所以现在在做事情前我一般会通过几种方法去改进自己：</p>\n<p>首先，我现在习惯于一般会给自己列一个计划，尽量按照计划去做事。</p>\n<p>另一方，其实这也是一个认知的问题。我现在逐渐意识到准备本身也是做事情的一部分，通过预先调研往往能保证事情在执行阶段更加顺利。相当于说工欲善其事，必先利其器</p>\n<p>最后，我也会让自己去相信自己的能力，告诉自己我有能力去在期限内完成，更重要的其实在于每一个细节的达成。</p>\n<p>2 你怎么评价你面试的这家公司？</p>\n<p>3 你在校期间，有没有哪段时间或者某件事情让你受挫？</p>\n<p>去年此时，我发现自己体脂率很高，并且感觉不太健康了</p>\n<p>另一方面，之前的论文没有中，需要在两个月内完成一篇期刊，</p>\n<p>下定决心开始早起，作息从2点睡11点起更改到12点睡8点起。每天抽一个小时去运动一下，然后开始蹲图书馆</p>\n<p>4 在校期间遇到最有挑战的事情是什么？</p>\n<p>5 目前手上有 offer 吗？</p>\n<p>6  自我介绍</p>\n<p>7  职业规划</p>\n<p>8 报学校专业是怎么考虑的？</p>\n<p>9  工作城市</p>\n<p>10 你是独生子女吗？</p>\n<p>11 那你有男/女 朋友吗？</p>\n<p>12  你们出来面试都了解过哪些企业？</p>\n<p>13  到后期你们每个人手上有好几个offer，哪些因素决定你们选择这家公司?</p>\n<p>14  你更倾向哪种公司？有什么特别的点？</p>\n<p>15  你大学有没有特别难忘的经历或者项目分享一下的?</p>\n<p>16  团队合作中遇到什么问题？</p>\n<p>17  对互联网加班有什么看法？</p>\n<p>18  那你现在的技术薄弱点在哪里，怎么去突破？</p>\n<p>19  你的兴趣爱好有哪些？</p>\n<p>20 现在进度最快的公司是哪家？</p>\n<p>21 拿到哪几家offer，是否谈过薪资等</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cmhg4qt410006f5fa2o51ep3q","tag_id":"cmhg4qt420008f5fabfx33q6c","_id":"cmhg4qt49000cf5fa3b2pd58t"},{"post_id":"cmhg4qt4e000lf5fada87eghl","tag_id":"cmhg4qt4f000nf5fa9hszbs35","_id":"cmhg4qt4g000sf5fabn7445x6"},{"post_id":"cmhg4qt4f000of5fa1r028cwo","tag_id":"cmhg4qt4g000rf5fa5ypr8weu","_id":"cmhg4qt4h000xf5fadk268zqu"},{"post_id":"cmhg4qt4h000wf5fa01dia13p","tag_id":"cmhg4qt4h000vf5fa7qaq0raq","_id":"cmhg4qt4j0010f5fa33m6gwgp"},{"post_id":"cmhg4qt4f000pf5fa1kzmevu7","tag_id":"cmhg4qt4h000vf5fa7qaq0raq","_id":"cmhg4qt4v0012f5fa2jmu6sdh"},{"post_id":"cmhg4qt4h000yf5fa3s222pcy","tag_id":"cmhg4qt4h000vf5fa7qaq0raq","_id":"cmhg4qt4y0015f5fa1d61d7s5"},{"post_id":"cmhg4qt4l0011f5faf5hfhz53","tag_id":"cmhg4qt4h000vf5fa7qaq0raq","_id":"cmhg4qt520017f5fa2v2l71j8"},{"post_id":"cmhg4qt4g000qf5fa7lae8nb2","tag_id":"cmhg4qt4h000vf5fa7qaq0raq","_id":"cmhg4qt54001af5fadilc7a7l"},{"post_id":"cmhg4qt4w0013f5fa13xd4yzr","tag_id":"cmhg4qt4h000vf5fa7qaq0raq","_id":"cmhg4qt55001cf5fahno0e9b2"},{"post_id":"cmhg4qt4z0016f5fa696eb4j1","tag_id":"cmhg4qt4h000vf5fa7qaq0raq","_id":"cmhg4qt55001ef5fa7tqogf0n"},{"post_id":"cmhg4qt4g000tf5faddox3lyr","tag_id":"cmhg4qt4h000vf5fa7qaq0raq","_id":"cmhg4qt55001ff5fa3kl85moi"},{"post_id":"cmhg4qt4h000uf5faamxlbykn","tag_id":"cmhg4qt4h000vf5fa7qaq0raq","_id":"cmhg4qt55001gf5fa24po6qn7"},{"post_id":"cmhg4qt520018f5fa6bwselp6","tag_id":"cmhg4qt55001df5faeiy93pjc","_id":"cmhg4qt55001if5fa1v5p0boj"},{"post_id":"cmhg4qt54001bf5fa53os8knw","tag_id":"cmhg4qt55001df5faeiy93pjc","_id":"cmhg4qt56001jf5faee3dhgeu"},{"post_id":"cmhg4qvnb001lf5fa5spj0pn5","tag_id":"cmhg4qt55001df5faeiy93pjc","_id":"cmhg4qvnc001mf5fa7kl65uzf"}],"Tag":[{"name":"技术","_id":"cmhg4qt420008f5fabfx33q6c"},{"name":"算法","_id":"cmhg4qt4f000nf5fa9hszbs35"},{"name":"生日","_id":"cmhg4qt4g000rf5fa5ypr8weu"},{"name":"暑期实习","_id":"cmhg4qt4h000vf5fa7qaq0raq"},{"name":"秋招","_id":"cmhg4qt55001df5faeiy93pjc"}]}}