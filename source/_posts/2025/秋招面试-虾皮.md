---
title: 秋招面试-虾皮
date: 2025-11-01 17:57:00
cover: https://upic-1301780692.cos.ap-shanghai.myqcloud.com/26c9324913c021677768-20251101-180143.png
tag: 秋招
---

# 秋招面试-虾皮

## 虾皮一面
（8.5，50min）

### 自我介绍+项目
（约20分钟）

自我介绍

腾讯实习介绍+面试官challenge细节

蔚来实习介绍

实验室项目介绍+面试官challenge细节


### 算法
算法题（把树上每一层的节点全部往左移动，右边剩下的的位置设置为空）

纯代码编辑器，但是跟面试官说只写核心算法。因为没跑，所以最开始忘记把每一层后面的节点都置为null了

### 八股部分

死锁

如何解决死锁

进程间的通信方式

用过哪些linux命令

mysql为什么用B+树，而非B树和二叉树

跳表为什么不行

mysql如何查询优化

select b from tab where a =xxx 为什么没走(a,b)索引

TCP三次握手和四次挥手

反问

## 虾皮二面

（8.8）

1. 业务介绍
2. 自我介绍
3. 腾讯实习项目介绍，以及面试官的一些challenge
4. volatile如何实现可见性？每次都必须要从主存中拿数据吗？
5. 二维数组按行访问和按列访问的时间分别是多少？
6. index(a, b, c) select * from t where b = 1 and a = 2 order by c; 走了索引的哪些字段？
7. 现在上面这个查询语句没有走索引，为什么？
8. 现在每个商家有自己的一张订单表，要实现某一个商家下载订单表全部数据的功能。如何查询订单表全部的数据？
{% raw %}
9. 算法题：K个有序数组 {{1,3}, {2,4,5,6,7,9}, {1,2,7,9,10,11,12}}，将其合并为一个数组{1,1,2,2,...}
{% endraw %}



```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) {
        int[][] nums = {{1,3}, {2,4,5,6,7,9}, {1,2,7,9,10,11,12}};
        int[] ans = sort(nums, 0, 2);

        for (int i = 0; i < ans.length; ++i) {
            System.out.print(ans[i] + ",");
        }
    }
    // k * n
    // 时间复杂度：O(nlogK)
    // 空间复杂度：O(k*n)
    public static int[] sort(int[][] nums, int left, int right) {
        if (left >= right) {
            return nums[left];
        }
        int mid = left + (right - left) / 2;
        int[] nums1 = sort(nums, left, mid);
        int[] nums2 = sort(nums, mid + 1, right);
        // 合并成一个更大的数组
        int len1 = nums1.length;
        int len2 = nums2.length;
        // System.out.println(len1 + ", " + len2);
        int[] sumNums = new int[len1 + len2];
        int i = 0, j = 0;
        int index = 0;
        while (i < len1 && j < len2) {
            if (nums1[i] < nums2[j]) {
                sumNums[index] = nums1[i];
                ++i;
            } else {
                sumNums[index] = nums2[j];
                ++j;
            }
            ++index;
        }
        while (i < len1) {
            sumNums[index] = nums1[i];
            ++i;
            ++index;
        }
        while (j < len2) {
            sumNums[index] = nums2[j];
            ++j;
            ++index;
        }
        return sumNums;
    }
}
```

## 虾皮HR面
（8.13）
