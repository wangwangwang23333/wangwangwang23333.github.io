---
title: 秋招面试-百度
date: 2025-11-01 18:25:00
cover: https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20251101182512873-20251101-182513.png
tag: 秋招
---

# 秋招面试-百度

## 笔试

- 斐波那契数列1, 1, 2, 3, 5, ... 现给出l，r，求数列的第l项到第r项之间有多少个奇数
- 猫猫有一个融值v，每种液体都有一个液体度n（1～10^9)。如果猫猫融值v和液体的液体度n满足|n - v|<= x（其中x是阈值，整数），那么猫猫可以融化进这个液体；另一方面，猫猫可以随时变化成任意一个液体度。现在已知n种液体的液体度，猫猫按照液体编号从小到大的顺序依次融化进去，共需要变换m次，求满足条件的最小阈值。`（0<=m<n<=10^9）`
- 数组ai(1<=ai<=300)长度为n（1<=n<=100)，现在可以将ai修改为非负整数bi，代价为|ai-bi|。要求满足修改后的数组相邻两项满足：bi xor bi+1 = bi + bi+1，求修改的最小代价。

```java
// 第一题
int T = nextInt();
while (T-- > 0) {
    int l = nextInt();
    int r = nextInt();
    int sum = (r - l + 1) / 3 * 2;
    int yu = (r - l + 1) % 3; // 0, 1, 2
    for (int i = 0; i < yu; ++i) {
        if ((l + i) % 3 != 0) {
            sum++;
        }
    }
    bw.write(sum + "");
    if (T != 0) {
        bw.newLine();
    }
}

// 第二题
public static void main(String[] args) throws IOException {
      int T = nextInt();
      while (T-- > 0) {
          int n = nextInt();
          int m = nextInt();
          int[] arr = new int[n];

          //
          int minValue = Integer.MAX_VALUE;
          int maxValue = Integer.MIN_VALUE;

          for (int i = 0; i < n; ++i) {
              arr[i] = nextInt();
              minValue = Math.min(minValue, arr[i]);
              maxValue = Math.max(maxValue, arr[i]);
          }

          // x的最小可能值和最大可能值
          long left = 0, right = maxValue - minValue;
          while (left < right) {
              long mid = left + (right - left) / 2;
              if (check(arr, n, m, mid)) {
                  // 可行
                  right = mid;
              } else {
                  left = mid + 1;
              }
          }


          bw.write(left + "");
          if (T != 0) {
              bw.newLine();
          }
      }


      bw.flush();
      bw.close();

  }

  public static boolean check(int[] arr, int n, int m, long x) {
      // 记录当前最小融值和最大融值
      long min = arr[0] - x;
      long max = arr[0] + x;

      int ans = 0;
      for (int i = 1; i < n; ++i) {
          // 查看是否还在融值区间内
          if (arr[i] >= min - x && arr[i] <= max + x) {
              // 求出新的融值区间
              min = Math.max(min, arr[i] - x);
              max = Math.min(max, arr[i] + x);
          } else {
              // 不在了，那就必须消耗一次
              ++ans;
              min = arr[i] - x;
              max = arr[i] + x;
          }
      }
      return ans <= m;
  }


// 第三题
int n = nextInt();
  int[] arr = new int[n];
  for (int i = 0; i < n; ++i) {
      arr[i] = nextInt();
  }

  // ai, ai+1
  // 不能都是正数，或者都是负数
  // 必须一个非正数，一个非负数

  // 找到0 ～ 300之间可以满足xor关系的所有数字
  boolean[][] specialNumbers = new boolean[MAX_VALUE + 1][MAX_VALUE + 1];
  for (int i = 0; i <= MAX_VALUE / 2; ++i) {
      for (int j = 0; j <= MAX_VALUE; ++j) {
          if ((i ^ j) == i + j) {
              specialNumbers[i][j] = true;
              specialNumbers[j][i] = true;
          }
      }
  }

  // dp[i][j]表示处理到第i个后，上一个数字是j的情况下，当前总开销
  int[][] dp = new int[n][MAX_VALUE + 1];
  for (int j = 0; j <= MAX_VALUE; ++j) {
      dp[0][j] = Math.abs(j - arr[0]);
  }

  for (int i = 1; i < n; ++i) {
      // 当前数字变为j
      for (int j = 0; j <= MAX_VALUE; ++j) {
          dp[i][j] = Integer.MAX_VALUE;
          // dp[i][j]
          for (int k = 0; k <= MAX_VALUE; ++k) {
              if (specialNumbers[j][k]) {
                  dp[i][j] = Math.min(dp[i][j], dp[i - 1][k] + Math.abs(arr[i] - j));
              }
          }
      }
  }

  int ans = Integer.MAX_VALUE;
  for (int j = 0; j <= MAX_VALUE; ++j) {
      ans = Math.min(ans, dp[n - 1][j]);
  }
  ```



## 百度一面
（9.1，45min，商务品牌研发·广告投放）

1. 自我介绍
2. 实时协同编程的应用，未来实际落地方向
3. 蔚来实习项目性能优化简介
4. 腾讯实习项目，自己的收获以及未来优化方向
5. （算法）KMP不会（只记得大概有个next数组），换成了LRU
6. 反问

ps：很感人，这面试官还进了我简历上的网站

pps：一个八股没问，说看简历和实习觉得不用问


## 百度二面

（9.5，50min）

1. 自我介绍
2. 抽象语法树如何实现的；了解ast和cst的区别吗
3. 流式备份方法介绍
4. 为什么Etcd用Raft算法不用Paxos算法
5. Etcd和Zookeeper的区别（zookeeper存在什么问题）
6. Etcd备份的方法
7. etcd备份过程如何保障数据的一致性
8. 如何用Backup Agent实现的分布式锁
9. 介绍下Mysql中的慢日志优化
10. Mysql中for update加了什么锁
11. 什么是乐观锁
12. Mysql的B+树
13. 主键是什么索引
14. 为什么主键不能重复，且只能有一个
15. 介绍Java的集合
16. 介绍Java集合中的Map
17. TCP和UDP的区别
18. Http是有状态还是无状态的；如何实现的有状态
19. 了解Cacheline吗
20. 进程和线程的区别
21. 如何减少线程上下文切换的开销
22. 线程池为了解决什么问题
23. （算法）没有具体让做，就是说说思路：买卖股票的最佳时机1；atoi的实现
24. 目前有offer吗
25. 反问：学习下中间件；操作系统；agent相关知识


## 百度三面

（9.9，40min）

1. 简历中没有提到但比较有意思的项目介绍
2. 腾讯实习项目介绍
   1. 不落盘本地
   2. 分布式锁
   3. 项目背景
3. 是否有用过Spark之类的大数据；用过哪些其他语言
4. 算法：
   1. （写代码）两个线程一个打印奇数，一个打印偶数，交替打印：1,2,3,4...
   2. （口述）select for update加了什么锁
   3. （说了下想法）模拟一个简单的版本控制场景，给定一个基础版本base，以及两个基于base修改后的版本v1和v2，判断它们是否有冲突；或者能否自动合并
5. 反问
