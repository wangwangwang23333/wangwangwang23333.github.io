---
title: 暑期实习-蚂蚁面试
date: 2025-10-31 00:07:00
cover: https://upic-1301780692.cos.ap-shanghai.myqcloud.com/u=2193217229,3865826716&fm=253&app=138&f=JPEG-20251031-101944.jpeg
tag: 暑期实习
---

# 暑期实习-蚂蚁面试

## 笔试

（TCP报文数据总量）数据包1400字节，tcp头部20字节，应用层数据大小为1360字节，发送100个数据包，那么传输的字节数是多少？

> 传输的总字节数为 **140,000 字节**（140 KB）

umask为022，在创建文件的时候的权限是？

> 当 `umask` 设置为 **022** 时，新创建文件的权限为 **rw-r--r--**（即权限码 `644`）
>
> - **umask 作用**： umask 通过**屏蔽（禁用）**权限位来限制默认权限。计算方式为： 实际权限=默认权限 &  umask实际权限=默认权限& umask
>
> 文件基础权限：666（rw-rw-rw-），即所有用户可读可写，但不可执行（Linux默认不给文件执行权限）。
> 目录基础权限：777（rwxrwxrwx），即所有用户可读、写、执行。
> umask作用：通过按位取反后与基础权限进行逻辑与操作，屏蔽不需要的权限。

（结构型设计模式）责任链模式属于什么类型的设计模式？

> 属于 **行为型设计模式**，其核心目标是解耦请求的发送者与接收者，通过构建链式结构让多个对象依次处理同一请求，直到有对象处理成功或传递至链尾

主键不能为null吗？

> 是的，主键不能为null

对象可以调用线程的run方法吗？

> 是的，对象可以调用线程的 `run()` 方法，但这种方式并不会启动新线程，而是以**同步方式在当前线程中执行** `run()` 方法内的代码。这与 `start()` 方法启动线程的机制有本质区别

以下哪些适合强制缓存？静态图片；css；API

> **强制缓存**适用于内容不频繁变更的静态资源，其核心原理是通过设置 `Cache-Control` 或 `Expires` 响应头
>
> 静态图片和css文件适合

（哈夫曼树）(a, 5), (g, 90), (t, 53), (i, 80), (e, 49)构造成哈夫曼树，那么哈夫曼树的权值是多少

```shell
      277
     /   \
    107   170
   /  \   / \
  53  54 80 90
     / \
    5  49
```

做了2.75题

第一题：贪心就行，很简单

第二题：排序+二分就行

第三题：质数筛 + 组合方法？（最后只过了80%）

> int count = new int[10]表示数字0～9的个数，用他们组成不同的排列数如：0，1，1，2可以组成1120，1210，2110，1012，1102，1021，1201，2011，2101，112，121，211（忽略前导0，前导0等价于没有0），那么一共有多少种方式？理论上组合数就能解决，不需要动态规划

做完后思考：想复杂了，其实0当作普通的数字处理即可

```java
import java.util.*;
import java.io.*;



public class Main {
    static BufferedReader br;
    static StringTokenizer st;

    static String next() throws IOException {
        while (!st.hasMoreTokens()) {
            st = new StringTokenizer(br.readLine());
        }
        return st.nextToken();
    }

    static Integer nextInt() throws IOException {
        return Integer.parseInt(next());
    }

    static Long nextLong() throws IOException {
        return Long.parseLong(next());
    }

    public static void main(String[] args) throws IOException {
        br = new BufferedReader(new InputStreamReader(System.in));
        st = new StringTokenizer("");

        int T = nextInt();

        boolean[] zhishu = new boolean[1001];
        Arrays.fill(zhishu, true);
        zhishu[1] = false;
        zhishu[0] = false;
        for (int num = 2; num <= 1000; ++num) {
            if (!zhishu[num]) {
                continue;
            }
            for (int i = 2; i * num <= 1000; i++) {
                zhishu[i * num] = false;
            }
        }


        while (T-- > 0) {
            int x = nextInt();

            // 记录数位之和
            // 还需要看每个数字有几个
            int[] count = new int[10];
            String s = String.valueOf(x);
            int sum = 0;
            for (char ch : s.toCharArray()) {
                int index = ch - '0';
                count[index]++;
                sum += index;
            }

            if (!zhishu[sum]) {
                System.out.println(0);
                continue;
            }

            // 本质就是看这些数字有多少种排列方式
            // 2 1 0 3 ->

            // 对于放不放0的一些情况
            // Set<Integer> set = new HashSet<>();
            int len = s.length();

            // dfs(0, len, 0, count, set);
            // System.out.println(set.size() - 1);

            long ans = 1;

            int nonZeroCount = len - count[0];
            // 阶乘
            for (int i = 2; i <= nonZeroCount; ++i) {
                ans *= i;
            }
            // 除以出现重复的数量
            for (int num = 1; num <= 9; ++num) {
                if (count[num] <= 1) {
                    continue;
                }
                // 除以 num的阶乘
                for (int i = 2; i <= count[num]; ++i) {
                    ans /= i;
                }
            }

            // 接下来再把0塞进去
            // 0 有nonZeroCount + 1 个位置可以放
            int zeroCount = count[0];


            // 第i个数字放在第 j个0后面的方法
            long[][] dp = new long[nonZeroCount + 1][zeroCount + 1];
            Arrays.fill(dp[1], 1);

            for (int i = 2; i <= nonZeroCount; ++i) {
                for (int j = 0; j <= zeroCount; ++j) {
                    for (int k = 0; k <= j; ++k) {
                        dp[i][j] += dp[i - 1][k];
                    }
                }
            }

            // 数字的总放置方法
            long tot = 0;
            for (int j = 0; j <= zeroCount; ++j) {
                tot += dp[nonZeroCount][j];
            }
            ans *= tot;

            System.out.println(ans - 1);
        }

    }

    // 本质就是先不考虑0，把数字塞进去
    public static void dfs(int index, int len, int cur, int[] count,
                           Set<Integer> s) {
        if (index >= len) {
            s.add(cur);
            return;
        }
        for (int num = 0; num <= 9; ++num) {
            if (count[num] == 0) {
                continue;
            }
            count[num]--;
            dfs(index + 1, len, cur * 10 + num, count, s);
            count[num]++;
        }
    }

}
```

## 蚂蚁一面
（3.25，57min，电话面）

1. 自我介绍
2. 对微服务的理解
3. spring cloud中微服务A（支付受理）之间如何调用微服务B（支付资金扣减），A如何知道B的地址（eureka+gateway转发）
4. gateway请求压力不会很大吗，微服务A可以直接调用微服务B吗
5. 如果某个节点挂掉了，其他微服务怎么知道这件事情呢
6. 介绍线程池的参数
7. 当线程池的一个线程执行完任务之后，该线程处于什么状态
8. 线程池的5个核心线程，大小为2的阻塞队列，最大线程数为8，最开始有几个核心线程
9. 当核心线程的任务都执行完毕后，新到来的任务会交给哪个核心线程
10. 线程池的阻塞队列“阻塞”的是什么
11. 阻塞队列的实现原理
12. LinkedBlockingQueue用两个锁有什么优势
13. 介绍ThreadLocal实现原理
14. Java中有哪几种引用类型
15. 了解RPC吗
16. 如果自己实现一个限流算法，如实现QPS不超过10
17. 你实现的固定窗口限流算法如何解决前半段和后半段激增的流量
18. 你实现的限流算法如何解决短时间内突然到来的大量请求
19. 限流算法必须一个线程在那里给令牌桶添加令牌吗，有其他实现方法吗
20. 了解RateLimiter源码吗
21. 选一个最有挑战性的项目介绍
22. 有学习过大模型，如RAG和SFT吗
23. 反问：base杭州，信贷风控


## 蚂蚁二面
（3.31，40min，电话面）

1. 自我介绍
2. 实时协同编程的系列问题探讨
3. 实时协同编程应用场景的探讨
4. 实习项目2s优化到300ms的探讨
5. 数据库层面怎么优化的探讨
6. 大模型是否了解等问题
7. 什么是一个agent
8. （反问）大模型相关问题的探讨；流程疑问

> 面完后就没后续了，就没管了
