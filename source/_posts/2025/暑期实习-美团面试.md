---
title: 暑期实习-美团面试
date: 2025-10-31 00:06:00
cover: https://upic-1301780692.cos.ap-shanghai.myqcloud.com/u=3581427709,860796011&fm=253&app=138&f=JPEG-20251031-101635.jpeg
tag: 暑期实习
---

# 暑期实习-美团面试

## 笔试
3.22，ac了2.2

最后一题需要查看一下思路


## 美团AI面
1. TCP和UDP的区别，适用于什么场景
2. Java的内部类是什么？介绍一下匿名内部类
3. 垃圾回收是什么？如何触发垃圾回收
4. 介绍聚簇索引和非聚簇索引
5. 介绍5种Java集合，以及特点
6. 如何保证商品不出现超卖
7. 介绍如何去学习的
8. 介绍解决某个问题是否需要投入大量时间，从哪些方面考虑
9. 未来三年的职业规划


## 美团一面
（3.27，47min）

1. 自我介绍
2. 最能体现技术能力的项目介绍
3. 如何设计实现一个定时任务执行器
4. 如果不希望cpu空转，如何设计一个定时任务执行器
5. 实习项目用到了Spring Task定时任务，说一说
6. 介绍令牌桶算法
7. 哪些地方应用到了惰性机制
8. 介绍项目中提到的冗余表和索引
9. 是否遇到过索引失效
10. 数据区分度足够高，如何建立索引：select * from table where x = 1 and y < 1 order by z;
11. 是否存在查询同时使用两个索引的情况；
12. 算法：K个一组反转链表

```java
// 代码中已指定的类名、方法名、参数名，请勿修改，直接返回方法规定的值即可

class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        if (k <= 1) {
          return head;
        }
      
        ListNode dummpy = new ListNode(0, head);
        // 找到末尾的k个节点
        ListNode node = dummpy;
      
        while (node != null) {
          // 获取后k个节点
          boolean hasKNode = true;
          ListNode tail = node;
          for (int i = 0; i < k; ++i) {
            tail = tail.next;
            if (tail == null) {
              hasKNode = false;
              break;
            }
          }
          // 如果剩下部分不存在K个节点
          if (!hasKNode) {
            break;
          }
        
          // 反转这k个节点
          ListNode nodeNext = tail.next;
          tail.next = null;
          // 记录新的尾节点
          ListNode newTail = node.next;
        
          ListNode firstNode = newTail;
          ListNode prev = null;
        
          while (firstNode != null) {
            ListNode next = firstNode.next;
            firstNode.next = prev;
            prev = firstNode;
            firstNode = next;
          }
        
          // 此时prev指向反转后的第一个节点
          node.next = prev;
          newTail.next = nodeNext; 
        
          // node要指向下一段
          node = newTail;
        }
      
        return dummpy.next;
    }
}
```
13. （反问）base和业务：美团到店结算交易平台

## 美团二面
（3.31，52min）

1. 自我介绍
2. 实时协同编程系统参与了什么工作
3. 实时协同编程环境中遇到了什么问题
4. 归宿项目中负责了什么工作
5. 最左匹配原则
6. 那(经度，纬度) 联合索引可以生效吗
7. 介绍JVM
8. 介绍垃圾回收算法
9. 你们平时使用什么垃圾回收算法
10. Java中四种垃圾回收机制
11. 软引用是Full GC的时候回收吗
12. Java中的设计模式了解如何
13. 为面试准备了多久，如何学习
14. 一个月时间如何更快学习
15. （算法）124 二叉树中最大路径和+改造为方法线程安全的单例模式

```java
// 代码中已指定的类名、方法名、参数名，请勿修改，直接返回方法规定的值即可

/**
 * Definition for a binary tree node. 
 *  public class TreeNode { 
 *      int val; 
 *      TreeNode left; 
 *      TreeNode right; 
 *      TreeNode() {} 
 *      TreeNode(int val) { this.val = val; } 
 *      TreeNode(int val, TreeNode left, TreeNode right) { 
 *          this.val = val; 
 *          this.left = left; 
 *          this.right = right; 
 *      }
 *  } 
 *  
**/
class Solution {
  
    private static volatile Solution instance;
  
    private Solution() {
      // initialize
    }
  
    public static Solution getInstance() {
      if (instance == null) {
        synchronized (Solution.class) {
          if (instance == null) {
            instance = new Instance();
          }
        }
      }
      return instance;
    }
  
  
  
    private volatile int maxVal = Integer.MIN_VALUE;
  
    public int maxPathSum2(TreeNode root) {
      int maxValCur = Integer.MIN_VALUE;
      // Deque
      Deque<TreeNode> deque = new ArrayDeque<>();
    
      deque.add(root);
      // and so on
    }
  
   
    public synchronized int maxPathSum(TreeNode root) {
        maxVal = Integer.MIN_VALUE;
        maxPathSumHelper(root);
        return maxVal;
    }
  
    private synchronized int maxPathSumHelper(TreeNode node) {
      if (node == null) {
        return 0;
      }
      // 获取子树的最大val
      int leftVal = maxPathSumHelper(node.left);
      int rightVal = maxPathSumHelper(node.right);
    
      // 查看能否被更新
      int newVal = Math.max(0, leftVal) + Math.max(0, rightVal) + node.val;
      maxVal = Math.max(maxVal, newVal);
    
      return Math.max(0, Math.max(leftVal, rightVal)) + node.val;
    }
}
```