---
title: 秋招知识储备
date: 2025-11-01 23:50:00
cover: https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20251031102636698-20251031-102637.png
desc: 暑期实习和秋招的知识储备，除了看JavaGuide等外，可以随时回来查缺补漏
tag: 秋招
---

# 写在前面
> 暑期实习和秋招的知识储备，除了看JavaGuide等外，可以随时回来查缺补漏
> 个人觉得**简历**最为重要，因为在面试中会被问到的问题基本都是围绕着自己简历展开的
> 关注自己的简历都不用太去看面经了（看些通用的就行），应该关注自己的简历会被如何拷打

> 面试的时候表现的积极点、聪明点，很多时候面试问的问题未必回答的出来，但要表现出有一种愿意主动思考的态度。很多时候一个优秀的面试官是会主动引导的，这里举个自己某次面试时遇到的例子。
> 面试官：端口是哪一层协议的？
> 我：我确实不太清楚，让我思考一下...我猜测可能是网络层或者传输层？
> 面试官：TCP和UDP连接可以用同一个端口吗？
> 这里其实就是暗示了，我知道TCP和UDP可以用同一个端口，这就说明了它们的端口不是一个概念，且已知tcp和udp是传输层的协议，所以端口也应该是传输层的概念。
> 因此在面试的时候遇到不会的问题不必太担忧，大胆说出自己的思考，结合学过的知识去分析一下，其实也是很不错的能力。

> 针对HR面和技术面准备不同的自我介绍。
> 比如我在技术面的时候一般就会说：做了blabla什么项目，最后一带而过自己还参加过暑期支教活动和研究生班长；而HR面则重点介绍暑期支教活动和研究生班长经历，一带而过项目等等。

> 每次完成一场面试后，及时记录这场面试中所被问到的问题，形成面经
> 这样做的好处在于：可以复盘这场面试中自己哪些问题没有回答出来，有针对性的去复习，做到“以面应面”



# 个人面经

暑期实习面经：https://wangwangwang.website/tags/%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0/

秋招面经：https://wangwangwang.website/tags/%E7%A7%8B%E6%8B%9B/


# 八股知识储备


## 分布式锁

分布式锁应当满足：

- 互斥
- 高可用：出问题，能够释放（超时机制）
- 可重入（获取了锁之后，还可以再次获取）

常见实现方案：Redis和ZooKeeper

## 其他工具

### 限流和熔断

限流（Rate Limiting）是一种常用的技术手段，用于控制系统对资源的访问速率，确保系统的稳定性和可靠性

熔断（Circuit Breaker）模式是一种用于处理分布式系统中因服务调用失败而可能导致系统雪崩效应的保护机制。它借用了电路中的“熔断器”概念，当电流过大时，熔断器会自动切断电路，以保护整个电路系统不被烧毁。在分布式系统中，熔断器用于监控服务调用的健康状况，并在检测到异常（如服务调用失败率过高、响应时间过长等）时，自动切断对该服务的调用，从而防止故障在系统中蔓延，保障系统的整体稳定性和可用性

- 防止服务雪崩
- 提升系统弹性

### 限流算法

漏桶算法：无法应对激增流量；请求被丢弃

令牌桶算法：可以限制平均速率，以及处理激增的流量；可以动态调整生成令牌速率

动态调整生成令牌速率的方法：

`RedisRateLimiter`的令牌生成速率（`replenishRate`）和突发容量（`burstCapacity`）

可以考虑使用nanos进行动态配置，同时实现动态路由加载

**限流可以进化到降级**

![image-20250312195240597](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250312195240597-20250312-195242.png)

令牌桶算法添加令牌的方式是多样的：

#### 传统线程驱动

通过后台线程定期（如每秒）向令牌桶中添加固定数量的令牌，直到桶满为止。

**优点**：

- 实现简单，逻辑清晰。
- 令牌生成速率恒定，适合需要严格控制平均速率的场景。

**缺点**：

- 需要维护额外线程，增加系统资源开销。
- 实时性差，突发流量可能导致令牌补充不及时（如网页44提到的瞬时流量可能超过限速阈值

#### 惰性计算

在每次请求到来时，根据当前时间与上次请求的时间差动态计算应补充的令牌数，并更新桶内令牌。

```java
// 网页58中的令牌桶核心逻辑
private void refillTokens() {
    long now = System.nanoTime();
    long duration = now - lastRefillTime;
    long newTokens = duration * refillRate / 1_000_000_000; // 计算时间差对应的令牌数
    tokens.updateAndGet(current -> Math.min(capacity, current + newTokens));
    lastRefillTime = now;
}
```

**优点**：

- 无需独立线程，减少资源消耗。
- 时间驱动更精确，适合高并发场景（如淘宝交易系统的动态限流）

**缺点**：

- 计算逻辑需保证线程安全（如使用原子操作或同步锁）。
- 频繁的时间计算可能带来轻微性能损耗。

#### RateLimiter的实现

**核心原理**： 在每次请求到来时，根据**当前时间与上次令牌补充的时间差**，动态计算应补充的令牌数量。这种方式无需独立线程维护令牌桶，通过实时计算实现令牌生成。 **实现细节**：

1. **时间差计算**：记录上次补充令牌的时间戳（如 `nextFreeTicketMicros`），通过当前时间差除以令牌生成间隔（`stableIntervalMicros`），得到应补充的令牌数。
2. **令牌补充上限**：确保补充后令牌不超过桶的最大容量（`maxPermits`）。
3. **原子性操作**：使用同步锁或原子变量保证线程安全。 **代码示例**（参考Guava的 `SmoothRateLimiter` 类）：

```java
private void resync(long nowMicros) {  
    if (nowMicros > nextFreeTicketMicros) {  
        double timeDiff = nowMicros - nextFreeTicketMicros;  
        double newPermits = timeDiff / stableIntervalMicros;  
        storedPermits = Math.min(maxPermits, storedPermits + newPermits);  
        nextFreeTicketMicros = nowMicros;  
    }  
}  
```

**优点**：

- 无需额外线程，资源消耗低。
- 实时性强，精确控制突发流量。

**适用场景**：高并发、分布式系统（如Guava RateLimiter的默认实现）

| **方法** | **资源消耗** | **实时性** | **适用场景**              |
| -------------- | ------------------ | ---------------- | ------------------------------- |
| 惰性计算法     | 低                 | 高               | 高并发、分布式系统（如API网关） |
| 定时补充法     | 中                 | 中               | 单机简单限流（如传统后台服务）  |

### maven

解决冲突？todo

### docker和虚拟机的区别

<img src="https://upic-1301780692.cos.ap-shanghai.myqcloud.com/4ef8691d67eb1eb53217099d0a691eb5-20250302-153527.png" alt="img" style="zoom: 67%;" />

容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高。

### Oauth 2.0

一种新的授权机制，为第三方应用颁发一个有时效性的令牌Token，使得第三方应用能够通过该令牌获得相关的资源。

令牌（token）与密码（password）的作用是一样的，都可以进入系统，但是有三点差异。

（1）令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。

（2）令牌可以被数据所有者撤销，会立即失效。以上例而言，屋主可以随时取消快递员的令牌。密码一般不允许被他人撤销。

（3）令牌有权限范围（scope），比如只能进小区的二号门。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。

授权层分离出两种角色：客户端和资源所有者。本质oauth的核心就是***向第三方应用颁发令牌***

需要阅读：https://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html

### nginx

nginx正向代理和反向代理

https://zhuanlan.zhihu.com/p/163948996

- 正向代理是**客户端代理**，代理客户端，服务端不知道实际发起请求的客户端
- 反向代理是**服务端代理**，代理服务端，客户端不知道实际提供服务的服务端.

### cookie和localStorage

![image-20250321152306879](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250321152306879-20250321-152307.png)

**单点登录（SSO）**：用户登录百度主站（如 `www.baidu.com`）时，服务器生成一个认证Cookie，并设置其 `domain`属性为 `.baidu.com`。这使得所有子域名（如 `pan.baidu.com`）均可读取该Cookie，实现自动登录

### 时间轮算法

- 环形时间轮：时间轮由多个**槽（Slot）** 组成环形数组，每个槽对应一个时间间隔（如1秒）。例如，一个60槽的时间轮，每槽间隔1秒，可覆盖60秒内的任务
- **指针（tick）**：指针周期性移动（如每秒移动一槽），触发当前槽内所有任务的执行
- **任务链表**：每个槽挂载一个任务链表，存储需在该时间点触发的任务

![image-20250321155727208](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250321155727208-20250321-155727.png)

![img](https://static001.geekbang.org/infoq/71/71313f214caded7d34001de907131cfe.png)

以两层时间轮为例，第一层时间轮周期为1秒，第二层时间轮周期为10秒。

还是以上述3个任务为例，可以看到任务A和B分布在第一层时间轮上，而任务C分布在第二层时间轮的槽1处。当第一层时间轮转动时，任务A和任务B会被先后执行。1秒钟之后，第一层时间轮完成了一个周期转动。从新开始第0跳，这时第二层时间轮从槽0跳到了槽1处，将槽1处的任务，也就是任务C取出放入到第一层时间轮的槽位9处，当第一层时间轮转动到槽位9处，任务C就会被执行。这种将第二层的任务取出放入第一层中称为降级，它是为了保证任务被处理的时间精度。Kafka内部就是采用的这种多层时间轮机制。

![img](https://static001.geekbang.org/infoq/da/daf543a1284837a0de12c29aee43c55b.png)

应用场景：

- redisson通过时间轮算法实现锁的自动续期

### 权限模型

在 RBAC（基于角色的访问控制）模型中，**资源（Resource）** 是系统中被标识、可被访问或操作的一切事物。其涵盖范围包括但不限于：

**功能型资源**

- **模块**：如商品管理、订单管理、财务管理等业务板块。
- **页面**：如商品列表页、订单详情页等具体界面。
- **按钮**：如“新增商品”“删除订单”等交互操作。
- **字段**：如商品详情中的“价格”字段是否可编辑

**数据型资源**

- **实体数据**：如数据库中的某条订单记录、客户信息表。
- **文件/路径**：如服务器上的文件目录或特定文档。
- **API 接口**：如 `/api/orders` 路径对应的 RESTful 接口

RBAC 模型中的权限管理需从两个维度进行切分：**功能权限**（操作权限）和**数据权限**（数据范围权限）。两者相辅相成，共同实现精细化控制

1. **功能权限（操作权限）**

**定义**：控制用户能否使用系统中的特定功能或执行操作，例如页面访问、按钮点击、API 调用等。

2. **数据权限（范围权限）**

**定义**：控制用户能访问哪些具体数据，例如某部门的数据、某区域的订单等。 **典型维度**：

- **组织架构**：如上海分公司的员工只能访问分公司数据

**总结**：

- 功能权限解决“**能否操作**”的问题（如能否删除订单）。
- 数据权限解决“**能操作哪些数据**”的问题（如只能删除自己创建的订单



### 负载均衡算法

**静态**：轮询、加权轮询、随机、哈希、**一致性哈希**。

**动态**：最少连接、最少响应时间、最少负载、带权最少连接

## MySQL

单表数据量控制在500w以内

### 回表

Mysql回表

回表怎么解决

回表返回的是一行还是一张表还是索引

### 缓冲区

innodb中无论是查询还是写绝大部分都是在buffer pool中进行操作的，它相当于innodb的缓存区，可以通过show engine innodb status来查看buffer pool的使用情况；可以通过innodb_buffer_pool_size来设置buffer pool的大小，线上不要吝啬给几个G内存都是正常的，但无论给多大内存都会有不够的时候，innodb采用了变种的LRU算法对数据页进行淘汰

参考文献：https://cloud.tencent.com/developer/article/1828772

### 覆盖索引

覆盖索引的好处：

1. 避免InnoDB的回表
2. 将随机IO变为顺序IO：覆盖索引的 B+ 树叶子节点中，索引键值按升序排列（例如联合索引 `(a, b)` 会先按 `a` 排序，再按 `b` 排序）。当执行范围查询（如 `WHERE a > 10 AND a < 20`）时，所需数据在索引中是连续存储的，磁盘可以一次性顺序读取多个相邻数据页，避免跳跃式寻址

### InnoDB相比于MyISAM的优势

事务支持和ACID特性

行级锁

索引结构的优化（数据和索引文件在一起）

多版本并发控制（MVCC）

redo log，支持崩溃后的安全恢复

### 表级锁和行级锁

表级锁：针对非索引字段加的锁

行级锁：**针对索引字段加的锁**

### 最左匹配原则

使用联合索引的过程中，MySQL根据索引中的字段从左到右依次匹配查询条件

如果匹配，就会使用索引

最左匹配原则会一直向右匹配，直到遇到范围查询（如 >、<）为止。对于 >=、<=、BETWEEN 以及前缀匹配 LIKE 的范围查询，不会停止匹配

### 索引失效

https://mp.weixin.qq.com/s/mwME3qukHBFul57WQLkOYg

- 不符合最左匹配原则
- select *不会影响索引，但是会二次回表
- 使用函数
- 计算
- 非前缀匹配
- in的范围太大

### SQL优化

https://www.nowcoder.com/discuss/730039197121155072

B+树不要超过三层：https://juejin.cn/post/7165689453124517896

## 计算机网络

### TCP/IP 四层模型

应用层

传输层

网络层

网络接口层

#### 应用层

提供两个终端设备上应用程序之间信息交换的服务，定义信息交换的格式

http协议；smtp协议；pop3/imap协议；ftp协议；dns协议

#### 传输层

负责两台终端设备进程的通信提供通用的数据传输服务

tcp协议

udp协议

#### 网络层

负责分组交换网络上不同主机提供通信服务，负责路由和转发

ip协议

arp协议

icmp协议

nat协议

ospf/rip

#### 网络接口层

- 数据链路层：将网络层交下来的IP数据包组装成数据帧
- 物理层：负责计算机节点之间比特流的透明传输

### HTTP状态码

![常见 HTTP 状态码](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/http-status-code-20250303-095853.png)

**200 OK**：请求被成功处理。例如，发送一个查询用户数据的 HTTP 请求到服务端，服务端正确返回了用户数据。这个是我们平时最常见的一个 HTTP 状态码。

**201 Created**：请求被成功处理并且在服务端创建了一个新的资源。例如，通过 POST 请求创建一个新的用户。

**202 Accepted**：服务端已经接收到了请求，但是还未处理。例如，发送一个需要服务端花费较长时间处理的请求（如报告生成、Excel 导出），服务端接收了请求但尚未处理完毕。

**204 No Content**：服务端已经成功处理了请求，但是没有返回任何内容。例如，发送请求删除一个用户，服务器成功处理了删除操作但没有返回任何内容。

---

**301 Moved Permanently**：资源被永久重定向了。比如你的网站的网址更换了。

**302 Found**：资源被临时重定向了。比如你的网站的某些资源被暂时转移到另外一个网址。

---

**400 Bad Request**：发送的 HTTP 请求存在问题。比如请求参数不合法、请求方法错误。

**401 Unauthorized**：未认证却请求需要认证之后才能访问的资源。

**403 Forbidden**：直接拒绝 HTTP 请求，不处理。一般用来针对非法请求。

**404 Not Found**：你请求的资源未在服务端找到。比如你请求某个用户的信息，服务端并没有找到指定的用户。

---

**500 Internal Server Error**：服务端出问题了（通常是服务端出 Bug 了）。比如你服务端处理请求的时候突然抛出异常，但是异常并未在服务端被正确处理。

**502 Bad Gateway**：我们的网关将请求转发到服务端，但是服务端返回的却是一个错误的响应。

### http和https的区别

https是基于http，使用tcp作为底层协议，额外使用ssl/tls协议作为加密和安全认证。默认端口是443.

### QUIC协议

http3.0开始使用quic协议。

1. 协议僵化：tcp协议升级困难，quic基于udp实现，可在用户态灵活迭代
2. 队头阻塞
3. 连接迁移问题：QUIC 使用 **Connection ID** 标识连接，网络切换时无缝迁移连接，无需重建
4. QUIC 具有更高级别的加密 ，TCP 本身不做数据加密，依赖于 TLS

### WebSocket

基于TCP连接的全双工通信协议，客户端和服务器可以同时发送和接收数据

应用层的协议，用于弥补http在持久化通信能力上的不足

![image-20250303160210979](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250303160210979-20250303-160211.png)

### tcp保障可靠性的7种方式

1. 数据块传输
2. 序列号
3. 数据校验
4. 流量控制
5. 拥塞控制
6. 确认机制
7. 超时重传

### 挥手过程中的状态

| **状态**       | **触发方** | **阶段**                     | **持续时间**               |
| -------------------- | ---------------- | ---------------------------------- | -------------------------------- |
| **TIME_WAIT**  | 主动关闭方       | 发送最后一个 `ACK`后             | 固定 `2MSL`（约1-4分钟）       |
| **CLOSE_WAIT** | 被动关闭方       | 收到 `FIN`但未发送自己的 `FIN` | 理论上应短暂（实际可能长期存在） |

### tcp和udp的区别

1. 是否面向连接：udp传输数据之前不需要先建立连接，tcp则是提供面向连接的服务（必须先建立连接，传输结束后也需要释放连接）
2. 是否是可靠传输：udp收到udp报文后，不需要给出任何确认；tcp则通过各种机制保证数据的可靠传输（无差错、不丢失、不重复、按序到达）
3. 是否有状态：和上面差不多，就是tcp会维护数据的状态
4. 传输效率：udp高很多
5. 传输形式：tcp面向字节流，udp则面向报文
6. 首部开销：tcp（20-60字节），udp（8字节）
7. tcp只能点对点，而udp可以一对一、一对多、多对一等等。

|                        | TCP            | UDP        |
| ---------------------- | -------------- | ---------- |
| 是否面向连接           | 是             | 否         |
| 是否可靠               | 是             | 否         |
| 是否有状态             | 是             | 否         |
| 传输效率               | 较慢           | 较快       |
| 传输形式               | 字节流         | 数据报文段 |
| 首部开销               | 20 ～ 60 bytes | 8 bytes    |
| 是否提供广播或多播服务 | 否             | 是         |

### SYN洪流攻击

SYN Flood是最经典的DDos攻击

利用了TCP的三次握手（SYN->SYN/ACK->ACK），进入半连接状态，使得资源耗尽

预防手段：

1. 增加半连接工作队列数量
2. 回收最先创建的tcp半连接
3. syn cookie

## 操作系统

### 进程和线程的区别

1. 线程是进程划分为更小的运行单位，进程执行过程中可以产生多个线程
2. 线程共享资源，可以互相影响；进程基本是独立的
3. 线程执行开销小，进程则比较大

### 线程间同步的方式

1. 互斥锁
2. 读写锁
3. 信号量
4. 屏障
5. 事件（wait/notify）

### 进程间通信方式

1. 匿名管道（父子进程）/ 有名管道
2. 信号量
3. 共享内存
4. 消息队列
5. 套接字

### 父子进程

**子进程拷贝父进程数据的核心机制是写时复制（Copy-On-Write, COW）**。这一设计在Linux系统中通过 `fork()`系统调用实现，兼顾性能与资源利用率

![image-20250315152502507](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250315152502507-20250315-152503.png)

典型场景：Redis利用COW实现快照持久化，子进程直接读取父进程内存生成RDB文件

![image-20250315185109713](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250315185109713-20250315-185110.png)

### 银行家算法

https://cloud.tencent.com/developer/article/2108439

### 零拷贝机制

**零拷贝（Zero-Copy）**是一种计算机系统优化技术，旨在减少或消除数据在内存中的冗余拷贝操作，从而降低CPU开销、提升数据传输效率。其核心思想是：**通过硬件或操作系统级优化，避免CPU参与数据在用户空间与内核空间之间的复制过程**，直接在内核态完成数据传输

<img src="https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250315212414718-20250315-212415.png" alt="image-20250315212414718" style="zoom:50%;" />

基本过程理解：https://www.bilibili.com/video/BV1RxcoeLE5x

mmap：实现内核缓冲区和用户缓冲区之间的映射关系（避免CPU的拷贝过程）

### cpu三级缓存

**解决速度差异问题** CPU的执行速度远高于内存和磁盘，三级缓存通过**缩短数据访问路径**，减少CPU等待数据的时间，缓解“内存墙”问题。

- **速度对比**：寄存器 > L1 > L2 > L3 > 内存 > 磁盘
- **性能提升**：约95%的数据访问可通过缓存完成，仅5%需访问内存，极大减少延迟

核心目的：CPU与内存速度差异大，缓存通过空间换时间减少访问延迟

## Spring

### 注解

<img src="https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250304221412002-20250304-221412.png" alt="image-20250304221412002" style="zoom:50%;" />

### Spring自动装配原理

Spring 自动装配的核心目标是**通过约定大于配置的方式，自动加载符合条件的 Bean 到容器中**

![image-20250309102948593](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250309102948593-20250309-102949.png)

按需装配

### BeanFactory 和 FactoryBean

| **BeanFactory**                                                                                                                                  | **FactoryBean**                                                                                                                                               |
| ------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Spring 的核心接口**，是 IOC 容器的顶层设计，负责 Bean 的实例化、配置和管理。它是 Spring 工厂模式的实现，如 `ApplicationContext` 是其子接口。 | **特殊的 Bean**，本身是一个 Bean，但实现了工厂模式，用于创建其他 Bean 实例。例如 MyBatis 的 `SqlSessionFactoryBean` 和 Spring AOP 的 `ProxyFactoryBean`。 |
| **角色**：IOC 容器的管理者，提供 Bean 的基础操作（如 `getBean`、`isSingleton`） 。                                                           | **角色**：Bean 的生产工厂，通过 `getObject()` 方法返回目标对象，而非自身实例。                                                                              |

### Bean的生命周期

![img](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/spring-bean-lifestyle-20250226-125000.png)

### Bean加载问题

**默认扫描范围**： Spring 默认仅扫描主配置类（如 `@SpringBootApplication` 标注的类）所在的包及其子包。若类位于其他包中，需通过 `@ComponentScan` 显式指定扫描路径

```java
@SpringBootApplication
@ComponentScan(basePackages = "com.example.custom.package")
public class App { /*...*/ }
```

若配置了 `@ComponentScan` 的 `excludeFilters` 或 XML 的 `<context:exclude-filter>`，相关类可能被排除

### Spring的循环依赖

Spring使用三级缓存来解决循环依赖问题：

1. 一级缓存singletonObjects：存储最终形态的Bean
2. 二级缓存earylySingletonObjects：存储半成品Bean，即三级缓存ObjectFactory产生的对象。主要是为了AOP机制下， 每次产生新的代理对象
3. 三级缓存singletonFactories：存放ObjectFactory，ObjectFactory的getObject()方法（最终调用的是getEarlyBeanReference()方法）可以生成原始 Bean 对象或者代理对象（如果 Bean 被 AOP 切面代理）

创建Bean的具体流程如下：

1. 先去一级缓存singletonObjects获取，存在就返回；
2. 不存在，去二级缓存中获取
3. 仍然不存在，就在三级缓存获取到对应的objectFactory（并调用对应的getObject()）方法

具体解决循环依赖的方法如下：

1. Spring创建A时，A依赖了B，但是B又依赖了A
2. 由于A还没有初始化完成，因此在一二级缓存中没有A
3. 那么就去三级缓存调用getObject()方法获取A的早期暴露对象，放入二级缓存中，并注入到B中去

在AOP模式下存在的二级缓存：

确保多个对早期引用的请求，也返回同一个代理对象

### @Transactional

Spring中事务管理最关键的三个接口：

- PlatformTransactionManager：事务管理器，Spring事务策略的核心
- TransactionDefinition：事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)
- TransactionStatus：事务运行状态

#### 事务传播行为

解决业务层方法之间互相调用的事务问题

Propagation_Required：外部有事务，加入外部；外部没有，则自己新建一个事务（互相影响）

Propagation_requires_new：创建一个事务，把外部事务挂起（内部影响外部，外部不影响内部）

Propagation_nested：内部不会影响外部，外部会影响外部

#### 注解失效

- 只能作用在public方法上，其他不生效
- 当一个方法被标记@Transactional注解的时候，Spring 事务管理器只会在被其他类方法调用的时候生效，而不会在一个类中方法调用生效。

#### 相关面试题

> 1. 一个类的内部有A，B两个方法，其中B开启了事务，我在A中调用B，事务生效吗？
> 2. 这种情况下如何让事务生效？

在同一个类中，若方法A直接调用带有 `@Transactional`注解的方法B，**事务不会生效**。其核心原因在于Spring的事务管理基于AOP代理机制实现，而同类内部调用会绕过代理，直接通过目标对象执行，导致事务拦截失效。

解决方法：

- 拆分到不同的类
- 自我注入：注入一个自己类对象

  ```java
  @Service  
  public class MyService {  
    	// 需要开启循环依赖支持
      @Autowired  
      private MyService self;  
  }
  ```
- 获取当前代理对象：((MyService) AopContext.currentProxy()).methodB();   或者获取代理Bean对象

### Spring Cloud Gateway

![img](https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/springcloud-gateway-%20demo.png)

三个关键组件：

- **Route 路由**：Spring Cloud Gateway最基本的单元，定义了请求的匹配规则和转发目标。通过配置路由，可以将请求映射到后端服务实例或者URL上。路由规则根据请求的路径、方法或者请求头等条件进行匹配（断言），指定转发的目标URL
- **Predicate 断言**：用于匹配请求的目标，如果满足断言的条件，就会应用所配置的过滤器。内置多种断言方式，如Path（路径匹配）、Method（请求方法匹配）等
- **Filter 过滤器**：对请求进行转换和处理，可以修改请求、响应和自定义逻辑。提供了多个内置的过滤器，如请求转发、请求重试、请求限流等。

具体工作流程：

![Spring Cloud Gateway 的工作流程](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/spring-cloud-gateway-workflow-20250315-144117.png)

1. **路由判断**：客户端的请求到达网关后，先经过 Gateway Handler Mapping 处理，这里面会做断言（Predicate）判断，看下符合哪个路由规则，这个路由映射后端的某个服务。
2. **请求过滤**：然后请求到达 Gateway Web Handler，这里面有很多过滤器，组成过滤器链（Filter Chain），这些过滤器可以对请求进行拦截和修改，比如添加请求头、参数校验等等，有点像净化污水。然后将请求转发到实际的后端服务。这些过滤器逻辑上可以称作 Pre-Filters，Pre 可以理解为“在...之前”。
3. **服务处理**：后端服务会对请求进行处理。
4. **响应过滤**：后端处理完结果后，返回给 Gateway 的过滤器再次做处理，逻辑上可以称作 Post-Filters，Post 可以理解为“在...之后”。
5. **响应返回**：响应经过过滤处理后，返回给客户端。

#### 内部调用

微服务A和B在注册中心注册后，可通过内部服务名（如 `payment-service`）直接调用，无需经过网关

**注册中心的健康检查**

- **心跳检测**：服务实例定期向注册中心发送心跳（如Eureka默认30秒一次），若超时未收到心跳（Eureka默认90秒），则标记实例为不可用并剔除
- **主动探针**：Nacos支持TCP/HTTP主动探针，实时检测服务健康状态

**客户端的动态更新**

- **本地缓存**：客户端（如Ribbon）会定期从注册中心拉取最新服务列表（默认30秒），并缓存到本地。当某节点挂掉时，客户端在下一次请求时会自动跳过该节点
- **故障转移**：负载均衡器（如Ribbon）在调用失败时自动重试其他可用实例（默认不重试，需配置 `RetryPolicy`）

#### 内部绕过鉴权

其实内部也不需要再鉴权了

内部请求的时候添加请求头：

```java
// 内部服务调用时添加请求头
webClient.get()
    .uri("http://internal-service/api/data")
    .header("X-Internal", "true")
    .retrieve();
```

**结合IP白名单限制**

- 网关配置：在网关过滤器中校验请求来源IP是否属于内部网络

```java
@Component
public class InternalIpFilter implements GlobalFilter {
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String clientIp = exchange.getRequest().getRemoteAddress().getAddress().getHostAddress();
        // 判断是否是内部的请求
      	if (isInternalIp(clientIp) && exchange.getRequest().getHeaders().containsKey("X-Internal")) {
            return chain.filter(exchange);
        }
      	// 外部就需要校验
        return checkAuth(exchange, chain);
    }
}
```

**临时Token+请求头**

内部服务调用时生成带时效和签名的Token（如JWT），网关验证Token有效性

#### 服务发现

| **注册中心**   | **一致性模型** | **功能扩展**  | **适用场景**            |
| -------------------- | -------------------- | ------------------- | ----------------------------- |
| **Eureka**     | AP                   | 服务注册与发现      | Spring Cloud 传统架构         |
| **Consul**     | CA（最终一致）       | 多数据中心、KV 存储 | 混合云或复杂网络环境          |
| **Nacos**      | AP/CP 可选           | 动态配置管理        | 云原生、多环境配置统一        |
| **ZooKeeper**  | CP                   | 分布式协调          | 强一致性要求的金融或交易系统  |
| **Etcd**       | CP                   | 键值存储            | Kubernetes 集群或分布式数据库 |
| **Kubernetes** | 无独立模型           | 容器编排集成        | 已容器化的云原生应用          |

### **总结**

- **中小型项目**：优先选择 **Nacos**（功能全面）或 **Consul**（多数据中心）。
- **强一致性需求**：选择 **ZooKeeper** 或 **Etcd**。
- **云原生环境**：直接使用 **Kubernetes 原生服务发现**。
- **历史系统迁移**：若原用 Eureka，可逐步过渡到 Nacos 以兼容 Spring Cloud 生态

## Redis

### 分布式

主从复制：Redis集群（master负责写请求，slave负责读请求）

<img src="https://upic-1301780692.cos.ap-shanghai.myqcloud.com/1676964296594-1f216792-7828-4e11-bd01-d30c63a37f89-20250304-160612.png" alt="img" style="zoom: 50%;" />

### 延迟双删策略

**延迟双删策略**是用于维护数据库（如 MySQL）与 Redis 缓存之间数据最终一致性的常见方案。其核心步骤为：

1. **第一次删除缓存**：在更新数据库前，先删除 Redis 中的缓存数据，避免其他线程在数据库更新期间读取到旧数据。
2. **更新数据库**：执行数据库的写入操作。
3. **第二次延迟删除缓存**：在数据库更新完成后，延迟一段时间（如 1-5 秒），再次删除缓存。此步骤的目的是防止在数据库主从同步延迟期间，其他线程将旧数据重新写入缓存

| **方案**                    | **一致性强度** | **复杂度** | **适用场景**           |
| --------------------------------- | -------------------- | ---------------- | ---------------------------- |
| **延迟双删**                | 最终一致性           | 低               | 高频更新、容忍短暂不一致     |
| **先更新数据库再删缓存**    | 更高一致性           | 中               | 强一致性要求（如金融交易）   |
| **Canal 监听 binlog**       | 最终一致性           | 高               | 无需侵入业务代码的大规模系统 |
| **分布式锁（如 Redisson）** | 强一致性             | 高               | 对性能要求低、强一致性场景   |

缓存和数据库一致性：https://mp.weixin.qq.com/s?__biz=MzIyOTYxNDI5OA==&mid=2247487312&idx=1&sn=fa19566f5729d6598155b5c676eee62d&chksm=e8beb8e5dfc931f3e35655da9da0b61c79f2843101c130cf38996446975014f958a6481aacf1&scene=178&cur_album_id=1699766580538032128#rd

流行的解决方案：**订阅数据库变更日志，再操作缓存**。

具体来讲就是，我们的业务应用在修改数据时，「只需」修改数据库，无需操作缓存。

那什么时候操作缓存呢？这就和数据库的「变更日志」有关了。

拿 MySQL 举例，当一条数据发生修改时，MySQL 就会产生一条变更日志（Binlog），我们可以订阅这个日志，拿到具体操作的数据，然后再根据这条数据，去删除对应的缓存。

<img src="https://upic-1301780692.cos.ap-shanghai.myqcloud.com/640-20250306-204147.jpg" alt="图片" style="zoom:50%;" />

整体流程如下：

- **监听Binlog**：通过中间件（如Canal、Maxwell）模拟MySQL从库，实时捕获Binlog事件。
- **数据转换**：将Binlog中的操作转换为Redis命令（如SET、DEL），保证缓存与数据库操作一致。
- **异步处理**：通过消息队列（如Kafka、RocketMQ）解耦，实现削峰填谷和失败重试

### k-v结构

Redis 使用一个**全局哈希表**（`dict`）来存储所有键值对，哈希表的结构如下：

- **哈希桶（Hash Bucket）**：通过哈希函数将键（Key）映射到哈希桶中，每个桶存储指向具体键值对的指针；
- **哈希节点（`dictEntry`）**：每个节点包含键、值指针以及指向下一个节点的指针（用于解决哈希冲突）

哈希表的调整：

- **渐进式 Rehash**：当哈希表负载因子（元素数量 / 哈希表大小）超过阈值时，Redis 会启动渐进式 Rehash，逐步将数据从旧哈希表迁移到新哈希表，避免一次性迁移导致的性能抖动

### 看门狗机制

![image-20250321155521729](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250321155521729-20250321-155522.png)

后台线程池：执行续期操作

时间轮算法：异步原子地续期

## Java

### 多态的两种表现

1. 编译时多态

- 方法重载

2. 运行时多态：运行时才能确定

- 方法重写
- 接口实现

运行时多态的实现机制：

- **动态绑定**：JVM 在运行时根据对象类型解析方法调用地址
- **虚方法表（VTable）**：存储类的方法地址，子类重写方法会覆盖虚表中的父类方法指针

### throw和throws

```java
public void str2int(String str) throws Exception { //这里将得到的异常向外抛出，可以抛出多个
    try {
        System.out.println(Integer.parseInt(str));
    } catch(NumberFormatException e) {
        //TODO 这里可以做一些处理，处理完成后将异常报出，让外层可以得到异常信息
        throw new Exception("格式化异常");
    }
}
```

### Java性能分析

使用top初步定位进程，之后通过jstack找到对应线程的堆栈信息

- jconsole也是一个查看当前java进程运行情况，可以检测死锁。jconsole可以分析出来内存情况，以及能看到线程状态。结合运行前的heapdumppath，可以分析出当前堆内存占用情况，找到时哪一段对应变量造成的，从而定位问题
- jstack：生成虚拟机当前时刻的线程快照。 用于生成 Java 进程在**某个时间点**的所有线程堆栈信息，帮助定位死锁、死循环、资源等待等问题

### JVM内存分配

JVM给对象分配内存有多种策略。

1. 基于堆内存的常规分配：
   - 指针碰撞
   - 空闲列表
2. 多线程分配优化：
   - CAS+重试
   - 线程本地分配缓冲TLAB
3. 特殊场景：
   - 栈上分配：通过**逃逸分析**确定对象生命周期不逃逸出方法（直接在栈帧中分配，结束后自动销毁，避免堆内存分配）

逃逸分析：JVM在编译期或运行时的优化技术，主要用于分析对象的动态作用域，判断是否会被外部方法或线程访问。核心目的是减少堆内存分配、同步开销和对象生命周期管理成本。

根据分析结果，会应用以下优化技术：

- **栈上分配**：若对象未逃逸（仅在当前线程或方法内使用），JVM 可将对象分配在栈帧中，随方法结束自动销毁，无需垃圾回收
- **标量替换**：若对象未逃逸且结构简单，JVM 会将其拆解为独立的标量（如 `int`、`double`）或字段，直接存储在栈或寄存器中
- **同步消除**：若对象未逃逸且仅被单线程访问，JVM 会移除其同步锁（如 `synchronized` 块）

### CPU空转问题

CPU 空转通常由未合理阻塞的循环或锁竞争引起。JVM 通过自适应自旋锁和锁升级机制减少无效空转，开发者需结合以下策略：

1. **代码层面**：用阻塞方法（如 `take()`）替代轮询，设置自旋超时，利用线程池控制并发。
2. **工具定位**：通过 `jstack` 或 Arthas 定位高 CPU 线程，分析是否为自旋锁或死循环。
3. **锁优化**：评估锁粒度，优先使用 `ReentrantLock` 替代 `synchronized`，结合条件变量减少竞争（如网页43的锁示例）。 例如，某压测场景中，通过火焰图定位到 `while(true)` 空循环，添加 `Thread.sleep(50)` 后 CPU 从 95% 降至正常水平

### 线程池

线程池参数，过期时间的意义，超出核心线程数的会被回收吗，非核心线程会被回收吗？怎么判断他要不要回收，怎么知道他过期了的。那我创建十个线程，1~10,核心数8个，9和10还在执行任务，1~8不执行了，这时候会怎么做。
说说线程池的阻塞队列有什么用，为什么用阻塞队列不用普通队列，在并发情况下，往队列中加任务不会有线程安全问题吗。

TODO

### callable和runnable区别

| **对比维度** | **Runnable**                                 | **Callable**                                                             |
| ------------------ | -------------------------------------------------- | ------------------------------------------------------------------------------ |
| **接口定义** | `public interface Runnable { void run(); }`      | `public interface Callable<V> { V call() throws Exception; }`                |
| **返回值**   | **无返回值**（`void`）                     | **有返回值**（泛型类型 `V`）                                           |
| **异常处理** | 无法抛出受检异常（必须内部 `try-catch` 处理）    | 允许抛出受检异常（通过 `Future.get()` 捕获 `ExecutionException` 获取原因） |
| **执行方式** | 通过 `Thread` 或 `Executor.execute()` 直接执行 | 必须通过 `ExecutorService.submit()` 提交，返回 `Future` 对象               |
| **任务管理** | 无状态追踪，无法取消任务或获取结果                 | 通过 `Future` 管理任务状态（取消、超时、结果查询）                           |
| **泛型支持** | 不支持                                             | 支持（通过泛型指定返回值类型，如 `Callable<String>`）                        |

### 反射

反射的核心方法是invoke，通过调用jvm内部的native方法，完成动态方法调用

#### 性能影响

1. 动态解析和运行时开销：需要动态加载类、解析方法/字段的元数据，这些操作在直接调用中是由编译器完成的
2. 方法调用的性能损失：反射调用（如 `method.invoke()`）无法享受 JIT 编译器的优化（如方法内联），导致执行速度比直接调用慢约 **10-30倍**

优化方向：

- 缓存反射元数据：将频繁使用的 `Method`、`Field` 对象缓存起来，避免重复解析
- 使用高性能反射库：如**Spring的 `ReflectionUtils`**

### 泛型机制

Java的泛型是伪泛型，在编译期间所有泛型信息都会被擦除，也就是类型擦除。

即使泛型擦除存在，但是使用泛型仍然存在一系列好处：

- 可以在编译期间进行类型检查
- 使用Object类型需要手动添加强制类型转换

泛型可以增强代码的可读性和稳定性，编译器会对泛型参数进行检测（指定传入对象的类型）

### 并发的同步

Synchronized 关键字

Lock接口及其实现类

原子类

并发集合

读写锁

线程同步工具（CountdownLatch、Semaphore）

### 并发编程的三个特性

1. **原子性**

一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。

在 Java 中，可以借助 `synchronized`、各种 `Lock` 以及各种原子类实现原子性。

`synchronized` 和各种 `Lock` 可以保证任一时刻只有一个线程访问该代码块，因此可以保障原子性。各种原子类是利用 CAS (compare and swap) 操作（可能也会用到 `volatile`或者 `final`关键字）来保证原子操作。

2. **可见性**

当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。

在 Java 中，可以借助 `synchronized`、`volatile` 以及各种 `Lock` 实现可见性。

如果我们将变量声明为 `volatile` ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。

3. **有序性**

在 Java 中，`volatile` 关键字可以禁止指令进行重排序优化。

### AQS

参考文献：https://mp.weixin.qq.com/s/jEx-4XhNGOFdCo4Nou5tqg

抽象类，为同步器提供了通用的执行框架。定义了资源获取和释放的通用流程，具体的资源获取和释放则通过模版方法来实现。

性能好的点在于：**CAS+线程阻塞/唤醒**

**核心思想**：如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态

### synchronized和Lock的区别

| **维度**       | **synchronized**       | **Lock**                  |
| -------------------- | ---------------------------- | ------------------------------- |
| **锁释放**     | 自动释放（代码块结束或异常） | 手动释放（需 `unlock()`）     |
| **公平性**     | 仅非公平锁                   | 支持公平锁与非公平锁            |
| **中断响应**   | 不支持                       | 支持（`lockInterruptibly()`） |
| **锁状态检测** | 无法判断                     | 可检测（`tryLock()`）         |
| **性能**       | 低竞争场景优                 | 高竞争场景优                    |
| **适用场景**   | 简单同步、快速开发           | 复杂逻辑、高并发优化            |

从底层实现上：

- synchronized是java的关键词，由jvm直接管理，通过字节码指令 `monitorenter`和 `monitorexit`实现（还有锁升级机制）
- Lock是类，实现包括：
  - 乐观锁，基于volatile变量和CAS算法实现
  - `ReentrantLock` 通过 AQS 维护锁状态和等待队列，支持可重入性和公平性

### Future和CompletableFuture

应用为主

CompletableFuture支持任务之间的并行调用，在等待A任务执行完之后执行另外的任务，也支持组合两个任务，等待两个任务同时执行完毕

### ForkJoinPool

![image-20250310163700719](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250310163700719-20250310-163702.png)

CompletableFuture如果不自定义线程池，默认使用的全局线程池就是ForkJoinPool

```java
public class MergeSortTask extends RecursiveAction {
    private int[] array;
    private int left, right;
    private static final int THRESHOLD = 1000; // 拆分阈值

    @Override
    protected void compute() {
        if (right - left <= THRESHOLD) {
            Arrays.sort(array, left, right); // 小任务直接排序
        } else {
            int mid = (left + right) / 2;
            invokeAll(
                new MergeSortTask(array, left, mid),
                new MergeSortTask(array, mid, right)
            );
            merge(array, left, mid, right); // 合并结果
        }
    }
}
// 使用方式
ForkJoinPool pool = new ForkJoinPool();
pool.invoke(new MergeSortTask(arr, 0, arr.length));
```

```java
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.RecursiveTask;

public class ForkJoinSumCalculator extends RecursiveTask<Long> {
    private final long[] array;
    private final int start;
    private final int end;
    private static final int THRESHOLD = 10_000; // 任务拆分阈值

    public ForkJoinSumCalculator(long[] array) {
        this(array, 0, array.length);
    }

    private ForkJoinSumCalculator(long[] array, int start, int end) {
        this.array = array;
        this.start = start;
        this.end = end;
    }

    @Override
    protected Long compute() {
        int length = end - start;
        // 如果任务足够小，直接计算
        if (length <= THRESHOLD) {
            return computeDirectly();
        }
        // 拆分任务：将大任务分为两个子任务
        int mid = start + length / 2;
        ForkJoinSumCalculator leftTask = new ForkJoinSumCalculator(array, start, mid);
        ForkJoinSumCalculator rightTask = new ForkJoinSumCalculator(array, mid, end);

        // 异步执行左半部分任务（fork）
        leftTask.fork();

        // 同步执行右半部分任务，并合并结果（join）
        Long rightResult = rightTask.compute();
        Long leftResult = leftTask.join();

        return leftResult + rightResult;
    }

    // 直接计算区间和
    private long computeDirectly() {
        long sum = 0;
        for (int i = start; i < end; i++) {
            sum += array[i];
        }
        return sum;
    }

    public static void main(String[] args) {
        long[] array = new long[100_000];
        for (int i = 0; i < array.length; i++) {
            array[i] = i + 1; // 初始化数组为1~100000
        }

        // 创建ForkJoinPool并提交任务
        ForkJoinPool pool = new ForkJoinPool();
        Long result = pool.invoke(new ForkJoinSumCalculator(array));

        System.out.println("计算结果: " + result); // 应输出5000050000
    }
}
```

1. 避免饥饿：通过工作窃取机制，空闲线程主动从其他队列窃取任务，动态平衡负载（内部会为每一个线程简历一个工作队列）
2. 合理设置任务拆分阈值（THRESHOLD）

关键点：**分治策略** + **工作窃取**

### Hash结构的数据解决哈希冲突的方法有哪些

1. 开放定址法：哈希冲突发生时，按照特定的规则寻找下一个哈希地址
2. 链地址法
3. 再哈希法（使用备用哈希函数）
4. 公共溢出区法

### HashMap和HashTable的区别

1. 线程安全性：HashMap线程不安全，HashTable线程安全（内部方法都通过synchronized关键词修饰）
2. 效率：HashMap高于HashTable（为了保证线程安全，牺牲了性能）
3. 对Null的支持：HashMap允许存在Null的key和value，而HashTable不允许
4. 初始化容量：
   - HashMap初始化大小为16，每次扩容两倍；如果设置了初始大小，就会设置为比初始大小大的2的幂次方
   - HashTable初始大小为11，每次扩容2n+1；如果设置了初始大小，则直接使用初始大小
5. 1.8后的HashMap存在链表转红黑树的过程
6. HashMap对哈希值的高位和低位进行了扰动处理

### 单例模式的破坏

1. **反射绕过单例**

```java
Class<?> clazz = Singleton.class;
Constructor<?> constructor = clazz.getDeclaredConstructor();
constructor.setAccessible(true);
Singleton instance1 = (Singleton) constructor.newInstance();
Singleton instance2 = (Singleton) constructor.newInstance();
System.out.println(instance1 == instance2); // 输出 false
```

可以直接在构造函数中去进行实例检查：

```java
private Singleton() {
    if (Inner.instance != null) {
        throw new RuntimeException("禁止通过反射创建实例！");
    }
}
```

注意懒汉式，还需要额外进行考虑，添加一个状态位：

```java
private static boolean flag = false;
private Singleton() {
    synchronized (Singleton.class) {
        if (flag) throw new RuntimeException("禁止反射创建！");
        flag = true;
      	if (instance == null) {
          ...
				}
    }
}
```

但是，状态位也可能会被反射更新。因此，懒汉式实现的单例模式是不可以防止被反射破坏的

2. **序列化和反序列化对单例模式的破坏**

单例类实现 `Serializable` 接口后，反序列化时会通过反射生成新对象，而非复用已有实例。

解决方法：

（1）枚举类会直接返回已有实例

（2）添加readResolve()，返回已有实例。**`readResolve()` 是 Java 序列化机制中的一个特殊回调方法**，用于在反序列化过程中替换或控制最终返回的对象

可以考虑实现单例模式的另外两种方案：

1. **枚举单例** （最优方案）

枚举类禁止创建反射单例（JVM禁止），也不需要依赖构造函数检查

```java
public enum Singleton {
    INSTANCE;
    // 添加方法
}
```

**优势**：无需手动防御反射，安全性最高

2. 静态内部类

```java
public class Singleton {
    private static class Holder {
        private static final Singleton INSTANCE = new Singleton();
    }
    private Singleton() {}
  
    public static Singleton getInstance() {
        return Holder.INSTANCE;
    }
}
```

**原理**：静态内部类在首次调用 `getInstance()` 时才加载，JVM保证类加载过程的线程安全性

### 新版本Java

Java24发布了，最重要的一个特性：**虚拟线程的同步而不固定平台线程**

优化了虚拟线程与 `synchronized` 的工作机制。虚拟线程在 `synchronized` 方法和代码块中阻塞时，通常能够释放其占用的操作系统线程（平台线程），避免了对平台线程的长时间占用，从而提升应用程序的并发能力。这种机制避免了“固定 (Pinning)”——即虚拟线程长时间占用平台线程，阻止其服务于其他虚拟线程的情况。

现有的使用 `synchronized` 的 Java 代码无需修改即可受益于虚拟线程的扩展能力。例如，一个 I/O 密集型的应用程序，如果使用传统的平台线程，可能会因为线程阻塞而导致并发能力下降。而使用虚拟线程，即使在 `synchronized` 块中发生阻塞，也不会固定平台线程，从而允许平台线程继续服务于其他虚拟线程，提高整体的并发性能。

**核心**：虚拟线程在被synchronized阻塞的时候，会释放掉所占用的平台线程

**提前类加载和链接**：缓存已经加载和链接过的类，减少重复工作的开销（无侵入）

### Spring Task

`ScheduledThreadPoolExecutor` 是 JDK 自带的定时调度器，基于一个 **延时队列（DelayedWorkQueue）** 来管理任务：

- 提交任务时，会计算出**下次执行的时间戳**，丢进延时队列。
- 一个专门的工作线程会不断从队列里取“到期的任务”，放到线程池里去执行。
- 如果是周期任务（fixedRate/fixedDelay），执行完毕后会**重新计算下次时间**，再放回队列

默认使用`ThreadPoolTaskScheduler` 的线程池大小 = 1，也就是单线程顺序执行。因此，可以自己配置一个线程池：

- **扫描 @Scheduled 注解** → 注册成定时任务。
- **交给 TaskScheduler（默认 ThreadPoolTaskScheduler）** 管理。
- **底层依赖 JDK 的 ScheduledThreadPoolExecutor**（基于延时队列实现）。
- 周期任务 / Cron 任务：每次执行完毕后算出下一次执行时间，再丢回调度队列



## Linux

htop查看内存占用情况，PID等信息

![image-20250305125116718](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250305125116718-20250305-125117.png)

### 处理大文件

> Linux读取大文件进行文本替换

**使用 `sed` 命令（流式处理，内存友好）**

- **适用场景**：全局或局部替换文本，支持正则表达式。
- **优势**：逐行处理文件，无需加载整个文件到内存。

```shell
# 替换文件中所有 "old_text" 为 "new_text"（直接修改原文件）
sed -i 's/old_text/new_text/g' large_file.txt

# 仅替换第 100 到 200 行的内容
sed -i '100,200s/old_text/new_text/g' large_file.txt
```

![image-20250321125123282](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250321125123282-20250321-125126.png)

## 数据结构

### 红黑树

1. 每个节点非黑即红，黑色代表平衡，红色代表不平衡；
2. 根节点总是黑色的
3. 每个叶子节点都是黑色的空节点（NIL 节点）。这里指的是红黑树都会有一个空的叶子节点，是红黑树自己的规则；
4. 如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；
5. 从任意节点到它的叶子节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。



## Etcd

### 备份过程数据的一致性

原因在于它不是简单去拷贝数据文件，而是通过 **Raft 一致性和 etcd 的 MVCC 存储机制** 来保证

- etcd 集群所有写入必须经过 **Raft 共识** 才能提交。
- 当执行 `etcdctl snapshot save` 时，etcd 会选定一个**一致的 Raft 提交点**（commit index），以该时刻为快照边界
- etcd 底层使用 **boltdb** 存储，并且有 **MVCC（多版本并发控制）索引层**

综上，一致性保障来源于两方面：

**Raft 共识 → 确保提交点一致**；

**MVCC 快照 → 确保读取的是某个固定 revision 的全局状态**

 **MVCC 在这里的作用**就是：保证 `snapshot save` 读出的所有数据属于同一个 revision，不会前后混杂

### Raft 而非 Paxos

**Paxos**：理论优雅，但工程实现复杂，难以理解和维护；

**Raft**：在保证相同一致性语义的前提下，更直观、更易实现和维护

一句话总结：Raft 更工程友好，理解和实现成本更低，维护更容易



### Etcd VS Zookeeper

Zookeeper的问题：

**Watch 机制不足**

- 触发一次就失效，需要重新注册；
- 客户端多时容易引发“惊群效应”

**一致性协议复杂**

- ZAB 没有 Raft 那么直观，理解和验证成本高









# 场景题

## 算法

智力题pdf： [场景题.pdf](场景题.pdf) 

### 最大的100个数字

> 有很多个没有排序过的数字，想要找到其中最大的100个数字，怎么实现，时间复杂度是多少？

1. 最小堆法：

将前100个数构建为**最小堆**

后续每个数，如果大于堆顶，那么就替换并且更新结构；否则就不需要

建堆O(100)，后续每次处理为O(nlog100) = O(n)

时间复杂度为：O（n）

2. 快速选择算法：分区，找到第100大的元素。此时左边就是需要的

平均O（n），最坏情况（n^2）

3. 分治法（数据量过大的时候）：

   将数据分成若干块（每块100万个），每块使用上述两种方法找到最大的100个数

   合并top100，再次筛选

   时间复杂度为O(n + mlogm + 100m)，m是块数

### 大数据量的状态

> 有一台16G内存的电脑，要保存2的32次方个qq号的状态，怎么设计，大概占多少内存空间？

都用1位表示状态：

2^32 * 1 / 8 =536,870,912 字节 = 512MB

布隆过滤器近似计算

### 查找高频词

> 在内容安全工作中，常用高频词查找的需要。
> 你需要在最多不超过 10^7 的单词中查找其中出现次数最多的 100 个，即 TOP100。
> 为了简单起见，所有单词都已经被提取出来，每个单词由小写字母 a-z 组成，长度不超过 20 个字母。
> 你需要使用尽可能小的内存空间和尽可能快的算法来找出这 100 个单词。
> 样例1:
> [输入]
> 5
> splunk
> elastic
> splunk
> clickhouse
> elastic

先存储（用map或者trie？长度20的话，20*26=520 ）；用map也可以

然后用最大的100个数字的方法

### 统计10G电话号码

> 10G的11位电话号码文件，2G内存，如何获取重复率最高的电话号码

1. **哈希分片**：
   - 将10G文件按电话号码的哈希值（如**取模**运算）分割为多个小文件，确保相同电话号码一定落入同一文件。例如，哈希函数设为 `hash(phone) % 1000`，生成1000个子文件，每个文件约10MB（假设电话号码均匀分布）
2. 逐文件统计频率：
   - 逐个读取子文件，在内存中统计每个文件的电话号码出现次数
   - 记录当前文件的**最高频率号码**及其次数
3. 全局汇总：
   - 合并所有子文件的统计结果，计算全局最高频率
   - 读取所有临时结果文件，使用**最小堆**或**外部排序**合并数据

哈希分片 or bitmap（本题不适用） 是一种很重要的思想方法

### 3次失败登陆锁定15分钟

```java
public Result login(String username, String password) {
    // 1. 检查是否已锁定
    if (redis.exists("lock:" + username)) {
        return Result.error("账户已锁定，请15分钟后重试");
    }
  
    // 2. 验证用户名密码
    User user = userService.findByUsername(username);
    if (user != null && password.equals(user.getPassword())) {
        // 登录成功：重置失败次数
        redis.delete("login_fail:" + username);
        return Result.success();
    } else {
        // 3. 登录失败：递增失败次数
        long count = redis.incr("login_fail:" + username);
        redis.expire("login_fail:" + username, 900); // 15分钟滑动窗口
      
        // 4. 判断是否触发锁定
        if (count >= 3) {
            redis.setex("lock:" + username, 900, "locked"); // 锁定15分钟
            return Result.error("连续失败3次，账户已锁定");
        }
        return Result.error("用户名或密码错误");
    }
}
```

| **方案**          | **优点**                 | **缺点**                  | **适用场景**       |
| ----------------------- | ------------------------------ | ------------------------------- | ------------------------ |
| **纯数据库实现**  | 无需额外中间件，数据持久化可靠 | 高并发下性能瓶颈，锁竞争严重    | 低并发、数据一致性要求高 |
| **Redis+数据库**  | 高性能，自动过期，易于扩展     | 依赖Redis可用性，需处理缓存穿透 | 中高并发，实时性要求高   |
| **分布式锁+计数** | 支持分布式部署，强一致性       | 实现复杂，运维成本高            | 大型系统，多节点协同     |

### 秒杀场景

**数据库层面的解决方案**

乐观锁：在商品表中增加 `version`字段，每次更新库存时校验版本号是否一致

唯一索引+条件更新：

创建用户购买记录表，对 `(uid, goods_id)`添加唯一索引，防止重复购买

**redis实现分布式锁**

在锁内执行库存预减和订单生成逻辑

```java
// 加锁示例（Redisson实现）
RLock lock = redissonClient.getLock("lock:product_1");
lock.lock(10, TimeUnit.SECONDS);
try {
    int stock = redis.get("product_stock_1");
    if (stock > 0) {
        redis.decr("product_stock_1");
        // 异步生成订单
        sendToMQ(order);
    }
} finally {
    lock.unlock();
}
```

**原子性初始化** 使用Redis的 `SET`命令结合 `NX`（不存在时设置）选项，确保库存仅被初始化一次。例如：

```sh
SET product:stock 50 NX  # 仅当键不存在时设置库存为50
```

**Lua脚本实现原子操作** 通过Lua脚本在Redis服务端**原子性校验并扣减库存**，避免并发下的数据不一致。脚本逻辑如下

```lua
-- KEYS[1]: 库存键（如product:stock）
-- ARGV[1]: 扣减数量（如1）
local stock = tonumber(redis.call('get', KEYS[1]))
if stock >= tonumber(ARGV[1]) then
    return redis.call('decrby', KEYS[1], ARGV[1])
else
    return -1  -- 库存不足
end
```

![image-20250321155154531](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250321155154531-20250321-155154.png)

### 多线程任务场景

> 开一个线程池，5个核心线程，10个任务，保证10个任务执行完，再执行主线程的一些任务

```java
ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 10, 10, TimeUnit.SECONDS,
        new ArrayBlockingQueue<>(5));

// 10个执行完才能够执行其他的
CountDownLatch countDownLatch = new CountDownLatch(10);

// 10个任务
Random random = new Random();
for (int i = 0; i < 10; ++i) {
    int finalI = i + 1;
    threadPoolExecutor.submit(() -> {
        try {
            System.out.println("任务" + finalI);
            Thread.sleep(random.nextInt(500) + 1000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } finally {
            countDownLatch.countDown();
        }

    });
}
countDownLatch.await();
System.out.println("所有任务已完成");
threadPoolExecutor.shutdown();
```

### 生产者-消费者模型

2个生产者和4个消费者的模型。生产者负责读取文件数据，消费者负责消费文件并输出

阻塞队列可以

### 并查集的删除

在处理某些人之间具有关系的数据结构中，常常用到并查集。例如：a和b认识，b和c认识，那么a和c就可以连接上，可以用并查集来存储这种关系。但是现在需要考虑a和b绝交了，在这种情形下如何用并查集来处理，确认某两个人之间是否还能连接

可以反向处理，将删除等价为增加

### 查询问题

> 场景1：查全校人的姓名，选出top10出现率的名字
> 场景2：如果查询范围变成全国呢？
> 场景3：如果空间有限，不让用多级索引呢？用什么数据结构节省空间？
> 场景4：DNS服务器解析域名对应的IP地址的时候，怎么快速查找到对应的IP地址同时节省存储空间？

### 称盐问题

> 140g的盐 各有一个2g和一个7g的砝码 只能用三次天平，如何称出50g 和 90 g

第一次平分，70+70，第二次继续对一份70克平分，35+35，第三次左边2g砝码，右边7克砝码，调整35克盐以达到平衡，这样左边有20克盐，右边15克盐。把20克盐加到一份70克中即可

### 烧绳子

> 一根绳子烧完要1小时，如何计时15分钟，30分钟和45分钟

## SQL代码

复习一些典型的SQL语句的用法：

```sql
with basic_query as (
select 
distinct products.product_id,
category,
name as product_name,
sum(quantity) over (partition by products.product_id) as total_sales
from
products inner join orders on products.product_id = orders.product_id
)
select 
product_name,
total_sales,
rank() over (partition by category order by total_sales desc) as category_rank
from basic_query;
```

```sql
SELECT 
    date1, 
    date2,
    CASE 
        WHEN DATE(date1) = DATE(date2) THEN 'Same Day'
        ELSE 'Different Day'
    END AS IsSameDay
FROM 
    your_table;
```

# HR面

1 你觉得你有哪些缺点和优点？

> 缺点：在面对一些比较重要的任务和紧迫的DDL的压制下，由于我本身的执行力非常强，所以这种时候我会试图去尽快把一件事情做完。这种时候，我往往做到了高效完成任务，但容易忽视前期的一些调研准备工作，使得自己在真正去做这件事情的时候会遇到一些波折，导致出现一些小规模的返工。
> 所以现在在做事情前我一般会通过几种方法去改进自己：
> 首先，我现在习惯于一般会给自己列一个计划，尽量按照计划去做事。
> 另一方，其实这也是一个认知的问题。我现在逐渐意识到准备本身也是做事情的一部分，通过预先调研往往能保证事情在执行阶段更加顺利。相当于说工欲善其事，必先利其器
> 最后，我也会让自己去相信自己的能力，告诉自己我有能力去在期限内完成，更重要的其实在于每一个细节的达成。

2 你怎么评价你面试的这家公司？

3 你在校期间，有没有哪段时间或者某件事情让你受挫？

> 以下是个人之前准备的话术
> 去年此时，我发现自己体脂率很高，并且感觉不太健康了
> 另一方面，之前的论文没有中，需要在两个月内完成一篇期刊，
> 下定决心开始早起，作息从2点睡11点起更改到12点睡8点起。每天抽一个小时去运动一下，然后开始蹲图书馆

4 在校期间遇到最有挑战的事情是什么？

5 目前手上有 offer 吗？

6  自我介绍

7  职业规划

8 报学校专业是怎么考虑的？

9  工作城市

10 你是独生子女吗？

11 那你有男/女 朋友吗？

12  你们出来面试都了解过哪些企业？

13  到后期你们每个人手上有好几个offer，哪些因素决定你们选择这家公司?

14  你更倾向哪种公司？有什么特别的点？

15  你大学有没有特别难忘的经历或者项目分享一下的?

16  团队合作中遇到什么问题？

17  对互联网加班有什么看法？

18  那你现在的技术薄弱点在哪里，怎么去突破？

19  你的兴趣爱好有哪些？

20 现在进度最快的公司是哪家？

21 拿到哪几家offer，是否谈过薪资等
