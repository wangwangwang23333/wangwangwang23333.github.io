---
title: 秋招面试-高德
date: 2025-11-01 18:31:00
tag: 秋招
---

# 秋招面试-高德

## 算法

（23min）

单选+多选（挺难）+3道算法题

不用自己写输入输出，完成函数即可

1. （LC64）给定一个n*m的数组，表示到该位置的开销，每次可以往下或者往右走，求(0,0)到(n-1,m-1)的最小开销
2. （LC1976）给定一个无向图（表示任意两点间的时间开销），求0到n-1位置花销时间最小的方式有多少种（对10^9+7取模）
3. （LC55）给定一个数组，表示能从该位置跳的最远距离，判断能否从下标0跳到n-1


## 高德一面

（9.9，1h，底层路网数据）

1. 自我介绍
2. 实习项目介绍
3. Redis
4. 线程池如何更好使用
5. 慢日志优化具体例子
6. 对AI的看法
7. （算法）如下图所示，求出所有到N1的距离小于等于指定长度的路径


![image-20250909150207363](https://upic-1301780692.cos.ap-shanghai.myqcloud.com/image-20250909150207363-20250909-150209.png)

```java
import java.io.*;
import java.util.*;


public class Main {

    /**
     图：找到指定长度的路径
     输入示例：[[1, 3, 200], [1, 2, 50], [2,3,180], [2,4,230],[3,4,100]]

     */
    
    static BufferedWriter bw;

    public static void main(String[] args) throws IOException {

        bw = new BufferedWriter(new OutputStreamWriter(System.out));

        int n = 4;
        int[][] arr = new int[][] {{0,2,200},{0,1,50}, {1,2,180},{1,3,230},{2,3,100}};
        boolean[] visited = new boolean[n];
        int maxLength = 300;
        int[] dis = new int[n];
        Arrays.fill(dis, Integer.MAX_VALUE);
        dis[0] = 0;

        List<List> ans = new ArrayList<>();

        List<Integer>[] paths = new List[n];
        for (int i = 0; i < n; ++i) {
            paths[i] = new ArrayList<Integer>();
        }



        while (true) {
            // 找到当前距离最近的点
            // 从0出发找到最近的一个点
            // 找距离最近目的的点
            int minVal = Integer.MAX_VALUE;
            int targetIndex = -1;
            for (int i = 0; i < n; ++i) {
                // 不能访问已经访问过的点
                if (visited[i]) {
                    continue;
                }
                if (dis[i] < minVal) {
                    targetIndex = i;
                }
            }
            if (targetIndex == -1) {
                break;
            }
            // 此时要访问的点是targetIndex
            if (dis[targetIndex] <= maxLength) {
                // 这个点的路径就需要加入进来
                // i -> targetIndex之间的路径呢？
                ans.add(new ArrayList<>(paths[targetIndex]));
            } else {
                break;
            }
            // 这个时候就是看到targetIndex之间的距离
            for (int[] path: arr) {
                if (path[0] == targetIndex && !visited[path[1]]) {
                    if (dis[path[1]] > dis[targetIndex] + path[2]) {
                        // 收缩长度，走新的路径
                        dis[path[1]] = dis[targetIndex] + path[2];
                        // 记录这种路径,如何走到的targetIndex?
                        paths[path[1]] = new ArrayList<>(paths[path[0]]);
                        paths[path[1]].add(path[1]);
                    }
                }
            }
            visited[targetIndex] = true;

        }


        // 打印ans
        for (int i = 0; i < ans.size(); ++i) {
            List<Integer> path = ans.get(i);
            for (int j = 0; j < path.size(); ++j) {
                System.out.print((path.get(j) + 1) + ", ");
            }
            System.out.println();
        }


        bw.flush();
        bw.close();
    }
}
```

## 高德二面

（9.16，1h）

1. 自我介绍
2. 归宿项目拷打：项目的架构；归宿项目用分布式锁；用Redis
3. 计算机七层网络模型
4. Spring Cloud由哪些部分组成
5. Http协议是哪一层的，长连接和断连接
6. 端口是计网哪一层的
7. 端口号有多少个；2的多少次方
8. 两个进程可以在同一个端口吗
9. 微服务接收到具体的订单请求后，不同线程是如何处理的（如：有一个监听端口）
10. Mysql和redis数据一致性
11. RPC
12. 死锁的四个条件
13. 生产者和消费者模型
14. 实现生产者和消费者模型必须用锁吗
15. 腾讯实习项目拷打
16. 介绍红黑树；查询的时间复杂度
17. 介绍堆；建堆的时间复杂度；堆排序的时间复杂度
18. 堆可以用红黑树实现吗
19. 图的遍历方法
20. 最短路径算法有哪些；介绍Dij算法
21. 反问


## 高德三面

（9.29，24min）

1. 自我介绍
2. 实习经历；备份过程发生故障；数据完整性保障
3. 对于AI的看法等
4. 未来职业规划
5. 反问


## 高德HR面

（10.16，22min）

1. 自我介绍
2. 本科和研究生期间如何分配的时间
3. 除了学习工作外还做了什么
4. 选择工作时会考量的因素
5. 反问
